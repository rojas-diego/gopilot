{"task_id": "Go/0", "prompt": "import (\n\t\"math\"\n)\n\n// Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n// >>> HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5)\n// false\n// >>> HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n// true\nfunc HasCloseElements(numbers []float64, threshold float64) bool {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n// >>> HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5)\n// false\n// >>> HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n// true\n", "declaration": "\nfunc HasCloseElements(numbers []float64, threshold float64) bool {\n", "canonical_solution": "\tfor i := 0; i < len(numbers); i++ {\n\t\tfor j := i + 1; j < len(numbers); j++ {\n\t\t\tvar distance float64 = math.Abs(numbers[i] - numbers[j])\n\t\t\tif distance < threshold {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n", "test": "func TestHasCloseElements(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, HasCloseElements([]float64{11.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3))\n\tassert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05))\n\tassert.Equal(true, HasCloseElements([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95))\n\tassert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8))\n\tassert.Equal(true, HasCloseElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1))\n\tassert.Equal(true, HasCloseElements([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0))\n\tassert.Equal(false, HasCloseElements([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestHasCloseElements(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5))\n\tassert.Equal(true, HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3))\n}\n"}
{"task_id": "Go/1", "prompt": "\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> SeparateParenGroups('( ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nfunc SeparateParenGroups(paren_string string) []string {\n", "import": "", "docstring": "// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> SeparateParenGroups('( ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\n", "declaration": "\nfunc SeparateParenGroups(paren_string string) []string {\n", "canonical_solution": "\tresult := make([]string, 0)\n\tcurrent_string := make([]rune, 0)\n\tcurrent_depth := 0\n\n\tfor _, c := range paren_string {\n\t\tif c == '(' {\n\t\t\tcurrent_depth += 1\n\t\t\tcurrent_string = append(current_string, c)\n\t\t}else if c== ')'{\n\t\t\tcurrent_depth -= 1\n\t\t\tcurrent_string = append(current_string, c)\n\n\t\t\tif current_depth == 0{\n\t\t\t\tresult = append(result, string(current_string))\n\t\t\t\tcurrent_string =  make([]rune, 0)\n\t\t\t}\n\t\t}\n\n\t}\n\treturn result\n}\n\n", "test": "func TestSeparateParenGroups(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"(()())\", \"((()))\", \"()\", \"((())()())\"}, SeparateParenGroups(\"(()()) ((())) () ((())()())\"))\n\tassert.Equal([]string{\"()\", \"(())\", \"((()))\", \"(((())))\"}, SeparateParenGroups(\"() (()) ((())) (((())))\"))\n\tassert.Equal([]string{\"(()(())((())))\"}, SeparateParenGroups(\"(()(())((())))\"))\n\tassert.Equal([]string{\"()\", \"(())\", \"(()())\"}, SeparateParenGroups(\"( ) (( )) (( )( ))\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSeparateParenGroups(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"()\", \"(())\", \"(()())\"}, SeparateParenGroups(\"( ) (( )) (( )( ))\"))\n}\n"}
{"task_id": "Go/2", "prompt": "import (\n\t\"math\"\n)\n\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// \n// Return the decimal part of the number.\n// >>> TruncateNumber(3.5)\n// 0.5\nfunc TruncateNumber(number float64) float64 {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// \n// Return the decimal part of the number.\n// >>> TruncateNumber(3.5)\n// 0.5\n", "declaration": "\nfunc TruncateNumber(number float64) float64 {\n", "canonical_solution": "\treturn math.Mod(number,1)\n}\n\n", "test": "func TestTruncateNumber(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0.5, TruncateNumber(3.5))\n\tassert.Equal(true, math.Abs(TruncateNumber(1.33)-0.33) < 1e-6)\n\tassert.Equal(true, math.Abs(TruncateNumber(123.456)-0.456) < 1e-6)\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTruncateNumber(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0.5, TruncateNumber(3.5))\n}\n"}
{"task_id": "Go/3", "prompt": "\n// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> BelowZero([1, 2, 3])\n// false\n// >>> BelowZero([1, 2, -4, 5])\n// true\nfunc BelowZero(operations []int) bool {\n", "import": "", "docstring": "// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> BelowZero([1, 2, 3])\n// false\n// >>> BelowZero([1, 2, -4, 5])\n// true\n", "declaration": "\nfunc BelowZero(operations []int) bool {\n", "canonical_solution": "\tbalance := 0\n\tfor _, op := range operations {\n\t\tbalance += op\n\t\tif balance < 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n", "test": "func TestBelowZero(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, BelowZero([]int{}))\n\tassert.Equal(false, BelowZero([]int{1, 2, -3, 1, 2, -3}))\n\tassert.Equal(true, BelowZero([]int{1, 2, -4, 5, 6}))\n\tassert.Equal(false, BelowZero([]int{1, -1, 2, -2, 5, -5, 4, -4}))\n\tassert.Equal(true, BelowZero([]int{1, -1, 2, -2, 5, -5, 4, -5}))\n\tassert.Equal(true, BelowZero([]int{1, -2, 2, -2, 5, -5, 4, -4}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestBelowZero(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, BelowZero([]int{1, 2, 3}))\n\tassert.Equal(true, BelowZero([]int{1, 2, -4, 5}))\n}\n"}
{"task_id": "Go/4", "prompt": "import (\n\t\"math\"\n)\n\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> MeanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n// 1.0\nfunc MeanAbsoluteDeviation(numbers []float64) float64 {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> MeanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n// 1.0\n", "declaration": "\nfunc MeanAbsoluteDeviation(numbers []float64) float64 {\n", "canonical_solution": "\tsum := func(numbers []float64) float64 {\n\t\tsum := 0.0\n\t\tfor _, num := range numbers {\n\t\t\tsum += num\n\t\t}\n\t\treturn sum\n\t}\n\n\tmean := sum(numbers) / float64(len(numbers))\n\tnumList := make([]float64, 0)\n\tfor _, x := range numbers {\n\t\tnumList = append(numList, math.Abs(x-mean))\n\t}\n\treturn sum(numList) / float64(len(numbers))\n}\n\n", "test": "func TestMeanAbsoluteDeviation(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0})-2.0/3.0) < 1e-6)\n\tassert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0})-1.0) < 1e-6)\n\tassert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0, 5.0})-6.0/5.0) < 1e-6)\n\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMeanAbsoluteDeviation(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0})-1.0) < 1e-6)\n}\n"}
{"task_id": "Go/5", "prompt": "\n// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> Intersperse([], 4)\n// []\n// >>> Intersperse([1, 2, 3], 4)\n// [1, 4, 2, 4, 3]\nfunc Intersperse(numbers []int, delimeter int) []int {\n", "import": "", "docstring": "// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> Intersperse([], 4)\n// []\n// >>> Intersperse([1, 2, 3], 4)\n// [1, 4, 2, 4, 3]\n", "declaration": "\nfunc Intersperse(numbers []int, delimeter int) []int {\n", "canonical_solution": "\tresult := make([]int, 0)\n\tif len(numbers) == 0 {\n\t\treturn result\n\t}\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tn := numbers[i]\n\t\tresult = append(result, n)\n\t\tresult = append(result, delimeter)\n\t}\n\tresult = append(result, numbers[len(numbers)-1])\n\treturn result\n}\n\n", "test": "func TestIntersperse(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{}, Intersperse([]int{}, 7))\n\tassert.Equal([]int{5, 8, 6, 8, 3, 8, 2}, Intersperse([]int{5, 6, 3, 2}, 8))\n\tassert.Equal([]int{2, 2, 2, 2, 2}, Intersperse([]int{2, 2, 2}, 2))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIntersperse(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{}, Intersperse([]int{}, 4))\n\tassert.Equal([]int{1,4,2,4,3}, Intersperse([]int{1,2,3}, 4))\n}\n"}
{"task_id": "Go/6", "prompt": "import (\n\t\"math\"\n\t\"strings\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// \n// >>> ParseNestedParens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc ParseNestedParens(paren_string string) []int {\n", "import": "import (\n\t\"math\"\n\t\"strings\"\n)\n", "docstring": "// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// \n// >>> ParseNestedParens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\n", "declaration": "\nfunc ParseNestedParens(paren_string string) []int {\n", "canonical_solution": "\tparse_paren_group := func(s string) int {\n\t\tdepth := 0\n\t\tmax_depth := 0\n\t\tfor _, c := range s {\n\t\t\tif c == '(' {\n\t\t\t\tdepth += 1\n\t\t\t\tmax_depth = int(math.Max(float64(depth), float64(max_depth)))\n\t\t\t} else {\n\t\t\t\tdepth -= 1\n\t\t\t}\n\t\t}\n\t\treturn max_depth\n\t}\n\tresult := make([]int, 0)\n\tfor _, x := range strings.Split(paren_string, \" \") {\n\t\tresult = append(result, parse_paren_group(x))\n\t}\n\treturn result\n\n}\n\n", "test": "func TestParseNestedParens(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 3, 1, 3}, ParseNestedParens(\"(()()) ((())) () ((())()())\"))\n\tassert.Equal([]int{1, 2, 3, 4}, ParseNestedParens(\"() (()) ((())) (((())))\"))\n\tassert.Equal([]int{4}, ParseNestedParens(\"(()(())((())))\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestParseNestedParens(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 3, 1, 3}, ParseNestedParens(\"(()()) ((())) () ((())()())\"))\n}\n"}
{"task_id": "Go/7", "prompt": "import (\n\t\"strings\"\n)\n\n// Filter an input list of strings only for ones that contain given substring\n// >>> FilterBySubstring([], 'a')\n// []\n// >>> FilterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nfunc FilterBySubstring(stringList []string, substring string) []string {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Filter an input list of strings only for ones that contain given substring\n// >>> FilterBySubstring([], 'a')\n// []\n// >>> FilterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\n", "declaration": "\nfunc FilterBySubstring(stringList []string, substring string) []string {\n", "canonical_solution": "\tresult := make([]string, 0)\n\tfor _, x := range stringList {\n\t\tif strings.Index(x, substring) != -1 {\n\t\t\tresult = append(result, x)\n\t\t}\n\t}\n\treturn result\n}\n\n", "test": "func TestFilterBySubstring(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{}, FilterBySubstring([]string{}, \"john\"))\n\tassert.Equal([]string{\"xxx\", \"xxxAAA\", \"xxx\"}, FilterBySubstring([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"))\n\tassert.Equal([]string{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"}, FilterBySubstring([]string{\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"))\n\tassert.Equal([]string{\"grunt\", \"prune\"}, FilterBySubstring([]string{\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFilterBySubstring(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{}, FilterBySubstring([]string{}, \"a\"))\n\tassert.Equal([]string{\"abc\", \"bacd\", \"array\"}, FilterBySubstring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\"))\n}\n"}
{"task_id": "Go/8", "prompt": "\n// For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> SumProduct([])\n// (0, 1)\n// >>> SumProduct([1, 2, 3, 4])\n// (10, 24)\nfunc SumProduct(numbers []int) [2]int {\n", "import": "", "docstring": "// For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> SumProduct([])\n// (0, 1)\n// >>> SumProduct([1, 2, 3, 4])\n// (10, 24)\n", "declaration": "\nfunc SumProduct(numbers []int) [2]int {\n", "canonical_solution": "\tsum_value := 0\n\tprod_value := 1\n\n\tfor _, n := range numbers {\n\t\tsum_value += n\n\t\tprod_value *= n\n\t}\n\treturn [2]int{sum_value, prod_value}\n}\n\n", "test": "func TestSumProduct(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]int{0, 1}, SumProduct([]int{}))\n\tassert.Equal([2]int{3, 1}, SumProduct([]int{1, 1, 1}))\n\tassert.Equal([2]int{100, 0}, SumProduct([]int{100, 0}))\n\tassert.Equal([2]int{3 + 5 + 7, 3 * 5 * 7}, SumProduct([]int{3, 5, 7}))\n\tassert.Equal([2]int{10, 10}, SumProduct([]int{10}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSumProduct(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]int{0, 1}, SumProduct([]int{}))\n\tassert.Equal([2]int{10,24}, SumProduct([]int{1, 2,3,4}))\n}\n"}
{"task_id": "Go/9", "prompt": "import (\n\t\"math\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> RollingMax([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc RollingMax(numbers []int) []int {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> RollingMax([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\n", "declaration": "\nfunc RollingMax(numbers []int) []int {\n", "canonical_solution": "\trunning_max := math.MinInt32\n\tresult := make([]int, 0)\n\n\tfor _, n := range numbers {\n\t\tif running_max == math.MinInt32 {\n\t\t\trunning_max = n\n\t\t} else {\n\t\t\trunning_max = int(math.Max(float64(running_max), float64(n)))\n\t\t}\n\t\tresult = append(result, running_max)\n\t}\n\n\treturn result\n}\n\n", "test": "func TestRollingMax(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{}, RollingMax([]int{}))\n\tassert.Equal([]int{1, 2, 3, 4}, RollingMax([]int{1, 2, 3, 4}))\n\tassert.Equal([]int{4, 4, 4, 4}, RollingMax([]int{4, 3, 2, 1}))\n\tassert.Equal([]int{3, 3, 3, 100, 100}, RollingMax([]int{3, 2, 3, 100, 3}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRollingMax(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 2, 3,3, 3, 4, 4}, RollingMax([]int{1, 2, 3, 2, 3, 4, 2}))\n}\n"}
{"task_id": "Go/10", "prompt": "import (\n\t\"strings\"\n)\n\n// Test if given string is a palindrome.\nfunc IsPalindrome(str string) bool {\n\trunes := []rune(str)\n\tresult := make([]rune, 0)\n\tfor i := len(runes) - 1; i >= 0; i-- {\n\t\tresult = append(result, runes[i])\n\t}\n\treturn str == string(result)\n}\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> MakePalindrome('')\n// ''\n// >>> MakePalindrome('cat')\n// 'catac'\n// >>> MakePalindrome('cata')\n// 'catac'\nfunc MakePalindrome(str string) string {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> MakePalindrome('')\n// ''\n// >>> MakePalindrome('cat')\n// 'catac'\n// >>> MakePalindrome('cata')\n// 'catac'\n", "declaration": "\nfunc MakePalindrome(str string) string {\n", "canonical_solution": "\tif strings.TrimSpace(str) == \"\" {\n\t\treturn \"\"\n\t}\n\tbeginning_of_suffix := 0\n\trunes := []rune(str)\n\tfor !IsPalindrome(string(runes[beginning_of_suffix:])) {\n\t\tbeginning_of_suffix += 1\n\t}\n\tresult := make([]rune, 0)\n\tfor i := len(str[:beginning_of_suffix]) - 1; i >= 0; i-- {\n\t\tresult = append(result, runes[i])\n\t}\n\treturn str + string(result)\n}\n\n", "test": "func TestMakePalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"\", MakePalindrome(\"\"))\n\tassert.Equal(\"x\", MakePalindrome(\"x\"))\n\tassert.Equal(\"xyzyx\", MakePalindrome(\"xyz\"))\n\tassert.Equal(\"xyx\", MakePalindrome(\"xyx\"))\n\tassert.Equal(\"jerryrrej\", MakePalindrome(\"jerry\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMakePalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"\", MakePalindrome(\"\"))\n\tassert.Equal(\"catac\", MakePalindrome(\"cat\"))\n\tassert.Equal(\"catac\", MakePalindrome(\"cata\"))\n}\n"}
{"task_id": "Go/11", "prompt": "import (\n\t\"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> StringXor('010', '110')\n// '100'\nfunc StringXor(a string, b string) string {\n", "import": "import (\n\t\"fmt\"\n)\n", "docstring": "// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> StringXor('010', '110')\n// '100'\n", "declaration": "\nfunc StringXor(a string, b string) string {\n", "canonical_solution": "\ts2b := func(bs string) int32 {\n\t\tresult := int32(0)\n\t\trunes := []rune(bs)\n\t\tfor _, r := range runes {\n\t\t\tresult = result << 1\n\t\t\ttemp := r - rune('0')\n\t\t\tresult += temp\n\t\t}\n\t\treturn result\n\t}\n\tab := s2b(a)\n\tbb := s2b(b)\n\tres := ab ^ bb\n\tsprint := fmt.Sprintf(\"%b\", res)\n\tfor i := 0; i < len(a)-len(sprint); i++ {\n\t\tsprint = \"0\" + sprint\n\t}\n\treturn sprint\n}\n\n", "test": "func TestStringXor(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"010010\", StringXor(\"111000\", \"101010\"))\n\tassert.Equal(\"0\", StringXor(\"1\", \"1\"))\n\tassert.Equal(\"0101\", StringXor(\"0101\", \"0000\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStringXor(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"100\", StringXor(\"010\", \"110\"))\n}\n"}
{"task_id": "Go/12", "prompt": "// Out of list of strings, return the Longest one. Return the first one in case of multiple\n// strings of the same length. Return nil in case the input list is empty.\n// >>> Longest([])\n// nil\n// >>> Longest(['a', 'b', 'c'])\n// 'a'\n// >>> Longest(['a', 'bb', 'ccc'])\n// 'ccc'\nfunc Longest(strings []string) interface{}{\n", "import": "", "docstring": "// Out of list of strings, return the Longest one. Return the first one in case of multiple\n// strings of the same length. Return nil in case the input list is empty.\n// >>> Longest([])\n// nil\n// >>> Longest(['a', 'b', 'c'])\n// 'a'\n// >>> Longest(['a', 'bb', 'ccc'])\n// 'ccc'\n", "declaration": "\nfunc Longest(strings []string) interface{}{\n", "canonical_solution": "\tif strings == nil || len(strings) == 0 {\n\t\treturn nil\n\t}\n\tmaxlen := 0\n\tmaxi := 0\n\tfor i, s := range strings {\n\t\tif maxlen < len(s) {\n\t\t\tmaxlen = len(s)\n\t\t\tmaxi = i\n\t\t}\n\t}\n\treturn strings[maxi]\n}\n\n", "test": "func TestLongest(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(nil, Longest([]string{}))\n\tassert.Equal(\"x\", Longest([]string{\"x\", \"y\", \"z\"}))\n\tassert.Equal(\"zzzz\", Longest([]string{\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestLongest(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(nil, Longest([]string{}))\n\tassert.Equal(\"a\", Longest([]string{\"a\", \"b\", \"c\"}))\n\tassert.Equal(\"ccc\", Longest([]string{\"a\", \"bb\", \"ccc\"}))\n}\n"}
{"task_id": "Go/13", "prompt": "\n// Return a greatest common divisor of two integers a and b\n// >>> GreatestCommonDivisor(3, 5)\n// 1\n// >>> GreatestCommonDivisor(25, 15)\n// 5\nfunc GreatestCommonDivisor(a int,b int) int{\n", "import": "", "docstring": "// Return a greatest common divisor of two integers a and b\n// >>> GreatestCommonDivisor(3, 5)\n// 1\n// >>> GreatestCommonDivisor(25, 15)\n// 5\n", "declaration": "\nfunc GreatestCommonDivisor(a int,b int) int{\n", "canonical_solution": "\tif b < 2 {\n\t\treturn b\n\t}\n\tvar gcd int = 1\n\tfor i := 2; i < b; i++ {\n\t\tif a%i == 0 && b%i == 0 {\n\t\t\tgcd = i\n\t\t}\n\t}\n\treturn gcd\n}\n\n", "test": "func TestGreatestCommonDivisor(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, GreatestCommonDivisor(3, 7))\n\tassert.Equal(5, GreatestCommonDivisor(10, 15))\n\tassert.Equal(7, GreatestCommonDivisor(49, 14))\n\tassert.Equal(12, GreatestCommonDivisor(144, 60))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGreatestCommonDivisor(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, GreatestCommonDivisor(3, 5))\n\tassert.Equal(5, GreatestCommonDivisor(25, 15))\n}\n"}
{"task_id": "Go/14", "prompt": "\n// Return list of all prefixes from shortest to longest of the input string\n// >>> AllPrefixes('abc')\n// ['a', 'ab', 'abc']\nfunc AllPrefixes(str string) []string{\n", "import": "", "docstring": "// Return list of all prefixes from shortest to longest of the input string\n// >>> AllPrefixes('abc')\n// ['a', 'ab', 'abc']\n", "declaration": "\nfunc AllPrefixes(str string) []string{\n", "canonical_solution": "\tprefixes := make([]string, 0, len(str))\n\tfor i := 0; i < len(str); i++ {\n\t\tprefixes = append(prefixes, str[:i+1])\n\t}\n\treturn prefixes\n}\n\n", "test": "func TestAllPrefixes(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{}, AllPrefixes(\"\"))\n\tassert.Equal([]string{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"}, AllPrefixes(\"asdfgh\"))\n\tassert.Equal([]string{\"W\", \"WW\", \"WWW\"}, AllPrefixes(\"WWW\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAllPrefixes(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"a\", \"ab\", \"abc\"}, AllPrefixes(\"abc\"))\n}\n"}
{"task_id": "Go/15", "prompt": "import (\n\t\"strconv\"\n)\n\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> StringSequence(0)\n// '0'\n// >>> StringSequence(5)\n// '0 1 2 3 4 5'\nfunc StringSequence(n int) string{\n", "import": "import (\n\t\"strconv\"\n)\n", "docstring": "// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> StringSequence(0)\n// '0'\n// >>> StringSequence(5)\n// '0 1 2 3 4 5'\n", "declaration": "\nfunc StringSequence(n int) string{\n", "canonical_solution": "\tvar seq string\n\tfor i := 0; i <= n; i++ {\n\t\tseq += strconv.Itoa(i)\n\t\tif i != n {\n\t\t\tseq += \" \"\n\t\t}\n\t}\n\treturn seq\n}\n\n", "test": "func TestStringSequence(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"0\", StringSequence(0))\n\tassert.Equal(\"0 1 2 3\", StringSequence(3))\n\tassert.Equal(\"0 1 2 3 4 5 6 7 8 9 10\", StringSequence(10))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStringSequence(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"0\", StringSequence(0))\n\tassert.Equal(\"0 1 2 3 4 5\", StringSequence(5))\n}\n"}
{"task_id": "Go/16", "prompt": "import (\n\t\"strings\"\n)\n\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> CountDistinctCharacters('xyzXYZ')\n// 3\n// >>> CountDistinctCharacters('Jerry')\n// 4\nfunc CountDistinctCharacters(str string) int{\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> CountDistinctCharacters('xyzXYZ')\n// 3\n// >>> CountDistinctCharacters('Jerry')\n// 4\n", "declaration": "\nfunc CountDistinctCharacters(str string) int{\n", "canonical_solution": "\tlower := strings.ToLower(str)\n\tcount := 0\n\tset := make(map[rune]bool)\n\tfor _, i := range lower {\n\t\tif set[i] == true {\n\t\t\tcontinue\n\t\t} else {\n\t\t\tset[i] = true\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n\n", "test": "func TestCountDistinctCharacters(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, CountDistinctCharacters(\"\"))\n\tassert.Equal(5, CountDistinctCharacters(\"abcde\"))\n\tassert.Equal(5, CountDistinctCharacters(\"abcde\" + \"cade\" + \"CADE\"))\n\tassert.Equal(1, CountDistinctCharacters(\"aaaaAAAAaaaa\"))\n\tassert.Equal(5, CountDistinctCharacters(\"Jerry jERRY JeRRRY\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCountDistinctCharacters(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, CountDistinctCharacters(\"xyzXYZ\"))\n\tassert.Equal(4, CountDistinctCharacters(\"Jerry\"))\n}\n"}
{"task_id": "Go/17", "prompt": "\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// \n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// \n// >>> ParseMusic('o o| .| o| o| .| .| .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc ParseMusic(music_string string) []int{\n", "import": "", "docstring": "// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// \n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// \n// >>> ParseMusic('o o| .| o| o| .| .| .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n", "declaration": "\nfunc ParseMusic(music_string string) []int{\n", "canonical_solution": "\tnote_map := map[string]int{\"o\": 4, \"o|\": 2, \".|\": 1}\n\tsplit := strings.Split(music_string, \" \")\n\tresult := make([]int, 0)\n\tfor _, x := range split {\n\t\tif i, ok := note_map[x]; ok {\n\t\t\tresult = append(result, i)\n\t\t}\n\t}\n\treturn result\n}\n\n\n", "test": "func TestParseMusic(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{}, ParseMusic(\"\"))\n\tassert.Equal([]int{4, 4, 4, 4}, ParseMusic(\"o o o o\"))\n\tassert.Equal([]int{1, 1, 1, 1}, ParseMusic(\".| .| .| .|\"))\n\tassert.Equal([]int{2, 2, 1, 1, 4, 4, 4, 4}, ParseMusic(\"o| o| .| .| o o o o\"))\n\tassert.Equal([]int{2, 1, 2, 1, 4, 2, 4, 2}, ParseMusic(\"o| .| o| .| o o| o o|\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestParseMusic(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}, ParseMusic(\"o o| .| o| o| .| .| .| .| o o\"))\n}\n"}
{"task_id": "Go/18", "prompt": "\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> HowManyTimes('', 'a')\n// 0\n// >>> HowManyTimes('aaa', 'a')\n// 3\n// >>> HowManyTimes('aaaa', 'aa')\n// 3\nfunc HowManyTimes(str string,substring string) int{\n", "import": "", "docstring": "\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> HowManyTimes('', 'a')\n// 0\n// >>> HowManyTimes('aaa', 'a')\n// 3\n// >>> HowManyTimes('aaaa', 'aa')\n// 3\n", "declaration": "\nfunc HowManyTimes(str string,substring string) int{\n", "canonical_solution": "\ttimes := 0\n\tfor i := 0; i < (len(str) - len(substring) + 1); i++ {\n\t\tif str[i:i+len(substring)] == substring {\n\t\t\ttimes += 1\n\t\t}\n\t}\n\treturn times\n}\n\n\n", "test": "func TestHowManyTimes(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, HowManyTimes(\"\", \"x\"))\n\tassert.Equal(4, HowManyTimes(\"xyxyxyx\", \"x\"))\n\tassert.Equal(4, HowManyTimes(\"cacacacac\", \"cac\"))\n\tassert.Equal(1, HowManyTimes(\"john doe\", \"john\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestHowManyTimes(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, HowManyTimes(\"\", \"a\"))\n\tassert.Equal(3, HowManyTimes(\"aaa\", \"a\"))\n\tassert.Equal(3, HowManyTimes(\"aaaa\", \"aa\"))\n}\n"}
{"task_id": "Go/19", "prompt": "import (\n\t\"sort\"\n\t\"strings\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> SortNumbers('three one five')\n// 'one three five'\nfunc SortNumbers(numbers string) string{\n", "import": "import (\n\t\"sort\"\n\t\"strings\"\n)", "docstring": "// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> SortNumbers('three one five')\n// 'one three five'\n", "declaration": "\nfunc SortNumbers(numbers string) string{\n", "canonical_solution": "\tvalueMap := map[string]int{\n\t\t\"zero\":  0,\n\t\t\"one\":   1,\n\t\t\"two\":   2,\n\t\t\"three\": 3,\n\t\t\"four\":  4,\n\t\t\"five\":  5,\n\t\t\"six\":   6,\n\t\t\"seven\": 7,\n\t\t\"eight\": 8,\n\t\t\"nine\":  9,\n\t}\n\tstringMap := make(map[int]string)\n\tfor s, i := range valueMap {\n\t\tstringMap[i] = s\n\t}\n\tsplit := strings.Split(numbers, \" \")\n\ttemp := make([]int, 0)\n\tfor _, s := range split {\n\t\tif i, ok := valueMap[s]; ok {\n\t\t\ttemp = append(temp, i)\n\t\t}\n\t}\n\tsort.Ints(temp)\n\tresult := make([]string, 0)\n\tfor _, i := range temp {\n\t\tresult = append(result, stringMap[i])\n\t}\n\treturn strings.Join(result, \" \")\n}\n\n\n", "test": "func TestSortNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"\", SortNumbers(\"\"))\n\tassert.Equal(\"three\", SortNumbers(\"three\"))\n\tassert.Equal(\"three five nine\", SortNumbers(\"three five nine\"))\n\tassert.Equal(\"zero four five seven eight nine\", SortNumbers(\"five zero four seven nine eight\"))\n\tassert.Equal(\"zero one two three four five six\", SortNumbers(\"six five four three two one zero\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"one three five\", SortNumbers(\"three one five\"))\n}\n"}
{"task_id": "Go/20", "prompt": "\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> FindClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n// (2.0, 2.2)\n// >>> FindClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n// (2.0, 2.0)\nfunc FindClosestElements(numbers []float64) [2]float64 {\n", "import": "", "docstring": "// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> FindClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n// (2.0, 2.2)\n// >>> FindClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n// (2.0, 2.0)\n", "declaration": "\nfunc FindClosestElements(numbers []float64) [2]float64 {\n", "canonical_solution": "\tdistance := math.MaxFloat64\n\tvar closestPair [2]float64\n\tfor idx, elem := range numbers {\n\t\tfor idx2, elem2 := range numbers {\n\t\t\tif idx != idx2 {\n\t\t\t\tif distance == math.MinInt64 {\n\t\t\t\t\tdistance = math.Abs(elem - elem2)\n\t\t\t\t\tfloat64s := []float64{elem, elem2}\n\t\t\t\t\tsort.Float64s(float64s)\n\t\t\t\t\tclosestPair = [2]float64{float64s[0], float64s[1]}\n\t\t\t\t} else {\n\t\t\t\t\tnewDistance := math.Abs(elem - elem2)\n\t\t\t\t\tif newDistance < distance{\n\t\t\t\t\t\tdistance = newDistance\n\t\t\t\t\t\tfloat64s := []float64{elem, elem2}\n\t\t\t\t\t\tsort.Float64s(float64s)\n\t\t\t\t\t\tclosestPair = [2]float64{float64s[0], float64s[1]}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn closestPair\n}\n\n\n", "test": "func TestFindClosestElements(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]float64{3.9, 4.0}, FindClosestElements([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}))\n\tassert.Equal([2]float64{5.0, 5.9}, FindClosestElements([]float64{1.0, 2.0, 5.9, 4.0, 5.0}))\n\tassert.Equal([2]float64{2.0, 2.2}, FindClosestElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}))\n\tassert.Equal([2]float64{2.0, 2.0}, FindClosestElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}))\n\tassert.Equal([2]float64{2.2, 3.1}, FindClosestElements([]float64{1.1, 2.2, 3.1, 4.1, 5.1}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFindClosestElements(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]float64{2.0, 2.2}, FindClosestElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}))\n\tassert.Equal([2]float64{2.0, 2.0}, FindClosestElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}))\n}\n"}
{"task_id": "Go/21", "prompt": "\n// Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> RescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc RescaleToUnit(numbers []float64) []float64 {\n", "import": "", "docstring": "// Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> RescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n", "declaration": "\nfunc RescaleToUnit(numbers []float64) []float64 {\n", "canonical_solution": "\tsmallest := numbers[0]\n\tlargest := smallest\n\tfor _, n := range numbers {\n\t\tif smallest > n {\n\t\t\tsmallest = n\n\t\t}\n\t\tif largest < n {\n\t\t\tlargest = n\n\t\t}\n\t}\n\tif smallest == largest {\n\t\treturn numbers\n\t}\n\tfor i, n := range numbers {\n\t\tnumbers[i] = (n - smallest) / (largest - smallest)\n\t}\n\treturn numbers\n}\n\n", "test": "func TestRescaleToUnit(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]float64{0.0, 1.0}, RescaleToUnit([]float64{2.0, 49.9}))\n\tassert.Equal([]float64{1.0, 0.0}, RescaleToUnit([]float64{100.0, 49.9}))\n\tassert.Equal([]float64{0.0, 0.25, 0.5, 0.75, 1.0}, RescaleToUnit([]float64{1.0, 2.0, 3.0, 4.0, 5.0}))\n\tassert.Equal([]float64{0.25, 0.0, 1.0, 0.5, 0.75}, RescaleToUnit([]float64{2.0, 1.0, 5.0, 3.0, 4.0}))\n\tassert.Equal([]float64{0.25, 0.0, 1.0, 0.5, 0.75}, RescaleToUnit([]float64{12.0, 11.0, 15.0, 13.0, 14.0}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRescaleToUnit(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]float64{0.0, 0.25, 0.5, 0.75, 1.0}, RescaleToUnit([]float64{1.0, 2.0, 3.0, 4.0, 5.0}))\n}\n"}
{"task_id": "Go/22", "prompt": "// Filter given list of any values only for integers\n// >>> FilterIntegers(['a', 3.14, 5])\n// [5]\n// >>> FilterIntegers([1, 2, 3, 'abc', {}, []])\n// [1, 2, 3]\nfunc FilterIntegers(values []interface{}) []int {\n", "import": "", "docstring": "// Filter given list of any values only for integers\n// >>> FilterIntegers(['a', 3.14, 5])\n// [5]\n// >>> FilterIntegers([1, 2, 3, 'abc', {}, []])\n// [1, 2, 3]\n", "declaration": "\nfunc FilterIntegers(values []interface{}) []int {\n", "canonical_solution": "\tresult := make([]int, 0)\n\tfor _, val := range values {\n\t\tswitch i := val.(type) {\n\t\tcase int:\n\t\t\tresult = append(result, i)\n\t\t}\n\t}\n\treturn result\n}\n\n", "test": "func TestFilterIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{}, FilterIntegers([]interface{}{}))\n\tassert.Equal([]int{4, 9}, FilterIntegers([]interface{}{4, nil, []interface{}{}, 23.2, 9, \"adasd\"}))\n\tassert.Equal([]int{3, 3, 3}, FilterIntegers([]interface{}{3, 'c', 3, 3, 'a', 'b'}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFilterIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{5}, FilterIntegers([]interface{}{'a', 3.14, 5}))\n\tassert.Equal([]int{1,2,3}, FilterIntegers([]interface{}{1,2,3,\"abc\", nil, []interface{}{}}))\n}\n"}
{"task_id": "Go/23", "prompt": "\n// Return length of given string\n// >>> Strlen('')\n// 0\n// >>> Strlen('abc')\n// 3\nfunc Strlen(str string) int {\n", "import": "", "docstring": "// Return length of given string\n// >>> Strlen('')\n// 0\n// >>> Strlen('abc')\n// 3\n", "declaration": "\nfunc Strlen(str string) int {\n", "canonical_solution": "\treturn len(str)\n}\n\n", "test": "func TestStrlen(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, Strlen(\"\"))\n\tassert.Equal(1, Strlen(\"x\"))\n\tassert.Equal(9, Strlen(\"asdasnakj\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStrlen(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, Strlen(\"\"))\n\tassert.Equal(3, Strlen(\"abc\"))\n}\n"}
{"task_id": "Go/24", "prompt": "\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> LargestDivisor(15)\n// 5\nfunc LargestDivisor(n int) int {\n", "import": "", "docstring": "// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> LargestDivisor(15)\n// 5\n", "declaration": "\nfunc LargestDivisor(n int) int {\n", "canonical_solution": "\tfor i := n - 1; i > 0; i-- {\n\t\tif n % i == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn 0\n}\n\n", "test": "func TestLargestDivisor(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, LargestDivisor(3))\n\tassert.Equal(1, LargestDivisor(7))\n\tassert.Equal(5, LargestDivisor(10))\n\tassert.Equal(50, LargestDivisor(100))\n\tassert.Equal(7, LargestDivisor(49))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestLargestDivisor(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(5, LargestDivisor(15))\n}\n"}
{"task_id": "Go/25", "prompt": "import (\n\t\"math\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> Factorize(8)\n// [2, 2, 2]\n// >>> Factorize(25)\n// [5, 5]\n// >>> Factorize(70)\n// [2, 5, 7]\nfunc Factorize(n int) []int {\n", "import": "import (\n\t\"math\"\n)", "docstring": "// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> Factorize(8)\n// [2, 2, 2]\n// >>> Factorize(25)\n// [5, 5]\n// >>> Factorize(70)\n// [2, 5, 7]\n", "declaration": "\nfunc Factorize(n int) []int {\n", "canonical_solution": "\tfact := make([]int, 0)\n\tfor i := 2; i <= int(math.Sqrt(float64(n))+1); {\n\t\tif n%i == 0 {\n\t\t\tfact = append(fact, i)\n\t\t\tn = n / i\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfact = append(fact, n)\n\t}\n\treturn fact\n}\n\n", "test": "func TestFactorize(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2}, Factorize(2))\n\tassert.Equal([]int{2, 2}, Factorize(4))\n\tassert.Equal([]int{2, 2, 2}, Factorize(8))\n\tassert.Equal([]int{3, 19}, Factorize(3 * 19))\n\tassert.Equal([]int{3, 3, 19, 19}, Factorize(3 * 19 * 3 * 19))\n\tassert.Equal([]int{3, 3, 3, 19, 19, 19}, Factorize(3 * 19 * 3 * 19 * 3 * 19))\n\tassert.Equal([]int{3, 19, 19, 19}, Factorize(3 * 19 * 19 * 19))\n\tassert.Equal([]int{2, 3, 3}, Factorize(3 * 2 * 3))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFactorize(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 2, 2}, Factorize(8))\n\tassert.Equal([]int{5,5}, Factorize(25))\n\tassert.Equal([]int{2,5,7}, Factorize(70))\n}\n"}
{"task_id": "Go/26", "prompt": "\n// From a list of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> RemoveDuplicates([1, 2, 3, 2, 4])\n// [1, 3, 4]\nfunc RemoveDuplicates(numbers []int) []int {\n", "import": "", "docstring": "// From a list of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> RemoveDuplicates([1, 2, 3, 2, 4])\n// [1, 3, 4]\n", "declaration": "\nfunc RemoveDuplicates(numbers []int) []int {\n", "canonical_solution": "\tc := make(map[int] int)\n\tfor _, number := range numbers {\n\t\tif i, ok := c[number]; ok {\n\t\t\tc[number] = i + 1\n\t\t} else {\n\t\t\tc[number] = 1\n\t\t}\n\t}\n\tresult := make([]int, 0)\n\tfor _, number := range numbers {\n\t\tif c[number] <= 1 {\n\t\t\tresult = append(result, number)\n\t\t}\n\t}\n\treturn result\n}\n\n", "test": "func TestRemoveDuplicates(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{}, RemoveDuplicates([]int{}))\n\tassert.Equal([]int{1, 2, 3, 4}, RemoveDuplicates([]int{1, 2, 3,4}))\n\tassert.Equal([]int{1, 4, 5}, RemoveDuplicates([]int{1, 2, 3, 2,4, 3, 5}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRemoveDuplicates(t *testing.T) {\n\tassert := assert.New(t)  \n\tassert.Equal([]int{1,  3, 4}, RemoveDuplicates([]int{1,2, 3,2,4}))\n}\n"}
{"task_id": "Go/27", "prompt": "import (\n\t\"strings\"\n)\n\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> FlipCase('Hello')\n// 'hELLO'\nfunc FlipCase(str string) string {\n", "import": "import (\n\t\"strings\"\n)", "docstring": "\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> FlipCase('Hello')\n// 'hELLO'\n", "declaration": "\nfunc FlipCase(str string) string {\n", "canonical_solution": "\tresult := []rune{}\n\tfor _, c := range str {\n\t\tif c >= 'A' && c <= 'Z' {\n\t\t\tresult = append(result, 'a' + ((c - 'A' + 26) % 26))\n\t\t} else if c >= 'a' && c <= 'z' {\n\t\t\tresult = append(result, 'A' + ((c - 'a' + 26) % 26))\n\t\t} else {\n\t\t\tresult = append(result, c)\n\t\t}\n\t}\n\treturn string(result)\n}\n\n", "test": "func TestFlipCase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"\", FlipCase(\"\"))\n\tassert.Equal(\"hELLO!\", FlipCase(\"Hello!\"))\n\tassert.Equal(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\",FlipCase(\"These violent delights have violent ends\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFlipCase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"hELLO\", FlipCase(\"Hello\"))\n}\n"}
{"task_id": "Go/28", "prompt": "\n// Concatenate list of strings into a single string\n// >>> Concatenate([])\n// ''\n// >>> Concatenate(['a', 'b', 'c'])\n// 'abc'\nfunc Concatenate(strings []string) string {\n", "import": "", "docstring": "// Concatenate list of strings into a single string\n// >>> Concatenate([])\n// ''\n// >>> Concatenate(['a', 'b', 'c'])\n// 'abc'\n", "declaration": "\nfunc Concatenate(strings []string) string {\n", "canonical_solution": "\tif len(strings) == 0 {\n\t\treturn \"\"\n\t}\n\treturn strings[0] + Concatenate(strings[1:])\n}\n\n", "test": "func TestConcatenate(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"\", Concatenate([]string{}))\n\tassert.Equal(\"xyz\", Concatenate([]string{\"x\", \"y\", \"z\"}))\n\tassert.Equal(\"xyzwk\", Concatenate([]string{\"x\", \"y\",\"z\", \"w\", \"k\"}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestConcatenate(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"\", Concatenate([]string{}))\n\tassert.Equal(\"abc\", Concatenate([]string{\"a\", \"b\", \"c\"}))\n}\n"}
{"task_id": "Go/29", "prompt": "\n// Filter an input list of strings only for ones that start with a given prefix.\n// >>> FilterByPrefix([], 'a')\n// []\n// >>> FilterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n// ['abc', 'array']\nfunc FilterByPrefix(strings []string,prefix string) []string {\n", "import": "", "docstring": "// Filter an input list of strings only for ones that start with a given prefix.\n// >>> FilterByPrefix([], 'a')\n// []\n// >>> FilterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n// ['abc', 'array']\n", "declaration": "\nfunc FilterByPrefix(strings []string,prefix string) []string {\n", "canonical_solution": "\tif len(strings) == 0 {\n\t\treturn []string{}\n\t}\n\tres := make([]string, 0, len(strings))\n\tfor _, s := range strings {\n\t\tif s[:len(prefix)] == prefix {\n\t\t\tres = append(res, s)\n\t\t}\n\t}\n\treturn res\n}\n\n\n", "test": "func TestFilterByPrefix(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{}, FilterByPrefix([]string{}, \"john\"))\n\tassert.Equal([]string{\"xxx\", \"xxxAAA\", \"xxx\"}, FilterByPrefix([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFilterByPrefix(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{}, FilterByPrefix([]string{}, \"a\"))\n\tassert.Equal([]string{\"abc\", \"array\"}, FilterByPrefix([]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\"))\n}\n"}
{"task_id": "Go/30", "prompt": "\n// Return only positive numbers in the list.\n// >>> GetPositive([-1, 2, -4, 5, 6])\n// [2, 5, 6]\n// >>> GetPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// [5, 3, 2, 3, 9, 123, 1]\nfunc GetPositive(l []int) []int {\n", "import": "", "docstring": "// Return only positive numbers in the list.\n// >>> GetPositive([-1, 2, -4, 5, 6])\n// [2, 5, 6]\n// >>> GetPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// [5, 3, 2, 3, 9, 123, 1]\n", "declaration": "\nfunc GetPositive(l []int) []int {\n", "canonical_solution": "\tres := make([]int, 0)\n\tfor _, x := range l {\n\t\tif x > 0 {\n\t\t\tres = append(res, x)\n\t\t}\n\t}\n\treturn res\n}\n\n\n", "test": "func TestGetPositive(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{4, 5, 6}, GetPositive([]int{-1, -2, 4,5, 6}))\n\tassert.Equal([]int{5, 3, 2, 3, 3, 9, 123, 1}, GetPositive([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}))\n\tassert.Equal([]int{}, GetPositive([]int{-1, -2}))\n\tassert.Equal([]int{}, GetPositive([]int{}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGetPositive(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 5, 6}, GetPositive([]int{-1, 2, -4,5, 6}))\n\tassert.Equal([]int{5, 3, 2,  3, 9, 123, 1}, GetPositive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}))\n}\n"}
{"task_id": "Go/31", "prompt": "\n// Return true if a given number is prime, and false otherwise.\n// >>> IsPrime(6)\n// false\n// >>> IsPrime(101)\n// true\n// >>> IsPrime(11)\n// true\n// >>> IsPrime(13441)\n// true\n// >>> IsPrime(61)\n// true\n// >>> IsPrime(4)\n// false\n// >>> IsPrime(1)\n// false\nfunc IsPrime(n int) bool {\n", "import": "", "docstring": "// Return true if a given number is prime, and false otherwise.\n// >>> IsPrime(6)\n// false\n// >>> IsPrime(101)\n// true\n// >>> IsPrime(11)\n// true\n// >>> IsPrime(13441)\n// true\n// >>> IsPrime(61)\n// true\n// >>> IsPrime(4)\n// false\n// >>> IsPrime(1)\n// false\n", "declaration": "\nfunc IsPrime(n int) bool {\n", "canonical_solution": "\tif n <= 1 {\n\t\treturn false\n\t}\n\tif n == 2 {\n\t\treturn true\n\t}\n\tif n%2 == 0 {\n\t\treturn false\n\t}\n\tfor i := 3; i*i <= n; i += 2 {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\n", "test": "func TestIsPrime(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, IsPrime(6))\n\tassert.Equal(true, IsPrime(101))\n\tassert.Equal(true, IsPrime(11))\n\tassert.Equal(true, IsPrime(13441))\n\tassert.Equal(true, IsPrime(61))\n\tassert.Equal(false, IsPrime(4))\n\tassert.Equal(false, IsPrime(1))\n\tassert.Equal(true, IsPrime(5))\n\tassert.Equal(true, IsPrime(11))\n\tassert.Equal(true, IsPrime(17))\n\tassert.Equal(false, IsPrime(5 * 17))\n\tassert.Equal(false, IsPrime(11 * 7))\n\tassert.Equal(false, IsPrime(13441 * 19))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsPrime(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, IsPrime(6))\n\tassert.Equal(true, IsPrime(101))\n\tassert.Equal(true, IsPrime(11))\n\tassert.Equal(true, IsPrime(13441))\n\tassert.Equal(true, IsPrime(61))\n\tassert.Equal(false, IsPrime(4))\n\tassert.Equal(false, IsPrime(1))\n}\n"}
{"task_id": "Go/32", "prompt": "import (\n\t\"math\"\n)\n\n// Evaluates polynomial with coefficients xs at point x.\n// return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\nfunc Poly(xs []int, x float64) float64{\n\tsum := 0.0\n\tfor i, coeff := range xs {\n\t\tsum += float64(coeff) * math.Pow(x,float64(i))\n\t}\n\treturn sum\n}\n// xs are coefficients of a polynomial.\n// FindZero find x such that Poly(x) = 0.\n// FindZero returns only only zero point, even if there are many.\n// Moreover, FindZero only takes list xs having even number of coefficients\n// and largest non zero coefficient as it guarantees\n// a solution.\n// >>> round(FindZero([1, 2]), 2) # f(x) = 1 + 2x\n// -0.5\n// >>> round(FindZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n// 1.0\nfunc FindZero(xs []int) float64 {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// xs are coefficients of a polynomial.\n// FindZero find x such that Poly(x) = 0.\n// FindZero returns only only zero point, even if there are many.\n// Moreover, FindZero only takes list xs having even number of coefficients\n// and largest non zero coefficient as it guarantees\n// a solution.\n// >>> round(FindZero([1, 2]), 2) # f(x) = 1 + 2x\n// -0.5\n// >>> round(FindZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n// 1.0\n", "declaration": "\nfunc FindZero(xs []int) float64 {\n", "canonical_solution": "\tbegin := -1.0\n\tend := 1.0\n\tfor Poly(xs, begin)*Poly(xs, end) > 0 {\n\t\tbegin *= 2\n\t\tend *= 2\n\t}\n\tfor end-begin > 1e-10 {\n\t\tcenter := (begin + end) / 2\n\t\tif Poly(xs, center)*Poly(xs, begin) > 0 {\n\t\t\tbegin = center\n\t\t} else {\n\t\t\tend = center\n\t\t}\n\t}\n\treturn begin\n}\n\n", "test": "func TestFindZero(t *testing.T) {\n\tassert := assert.New(t)\n\trandInt := func(min, max int) int {\n\t\trng := rand.New(rand.NewSource(42))\n\t\tif min >= max || min == 0 || max == 0 {\n\t\t\treturn max\n\t\t}\n\t\treturn rng.Intn(max-min) + min\n\t}\n\tcopyInts := func(src []int) []int {\n\t\tints := make([]int, 0)\n\t\tfor _, i := range src {\n\t\t\tints = append(ints, i)\n\t\t}\n\t\treturn ints\n\t}\n\tfor i := 0; i < 100; i++ {\n\t\tncoeff := 2 * randInt(1, 4)\n\t\tcoeffs := make([]int, 0)\n\t\tfor j := 0; j < ncoeff; j++ {\n\t\t\tcoeff := randInt(-10, 10)\n\t\t\tif coeff == 0 {\n\t\t\t\tcoeff = 1\n\t\t\t}\n\t\t\tcoeffs = append(coeffs, coeff)\n\t\t}\n\t\tsolution := FindZero(copyInts(coeffs))\n\t\tassert.Equal(true, math.Abs(Poly(coeffs,solution))<1e-4)\n\t}\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"math/rand\"\n\t\"math\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFindZero(t *testing.T) {\n  assert := assert.New(t)\n\tassert.Equal(true, math.Abs(FindZero([]int{1,2})+0.5+rand.NormFloat64()*0.0)<1e-4)\n\tassert.Equal(true, math.Abs(FindZero([]int{-6,11,-6,1})-1)<1e-4)\n}\n"}
{"task_id": "Go/33", "prompt": "import (\n\t\"sort\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> SortThird([1, 2, 3])\n// [1, 2, 3]\n// >>> SortThird([5, 6, 3, 4, 8, 9, 2])\n// [2, 6, 3, 4, 8, 9, 5]\nfunc SortThird(l []int) []int {\n", "import": "import (\n\t\"sort\"\n)", "docstring": "// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> SortThird([1, 2, 3])\n// [1, 2, 3]\n// >>> SortThird([5, 6, 3, 4, 8, 9, 2])\n// [2, 6, 3, 4, 8, 9, 5]\n", "declaration": "\nfunc SortThird(l []int) []int {\n", "canonical_solution": "\ttemp := make([]int, 0)\n\tfor i := 0; i < len(l); i = i + 3 {\n\t\ttemp = append(temp, l[i])\n\t}\n\tsort.Ints(temp)\n\tj := 0\n\tfor i := 0; i < len(l); i = i + 3 {\n\t\tl[i] = temp[j]\n\t\tj++\n\t}\n\treturn l\n}\n\n", "test": "func TestSortThird(t *testing.T) {\n\tassert := assert.New(t)\n\tsame := func(src []int, target []int) bool {\n\t\tfor i := 0; i < len(src); i++ {\n\t\t\tif src[i] != target[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tassert.Equal(true, same([]int{1, 2, 3}, SortThird([]int{1, 2, 3})))\n\tassert.Equal(true, same([]int{1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10}, SortThird([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})))\n\tassert.Equal(true, same([]int{-10, 8, -12,3, 23, 2, 4, 11, 12, 5}, SortThird([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10})))\n\tassert.Equal(true, same([]int{2, 6, 3, 4, 8, 9, 5}, SortThird([]int{5, 6, 3, 4, 8, 9, 2})))\n\tassert.Equal(true, same([]int{2, 8, 3, 4, 6, 9, 5}, SortThird([]int{5, 8, 3, 4, 6, 9, 2})))\n\tassert.Equal(true, same([]int{2, 6, 9, 4, 8, 3, 5}, SortThird([]int{5, 6, 9, 4, 8, 3, 2})))\n\tassert.Equal(true, same([]int{2, 6, 3, 4, 8, 9, 5, 1}, SortThird([]int{5, 6, 3, 4, 8, 9, 2, 1})))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortThird(t *testing.T) {\n\tassert := assert.New(t)\n\tsame := func(src []int, target []int) bool {\n\t\tfor i := 0; i < len(src); i++ {\n\t\t\tif src[i] != target[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tassert.Equal(true, same([]int{1, 2, 3}, SortThird([]int{1, 2, 3})))\n\tassert.Equal(true, same([]int{2, 6, 3, 4, 8, 9, 5}, SortThird([]int{5, 6, 3, 4, 8, 9, 2})))\n}\n"}
{"task_id": "Go/34", "prompt": "import (\n\t\"sort\"\n)\n\n// Return sorted Unique elements in a list\n// >>> Unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\nfunc Unique(l []int) []int {\n", "import": "import (\n\t\"sort\"\n)", "docstring": "// Return sorted Unique elements in a list\n// >>> Unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\n", "declaration": "\nfunc Unique(l []int) []int {\n", "canonical_solution": "\tset := make(map[int]interface{})\n\tfor _, i := range l {\n\t\tset[i]=nil\n\t}\n\tl = make([]int,0)\n\tfor i, _ := range set {\n\t\tl = append(l, i)\n\t}\n\tsort.Ints(l)\n\treturn l\n}\n\n", "test": "func TestUnique(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{0, 2, 3, 5, 9, 123}, Unique([]int{5, 3,5, 2, 3, 3, 9, 0, 123}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestUnique(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{0, 2, 3, 5, 9, 123}, Unique([]int{5, 3,5, 2, 3, 3, 9, 0, 123}))\n}\n"}
{"task_id": "Go/35", "prompt": "\n// Return maximum element in the list.\n// >>> MaxElement([1, 2, 3])\n// 3\n// >>> MaxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// 123\nfunc MaxElement(l []int) int {\n", "import": "", "docstring": "// Return maximum element in the list.\n// >>> MaxElement([1, 2, 3])\n// 3\n// >>> MaxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// 123\n", "declaration": "\nfunc MaxElement(l []int) int {\n", "canonical_solution": "\tmax := l[0]\n\tfor _, x := range l {\n\t\tif x > max {\n\t\t\tmax = x\n\t\t}\n\t}\n\treturn max\n}\n\n", "test": "func TestMaxElement(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, MaxElement([]int{1, 2, 3}))\n\tassert.Equal(124, MaxElement([]int{5, 3, -5, 2, -3, 3, 9,0, 124, 1, -10}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMaxElement(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, MaxElement([]int{1, 2, 3}))\n\tassert.Equal(123, MaxElement([]int{5, 3, -5, 2, -3, 3, 9,0, 123, 1, -10}))\n}\n"}
{"task_id": "Go/36", "prompt": "import (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> FizzBuzz(50)\n// 0\n// >>> FizzBuzz(78)\n// 2\n// >>> FizzBuzz(79)\n// 3\nfunc FizzBuzz(n int) int {\n", "import": "import (\n\t\"strconv\"\n\t\"strings\"\n)", "docstring": "// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> FizzBuzz(50)\n// 0\n// >>> FizzBuzz(78)\n// 2\n// >>> FizzBuzz(79)\n// 3\n", "declaration": "\nfunc FizzBuzz(n int) int {\n", "canonical_solution": "\tns := make([]int, 0)\n\tfor i := 0; i < n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tns = append(ns, i)\n\t\t}\n\t}\n\ttemp := make([]string, 0)\n\tfor _, i := range ns {\n\t\ttemp = append(temp, strconv.Itoa(i))\n\t}\n\tjoin := strings.Join(temp, \"\")\n\tans := 0\n\tfor _, c := range join {\n\t\tif c == '7' {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\n", "test": "func TestFizzBuzz(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, FizzBuzz(50))\n\tassert.Equal(2, FizzBuzz(78))\n\tassert.Equal(3, FizzBuzz(79))\n\tassert.Equal(3, FizzBuzz(100))\n\tassert.Equal(6, FizzBuzz(200))\n\tassert.Equal(192, FizzBuzz(4000))\n\tassert.Equal(639, FizzBuzz(10000))\n\tassert.Equal(8026, FizzBuzz(100000))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFizzBuzz(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, FizzBuzz(50))\n\tassert.Equal(2, FizzBuzz(78))\n\tassert.Equal(3, FizzBuzz(79))\n}\n"}
{"task_id": "Go/37", "prompt": "import (\n\t\"sort\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> SortEven([1, 2, 3])\n// [1, 2, 3]\n// >>> SortEven([5, 6, 3, 4])\n// [3, 6, 5, 4]\nfunc SortEven(l []int) []int {\n", "import": "import (\n\t\"sort\"\n)", "docstring": "// This function takes a list l and returns a list l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> SortEven([1, 2, 3])\n// [1, 2, 3]\n// >>> SortEven([5, 6, 3, 4])\n// [3, 6, 5, 4]\n", "declaration": "\nfunc SortEven(l []int) []int {\n", "canonical_solution": "\tevens := make([]int, 0)\n\tfor i := 0; i < len(l); i += 2 {\n\t\tevens = append(evens, l[i])\n\t}\n\tsort.Ints(evens)\n\tj := 0\n\tfor i := 0; i < len(l); i += 2 {\n\t\tl[i] = evens[j]\n\t\tj++\n\t}\n\treturn l\n}\n\n", "test": "func TestSortEven(t *testing.T) {\n\tassert := assert.New(t)\n\tsame := func(src []int, target []int) bool {\n\t\tfor i := 0; i < len(src); i++ {\n\t\t\tif src[i] != target[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tassert.Equal(true, same([]int{1, 2, 3}, SortEven([]int{1, 2, 3})))\n\tassert.Equal(true, same([]int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}, SortEven([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})))\n\tassert.Equal(true, same([]int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}, SortEven([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10})))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortEven(t *testing.T) {\n\tassert := assert.New(t)\n\tsame := func(src []int, target []int) bool {\n\t\tfor i := 0; i < len(src); i++ {\n\t\t\tif src[i] != target[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tassert.Equal(true, same([]int{1, 2, 3}, SortEven([]int{1, 2, 3})))\n\tassert.Equal(true, same([]int{3,6,5,4}, SortEven([]int{5,6,3,4})))\n}\n"}
{"task_id": "Go/38", "prompt": "import (\n\t\"math\"\n\t\"strings\"\n\t\"time\"\n)\n\n// returns encoded string by cycling groups of three characters.\nfunc EncodeCyclic(s string) string {\n\tgroups := make([]string, 0)\n\tfor i := 0; i < ((len(s) + 2) / 3); i++ {\n\t\tgroups = append(groups, s[3*i:int(math.Min(float64(3*i+3), float64(len(s))))])\n\t}\n\tnewGroups := make([]string, 0)\n\tfor _, group := range groups {\n\t\trunes := []rune(group)\n\t\tif len(group) == 3 {\n\t\t\tnewGroups = append(newGroups, string(append(runes[1:], runes[0])))\n\t\t} else {\n\t\t\tnewGroups = append(newGroups, group)\n\t\t}\n\t}\n\treturn strings.Join(newGroups, \"\")\n}\n\n// takes as input string encoded with EncodeCyclic function. Returns decoded string.\nfunc DecodeCyclic(s string) string {\n", "import": "import (\n\t\"math\"\n\t\"strings\"\n\t\"time\"\n)\n", "docstring": "// returns encoded string by cycling groups of three characters.\n// takes as input string encoded with EncodeCyclic function. Returns decoded string.\n", "declaration": "\nfunc DecodeCyclic(s string) string {\n", "canonical_solution": "\treturn EncodeCyclic(EncodeCyclic(s))\n}\n\n", "test": "func TestDecodeCyclic(t *testing.T) {\n\tassert := assert.New(t)\n\trandInt := func(min, max int) int {\n\t\trng := rand.New(rand.NewSource(time.Now().UnixNano()))\n\t\tif min >= max || min == 0 || max == 0 {\n\t\t\treturn max\n\t\t}\n\t\treturn rng.Intn(max-min) + min\n\t}\n\tfor i := 0; i <100 ; i++ {\n\t\trunes := make([]rune, 0)\n\t\tfor j := 0; j < randInt(10,20); j++ {\n\t\t\trunes = append(runes, int32(randInt('a','z')))\n\t\t}\n\t\tencoded_str := EncodeCyclic(string(runes))\n\t\tassert.Equal(string(runes), DecodeCyclic(encoded_str))\n\t}\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"math/rand\"\n\t\"math\"\n\t\"time\"\n\t\"strings\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": ""}
{"task_id": "Go/39", "prompt": "import (\n\t\"math\"\n)\n\n// PrimeFib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> PrimeFib(1)\n// 2\n// >>> PrimeFib(2)\n// 3\n// >>> PrimeFib(3)\n// 5\n// >>> PrimeFib(4)\n// 13\n// >>> PrimeFib(5)\n// 89\nfunc PrimeFib(n int) int {\n", "import": "import (\n\t\"math\"\n)", "docstring": "// PrimeFib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> PrimeFib(1)\n// 2\n// >>> PrimeFib(2)\n// 3\n// >>> PrimeFib(3)\n// 5\n// >>> PrimeFib(4)\n// 13\n// >>> PrimeFib(5)\n// 89\n", "declaration": "\nfunc PrimeFib(n int) int {\n", "canonical_solution": "\tisPrime := func(p int) bool {\n\t\tif p < 2 {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 2; i < int(math.Min(math.Sqrt(float64(p))+1, float64(p-1))); i++ {\n\t\t\tif p%i == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tf := []int{0, 1}\n\tfor {\n\t\tf = append(f, f[len(f)-1]+f[len(f)-2])\n\t\tif isPrime(f[len(f)-1]) {\n\t\t\tn -= 1\n\t\t}\n\t\tif n == 0 {\n\t\t\treturn f[len(f)-1]\n\t\t}\n\t}\n}\n\n", "test": "func TestPrimeFib(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, PrimeFib(1))\n\tassert.Equal(3, PrimeFib(2))\n\tassert.Equal(5, PrimeFib(3))\n\tassert.Equal(13, PrimeFib(4))\n\tassert.Equal(89, PrimeFib(5))\n\tassert.Equal(233, PrimeFib(6))\n\tassert.Equal(1597, PrimeFib(7))\n\tassert.Equal(28657, PrimeFib(8))\n\tassert.Equal(514229, PrimeFib(9))\n\tassert.Equal(433494437, PrimeFib(10))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestPrimeFib(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, PrimeFib(1))\n\tassert.Equal(3, PrimeFib(2))\n\tassert.Equal(5, PrimeFib(3))\n\tassert.Equal(13, PrimeFib(4))\n\tassert.Equal(89, PrimeFib(5))\n}\n"}
{"task_id": "Go/40", "prompt": "\n// TriplesSumToZero takes a list of integers as an input.\n// it returns true if there are three distinct elements in the list that\n// sum to zero, and false otherwise.\n// \n// >>> TriplesSumToZero([1, 3, 5, 0])\n// false\n// >>> TriplesSumToZero([1, 3, -2, 1])\n// true\n// >>> TriplesSumToZero([1, 2, 3, 7])\n// false\n// >>> TriplesSumToZero([2, 4, -5, 3, 9, 7])\n// true\n// >>> TriplesSumToZero([1])\n// false\nfunc TriplesSumToZero(l []int) bool {\n", "import": "", "docstring": "// TriplesSumToZero takes a list of integers as an input.\n// it returns true if there are three distinct elements in the list that\n// sum to zero, and false otherwise.\n// \n// >>> TriplesSumToZero([1, 3, 5, 0])\n// false\n// >>> TriplesSumToZero([1, 3, -2, 1])\n// true\n// >>> TriplesSumToZero([1, 2, 3, 7])\n// false\n// >>> TriplesSumToZero([2, 4, -5, 3, 9, 7])\n// true\n// >>> TriplesSumToZero([1])\n// false\n", "declaration": "\nfunc TriplesSumToZero(l []int) bool {\n", "canonical_solution": "\tfor i := 0; i < len(l) - 2; i++ {\n\t\tfor j := i + 1; j < len(l) - 1; j++ {\n\t\t\tfor k := j + 1; k < len(l); k++ {\n\t\t\t\tif l[i] + l[j] + l[k] == 0 {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n", "test": "func TestTriplesSumToZero(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, TriplesSumToZero([]int{1, 3, 5, 0}))\n\tassert.Equal(false, TriplesSumToZero([]int{1, 3, 5, -1}))\n\tassert.Equal(true, TriplesSumToZero([]int{1, 3, -2, 1}))\n\tassert.Equal(false, TriplesSumToZero([]int{1, 2, 3, 7}))\n\tassert.Equal(false, TriplesSumToZero([]int{1, 2, 5, 7}))\n\tassert.Equal(true, TriplesSumToZero([]int{2, 4, -5, 3, 9, 7}))\n\tassert.Equal(false, TriplesSumToZero([]int{1}))\n\tassert.Equal(false, TriplesSumToZero([]int{1, 3, 5, -100}))\n\tassert.Equal(false, TriplesSumToZero([]int{100, 3, 5, -100}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTriplesSumToZero(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, TriplesSumToZero([]int{1, 3, 5, 0}))\n\tassert.Equal(true, TriplesSumToZero([]int{1, 3, -2, 1}))\n\tassert.Equal(false, TriplesSumToZero([]int{1, 2, 3, 7}))\n\tassert.Equal(true, TriplesSumToZero([]int{2, 4, -5, 3, 9, 7}))\n}\n"}
{"task_id": "Go/41", "prompt": "\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// \n// This function outputs the number of such collisions.\nfunc CarRaceCollision(n int) int {\n", "import": "", "docstring": "// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// \n// This function outputs the number of such collisions.\n", "declaration": "\nfunc CarRaceCollision(n int) int {\n", "canonical_solution": "\treturn n * n\n}\n\n", "test": "func TestCarRaceCollision(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, CarRaceCollision(2))\n\tassert.Equal(9, CarRaceCollision(3))\n\tassert.Equal(16, CarRaceCollision(4))\n\tassert.Equal(64, CarRaceCollision(8))\n\tassert.Equal(100, CarRaceCollision(10))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": ""}
{"task_id": "Go/42", "prompt": "\n// Return list with elements incremented by 1.\n// >>> IncrList([1, 2, 3])\n// [2, 3, 4]\n// >>> IncrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc IncrList(l []int) []int {\n", "import": "", "docstring": "// Return list with elements incremented by 1.\n// >>> IncrList([1, 2, 3])\n// [2, 3, 4]\n// >>> IncrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [6, 4, 6, 3, 4, 4, 10, 1, 124]\n", "declaration": "\nfunc IncrList(l []int) []int {\n", "canonical_solution": "\tn := len(l)\n\tfor i := 0; i < n; i++ {\n\t\tl[i]++\n\t}\n\treturn l\n}\n\n", "test": "func TestIncrList(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{}, IncrList([]int{}))\n\tassert.Equal([]int{4, 3, 2}, IncrList([]int{3, 2, 1}))\n\tassert.Equal([]int{6, 3, 6, 3, 4, 4, 10, 1, 124}, IncrList([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIncrList(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 3, 4}, IncrList([]int{1, 2, 3}))\n\tassert.Equal([]int{6, 3, 6, 3, 4, 4, 10, 1, 124}, IncrList([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}))\n}\n"}
{"task_id": "Go/43", "prompt": "\n// PairsSumToZero takes a list of integers as an input.\n// it returns true if there are two distinct elements in the list that\n// sum to zero, and false otherwise.\n// >>> PairsSumToZero([1, 3, 5, 0])\n// false\n// >>> PairsSumToZero([1, 3, -2, 1])\n// false\n// >>> PairsSumToZero([1, 2, 3, 7])\n// false\n// >>> PairsSumToZero([2, 4, -5, 3, 5, 7])\n// true\n// >>> PairsSumToZero([1])\n// false\nfunc PairsSumToZero(l []int) bool {\n", "import": "", "docstring": "// PairsSumToZero takes a list of integers as an input.\n// it returns true if there are two distinct elements in the list that\n// sum to zero, and false otherwise.\n// >>> PairsSumToZero([1, 3, 5, 0])\n// false\n// >>> PairsSumToZero([1, 3, -2, 1])\n// false\n// >>> PairsSumToZero([1, 2, 3, 7])\n// false\n// >>> PairsSumToZero([2, 4, -5, 3, 5, 7])\n// true\n// >>> PairsSumToZero([1])\n// false\n", "declaration": "\nfunc PairsSumToZero(l []int) bool {\n", "canonical_solution": "\tseen := map[int]bool{}\n\tfor i := 0; i < len(l); i++ {\n\t\tfor j := i + 1; j < len(l); j++ {\n\t\t\tif l[i] + l[j] == 0 {\n\t\t\t\tif _, ok := seen[l[i]]; !ok {\n\t\t\t\t\tseen[l[i]] = true\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tif _, ok := seen[l[j]]; !ok {\n\t\t\t\t\tseen[l[j]] = true\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n", "test": "func TestPairsSumToZero(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, PairsSumToZero([]int{1, 3, 5, 0}))\n\tassert.Equal(false, PairsSumToZero([]int{1, 3, -2, 1}))\n\tassert.Equal(false, PairsSumToZero([]int{1, 2, 3, 7}))\n\tassert.Equal(true, PairsSumToZero([]int{2, 4, -5, 3, 5, 7}))\n\tassert.Equal(false, PairsSumToZero([]int{1}))\n\tassert.Equal(true, PairsSumToZero([]int{-3, 9, -1, 3, 2, 30}))\n\tassert.Equal(true, PairsSumToZero([]int{-3, 9, -1, 3, 2, 31}))\n\tassert.Equal(false, PairsSumToZero([]int{-3, 9, -1, 4, 2, 30}))\n\tassert.Equal(false, PairsSumToZero([]int{-3, 9, -1, 4, 2, 31}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestPairsSumToZero(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, PairsSumToZero([]int{1, 3, 5, 0}))\n\tassert.Equal(false, PairsSumToZero([]int{1, 3, -2, 1}))\n\tassert.Equal(false, PairsSumToZero([]int{1, 2, 3, 7}))\n\tassert.Equal(true, PairsSumToZero([]int{2, 4, -5, 3, 5, 7}))\n}\n"}
{"task_id": "Go/44", "prompt": "import (\n\t\"strconv\"\n)\n\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> ChangeBase(8, 3)\n// '22'\n// >>> ChangeBase(8, 2)\n// '1000'\n// >>> ChangeBase(7, 2)\n// '111'\nfunc ChangeBase(x int, base int) string {\n", "import": "import (\n\t\"strconv\"\n)\n", "docstring": "// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> ChangeBase(8, 3)\n// '22'\n// >>> ChangeBase(8, 2)\n// '1000'\n// >>> ChangeBase(7, 2)\n// '111'\n", "declaration": "\nfunc ChangeBase(x int, base int) string {\n", "canonical_solution": "\tif x >= base {\n\t\treturn ChangeBase(x/base, base) + ChangeBase(x%base, base)\n\t}\n\treturn strconv.Itoa(x)\n}\n\n", "test": "func TestChangeBase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"22\", ChangeBase(8, 3))\n\tassert.Equal(\"100\", ChangeBase(9, 3))\n\tassert.Equal(\"11101010\", ChangeBase(234, 2))\n\tassert.Equal(\"10000\", ChangeBase(16, 2))\n\tassert.Equal(\"1000\", ChangeBase(8, 2))\n\tassert.Equal(\"111\", ChangeBase(7, 2))\n\tfor i := 2; i < 8; i++ {\n\t\tassert.Equal(strconv.Itoa(i), ChangeBase(i, i+1))\n\t}\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestChangeBase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"22\", ChangeBase(8, 3))\n\tassert.Equal(\"1000\", ChangeBase(8, 2))\n\tassert.Equal(\"111\", ChangeBase(7, 2))\n}\n"}
{"task_id": "Go/45", "prompt": "\n// Given length of a side and high return area for a triangle.\n// >>> TriangleArea(5, 3)\n// 7.5\nfunc TriangleArea(a float64, h float64) float64 {\n", "import": "", "docstring": "// Given length of a side and high return area for a triangle.\n// >>> TriangleArea(5, 3)\n// 7.5\n", "declaration": "\nfunc TriangleArea(a float64, h float64) float64 {\n", "canonical_solution": "\treturn a * h / 2\n}\n\n", "test": "func TestTriangleArea(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(7.5, TriangleArea(5, 3))\n\tassert.Equal(2.0, TriangleArea(2, 2))\n\tassert.Equal(40.0, TriangleArea(10, 8))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTriangleArea(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(7.5, TriangleArea(5, 3))\n}\n"}
{"task_id": "Go/46", "prompt": "\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// Fib4(0) -> 0\n// Fib4(1) -> 0\n// Fib4(2) -> 2\n// Fib4(3) -> 0\n// Fib4(n) -> Fib4(n-1) + Fib4(n-2) + Fib4(n-3) + Fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the Fib4 number sequence.  Do not use recursion.\n// >>> Fib4(5)\n// 4\n// >>> Fib4(6)\n// 8\n// >>> Fib4(7)\n// 14\nfunc Fib4(n int) int {\n", "import": "", "docstring": "// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// Fib4(0) -> 0\n// Fib4(1) -> 0\n// Fib4(2) -> 2\n// Fib4(3) -> 0\n// Fib4(n) -> Fib4(n-1) + Fib4(n-2) + Fib4(n-3) + Fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the Fib4 number sequence.  Do not use recursion.\n// >>> Fib4(5)\n// 4\n// >>> Fib4(6)\n// 8\n// >>> Fib4(7)\n// 14\n", "declaration": "\nfunc Fib4(n int) int {\n", "canonical_solution": "\tswitch n {\n\tcase 0:\n\t\treturn 0\n\tcase 1:\n\t\treturn 0\n\tcase 2:\n\t\treturn 2\n\tcase 3:\n\t\treturn 0\n\tdefault:\n\t\treturn Fib4(n-1) + Fib4(n-2) + Fib4(n-3) + Fib4(n-4)\n\t}\n}\n\n", "test": "func TestFib4(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, Fib4(5))\n\tassert.Equal(28, Fib4(8))\n\tassert.Equal(104, Fib4(10))\n\tassert.Equal(386, Fib4(12))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFib4(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, Fib4(5))\n\tassert.Equal(8, Fib4(6))\n\tassert.Equal(14, Fib4(7))\n}\n"}
{"task_id": "Go/47", "prompt": "import (\n\t\"sort\"\n)\n\n// Return Median of elements in the list l.\n// >>> Median([3, 1, 2, 4, 5])\n// 3.0\n// >>> Median([-10, 4, 6, 1000, 10, 20])\n// 15.0\nfunc Median(l []int) float64 {\n", "import": "import (\n\t\"sort\"\n)", "docstring": "// Return Median of elements in the list l.\n// >>> Median([3, 1, 2, 4, 5])\n// 3\n// >>> Median([-10, 4, 6, 1000, 10, 20])\n// 15.0\n", "declaration": "\nfunc Median(l []int) float64 {\n", "canonical_solution": "\tsort.Ints(l)\n\tif len(l)%2==1{\n\t\treturn float64(l[len(l)/2])\n\t}else{\n\t\treturn float64(l[len(l)/2-1]+l[len(l)/2])/2.0\n\t}\n}\n\n", "test": "func TestMedian(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3.0, Median([]int{3, 1, 2, 4, 5}))\n\tassert.Equal(8.0, Median([]int{-10, 4, 6, 1000, 10, 20}))\n\tassert.Equal(5.0, Median([]int{5}))\n\tassert.Equal(5.5, Median([]int{6, 5}))\n\tassert.Equal(7.0, Median([]int{8, 1, 3, 9, 9, 2, 7}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMedian(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3.0, Median([]int{3, 1, 2, 4, 5}))\n\tassert.Equal(8.0, Median([]int{-10, 4, 6, 1000, 10, 20}))\n}\n"}
{"task_id": "Go/48", "prompt": "\n// Checks if given string is a palindrome\n// >>> IsPalindrome('')\n// true\n// >>> IsPalindrome('aba')\n// true\n// >>> IsPalindrome('aaaaa')\n// true\n// >>> IsPalindrome('zbcd')\n// false\nfunc IsPalindrome(text string) bool {\n", "import": "", "docstring": "// Checks if given string is a palindrome\n// >>> IsPalindrome('')\n// true\n// >>> IsPalindrome('aba')\n// true\n// >>> IsPalindrome('aaaaa')\n// true\n// >>> IsPalindrome('zbcd')\n// false\n", "declaration": "\nfunc IsPalindrome(text string) bool {\n", "canonical_solution": "\trunes := []rune(text)\n\tresult := make([]rune, 0)\n\tfor i := len(runes) - 1; i >= 0; i-- {\n\t\tresult = append(result, runes[i])\n\t}\n\treturn text == string(result)\n}\n\n", "test": "func TestIsPalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, IsPalindrome(\"\"))\n\tassert.Equal(true, IsPalindrome(\"aba\"))\n\tassert.Equal(true, IsPalindrome(\"aaaaa\"))\n\tassert.Equal(false, IsPalindrome(\"zbcd\"))\n\tassert.Equal(true, IsPalindrome(\"xywyx\"))\n\tassert.Equal(false, IsPalindrome(\"xywyz\"))\n\tassert.Equal(false, IsPalindrome(\"xywzx\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsPalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, IsPalindrome(\"\"))\n\tassert.Equal(true, IsPalindrome(\"aba\"))\n\tassert.Equal(true, IsPalindrome(\"aaaaa\"))\n\tassert.Equal(false, IsPalindrome(\"zbcd\"))\n}\n"}
{"task_id": "Go/49", "prompt": "\n// Return 2^n modulo p (be aware of numerics).\n// >>> Modp(3, 5)\n// 3\n// >>> Modp(1101, 101)\n// 2\n// >>> Modp(0, 101)\n// 1\n// >>> Modp(3, 11)\n// 8\n// >>> Modp(100, 101)\n// 1\nfunc Modp(n int,p int) int {\n", "import": "", "docstring": "// Return 2^n modulo p (be aware of numerics).\n// >>> Modp(3, 5)\n// 3\n// >>> Modp(1101, 101)\n// 2\n// >>> Modp(0, 101)\n// 1\n// >>> Modp(3, 11)\n// 8\n// >>> Modp(100, 101)\n// 1\n", "declaration": "\nfunc Modp(n int,p int) int {\n", "canonical_solution": "\tret := 1\n\tfor i:= 0; i < n; i++ {\n\t\tret = (2 * ret) % p\n\t}\n\treturn ret\n}\n\n", "test": "func TestModp(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, Modp(3, 5))\n\tassert.Equal(2, Modp(1101, 101))\n\tassert.Equal(1, Modp(0, 101))\n\tassert.Equal(8, Modp(3, 11))\n\tassert.Equal(1, Modp(100, 101))\n\tassert.Equal(4, Modp(30, 5))\n\tassert.Equal(3, Modp(31, 5))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestModp(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, Modp(3, 5))\n\tassert.Equal(2, Modp(1101, 101))\n\tassert.Equal(1, Modp(0, 101))\n\tassert.Equal(8, Modp(3, 11))\n\tassert.Equal(1, Modp(100, 101))\n}\n"}
{"task_id": "Go/50", "prompt": "// returns encoded string by shifting every character by 5 in the alphabet.\nfunc EncodeShift(s string) string {\n\trunes := []rune(s)\n\tnewRunes := make([]rune, 0)\n\tfor _, ch := range runes {\n\t\tnewRunes = append(newRunes, (ch+5-'a')%26+'a')\n\t}\n\treturn string(runes)\n}\n\n// takes as input string encoded with EncodeShift function. Returns decoded string.\nfunc DecodeShift(s string) string {\n", "import": "", "docstring": "// returns encoded string by shifting every character by 5 in the alphabet.\n// takes as input string encoded with encode_shift function. Returns decoded string.\n", "declaration": "\nfunc DecodeShift(s string) string {\n", "canonical_solution": "\trunes := []rune(s)\n\tnewRunes := make([]rune, 0)\n\tfor _, ch := range runes {\n\t\tnewRunes = append(newRunes, (ch-5-'a')%26+'a')\n\t}\n\treturn string(runes)\n}\n\n", "test": "func TestDecodeShift(t *testing.T) {\n\tassert := assert.New(t)\n\trandInt := func(min, max int) int {\n\t\trng := rand.New(rand.NewSource(time.Now().UnixNano()))\n\t\tif min >= max || min == 0 || max == 0 {\n\t\t\treturn max\n\t\t}\n\t\treturn rng.Intn(max-min) + min\n\t}\n\tfor i := 0; i <100 ; i++ {\n\t\trunes := make([]rune, 0)\n\t\tfor j := 0; j < randInt(10,20); j++ {\n\t\t\trunes = append(runes, int32(randInt('a','z')))\n\t\t}\n\t\tencoded_str := EncodeShift(string(runes))\n\t\tassert.Equal(DecodeShift(encoded_str), string(runes))\n\t}\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"math/rand\"\n\t\"time\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": ""}
{"task_id": "Go/51", "prompt": "import (\n\t\"regexp\"\n)\n\n// RemoveVowels is a function that takes string and returns string without vowels.\n// >>> RemoveVowels('')\n// ''\n// >>> RemoveVowels(\"abcdef\\nghijklm\")\n// 'bcdf\\nghjklm'\n// >>> RemoveVowels('abcdef')\n// 'bcdf'\n// >>> RemoveVowels('aaaaa')\n// ''\n// >>> RemoveVowels('aaBAA')\n// 'B'\n// >>> RemoveVowels('zbcd')\n// 'zbcd'\nfunc RemoveVowels(text string) string {\n", "import": "import (\n\t\"regexp\"\n)", "docstring": "// RemoveVowels is a function that takes string and returns string without vowels.\n// >>> RemoveVowels('')\n// ''\n// >>> RemoveVowels(\"abcdef\\nghijklm\")\n// 'bcdf\\nghjklm'\n// >>> RemoveVowels('abcdef')\n// 'bcdf'\n// >>> RemoveVowels('aaaaa')\n// ''\n// >>> RemoveVowels('aaBAA')\n// 'B'\n// >>> RemoveVowels('zbcd')\n// 'zbcd'\n", "declaration": "\nfunc RemoveVowels(text string) string {\n\t", "canonical_solution": "\tvar re = regexp.MustCompile(\"[aeiouAEIOU]\")\n\ttext = re.ReplaceAllString(text, \"\")\n\treturn text\n}\n\n", "test": "func TestRemoveVowels(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"\", RemoveVowels(\"\"))\n\tassert.Equal(\"bcdf\\nghjklm\", RemoveVowels(\"abcdef\\nghijklm\"))\n\tassert.Equal(\"fdcb\", RemoveVowels(\"fedcba\"))\n\tassert.Equal(\"\", RemoveVowels(\"eeeee\"))\n\tassert.Equal(\"cB\", RemoveVowels(\"acBAA\"))\n\tassert.Equal(\"cB\", RemoveVowels(\"EcBOO\"))\n\tassert.Equal(\"ybcd\", RemoveVowels(\"ybcd\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRemoveVowels(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"\", RemoveVowels(\"\"))\n\tassert.Equal(\"bcdf\\nghjklm\", RemoveVowels(\"abcdef\\nghijklm\"))\n\tassert.Equal(\"bcdf\", RemoveVowels(\"abcdef\"))\n\tassert.Equal(\"\", RemoveVowels(\"aaaaa\"))\n\tassert.Equal(\"B\", RemoveVowels(\"aaBAA\"))\n\tassert.Equal(\"zbcd\", RemoveVowels(\"zbcd\"))\n}\n"}
{"task_id": "Go/52", "prompt": "\n// Return true if all numbers in the list l are below threshold t.\n// >>> BelowThreshold([1, 2, 4, 10], 100)\n// true\n// >>> BelowThreshold([1, 20, 4, 10], 5)\n// false\nfunc BelowThreshold(l []int,t int) bool {\n", "import": "", "docstring": "// Return true if all numbers in the list l are below threshold t.\n// >>> BelowThreshold([1, 2, 4, 10], 100)\n// true\n// >>> BelowThreshold([1, 20, 4, 10], 5)\n// false\n", "declaration": "\nfunc BelowThreshold(l []int,t int) bool {\n", "canonical_solution": "\tfor _, n := range l {\n\t\tif n >= t {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n", "test": "func TestBelowThreshold(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, BelowThreshold([]int{1, 2, 4, 10}, 100))\n\tassert.Equal(false, BelowThreshold([]int{1, 20, 4, 10}, 5))\n\tassert.Equal(true, BelowThreshold([]int{1, 20, 4, 10}, 21))\n\tassert.Equal(true, BelowThreshold([]int{1, 20, 4, 10}, 22))\n\tassert.Equal(true, BelowThreshold([]int{1, 8, 4, 10}, 11))\n\tassert.Equal(false, BelowThreshold([]int{1, 8, 4, 10}, 10))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestBelowThreshold(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, BelowThreshold([]int{1, 2, 4, 10}, 100))\n\tassert.Equal(false, BelowThreshold([]int{1, 20, 4, 10}, 5))\n}\n"}
{"task_id": "Go/53", "prompt": "\n// Add two numbers x and y\n// >>> Add(2, 3)\n// 5\n// >>> Add(5, 7)\n// 12\nfunc Add(x int, y int) int {\n", "import": "", "docstring": "// Add two numbers x and y\n// >>> Add(2, 3)\n// 5\n// >>> Add(5, 7)\n// 12\n", "declaration": "\nfunc Add(x int, y int) int {\n", "canonical_solution": "\treturn x + y\n}\n\n", "test": "func TestAdd(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, Add(0, 1))\n\tassert.Equal(1, Add(1, 0))\n\tassert.Equal(5, Add(2, 3))\n\tassert.Equal(12, Add(5, 7))\n\tassert.Equal(12, Add(7, 5))\n\tfor i := 0; i < 100; i++ {\n\t\tx := rand.Int31n(1000)\n\t\ty := rand.Int31n(1000)\n\t\tassert.Equal(int(x+y), Add(int(x), int(y)))\n\t}\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"math/rand\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAdd(t *testing.T) {\n   assert := assert.New(t)\n   assert.Equal(5, Add(2, 3+rand.Intn(1000)*0))\n\tassert.Equal(12, Add(5, 7))\n}\n"}
{"task_id": "Go/54", "prompt": "\n// Check if two words have the same characters.\n// >>> SameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n// true\n// >>> SameChars('abcd', 'dddddddabc')\n// true\n// >>> SameChars('dddddddabc', 'abcd')\n// true\n// >>> SameChars('eabcd', 'dddddddabc')\n// false\n// >>> SameChars('abcd', 'dddddddabce')\n// false\n// >>> SameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n// false\nfunc SameChars(s0 string, s1 string) bool {\n", "import": "", "docstring": "// Check if two words have the same characters.\n// >>> SameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n// true\n// >>> SameChars('abcd', 'dddddddabc')\n// true\n// >>> SameChars('dddddddabc', 'abcd')\n// true\n// >>> SameChars('eabcd', 'dddddddabc')\n// false\n// >>> SameChars('abcd', 'dddddddabce')\n// false\n// >>> SameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n// false\n", "declaration": "\nfunc SameChars(s0 string, s1 string) bool {\n", "canonical_solution": "\tset0 := make(map[int32]interface{})\n\tset1 := make(map[int32]interface{})\n\tfor _, i := range s0 {\n\t\tset0[i] = nil\n\t}\n\tfor _, i := range s1 {\n\t\tset1[i] = nil\n\t}\n\tfor i, _ := range set0 {\n\t\tif _,ok:=set1[i];!ok{\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i, _ := range set1 {\n\t\tif _,ok:=set0[i];!ok{\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n", "test": "func TestSameChars(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, SameChars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n\tassert.Equal(true, SameChars(\"abcd\", \"dddddddabc\"))\n\tassert.Equal(true, SameChars(\"dddddddabc\", \"abcd\"))\n\tassert.Equal(false, SameChars(\"eabcd\", \"dddddddabc\"))\n\tassert.Equal(false, SameChars(\"abcd\", \"dddddddabcf\"))\n\tassert.Equal(false, SameChars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n\tassert.Equal(false, SameChars(\"aabb\", \"aaccc\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSameChars(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, SameChars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n\tassert.Equal(true, SameChars(\"abcd\", \"dddddddabc\"))\n\tassert.Equal(true, SameChars(\"dddddddabc\", \"abcd\"))\n\tassert.Equal(false, SameChars(\"eabcd\", \"dddddddabc\"))\n\tassert.Equal(false, SameChars(\"abcd\", \"dddddddabcf\"))\n\tassert.Equal(false, SameChars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n}\n"}
{"task_id": "Go/55", "prompt": "\n// Return n-th Fibonacci number.\n// >>> Fib(10)\n// 55\n// >>> Fib(1)\n// 1\n// >>> Fib(8)\n// 21\nfunc Fib(n int) int {\n", "import": "", "docstring": "// Return n-th Fibonacci number.\n// >>> Fib(10)\n// 55\n// >>> Fib(1)\n// 1\n// >>> Fib(8)\n// 21\n", "declaration": "\nfunc Fib(n int) int {\n", "canonical_solution": "\tif n <= 1 {\n\t\treturn n\n\t}\n\treturn Fib(n-1) + Fib(n-2)\n}\n\n", "test": "func TestFib(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(55, Fib(10))\n\tassert.Equal(1, Fib(1))\n\tassert.Equal(21, Fib(8))\n\tassert.Equal(89, Fib(11))\n\tassert.Equal(144, Fib(12))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFib(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(55, Fib(10))\n\tassert.Equal(1, Fib(1))\n\tassert.Equal(21, Fib(8))\n}\n"}
{"task_id": "Go/56", "prompt": "\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// \n// >>> CorrectBracketing(\"<\")\n// false\n// >>> CorrectBracketing(\"<>\")\n// true\n// >>> CorrectBracketing(\"<<><>>\")\n// true\n// >>> CorrectBracketing(\"><<>\")\n// false\nfunc CorrectBracketing(brackets string) bool {\n", "import": "", "docstring": "// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// \n// >>> CorrectBracketing(\"<\")\n// false\n// >>> CorrectBracketing(\"<>\")\n// true\n// >>> CorrectBracketing(\"<<><>>\")\n// true\n// >>> CorrectBracketing(\"><<>\")\n// false\n", "declaration": "\nfunc CorrectBracketing(brackets string) bool {\n", "canonical_solution": "\tl := len(brackets)\n\tcount := 0\n\tfor index := 0; index < l; index++ {\n\t\tif brackets[index] == '<' {\n\t\t\tcount++\n\t\t} else if brackets[index] == '>' {\n\t\t\tcount--\n\t\t}\n\t\tif count < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\tif count == 0 {\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n\n", "test": "func TestCorrectBracketing(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, CorrectBracketing(\"<>\"))\n\tassert.Equal(true, CorrectBracketing(\"<<><>>\"))\n\tassert.Equal(true, CorrectBracketing(\"<><><<><>><>\"))\n\tassert.Equal(true, CorrectBracketing(\"<><><<<><><>><>><<><><<>>>\"))\n\tassert.Equal(false, CorrectBracketing(\"<<<><>>>>\"))\n\tassert.Equal(false, CorrectBracketing(\"><<>\"))\n\tassert.Equal(false, CorrectBracketing(\"<\"))\n\tassert.Equal(false, CorrectBracketing(\"<<<<\"))\n\tassert.Equal(false, CorrectBracketing(\">\"))\n\tassert.Equal(false, CorrectBracketing(\"<<>\"))\n\tassert.Equal(false, CorrectBracketing(\"<><><<><>><>><<>\"))\n\tassert.Equal(false, CorrectBracketing(\"<><><<><>><>>><>\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCorrectBracketing(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, CorrectBracketing(\"<>\"))\n\tassert.Equal(true, CorrectBracketing(\"<<><>>\"))\n\tassert.Equal(false, CorrectBracketing(\"><<>\"))\n\tassert.Equal(false, CorrectBracketing(\"<\"))\n}\n"}
{"task_id": "Go/57", "prompt": "\n// Return true is list elements are Monotonically increasing or decreasing.\n// >>> Monotonic([1, 2, 4, 20])\n// true\n// >>> Monotonic([1, 20, 4, 10])\n// false\n// >>> Monotonic([4, 1, 0, -10])\n// true\nfunc Monotonic(l []int) bool {\n", "import": "", "docstring": "// Return true is list elements are Monotonically increasing or decreasing.\n// >>> Monotonic([1, 2, 4, 20])\n// true\n// >>> Monotonic([1, 20, 4, 10])\n// false\n// >>> Monotonic([4, 1, 0, -10])\n// true\n", "declaration": "\nfunc Monotonic(l []int) bool {\n", "canonical_solution": "\tflag := true\n\tif len(l) > 1 {\n\t\tfor i := 0; i < len(l)-1; i++ {\n\t\t\tif l[i] != l[i+1] {\n\t\t\t\tflag = l[i] > l[i+1]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(l)-1; i++ {\n\t\tif flag != (l[i] >= l[i+1]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n", "test": "func TestMonotonic(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, Monotonic([]int{1, 2, 4, 10}))\n\tassert.Equal(true, Monotonic([]int{1, 2, 4, 20}))\n\tassert.Equal(false, Monotonic([]int{1, 20, 4, 10}))\n\tassert.Equal(true, Monotonic([]int{4, 1, 0, -10}))\n\tassert.Equal(true, Monotonic([]int{4, 1, 1, 0}))\n\tassert.Equal(false, Monotonic([]int{1, 2, 3, 2, 5, 60}))\n\tassert.Equal(true, Monotonic([]int{1, 2, 3, 4, 5, 60}))\n\tassert.Equal(true, Monotonic([]int{9, 9, 9, 9}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMonotonic(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, Monotonic([]int{1, 2, 4, 10}))\n\tassert.Equal(false, Monotonic([]int{1, 20, 4, 10}))\n\tassert.Equal(true, Monotonic([]int{4, 1, 0, -10}))\n}\n"}
{"task_id": "Go/58", "prompt": "import (\n\t\"sort\"\n)\n\n// Return sorted unique Common elements for two lists.\n// >>> Common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> Common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nfunc Common(l1 []int,l2 []int) []int {\n", "import": "import (\n\t\"sort\"\n)", "docstring": "// Return sorted unique Common elements for two lists.\n// >>> Common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> Common([5, 3, 2, 8], [3, 2])\n// [2, 3]\n", "declaration": "\nfunc Common(l1 []int,l2 []int) []int {\n", "canonical_solution": "\tm := make(map[int]bool)\n\tfor _, e1 := range l1 {\n\t\tif m[e1] {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, e2 := range l2 {\n\t\t\tif e1 == e2 {\n\t\t\t\tm[e1] = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tres := make([]int, 0, len(m))\n\tfor k, _ := range m {\n\t\tres = append(res, k)\n\t}\n\tsort.Ints(res)\n\treturn res\n}\n\n", "test": "func TestCommon(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 5, 653}, Common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}))\n\tassert.Equal([]int{2, 3}, Common([]int{5, 3, 2, 8}, []int{3, 2}))\n\tassert.Equal([]int{2, 3, 4}, Common([]int{4, 3, 2, 8}, []int{3, 2, 4}))\n\tassert.Equal([]int{}, Common([]int{4, 3, 2, 8}, []int{}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCommon(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 5, 653}, Common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}))\n\tassert.Equal([]int{2, 3}, Common([]int{5, 3, 2, 8}, []int{3, 2}))\n}\n"}
{"task_id": "Go/59", "prompt": "\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> LargestPrimeFactor(13195)\n// 29\n// >>> LargestPrimeFactor(2048)\n// 2\nfunc LargestPrimeFactor(n int) int {\n", "import": "", "docstring": "// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> LargestPrimeFactor(13195)\n// 29\n// >>> LargestPrimeFactor(2048)\n// 2\n", "declaration": "\nfunc LargestPrimeFactor(n int) int {\n", "canonical_solution": "\tisPrime := func(n int) bool {\n\t\tfor i := 2; i < int(math.Pow(float64(n), 0.5)+1); i++ {\n\t\t\tif n%i == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\tlargest := 1\n\tfor j := 2; j < n + 1; j++ {\n\t\tif n % j == 0 && isPrime(j) {\n\t\t\tif j > largest {\n\t\t\t\tlargest = j\n\t\t\t}\n\t\t}\n\t}\n\treturn largest\n}\n\n", "test": "func TestLargestPrimeFactor(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(5, LargestPrimeFactor(15))\n\tassert.Equal(3, LargestPrimeFactor(27))\n\tassert.Equal(7, LargestPrimeFactor(63))\n\tassert.Equal(11, LargestPrimeFactor(330))\n\tassert.Equal(29, LargestPrimeFactor(13195))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestLargestPrimeFactor(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, LargestPrimeFactor(2048))\n\tassert.Equal(29, LargestPrimeFactor(13195))\n}\n"}
{"task_id": "Go/60", "prompt": "\n// SumToN is a function that sums numbers from 1 to n.\n// >>> SumToN(30)\n// 465\n// >>> SumToN(100)\n// 5050\n// >>> SumToN(5)\n// 15\n// >>> SumToN(10)\n// 55\n// >>> SumToN(1)\n// 1\nfunc SumToN(n int) int {\n", "import": "", "docstring": "// SumToN is a function that sums numbers from 1 to n.\n// >>> SumToN(30)\n// 465\n// >>> SumToN(100)\n// 5050\n// >>> SumToN(5)\n// 15\n// >>> SumToN(10)\n// 55\n// >>> SumToN(1)\n// 1\n", "declaration": "\nfunc SumToN(n int) int {\n", "canonical_solution": "\tif n <= 0 {\n\t\treturn 0\n\t} else {\n\t\treturn n + SumToN(n - 1)\n\t}\n}\n\n", "test": "func TestSumToN(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, SumToN(1))\n\tassert.Equal(21, SumToN(6))\n\tassert.Equal(66, SumToN(11))\n\tassert.Equal(465, SumToN(30))\n\tassert.Equal(5050, SumToN(100))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSumToN(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, SumToN(1))\n\tassert.Equal(15, SumToN(5))\n\tassert.Equal(55, SumToN(10))\n\tassert.Equal(465, SumToN(30))\n\tassert.Equal(5050, SumToN(100))\n}\n"}
{"task_id": "Go/61", "prompt": "import (\n\t\"strings\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// \n// >>> CorrectBracketing(\"(\")\n// false\n// >>> CorrectBracketing(\"()\")\n// true\n// >>> CorrectBracketing(\"(()())\")\n// true\n// >>> CorrectBracketing(\")(()\")\n// false\nfunc CorrectBracketing(brackets string) bool {\n", "import": "import (\n\t\"strings\"\n)", "docstring": "// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// \n// >>> CorrectBracketing(\"(\")\n// false\n// >>> CorrectBracketing(\"()\")\n// true\n// >>> CorrectBracketing(\"(()())\")\n// true\n// >>> CorrectBracketing(\")(()\")\n// false\n", "declaration": "\nfunc CorrectBracketing(brackets string) bool {\n", "canonical_solution": "\tbrackets = strings.Replace(brackets, \"(\", \" ( \", -1)\n\tbrackets = strings.Replace(brackets, \")\", \") \", -1)\n\topen := 0\n\tfor _, b := range brackets {\n\t\tif b == '(' {\n\t\t\topen++\n\t\t} else if b == ')' {\n\t\t\topen--\n\t\t}\n\t\tif open < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn open == 0\n}\n\n", "test": "func TestCorrectBracketing(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, CorrectBracketing(\"()\"))\n\tassert.Equal(true, CorrectBracketing(\"(()())\"))\n\tassert.Equal(true, CorrectBracketing(\"()()(()())()\"))\n\tassert.Equal(true, CorrectBracketing(\"()()((()()())())(()()(()))\"))\n\tassert.Equal(false, CorrectBracketing(\"((()())))\"))\n\tassert.Equal(false, CorrectBracketing(\")(()\"))\n\tassert.Equal(false, CorrectBracketing(\"(\"))\n\tassert.Equal(false, CorrectBracketing(\"((((\"))\n\tassert.Equal(false, CorrectBracketing(\")\"))\n\tassert.Equal(false, CorrectBracketing(\"(()\"))\n\tassert.Equal(false, CorrectBracketing(\"()()(()())())(()\"))\n\tassert.Equal(false, CorrectBracketing(\"()()(()())()))()\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCorrectBracketing(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, CorrectBracketing(\"()\"))\n\tassert.Equal(true, CorrectBracketing(\"(()())\"))\n\tassert.Equal(false, CorrectBracketing(\")(()\"))\n\tassert.Equal(false, CorrectBracketing(\"(\"))\n}\n"}
{"task_id": "Go/62", "prompt": "\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return Derivative of this polynomial in the same form.\n// >>> Derivative([3, 1, 2, 4, 5])\n// [1, 4, 12, 20]\n// >>> Derivative([1, 2, 3])\n// [2, 6]\nfunc Derivative(xs []int) []int {\n", "import": "", "docstring": "// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return Derivative of this polynomial in the same form.\n// >>> Derivative([3, 1, 2, 4, 5])\n// [1, 4, 12, 20]\n// >>> Derivative([1, 2, 3])\n// [2, 6]\n", "declaration": "\nfunc Derivative(xs []int) []int {\n", "canonical_solution": "\tl := len(xs)\n\ty := make([]int, l - 1)\n\tfor i := 0; i < l - 1; i++ {\n\t\ty[i] = xs[i + 1] * (i + 1)\n\t}\n\treturn y\n}\n\n", "test": "func TestDerivative(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 4, 12, 20}, Derivative([]int{3, 1, 2, 4, 5}))\n\tassert.Equal([]int{2, 6}, Derivative([]int{1, 2, 3}))\n\tassert.Equal([]int{2, 2}, Derivative([]int{3, 2, 1}))\n\tassert.Equal([]int{2, 2, 0, 16}, Derivative([]int{3, 2, 1,0, 4}))\n\tassert.Equal([]int{}, Derivative([]int{1}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestDerivative(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 4, 12, 20}, Derivative([]int{3, 1, 2, 4, 5}))\n\tassert.Equal([]int{2, 6}, Derivative([]int{1, 2, 3}))\n}\n"}
{"task_id": "Go/63", "prompt": "\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// Fibfib(0) == 0\n// Fibfib(1) == 0\n// Fibfib(2) == 1\n// Fibfib(n) == Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the Fibfib number sequence.\n// >>> Fibfib(1)\n// 0\n// >>> Fibfib(5)\n// 4\n// >>> Fibfib(8)\n// 24\nfunc Fibfib(n int) int {\n", "import": "", "docstring": "// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// Fibfib(0) == 0\n// Fibfib(1) == 0\n// Fibfib(2) == 1\n// Fibfib(n) == Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the Fibfib number sequence.\n// >>> Fibfib(1)\n// 0\n// >>> Fibfib(5)\n// 4\n// >>> Fibfib(8)\n// 24\n", "declaration": "\nfunc Fibfib(n int) int {\n", "canonical_solution": "\tif n <= 0 {\n\t\treturn 0\n\t}\n\tswitch n {\n\tcase 0:\n\t\treturn 0\n\tcase 1:\n\t\treturn 0\n\tcase 2:\n\t\treturn 1\n\tdefault:\n\t\treturn Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3)\n\t}\n}\n\n", "test": "func TestFibfib(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, Fibfib(2))\n\tassert.Equal(0, Fibfib(1))\n\tassert.Equal(4, Fibfib(5))\n\tassert.Equal(24, Fibfib(8))\n\tassert.Equal(81, Fibfib(10))\n\tassert.Equal(274, Fibfib(12))\n\tassert.Equal(927, Fibfib(14))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFibfib(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, Fibfib(1))\n\tassert.Equal(4, Fibfib(5))\n\tassert.Equal(24, Fibfib(8))\n}\n"}
{"task_id": "Go/64", "prompt": "import (\n\t\"strings\"\n)\n\n// Write a function VowelsCount which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// \n// Example:\n// >>> VowelsCount(\"abcde\")\n// 2\n// >>> VowelsCount(\"ACEDY\")\n// 3\nfunc VowelsCount(s string) int {\n", "import": "import (\n\t\"strings\"\n)", "docstring": "// Write a function VowelsCount which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// \n// Example:\n// >>> VowelsCount(\"abcde\")\n// 2\n// >>> VowelsCount(\"ACEDY\")\n// 3\n", "declaration": "\nfunc VowelsCount(s string) int {\n", "canonical_solution": "\ts = strings.ToLower(s)\n\tvowels := map[int32]interface{}{'a': nil, 'e': nil, 'i': nil, 'o': nil, 'u': nil}\n\tcount := 0\n\tfor _, i := range s {\n\t\tif _, ok := vowels[i]; ok {\n\t\t\tcount++\n\t\t}\n\t}\n\tif (s[len(s)-1]) == 'y' {\n\t\tcount++\n\t}\n\treturn count\n}\n\n", "test": "func TestVowelsCount(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, VowelsCount(\"abcde\"))\n\tassert.Equal(3, VowelsCount(\"Alone\"))\n\tassert.Equal(2, VowelsCount(\"key\"))\n\tassert.Equal(1, VowelsCount(\"bye\"))\n\tassert.Equal(2, VowelsCount(\"keY\"))\n\tassert.Equal(1, VowelsCount(\"bYe\"))\n\tassert.Equal(3, VowelsCount(\"ACEDY\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestVowelsCount(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, VowelsCount(\"abcde\"))\n\tassert.Equal(3, VowelsCount(\"ACEDY\"))\n}\n"}
{"task_id": "Go/65", "prompt": "\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> CircularShift(12, 1)\n// \"21\"\n// >>> CircularShift(12, 2)\n// \"12\"\nfunc CircularShift(x int,shift int) string {\n", "import": "import (\n\t\"strconv\"\n)", "docstring": "// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> CircularShift(12, 1)\n// \"21\"\n// >>> CircularShift(12, 2)\n// \"12\"\n", "declaration": "\nfunc CircularShift(x int, shift int) string {\n", "canonical_solution": "\ts := strconv.Itoa(x)\n\tif shift > len(s) {\n\t\trunes := make([]rune, 0)\n\t\tfor i := len(s)-1; i >= 0; i-- {\n\t\t\trunes = append(runes, rune(s[i]))\n\t\t}\n\t\treturn string(runes)\n\t}else{\n\t\treturn s[len(s)-shift:]+s[:len(s)-shift]\n\t}\n}\n\n", "test": "func TestCircularShift(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"001\", CircularShift(100, 2))\n\tassert.Equal(\"12\", CircularShift(12, 2))\n\tassert.Equal(\"79\", CircularShift(97, 8))\n\tassert.Equal(\"21\", CircularShift(12, 1))\n\tassert.Equal(\"11\", CircularShift(11, 101))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCircularShift(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"12\", CircularShift(12, 2))\n\tassert.Equal(\"21\", CircularShift(12, 1))\n}\n"}
{"task_id": "Go/66", "prompt": "\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// \n// Examples:\n// Digitsum(\"\") => 0\n// Digitsum(\"abAB\") => 131\n// Digitsum(\"abcCd\") => 67\n// Digitsum(\"helloE\") => 69\n// Digitsum(\"woArBld\") => 131\n// Digitsum(\"aAaaaXa\") => 153\nfunc Digitsum(x string) int {\n", "import": "", "docstring": "// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// \n// Examples:\n// Digitsum(\"\") => 0\n// Digitsum(\"abAB\") => 131\n// Digitsum(\"abcCd\") => 67\n// Digitsum(\"helloE\") => 69\n// Digitsum(\"woArBld\") => 131\n// Digitsum(\"aAaaaXa\") => 153\n", "declaration": "\nfunc Digitsum(x string) int {\n", "canonical_solution": "\tif len(x) == 0 {\n\t\treturn 0\n\t}\n\tresult := 0\n\tfor _, i := range x {\n\t\tif 'A' <= i && i <= 'Z' {\n\t\t\tresult += int(i)\n\t\t}\n\t}\n\treturn result\n}\n\n", "test": "func TestDigitSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, Digitsum(\"\"))\n\tassert.Equal(131, Digitsum(\"abAB\"))\n\tassert.Equal(67, Digitsum(\"abcCd\"))\n\tassert.Equal(69, Digitsum(\"helloE\"))\n\tassert.Equal(131, Digitsum(\"woArBld\"))\n\tassert.Equal(153, Digitsum(\"aAaaaXa\"))\n\tassert.Equal(151, Digitsum(\" How are yOu?\"))\n\tassert.Equal(327, Digitsum(\"You arE Very Smart\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestDigitSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, Digitsum(\"\"))\n\tassert.Equal(131, Digitsum(\"abAB\"))\n\tassert.Equal(67, Digitsum(\"abcCd\"))\n\tassert.Equal(69, Digitsum(\"helloE\"))\n\tassert.Equal(131, Digitsum(\"woArBld\"))\n\tassert.Equal(153, Digitsum(\"aAaaaXa\"))\n}\n"}
{"task_id": "Go/67", "prompt": "import (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// In this task, you will be given a string that represents a number of apples and oranges\n// that are distributed in a basket of fruit this basket contains\n// apples, oranges, and mango fruits. Given the string that represents the total number of\n// the oranges and apples and an integer that represent the total number of the fruits\n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// FruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n// FruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n// FruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n// FruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\nfunc FruitDistribution(s string,n int) int {\n", "import": "import (\n\t\"strconv\"\n\t\"strings\"\n)", "docstring": "// In this task, you will be given a string that represents a number of apples and oranges\n// that are distributed in a basket of fruit this basket contains\n// apples, oranges, and mango fruits. Given the string that represents the total number of\n// the oranges and apples and an integer that represent the total number of the fruits\n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// FruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n// FruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n// FruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n// FruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n", "declaration": "\nfunc FruitDistribution(s string,n int) int {\n", "canonical_solution": "\tsplit := strings.Split(s, \" \")\n\tfor _, i := range split {\n\t\tatoi, err := strconv.Atoi(i)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tn = n - atoi\n\t}\n\treturn n\n}\n\n", "test": "func TestFruitDistribution(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(8, FruitDistribution(\"5 apples and 6 oranges\", 19))\n\tassert.Equal(10, FruitDistribution(\"5 apples and 6 oranges\", 21))\n\tassert.Equal(2, FruitDistribution(\"0 apples and 1 oranges\", 3))\n\tassert.Equal(2, FruitDistribution(\"1 apples and 0 oranges\", 3))\n\tassert.Equal(95, FruitDistribution(\"2 apples and 3 oranges\", 100))\n\tassert.Equal(0, FruitDistribution(\"2 apples and 3 oranges\", 5))\n\tassert.Equal(19, FruitDistribution(\"1 apples and 100 oranges\", 120))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFruitDistribution(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(8, FruitDistribution(\"5 apples and 6 oranges\", 19))\n\tassert.Equal(2, FruitDistribution(\"0 apples and 1 oranges\", 3))\n\tassert.Equal(95, FruitDistribution(\"2 apples and 3 oranges\", 100))\n\tassert.Equal(19, FruitDistribution(\"1 apples and 100 oranges\", 120))\n}\n"}
{"task_id": "Go/68", "prompt": "import (\n\t\"math\"\n)\n\n// Given an array representing a branch of a tree that has non-negative integer nodes\n// your task is to Pluck one of the nodes and return it.\n// The Plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// \n// The Plucked node should be returned in a list, [ smalest_value, its index ],\n// If there are no even values or the given array is empty, return [].\n// \n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 3:\n// Input: []\n// Output: []\n// \n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// \n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc Pluck(arr []int) []int {\n", "import": "import (\n\t\"math\"\n)", "docstring": "// Given an array representing a branch of a tree that has non-negative integer nodes\n// your task is to Pluck one of the nodes and return it.\n// The Plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// \n// The Plucked node should be returned in a list, [ smalest_value, its index ],\n// If there are no even values or the given array is empty, return [].\n// \n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 3:\n// Input: []\n// Output: []\n// \n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// \n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n", "declaration": "\nfunc Pluck(arr []int) []int {\n", "canonical_solution": "\tresult := make([]int, 0)\n\tif len(arr) == 0 {\n\t\treturn result\n\t}\n\tevens := make([]int, 0)\n\tmin := math.MaxInt64\n\tminIndex := 0\n\tfor i, x := range arr {\n\t\tif x%2 == 0 {\n\t\t\tevens = append(evens, x)\n\t\t\tif x < min {\n\t\t\t\tmin = x\n\t\t\t\tminIndex = i\n\t\t\t}\n\t\t}\n\t}\n\tif len(evens) == 0 {\n\t\treturn result\n\t}\n\tresult = []int{min, minIndex}\n\treturn result\n}\n\n", "test": "func TestPluck(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 1}, Pluck([]int{4,2,3}))\n\tassert.Equal([]int{2, 1}, Pluck([]int{1,2,3}))\n\tassert.Equal([]int{}, Pluck([]int{}))\n\tassert.Equal([]int{0, 1}, Pluck([]int{5, 0, 3, 0, 4, 2}))\n\tassert.Equal([]int{0, 3}, Pluck([]int{1, 2, 3, 0, 5, 3}))\n\tassert.Equal([]int{4, 1}, Pluck([]int{5, 4, 8, 4 ,8}))\n\tassert.Equal([]int{6, 1}, Pluck([]int{7, 6, 7, 1}))\n\tassert.Equal([]int{}, Pluck([]int{7, 9, 7, 1}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestPluck(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 1}, Pluck([]int{4,2,3}))\n\tassert.Equal([]int{2, 1}, Pluck([]int{1,2,3}))\n\tassert.Equal([]int{}, Pluck([]int{}))\n\tassert.Equal([]int{0, 1}, Pluck([]int{5, 0, 3, 0, 4, 2}))\n}\n"}
{"task_id": "Go/69", "prompt": "\n// You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n// zero, and has a frequency greater than or equal to the value of the integer itself.\n// The frequency of an integer is the number of times it appears in the list.\n// If no such a value exist, return -1.\n// Examples:\n// Search([4, 1, 2, 2, 3, 1]) == 2\n// Search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n// Search([5, 5, 4, 4, 4]) == -1\nfunc Search(lst []int) int {\n", "import": "", "docstring": "// You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n// zero, and has a frequency greater than or equal to the value of the integer itself.\n// The frequency of an integer is the number of times it appears in the list.\n// If no such a value exist, return -1.\n// Examples:\n// Search([4, 1, 2, 2, 3, 1]) == 2\n// Search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n// Search([5, 5, 4, 4, 4]) == -1\n", "declaration": "\nfunc Search(lst []int) int {\n", "canonical_solution": "\tcountMap := make(map[int]int)\n\tfor _, i := range lst {\n\t\tif count, ok := countMap[i]; ok {\n\t\t\tcountMap[i] = count + 1\n\t\t} else {\n\t\t\tcountMap[i] = 1\n\t\t}\n\t}\n\tmax := -1\n\tfor i, count := range countMap {\n\t\tif count >= i && count > max {\n\t\t\tmax = i\n\t\t}\n\t}\n\treturn max\n}\n\n", "test": "func TestSearch(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, Search([]int{5, 5, 5, 5, 1}))\n\tassert.Equal(4, Search([]int{4, 1, 4, 1, 4, 4}))\n\tassert.Equal(-1, Search([]int{3, 3}))\n\tassert.Equal(8, Search([]int{8, 8, 8, 8, 8, 8, 8, 8}))\n\tassert.Equal(2, Search([]int{2, 3, 3, 2, 2}))\n\tassert.Equal(1, Search([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6,5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}))\n\tassert.Equal(2, Search([]int{3, 2, 8, 2}))\n\tassert.Equal(1, Search([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}))\n\tassert.Equal(-1, Search([]int{8, 8, 3, 6, 5, 6, 4}))\n\tassert.Equal(1, Search([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8,9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}))\n\tassert.Equal(1, Search([]int{1, 9, 10, 1, 3}))\n\tassert.Equal(5, Search([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5,10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}))\n\tassert.Equal(1, Search([]int{1}))\n\tassert.Equal(4, Search([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}))\n\tassert.Equal(2, Search([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}))\n\tassert.Equal(1, Search([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}))\n\tassert.Equal(4, Search([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7,7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}))\n\tassert.Equal(4, Search([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}))\n\tassert.Equal(2, Search([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}))\n\tassert.Equal(-1, Search([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}))\n\tassert.Equal(-1, Search([]int{10}))\n\tassert.Equal(2, Search([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}))\n\tassert.Equal(1, Search([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}))\n\tassert.Equal(1, Search([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1,2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}))\n\tassert.Equal(-1, Search([]int{3, 10, 10, 9, 2}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSearch(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, Search([]int{4, 1, 2, 2, 3, 1}))\n\tassert.Equal(3, Search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4}))\n\tassert.Equal(-1, Search([]int{5, 5, 4, 4, 4}))\n}\n"}
{"task_id": "Go/70", "prompt": "import (\n\t\"sort\"\n)\n\n// Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// \n// Examples:\n// StrangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n// StrangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n// StrangeSortList([]) == []\nfunc StrangeSortList(lst []int) []int {\n", "import": "import (\n\t\"sort\"\n)", "docstring": "// Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// \n// Examples:\n// StrangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n// StrangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n// StrangeSortList([]) == []\n", "declaration": "\nfunc StrangeSortList(lst []int) []int {\n", "canonical_solution": "\tsort.Ints(lst)\n\tresult := make([]int, 0)\n\tfor i := 0; i < len(lst)/2; i++ {\n\t\tresult = append(result, lst[i])\n\t\tresult = append(result, lst[len(lst)-i-1])\n\t}\n\tif len(lst)%2 != 0 {\n\t\tresult = append(result, lst[len(lst)/2])\n\t}\n\treturn result\n}\n\n", "test": "func TestStrangeSortList(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 4, 2, 3}, StrangeSortList([]int{1,2, 3, 4}))\n\tassert.Equal([]int{5, 9, 6, 8, 7}, StrangeSortList([]int{5, 6, 7, 8, 9}))\n\tassert.Equal([]int{1, 5, 2, 4, 3}, StrangeSortList([]int{1, 2, 3, 4, 5}))\n\tassert.Equal([]int{1, 9, 5, 8, 6, 7}, StrangeSortList([]int{5, 6, 7, 8, 9, 1}))\n\tassert.Equal([]int{5, 5, 5, 5}, StrangeSortList([]int{5,5, 5, 5}))\n\tassert.Equal([]int{}, StrangeSortList([]int{}))\n\tassert.Equal([]int{1, 8, 2, 7, 3, 6, 4, 5}, StrangeSortList([]int{1,2,3,4,5,6,7,8}))\n\tassert.Equal([]int{-5, 5, -5, 5, 0, 2, 2, 2}, StrangeSortList([]int{0,2,2,2,5,5,-5,-5}))\n\tassert.Equal([]int{111111}, StrangeSortList([]int{111111}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStrangeSortList(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 4, 2, 3}, StrangeSortList([]int{1,2, 3, 4}))\n\tassert.Equal([]int{5, 5, 5, 5}, StrangeSortList([]int{5,5, 5, 5}))\n\tassert.Equal([]int{}, StrangeSortList([]int{}))\n}\n"}
{"task_id": "Go/71", "prompt": "import (\n\t\"math\"\n)\n\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater\n// than the third side.\n// Example:\n// TriangleArea(3, 4, 5) == 6.00\n// TriangleArea(1, 2, 10) == -1\nfunc TriangleArea(a float64, b float64, c float64) interface{} {\n", "import": "import (\n\t\"math\"\n)", "docstring": "// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater\n// than the third side.\n// Example:\n// TriangleArea(3, 4, 5) == 6.00\n// TriangleArea(1, 2, 10) == -1\n", "declaration": "\nfunc TriangleArea(a float64, b float64, c float64) interface{} {\n", "canonical_solution": "\tif a+b <= c || a+c <= b || b+c <= a {\n\t\treturn -1\n\t}\n\ts := (a + b + c) / 2\n\tarea := math.Pow(s * (s - a) * (s - b) * (s - c), 0.5)\n\tarea = math.Round(area*100)/100\n\treturn area\n}\n\n", "test": "func TestTriangleArea(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6.00, TriangleArea(3, 4, 5))\n\tassert.Equal(-1, TriangleArea(1, 2, 10))\n\tassert.Equal(8.18, TriangleArea(4, 8, 5))\n\tassert.Equal(1.73, TriangleArea(2, 2, 2))\n\tassert.Equal(-1, TriangleArea(1, 2, 3))\n\tassert.Equal(16.25, TriangleArea(10, 5, 7))\n\tassert.Equal(-1, TriangleArea(2, 6, 3))\n\tassert.Equal(0.43, TriangleArea(1, 1, 1))\n\tassert.Equal(-1, TriangleArea(2, 2, 10))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTriangleArea(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6.00, TriangleArea(3, 4, 5))\n\tassert.Equal(-1, TriangleArea(1, 2, 10))\n}\n"}
{"task_id": "Go/72", "prompt": "\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n// \n// Example:\n// WillItFly([1, 2], 5) \u279e false\n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n// \n// WillItFly([3, 2, 3], 1) \u279e false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n// \n// WillItFly([3, 2, 3], 9) \u279e true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n// \n// WillItFly([3], 5) \u279e true\n// 3 is less than the maximum possible weight, and it's balanced.\nfunc WillItFly(q []int,w int) bool {\n", "import": "", "docstring": "// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n// \n// Example:\n// WillItFly([1, 2], 5) \u279e false\n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n// \n// WillItFly([3, 2, 3], 1) \u279e false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n// \n// WillItFly([3, 2, 3], 9) \u279e true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n// \n// WillItFly([3], 5) \u279e true\n// 3 is less than the maximum possible weight, and it's balanced.\n", "declaration": "\nfunc WillItFly(q []int,w int) bool {\n", "canonical_solution": "\tsum := 0\n\tfor i := 0; i < len(q); i++ {\n\t\tsum += q[i]\n\t}\n\tif sum <= w && isPalindrome(q) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isPalindrome(arr []int) bool {\n\tfor i := 0; i < (len(arr) / 2); i++ {\n\t\tif arr[i] != arr[len(arr) - i - 1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n", "test": "func TestWillItFly(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, WillItFly([]int{3, 2, 3}, 9))\n\tassert.Equal(false, WillItFly([]int{1, 2}, 5))\n\tassert.Equal(true, WillItFly([]int{3}, 5))\n\tassert.Equal(false, WillItFly([]int{3, 2, 3}, 1))\n\tassert.Equal(false, WillItFly([]int{1, 2, 3}, 6))\n\tassert.Equal(true, WillItFly([]int{5}, 5))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestWillItFly(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, WillItFly([]int{3, 2, 3}, 9))\n\tassert.Equal(false, WillItFly([]int{1, 2}, 5))\n\tassert.Equal(true, WillItFly([]int{3}, 5))\n\tassert.Equal(false, WillItFly([]int{3, 2, 3}, 1))\n}\n"}
{"task_id": "Go/73", "prompt": "\n// Given an array arr of integers, find the minimum number of elements that\n// need to be changed to make the array palindromic. A palindromic array is an array that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// \n// For example:\n// SmallestChange([1,2,3,5,4,7,9,6]) == 4\n// SmallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n// SmallestChange([1, 2, 3, 2, 1]) == 0\nfunc SmallestChange(arr []int) int {\n", "import": "", "docstring": "// Given an array arr of integers, find the minimum number of elements that\n// need to be changed to make the array palindromic. A palindromic array is an array that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// \n// For example:\n// SmallestChange([1,2,3,5,4,7,9,6]) == 4\n// SmallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n// SmallestChange([1, 2, 3, 2, 1]) == 0\n", "declaration": "\nfunc SmallestChange(arr []int) int {\n", "canonical_solution": "\tcount := 0\n\tfor i := 0; i < len(arr) - 1; i++ {\n\t\ta := arr[len(arr) - i - 1]\n\t\tif arr[i] != a {\n\t\t\tarr[i] = a\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n", "test": "func TestSmallestChange(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, SmallestChange([]int{1,2,3,5,4,7,9,6}))\n\tassert.Equal(1, SmallestChange([]int{1, 2, 3, 4, 3, 2, 2}))\n\tassert.Equal(1, SmallestChange([]int{1, 4, 2}))\n\tassert.Equal(1, SmallestChange([]int{1, 4, 4, 2}))\n\tassert.Equal(0, SmallestChange([]int{1, 2, 3, 2, 1}))\n\tassert.Equal(0, SmallestChange([]int{3, 1, 1, 3}))\n\tassert.Equal(0, SmallestChange([]int{1}))\n\tassert.Equal(1, SmallestChange([]int{0, 1}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSmallestChange(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, SmallestChange([]int{1,2,3,5,4,7,9,6}))\n\tassert.Equal(1, SmallestChange([]int{1, 2, 3, 4, 3, 2, 2}))\n\tassert.Equal(0, SmallestChange([]int{1, 2, 3, 2, 1}))\n\tassert.Equal(0, SmallestChange([]int{3, 1, 1, 3}))\n}\n"}
{"task_id": "Go/74", "prompt": "\n// Write a function that accepts two lists of strings and returns the list that has\n// total number of chars in the all strings of the list less than the other list.\n// \n// if the two lists have the same number of chars, return the first list.\n// \n// Examples\n// TotalMatch([], []) \u279e []\n// TotalMatch(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n// TotalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n// TotalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n// TotalMatch(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\nfunc TotalMatch(lst1 []string,lst2 []string) []string {\n", "import": "", "docstring": "// Write a function that accepts two lists of strings and returns the list that has\n// total number of chars in the all strings of the list less than the other list.\n// \n// if the two lists have the same number of chars, return the first list.\n// \n// Examples\n// TotalMatch([], []) \u279e []\n// TotalMatch(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n// TotalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n// TotalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n// TotalMatch(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n", "declaration": "\nfunc TotalMatch(lst1 []string,lst2 []string) []string {\n", "canonical_solution": "\tvar numchar1 = 0\n\tvar numchar2 = 0\n\tfor _, item := range lst1 {\n\t\tnumchar1 += len(item)\n\t}\n\tfor _, item := range lst2 {\n\t\tnumchar2 += len(item)\n\t}\n\tif numchar1 <= numchar2 {\n\t\treturn lst1\n\t} else {\n\t\treturn lst2\n\t}\n}\n\n", "test": "func TestTotalMatch(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{}, TotalMatch([]string{}, []string{}))\n\tassert.Equal([]string{\"hi\", \"hi\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"}))\n\tassert.Equal([]string{\"hi\", \"admin\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}))\n\tassert.Equal([]string{\"4\"}, TotalMatch([]string{\"4\"},[]string{\"1\", \"2\", \"3\", \"4\", \"5\"}))\n\tassert.Equal([]string{\"hI\", \"Hi\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}))\n\tassert.Equal([]string{\"hI\", \"hi\", \"hi\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}))\n\tassert.Equal([]string{\"hi\", \"admin\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}))\n\tassert.Equal([]string{}, TotalMatch([]string{}, []string{\"this\"}))\n\tassert.Equal([]string{}, TotalMatch([]string{\"this\"}, []string{}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTotalMatch(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{}, TotalMatch([]string{}, []string{}))\n\tassert.Equal([]string{\"hi\", \"admin\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}))\n\tassert.Equal([]string{\"4\"}, TotalMatch([]string{\"4\"},[]string{\"1\", \"2\", \"3\", \"4\", \"5\"}))\n\tassert.Equal([]string{\"hI\", \"Hi\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}))\n\tassert.Equal([]string{\"hI\", \"hi\", \"hi\"}, TotalMatch([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}))\n}\n"}
{"task_id": "Go/75", "prompt": "\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100.\n// Example:\n// IsMultiplyPrime(30) == true\n// 30 = 2 * 3 * 5\nfunc IsMultiplyPrime(a int) bool {\n", "import": "", "docstring": "// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100.\n// Example:\n// IsMultiplyPrime(30) == true\n// 30 = 2 * 3 * 5\n", "declaration": "\nfunc IsMultiplyPrime(a int) bool {\n", "canonical_solution": "\tisPrime := func(n int) bool {\n\t\tfor i := 2; i < int(math.Pow(float64(n), 0.5)+1); i++ {\n\t\t\tif n%i == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tfor i := 2; i < 101; i++ {\n\t\tif !isPrime(i) {\n\t\t\tcontinue\n\t\t}\n\t\tfor j := 2; j < 101; j++ {\n\t\t\tif !isPrime(j) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor k := 2; k < 101; k++ {\n\t\t\t\tif !isPrime(k) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif i*j*k == a {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n", "test": "func TestIsMultiplyPrime(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, IsMultiplyPrime(5))\n\tassert.Equal(true, IsMultiplyPrime(30))\n\tassert.Equal(true, IsMultiplyPrime(8))\n\tassert.Equal(false, IsMultiplyPrime(10))\n\tassert.Equal(true, IsMultiplyPrime(125))\n\tassert.Equal(true, IsMultiplyPrime(3 * 5 * 7))\n\tassert.Equal(false, IsMultiplyPrime(3 * 6 * 7))\n\tassert.Equal(false, IsMultiplyPrime(9 * 9 * 9))\n\tassert.Equal(false, IsMultiplyPrime(11 * 9 * 9))\n\tassert.Equal(true, IsMultiplyPrime(11 * 13 * 7))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsMultiplyPrime(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, IsMultiplyPrime(30))\n}\n"}
{"task_id": "Go/76", "prompt": "\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// IsSimplePower(1, 4) => true\n// IsSimplePower(2, 2) => true\n// IsSimplePower(8, 2) => true\n// IsSimplePower(3, 2) => false\n// IsSimplePower(3, 1) => false\n// IsSimplePower(5, 3) => false\nfunc IsSimplePower(x int,n int) bool {\n", "import": "", "docstring": "// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// IsSimplePower(1, 4) => true\n// IsSimplePower(2, 2) => true\n// IsSimplePower(8, 2) => true\n// IsSimplePower(3, 2) => false\n// IsSimplePower(3, 1) => false\n// IsSimplePower(5, 3) => false\n", "declaration": "\nfunc IsSimplePower(x int,n int) bool {\n", "canonical_solution": "\tif x == 1 {\n\t\treturn true\n\t}\n\tif n==1 {\n\t\treturn false\n\t}\n\tif x % n != 0 {\n\t\treturn false\n\t}\n\treturn IsSimplePower(x / n, n)\n}\n\n", "test": "func TestIsSimplePower(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, IsSimplePower(1, 4))\n\tassert.Equal(true, IsSimplePower(2, 2))\n\tassert.Equal(true, IsSimplePower(8, 2))\n\tassert.Equal(false, IsSimplePower(3, 2))\n\tassert.Equal(false, IsSimplePower(3, 1))\n\tassert.Equal(false, IsSimplePower(5, 3))\n\tassert.Equal(true, IsSimplePower(16, 2))\n\tassert.Equal(false, IsSimplePower(143214, 16))\n\tassert.Equal(true, IsSimplePower(4, 2))\n\tassert.Equal(true, IsSimplePower(9, 3))\n\tassert.Equal(true, IsSimplePower(16, 4))\n\tassert.Equal(false, IsSimplePower(24, 2))\n\tassert.Equal(false, IsSimplePower(128, 4))\n\tassert.Equal(false, IsSimplePower(12, 6))\n\tassert.Equal(true, IsSimplePower(1, 1))\n\tassert.Equal(true, IsSimplePower(1, 12))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsSimplePower(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, IsSimplePower(1, 4))\n\tassert.Equal(true, IsSimplePower(2, 2))\n\tassert.Equal(true, IsSimplePower(8, 2))\n\tassert.Equal(false, IsSimplePower(3, 2))\n\tassert.Equal(false, IsSimplePower(3, 1))\n\tassert.Equal(false, IsSimplePower(5, 3))\n}\n"}
{"task_id": "Go/77", "prompt": "import (\n\t\"math\"\n)\n\n// Write a function that takes an integer a and returns true\n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// Iscube(1) ==> true\n// Iscube(2) ==> false\n// Iscube(-1) ==> true\n// Iscube(64) ==> true\n// Iscube(0) ==> true\n// Iscube(180) ==> false\nfunc Iscube(a int) bool {\n", "import": "import (\n\t\"math\"\n)", "docstring": "// Write a function that takes an integer a and returns true\n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// Iscube(1) ==> true\n// Iscube(2) ==> false\n// Iscube(-1) ==> true\n// Iscube(64) ==> true\n// Iscube(0) ==> true\n// Iscube(180) ==> false\n", "declaration": "\nfunc Iscube(a int) bool {\n", "canonical_solution": "\tabs := math.Abs(float64(a))\n\treturn int(math.Pow(math.Round(math.Pow(abs, 1.0/3.0)), 3.0)) == int(abs)\n}\n\n", "test": "func TestIscube(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, Iscube(1))\n\tassert.Equal(false, Iscube(2))\n\tassert.Equal(true, Iscube(-1))\n\tassert.Equal(true, Iscube(64))\n\tassert.Equal(false, Iscube(180))\n\tassert.Equal(true, Iscube(1000))\n\tassert.Equal(true, Iscube(0))\n\tassert.Equal(false, Iscube(1729))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIscube(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, Iscube(1))\n\tassert.Equal(false, Iscube(2))\n\tassert.Equal(true, Iscube(-1))\n\tassert.Equal(true, Iscube(64))\n\tassert.Equal(false, Iscube(180))\n\tassert.Equal(true, Iscube(0))\n}\n"}
{"task_id": "Go/78", "prompt": "\n// You have been tasked to write a function that receives\n// a hexadecimal number as a string and counts the number of hexadecimal\n// digits that are primes (prime number, or a prime, is a natural number\n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7,\n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string,\n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output should be 2.\nfunc HexKey(num string) int {\n", "import": "", "docstring": "// You have been tasked to write a function that receives\n// a hexadecimal number as a string and counts the number of hexadecimal\n// digits that are primes (prime number, or a prime, is a natural number\n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7,\n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string,\n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output should be 2.\n", "declaration": "\nfunc HexKey(num string) int {\n", "canonical_solution": "\tprimes := map[int32]interface{}{'2': nil, '3': nil, '5': nil, '7': nil, 'B': nil, 'D': nil}\n\ttotal := 0\n\tfor _, c := range num {\n\t\tif _, ok := primes[c]; ok {\n\t\t\ttotal++\n\t\t}\n\t}\n\treturn total\n}\n\n", "test": "func TestHexKey(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, HexKey(\"AB\"))\n\tassert.Equal(2, HexKey(\"1077E\"))\n\tassert.Equal(4, HexKey(\"ABED1A33\"))\n\tassert.Equal(2, HexKey(\"2020\"))\n\tassert.Equal(6, HexKey(\"123456789ABCDEF0\"))\n\tassert.Equal(12, HexKey(\"112233445566778899AABBCCDDEEFF00\"))\n\tassert.Equal(0, HexKey(\"\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestHexKey(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, HexKey(\"AB\"))\n\tassert.Equal(2, HexKey(\"1077E\"))\n\tassert.Equal(4, HexKey(\"ABED1A33\"))\n\tassert.Equal(2, HexKey(\"2020\"))\n\tassert.Equal(6, HexKey(\"123456789ABCDEF0\"))\n}\n"}
{"task_id": "Go/79", "prompt": "import (\n\t\"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// \n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// \n// Examples:\n// DecimalToBinary(15)   # returns \"db1111db\"\n// DecimalToBinary(32)   # returns \"db100000db\"\nfunc DecimalToBinary(decimal int) string {\n", "import": "import (\n\t\"fmt\"\n)", "docstring": "// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// \n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// \n// Examples:\n// DecimalToBinary(15)   # returns \"db1111db\"\n// DecimalToBinary(32)   # returns \"db100000db\"\n", "declaration": "\nfunc DecimalToBinary(decimal int) string {\n", "canonical_solution": "\treturn fmt.Sprintf(\"db%bdb\", decimal)\n}\n\n", "test": "func TestDecimalToBinary(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"db0db\", DecimalToBinary(0))\n\tassert.Equal(\"db100000db\", DecimalToBinary(32))\n\tassert.Equal(\"db1100111db\", DecimalToBinary(103))\n\tassert.Equal(\"db1111db\", DecimalToBinary(15))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestDecimalToBinary(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"db100000db\", DecimalToBinary(32))\n\tassert.Equal(\"db1111db\", DecimalToBinary(15))\n}\n"}
{"task_id": "Go/80", "prompt": "\n// You are given a string s.\n// Your task is to check if the string is happy or not.\n// A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// IsHappy(a) => false\n// IsHappy(aa) => false\n// IsHappy(abcd) => true\n// IsHappy(aabb) => false\n// IsHappy(adb) => true\n// IsHappy(xyy) => false\nfunc IsHappy(s string) bool {\n", "import": "", "docstring": "// You are given a string s.\n// Your task is to check if the string is happy or not.\n// A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// IsHappy(a) => false\n// IsHappy(aa) => false\n// IsHappy(abcd) => true\n// IsHappy(aabb) => false\n// IsHappy(adb) => true\n// IsHappy(xyy) => false\n", "declaration": "\nfunc IsHappy(s string) bool {\n", "canonical_solution": "\tif len(s) < 3 {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(s)-2; i++ {\n\t\tif s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n", "test": "func TestIsHappy(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, IsHappy(\"a\"), \"a\")\n\tassert.Equal(false, IsHappy(\"aa\"), \"aa\")\n\tassert.Equal(true, IsHappy(\"abcd\"), \"abcd\")\n\tassert.Equal(false, IsHappy(\"aabb\"), \"aabb\")\n\tassert.Equal(true, IsHappy(\"adb\"), \"adb\")\n\tassert.Equal(false, IsHappy(\"xyy\"), \"xyy\")\n\tassert.Equal(true, IsHappy(\"iopaxpoi\"), \"iopaxpoi\")\n\tassert.Equal(false, IsHappy(\"iopaxioi\"), \"iopaxioi\")\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsHappy(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, IsHappy(\"a\"), \"a\")\n\tassert.Equal(false, IsHappy(\"aa\"), \"aa\")\n\tassert.Equal(true, IsHappy(\"abcd\"), \"abcd\")\n\tassert.Equal(false, IsHappy(\"aabb\"), \"aabb\")\n\tassert.Equal(true, IsHappy(\"adb\"), \"adb\")\n\tassert.Equal(false, IsHappy(\"xyy\"), \"xyy\")\n}\n"}
{"task_id": "Go/81", "prompt": "\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a list of GPAs for some students and you have to write\n// a function that can output a list of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A\n// > 3.3                A-\n// > 3.0                B+\n// > 2.7                B\n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+\n// > 0.7                D\n// > 0.0                D-\n// 0.0                E\n// \n// \n// Example:\n// grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nfunc NumericalLetterGrade(grades []float64) []string {\n", "import": "", "docstring": "// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a list of GPAs for some students and you have to write\n// a function that can output a list of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A\n// > 3.3                A-\n// > 3.0                B+\n// > 2.7                B\n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+\n// > 0.7                D\n// > 0.0                D-\n// 0.0                E\n// \n// \n// Example:\n// grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n", "declaration": "\nfunc NumericalLetterGrade(grades []float64) []string {\n", "canonical_solution": "letter_grade := make([]string, 0, len(grades))\n\tfor _, gpa := range grades {\n\t\tswitch {\n\t\tcase gpa == 4.0:\n\t\t\tletter_grade = append(letter_grade, \"A+\")\n\t\tcase gpa > 3.7:\n\t\t\tletter_grade = append(letter_grade, \"A\")\n\t\tcase gpa > 3.3:\n\t\t\tletter_grade = append(letter_grade, \"A-\")\n\t\tcase gpa > 3.0:\n\t\t\tletter_grade = append(letter_grade, \"B+\")\n\t\tcase gpa > 2.7:\n\t\t\tletter_grade = append(letter_grade, \"B\")\n\t\tcase gpa > 2.3:\n\t\t\tletter_grade = append(letter_grade, \"B-\")\n\t\tcase gpa > 2.0:\n\t\t\tletter_grade = append(letter_grade, \"C+\")\n\t\tcase gpa > 1.7:\n\t\t\tletter_grade = append(letter_grade, \"C\")\n\t\tcase gpa > 1.3:\n\t\t\tletter_grade = append(letter_grade, \"C-\")\n\t\tcase gpa > 1.0:\n\t\t\tletter_grade = append(letter_grade, \"D+\")\n\t\tcase gpa > 0.7:\n\t\t\tletter_grade = append(letter_grade, \"D\")\n\t\tcase gpa > 0.0:\n\t\t\tletter_grade = append(letter_grade, \"D-\")\n\t\tdefault:\n\t\t\tletter_grade = append(letter_grade, \"E\")\n\t\t}\n\n\t}\n\treturn letter_grade\n}\n\n", "test": "func TestNumericalLetterGrade(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}, NumericalLetterGrade([]float64{4.0, 3, 1.7, 2, 3.5}))\n\tassert.Equal([]string{\"D+\"}, NumericalLetterGrade([]float64{1.2}))\n\tassert.Equal([]string{\"D-\"}, NumericalLetterGrade([]float64{0.5}))\n\tassert.Equal([]string{\"E\"}, NumericalLetterGrade([]float64{0.0}))\n\tassert.Equal([]string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"}, NumericalLetterGrade([]float64{1, 0.3, 1.5, 2.8, 3.3}))\n\tassert.Equal([]string{\"E\", \"D-\"}, NumericalLetterGrade([]float64{0, 0.7}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestNumericalLetterGrade(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}, NumericalLetterGrade([]float64{4.0, 3, 1.7, 2, 3.5}))\n}\n"}
{"task_id": "Go/82", "prompt": "\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// PrimeLength('Hello') == true\n// PrimeLength('abcdcba') == true\n// PrimeLength('kittens') == true\n// PrimeLength('orange') == false\nfunc PrimeLength(s string) bool {\n", "import": "", "docstring": "// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// PrimeLength('Hello') == true\n// PrimeLength('abcdcba') == true\n// PrimeLength('kittens') == true\n// PrimeLength('orange') == false\n", "declaration": "\nfunc PrimeLength(s string) bool {\n", "canonical_solution": "\tl := len(s)\n\tif l == 0 || l == 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i < l; i++ {\n\t\tif l%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n", "test": "func TestPrimeLength(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, PrimeLength(\"Hello\"))\n\tassert.Equal(true, PrimeLength(\"abcdcba\"))\n\tassert.Equal(true, PrimeLength(\"kittens\"))\n\tassert.Equal(false, PrimeLength(\"orange\"))\n\tassert.Equal(true, PrimeLength(\"wow\"))\n\tassert.Equal(true, PrimeLength(\"world\"))\n\tassert.Equal(true, PrimeLength(\"MadaM\"))\n\tassert.Equal(true, PrimeLength(\"Wow\"))\n\tassert.Equal(false, PrimeLength(\"\"))\n\tassert.Equal(true, PrimeLength(\"HI\"))\n\tassert.Equal(true, PrimeLength(\"go\"))\n\tassert.Equal(false, PrimeLength(\"gogo\"))\n\tassert.Equal(false, PrimeLength(\"aaaaaaaaaaaaaaa\"))\n\tassert.Equal(true, PrimeLength(\"Madam\"))\n\tassert.Equal(false, PrimeLength(\"M\"))\n\tassert.Equal(false, PrimeLength(\"0\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestPrimeLength(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, PrimeLength(\"Hello\"))\n\tassert.Equal(true, PrimeLength(\"abcdcba\"))\n\tassert.Equal(true, PrimeLength(\"kittens\"))\n\tassert.Equal(false, PrimeLength(\"orange\"))\n}\n"}
{"task_id": "Go/83", "prompt": "import (\n\t\"math\"\n)\n\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nfunc StartsOneEnds(n int) int {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\n", "declaration": "\nfunc StartsOneEnds(n int) int {\n", "canonical_solution": "\tif n == 1 {\n\t\treturn 1\n\t}\n\treturn 18 * int(math.Pow(10, float64(n-2)))\n}\n\n", "test": "func TestStartsOneEnds(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, StartsOneEnds(1))\n\tassert.Equal(18, StartsOneEnds(2))\n\tassert.Equal(180, StartsOneEnds(3))\n\tassert.Equal(1800, StartsOneEnds(4))\n\tassert.Equal(18000, StartsOneEnds(5))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": ""}
{"task_id": "Go/84", "prompt": "import (\n\t\"fmt\"\n\t\"strconv\"\n)\n\n// Given a positive integer N, return the total sum of its digits in binary.\n// \n// Example\n// For N = 1000, the sum of digits will be 1 the output should be \"1\".\n// For N = 150, the sum of digits will be 6 the output should be \"110\".\n// For N = 147, the sum of digits will be 12 the output should be \"1100\".\n// \n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nfunc Solve(N int) string {\n", "import": "import (\n\t\"fmt\"\n\t\"strconv\"\n)\n", "docstring": "// Given a positive integer N, return the total sum of its digits in binary.\n// \n// Example\n// For N = 1000, the sum of digits will be 1 the output should be \"1\".\n// For N = 150, the sum of digits will be 6 the output should be \"110\".\n// For N = 147, the sum of digits will be 12 the output should be \"1100\".\n// \n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\n", "declaration": "\nfunc Solve(N int) string {\n", "canonical_solution": "\tsum := 0\n\tfor _, c := range strconv.Itoa(N) {\n\t\tsum += int(c - '0')\n\t}\n\treturn fmt.Sprintf(\"%b\", sum)\n}\n\n", "test": "func TestSolve(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"1\", Solve(1000), \"Error\")\n\tassert.Equal(\"110\", Solve(150), \"Error\")\n\tassert.Equal(\"1100\", Solve(147), \"Error\")\n\tassert.Equal(\"1001\", Solve(333), \"Error\")\n\tassert.Equal(\"10010\", Solve(963), \"Error\")\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": ""}
{"task_id": "Go/85", "prompt": "\n// Given a non-empty list of integers lst. Add the even elements that are at odd indices..\n// \n// Examples:\n// Add([4, 2, 6, 7]) ==> 2\nfunc Add(lst []int) int {\n", "import": "", "docstring": "// Given a non-empty list of integers lst. Add the even elements that are at odd indices..\n// \n// Examples:\n// Add([4, 2, 6, 7]) ==> 2\n", "declaration": "\nfunc Add(lst []int) int {\n", "canonical_solution": "\tsum := 0\n\tfor i := 1; i < len(lst); i += 2 {\n\t\tif lst[i]%2 == 0 {\n\t\t\tsum += lst[i]\n\t\t}\n\t}\n\treturn sum\n}\n\n", "test": "func TestAdd(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(88, Add([]int{4, 88}))\n\tassert.Equal(122, Add([]int{4, 5, 6, 7, 2, 122}))\n\tassert.Equal(0, Add([]int{4, 0, 6, 7}))\n\tassert.Equal(12, Add([]int{4, 4, 6, 8}))\n}\n\t\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAdd(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, Add([]int{4, 2, 6, 7}))\n}\n"}
{"task_id": "Go/86", "prompt": "import (\n\t\"sort\"\n\t\"strings\"\n)\n\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// \n// For example:\n// AntiShuffle('Hi') returns 'Hi'\n// AntiShuffle('hello') returns 'ehllo'\n// AntiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\nfunc AntiShuffle(s string) string {\n", "import": "import (\n\t\"sort\"\n\t\"strings\"\n)\n", "docstring": "// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// \n// For example:\n// AntiShuffle('Hi') returns 'Hi'\n// AntiShuffle('hello') returns 'ehllo'\n// AntiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n", "declaration": "\nfunc AntiShuffle(s string) string {\n", "canonical_solution": "\tstrs := make([]string, 0)\n\tfor _, i := range strings.Fields(s) {\n\t\tword := []rune(i)\n\t\tsort.Slice(word, func(i, j int) bool {\n\t\t\treturn word[i] < word[j]\n\t\t})\n\t\tstrs = append(strs, string(word))\n\t}\n\treturn strings.Join(strs, \" \")\n}\n\n", "test": "func TestAntiShuffle(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Hi\", AntiShuffle(\"Hi\"))\n\tassert.Equal(\"ehllo\", AntiShuffle(\"hello\"))\n\tassert.Equal(\"bemnru\", AntiShuffle(\"number\"))\n\tassert.Equal(\"abcd\", AntiShuffle(\"abcd\"))\n\tassert.Equal(\"Hello !!!Wdlor\", AntiShuffle(\"Hello World!!!\"))\n\tassert.Equal(\"\", AntiShuffle(\"\"))\n\tassert.Equal(\".Hi My aemn is Meirst .Rboot How aer ?ouy\", AntiShuffle(\"Hi. My name is Mister Robot. How are you?\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAntiShuffle(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Hi\", AntiShuffle(\"Hi\"))\n\tassert.Equal(\"ehllo\", AntiShuffle(\"hello\"))\n\tassert.Equal(\"Hello !!!Wdlor\", AntiShuffle(\"Hello World!!!\"))\n}\n"}
{"task_id": "Go/87", "prompt": "import (\n\t\"sort\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// \n// Examples:\n// GetRow([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// GetRow([], 1) == []\n// GetRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nfunc GetRow(lst [][]int, x int) [][2]int {\n", "import": "import (\n\t\"sort\"\n)\n", "docstring": "// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// \n// Examples:\n// GetRow([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// GetRow([], 1) == []\n// GetRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n", "declaration": "\nfunc GetRow(lst [][]int, x int) [][2]int {\n", "canonical_solution": "\tcoords := make([][2]int, 0)\n\tfor i, row := range lst {\n\t\tfor j, item := range row {\n\t\t\tif item == x {\n\t\t\t\tcoords = append(coords, [2]int{i, j})\n\t\t\t}\n\t\t}\n\t}\n\tsort.Slice(coords, func(i, j int) bool {\n\t\tif coords[i][0] == coords[j][0] {\n\t\t\treturn coords[i][1] > coords[j][1]\n\t\t}\n\t\treturn coords[i][0] < coords[j][0]\n\t})\n\n\treturn coords\n}\n\n", "test": "func TestGetRow(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([][2]int{{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}, GetRow([][]int{\n\t\t{1, 2, 3, 4, 5, 6},\n\t\t{1, 2, 3, 4, 1, 6},\n\t\t{1, 2, 3, 4, 5, 1},\n\t}, 1))\n\tassert.Equal([][2]int{{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}}, GetRow([][]int{\n\t\t{1, 2, 3, 4, 5, 6},\n\t\t{1, 2, 3, 4, 5, 6},\n\t\t{1, 2, 3, 4, 5, 6},\n\t\t{1, 2, 3, 4, 5, 6},\n\t\t{1, 2, 3, 4, 5, 6},\n\t\t{1, 2, 3, 4, 5, 6},\n\t}, 2))\n\tassert.Equal([][2]int{{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}}, GetRow([][]int{\n\t\t{1, 2, 3, 4, 5, 6},\n\t\t{1, 2, 3, 4, 5, 6},\n\t\t{1, 1, 3, 4, 5, 6},\n\t\t{1, 2, 1, 4, 5, 6},\n\t\t{1, 2, 3, 1, 5, 6},\n\t\t{1, 2, 3, 4, 1, 6},\n\t\t{1, 2, 3, 4, 5, 1},\n\t}, 1))\n\tassert.Equal([][2]int{}, GetRow([][]int{{}}, 1))\n\tassert.Equal([][2]int{}, GetRow([][]int{{1}}, 2))\n\tassert.Equal([][2]int{{2, 2}}, GetRow([][]int{{}, {1}, {1, 2, 3}}, 3))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGetRow(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([][2]int{{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}, GetRow([][]int{\n\t\t{1, 2, 3, 4, 5, 6},\n\t\t{1, 2, 3, 4, 1, 6},\n\t\t{1, 2, 3, 4, 5, 1},\n\t}, 1))\n\tassert.Equal([][2]int{}, GetRow([][]int{{}}, 1))\n\tassert.Equal([][2]int{{2, 2}}, GetRow([][]int{{}, {1}, {1, 2, 3}}, 3))\n}\n"}
{"task_id": "Go/88", "prompt": "import (\n\t\"sort\"\n)\n\n// Given an array of non-negative integers, return a copy of the given array after sorting,\n// you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// \n// Note:\n// * don't change the given array.\n// \n// Examples:\n// * SortArray([]) => []\n// * SortArray([5]) => [5]\n// * SortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n// * SortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\nfunc SortArray(array []int) []int {\n", "import": "import (\n\t\"sort\"\n)\n", "docstring": "// Given an array of non-negative integers, return a copy of the given array after sorting,\n// you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// \n// Note:\n// * don't change the given array.\n// \n// Examples:\n// * SortArray([]) => []\n// * SortArray([5]) => [5]\n// * SortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n// * SortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n", "declaration": "\nfunc SortArray(array []int) []int {\n", "canonical_solution": "\tarr := make([]int, len(array))\n\tcopy(arr, array)\n\tif len(arr) == 0 {\n\t\treturn arr\n\t}\n\tif (arr[0]+arr[len(arr)-1])%2 == 0 {\n\t\tsort.Slice(arr, func(i, j int) bool {\n\t\t\treturn arr[i] > arr[j]\n\t\t})\n\t} else {\n\t\tsort.Slice(arr, func(i, j int) bool {\n\t\t\treturn arr[i] < arr[j]\n\t\t})\n\t}\n\treturn arr\n}\n\n", "test": "func TestSortArray(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{}, SortArray([]int{}), \"Error\")\n\tassert.Equal([]int{5}, SortArray([]int{5}), \"Error\")\n\tassert.Equal([]int{0, 1, 2, 3, 4, 5}, SortArray([]int{2, 4, 3, 0, 1, 5}), \"Error\")\n\tassert.Equal([]int{6, 5, 4, 3, 2, 1, 0}, SortArray([]int{2, 4, 3, 0, 1, 5, 6}), \"Error\")\n\tassert.Equal([]int{1, 2}, SortArray([]int{2, 1}), \"Error\")\n\tassert.Equal([]int{0, 11, 15, 32, 42, 87}, SortArray([]int{15, 42, 87, 32, 11, 0}), \"Error\")\n\tassert.Equal([]int{23, 21, 14, 11}, SortArray([]int{21, 14, 23, 11}), \"Error\")\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortArray(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{}, SortArray([]int{}), \"Error\")\n\tassert.Equal([]int{5}, SortArray([]int{5}), \"Error\")\n\tassert.Equal([]int{0, 1, 2, 3, 4, 5}, SortArray([]int{2, 4, 3, 0, 1, 5}), \"Error\")\n\tassert.Equal([]int{6, 5, 4, 3, 2, 1, 0}, SortArray([]int{2, 4, 3, 0, 1, 5, 6}), \"Error\")\n}\n"}
{"task_id": "Go/89", "prompt": "import (\n\t\"strings\"\n)\n\n// Create a function Encrypt that takes a string as an argument and\n// returns a string Encrypted with the alphabet being rotated.\n// The alphabet should be rotated in a manner such that the letters\n// shift down by two multiplied to two places.\n// For example:\n// Encrypt('hi') returns 'lm'\n// Encrypt('asdfghjkl') returns 'ewhjklnop'\n// Encrypt('gf') returns 'kj'\n// Encrypt('et') returns 'ix'\nfunc Encrypt(s string) string {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Create a function Encrypt that takes a string as an argument and\n// returns a string Encrypted with the alphabet being rotated.\n// The alphabet should be rotated in a manner such that the letters\n// shift down by two multiplied to two places.\n// For example:\n// Encrypt('hi') returns 'lm'\n// Encrypt('asdfghjkl') returns 'ewhjklnop'\n// Encrypt('gf') returns 'kj'\n// Encrypt('et') returns 'ix'\n", "declaration": "\nfunc Encrypt(s string) string {\n", "canonical_solution": "\td := \"abcdefghijklmnopqrstuvwxyz\"\n\tout := make([]rune, 0, len(s))\n\tfor _, c := range s {\n\t\tpos := strings.IndexRune(d, c)\n\t\tif pos != -1 {\n\t\t\tout = append(out, []rune(d)[(pos+2*2)%26])\n\t\t} else {\n\t\t\tout = append(out, c)\n\t\t}\n\t}\n\treturn string(out)\n}\n\n", "test": "func TestEncrypt(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"lm\", Encrypt(\"hi\"))\n\tassert.Equal(\"ewhjklnop\", Encrypt(\"asdfghjkl\"))\n\tassert.Equal(\"kj\", Encrypt(\"gf\"))\n\tassert.Equal(\"ix\", Encrypt(\"et\"))\n\tassert.Equal(\"jeiajeaijeiak\", Encrypt(\"faewfawefaewg\"))\n\tassert.Equal(\"lippsqcjvmirh\", Encrypt(\"hellomyfriend\"))\n\tassert.Equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\", Encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n\tassert.Equal(\"e\", Encrypt(\"a\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestEncrypt(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"lm\", Encrypt(\"hi\"))\n\tassert.Equal(\"ewhjklnop\", Encrypt(\"asdfghjkl\"))\n\tassert.Equal(\"kj\", Encrypt(\"gf\"))\n\tassert.Equal(\"ix\", Encrypt(\"et\"))\n}\n"}
{"task_id": "Go/90", "prompt": "import (\n\t\"math\"\n\t\"sort\"\n)\n\n// You are given a list of integers.\n// Write a function NextSmallest() that returns the 2nd smallest element of the list.\n// Return nil if there is no such element.\n// \n// NextSmallest([1, 2, 3, 4, 5]) == 2\n// NextSmallest([5, 1, 4, 3, 2]) == 2\n// NextSmallest([]) == nil\n// NextSmallest([1, 1]) == nil\nfunc NextSmallest(lst []int) interface{} {\n", "import": "import (\n\t\"math\"\n\t\"sort\"\n)\n", "docstring": "// You are given a list of integers.\n// Write a function NextSmallest() that returns the 2nd smallest element of the list.\n// Return nil if there is no such element.\n// \n// NextSmallest([1, 2, 3, 4, 5]) == 2\n// NextSmallest([5, 1, 4, 3, 2]) == 2\n// NextSmallest([]) == nil\n// NextSmallest([1, 1]) == nil\n", "declaration": "\nfunc NextSmallest(lst []int) interface{} {\n", "canonical_solution": "\tset := make(map[int]struct{})\n\tfor _, i := range lst {\n\t\tset[i] = struct{}{}\n\t}\n\tvals := make([]int, 0, len(set))\n\tfor k := range set {\n\t\tvals = append(vals, k)\n\t}\n\tsort.Slice(vals, func(i, j int) bool {\n\t\treturn vals[i] < vals[j]\n\t})\n\tif len(vals) < 2 {\n\t\treturn nil\n\t}\n\treturn vals[1]\n}\n\n", "test": "func TestNextSmallest(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, NextSmallest([]int{1, 2, 3, 4, 5}))\n\tassert.Equal(2, NextSmallest([]int{5, 1, 4, 3, 2}))\n\tassert.Equal(nil, NextSmallest([]int{}))\n\tassert.Equal(nil, NextSmallest([]int{1, 1}))\n\tassert.Equal(1, NextSmallest([]int{1,1,1,1,0}))\n\tassert.Equal(nil, NextSmallest([]int{1, int(math.Pow(0, 0))}))\n\tassert.Equal(-35, NextSmallest([]int{-35, 34, 12, -45}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"math\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestNextSmallest(t *testing.T) {\n  assert := assert.New(t)\n   assert.Equal(2+0*int(math.Pow(0, 0)), NextSmallest([]int{1, 2, 3, 4, 5}))\n\tassert.Equal(2, NextSmallest([]int{5, 1, 4, 3, 2}))\n\tassert.Equal(nil, NextSmallest([]int{}))\n\tassert.Equal(nil, NextSmallest([]int{1, 1}))\n}\n"}
{"task_id": "Go/91", "prompt": "import (\n\t\"regexp\"\n)\n\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// \n// For example:\n// >>> IsBored(\"Hello world\")\n// 0\n// >>> IsBored(\"The sky is blue. The sun is shining. I love this weather\")\n// 1\nfunc IsBored(S string) int {\n", "import": "import (\n\t\"regexp\"\n)\n", "docstring": "// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// \n// For example:\n// >>> IsBored(\"Hello world\")\n// 0\n// >>> IsBored(\"The sky is blue. The sun is shining. I love this weather\")\n// 1\n", "declaration": "\nfunc IsBored(S string) int {\n", "canonical_solution": "\tr, _ := regexp.Compile(`[.?!]\\s*`)\n\tsentences := r.Split(S, -1)\n\tsum := 0\n\tfor _, s := range sentences {\n\t\tif len(s) >= 2 && s[:2] == \"I \" {\n\t\t\tsum++\n\t\t}\n\t}\n\treturn sum\n}\n\n", "test": "func TestIsBored(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, IsBored(\"Hello world\"), \"Test 1\")\n\tassert.Equal(0, IsBored(\"Is the sky blue?\"), \"Test 2\")\n\tassert.Equal(1, IsBored(\"I love It !\"), \"Test 3\")\n\tassert.Equal(0, IsBored(\"bIt\"), \"Test 4\")\n\tassert.Equal(2, IsBored(\"I feel good today. I will be productive. will kill It\"), \"Test 5\")\n\tassert.Equal(0, IsBored(\"You and I are going for a walk\"), \"Test 6\")\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsBored(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, IsBored(\"Hello world\"), \"Test 1\")\n\tassert.Equal(1, IsBored(\"The sky is blue. The sun is shining. I love this weather\"), \"Test 3\")\n}\n"}
{"task_id": "Go/92", "prompt": "\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// \n// Examples\n// AnyInt(5, 2, 7) \u279e true\n// \n// AnyInt(3, 2, 2) \u279e false\n// \n// AnyInt(3, -2, 1) \u279e true\n// \n// AnyInt(3.6, -2.2, 2) \u279e false\nfunc AnyInt(x, y, z interface{}) bool {\n", "import": "", "docstring": "// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// \n// Examples\n// AnyInt(5, 2, 7) \u279e true\n// \n// AnyInt(3, 2, 2) \u279e false\n// \n// AnyInt(3, -2, 1) \u279e true\n// \n// AnyInt(3.6, -2.2, 2) \u279e false\n", "declaration": "\nfunc AnyInt(x, y, z interface{}) bool {\n", "canonical_solution": "\txx, ok := x.(int)\n\tif !ok {\n\t\treturn false\n\t}\n\tyy, ok := y.(int)\n\tif !ok {\n\t\treturn false\n\t}\n\tzz, ok := z.(int)\n\tif !ok {\n\t\treturn false\n\t}\n\n\tif (xx+yy == zz) || (xx+zz == yy) || (yy+zz == xx) {\n\t\treturn true\n\t}\n\treturn false\n}\n\n", "test": "func TestAnyInt(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, AnyInt(2, 3, 1))\n\tassert.Equal(false, AnyInt(2.5, 2, 3))\n\tassert.Equal(false, AnyInt(1.5, 5, 3.5))\n\tassert.Equal(false, AnyInt(2, 6, 2))\n\tassert.Equal(true, AnyInt(4, 2, 2))\n\tassert.Equal(false, AnyInt(2.2, 2.2, 2.2))\n\tassert.Equal(true, AnyInt(-4, 6, 2))\n\tassert.Equal(true, AnyInt(2, 1, 1))\n\tassert.Equal(true, AnyInt(3, 4, 7))\n\tassert.Equal(false, AnyInt(3.0, 4, 7))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAnyInt(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, AnyInt(5, 2, 7))\n\tassert.Equal(false, AnyInt(3, 2, 2))\n\tassert.Equal(true, AnyInt(3, -2, 1))\n\tassert.Equal(false, AnyInt(3.6, -2.2, 2))\n}\n"}
{"task_id": "Go/93", "prompt": "import (\n\t\"strings\"\n)\n\n// Write a function that takes a message, and Encodes in such a\n// way that it swaps case of all letters, replaces all vowels in\n// the message with the letter that appears 2 places ahead of that\n// vowel in the english alphabet.\n// Assume only letters.\n// \n// Examples:\n// >>> Encode('test')\n// 'TGST'\n// >>> Encode('This is a message')\n// 'tHKS KS C MGSSCGG'\nfunc Encode(message string) string {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Write a function that takes a message, and Encodes in such a\n// way that it swaps case of all letters, replaces all vowels in\n// the message with the letter that appears 2 places ahead of that\n// vowel in the english alphabet.\n// Assume only letters.\n// \n// Examples:\n// >>> Encode('test')\n// 'TGST'\n// >>> Encode('This is a message')\n// 'tHKS KS C MGSSCGG'\n", "declaration": "\nfunc Encode(message string) string {\n", "canonical_solution": "\tvowels := \"aeiouAEIOU\"\n\tvowels_replace := make(map[rune]rune)\n\tfor _, c := range vowels {\n\t\tvowels_replace[c] = c + 2\n\t}\n\tresult := make([]rune, 0, len(message))\n\tfor _, c := range message {\n\t\tif 'a' <= c && c <= 'z' {\n\t\t\tc += 'A' - 'a'\n\t\t} else if 'A' <= c && c <= 'Z' {\n\t\t\tc += 'a' - 'A'\n\t\t}\n\t\tif strings.ContainsRune(vowels, c) {\n\t\t\tresult = append(result, vowels_replace[c])\n\t\t} else {\n\t\t\tresult = append(result, c)\n\t\t}\n\t}\n\treturn string(result)\n}\n\n", "test": "func TestEncode(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"tgst\", Encode(\"TEST\"))\n\tassert.Equal(\"mWDCSKR\", Encode(\"Mudasir\"))\n\tassert.Equal(\"ygs\", Encode(\"YES\"))\n\tassert.Equal(\"tHKS KS C MGSSCGG\", Encode(\"This is a message\"))\n\tassert.Equal(\"k dQnT kNqW wHcT Tq wRkTg\", Encode(\"I DoNt KnOw WhAt tO WrItE\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestEncode(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"TGST\", Encode(\"test\"))\n\tassert.Equal(\"tHKS KS C MGSSCGG\", Encode(\"This is a message\"))\n}\n"}
{"task_id": "Go/94", "prompt": "import (\n\t\"math\"\n\t\"strconv\"\n)\n\n// You are given a list of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// \n// Examples:\n// For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n// For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n// For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n// For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n// For lst = [0,81,12,3,1,21] the output should be 3\n// For lst = [0,8,1,2,1,7] the output should be 7\nfunc Skjkasdkd(lst []int) int {\n", "import": "import (\n\t\"math\"\n\t\"strconv\"\n)\n", "docstring": "// You are given a list of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// \n// Examples:\n// For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n// For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n// For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n// For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n// For lst = [0,81,12,3,1,21] the output should be 3\n// For lst = [0,8,1,2,1,7] the output should be 7\n", "declaration": "\nfunc Skjkasdkd(lst []int) int {\n", "canonical_solution": "\tisPrime := func(n int) bool {\n\t\tfor i := 2; i < int(math.Pow(float64(n), 0.5)+1); i++ {\n\t\t\tif n%i == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tmaxx := 0\n\ti := 0\n\tfor i < len(lst) {\n\t\tif lst[i] > maxx && isPrime(lst[i]) {\n\t\t\tmaxx = lst[i]\n\t\t}\n\t\ti++\n\t}\n\tsum := 0\n\tfor _, d := range strconv.Itoa(maxx) {\n\t\tsum += int(d - '0')\n\t}\n\treturn sum\n}\n\n", "test": "func TestSkjkasdkd(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(10, Skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}))\n\tassert.Equal(25, Skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}))\n\tassert.Equal(13, Skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}))\n\tassert.Equal(11, Skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}))\n\tassert.Equal(3, Skjkasdkd([]int{0, 81, 12, 3, 1, 21}))\n\tassert.Equal(7, Skjkasdkd([]int{0, 8, 1, 2, 1, 7}))\n\tassert.Equal(19, Skjkasdkd([]int{8191}))\n\tassert.Equal(19, Skjkasdkd([]int{8191, 123456, 127, 7}))\n\tassert.Equal(10, Skjkasdkd([]int{127, 97, 8192}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSkjkasdkd(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(10, Skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}))\n\tassert.Equal(25, Skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}))\n\tassert.Equal(13, Skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}))\n\tassert.Equal(11, Skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}))\n\tassert.Equal(3, Skjkasdkd([]int{0, 81, 12, 3, 1, 21}))\n\tassert.Equal(7, Skjkasdkd([]int{0, 8, 1, 2, 1, 7}))\n}\n"}
{"task_id": "Go/95", "prompt": "import (\n\t\"strings\"\n)\n\n// Given a dictionary, return true if all keys are strings in lower\n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given dictionary is empty.\n// Examples:\n// CheckDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n// CheckDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n// CheckDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n// CheckDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n// CheckDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\nfunc CheckDictCase(dict map[interface{}]interface{}) bool {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Given a dictionary, return true if all keys are strings in lower\n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given dictionary is empty.\n// Examples:\n// CheckDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n// CheckDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n// CheckDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n// CheckDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n// CheckDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n", "declaration": "\nfunc CheckDictCase(dict map[interface{}]interface{}) bool {\n", "canonical_solution": "\tif len(dict) == 0 {\n\t\treturn false\n\t}\n\tstate := \"start\"\n\tkey := \"\"\n\tok := false\n\tfor k := range dict {\n\t\tif key, ok = k.(string); !ok {\n\t\t\tstate = \"mixed\"\n\t\t\tbreak\n\t\t}\n\t\tif state == \"start\" {\n\t\t\tif key == strings.ToUpper(key) {\n\t\t\t\tstate = \"upper\"\n\t\t\t} else if key == strings.ToLower(key) {\n\t\t\t\tstate = \"lower\"\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (state == \"upper\" && key != strings.ToUpper(key)) || (state == \"lower\" && key != strings.ToLower(key)) {\n\t\t\tstate = \"mixed\"\n\t\t\tbreak\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn state == \"upper\" || state == \"lower\"\n}\n\n", "test": "func TestCheckDictCase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", \"b\": \"banana\"}))\n\tassert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}))\n\tassert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", 5: \"banana\", \"a\": \"apple\"}))\n\tassert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}))\n\tassert.Equal(true, CheckDictCase(map[interface{}]interface{}{\"STATE\": \"NC\", \"ZIP\": \"12345\"}))\n\tassert.Equal(true, CheckDictCase(map[interface{}]interface{}{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}))\n\tassert.Equal(false, CheckDictCase(map[interface{}]interface{}{}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCheckDictCase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", \"b\": \"banana\"}))\n\tassert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}))\n\tassert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"p\": \"pineapple\", 8: \"banana\", \"a\": \"apple\"}))\n\tassert.Equal(false, CheckDictCase(map[interface{}]interface{}{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}))\n\tassert.Equal(true, CheckDictCase(map[interface{}]interface{}{\"STATE\": \"NC\", \"ZIP\": \"12345\"}))\n}\n"}
{"task_id": "Go/96", "prompt": "\n// Implement a function that takes an non-negative integer and returns an array of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// CountUpTo(5) => [2,3]\n// CountUpTo(11) => [2,3,5,7]\n// CountUpTo(0) => []\n// CountUpTo(20) => [2,3,5,7,11,13,17,19]\n// CountUpTo(1) => []\n// CountUpTo(18) => [2,3,5,7,11,13,17]\nfunc CountUpTo(n int) []int {\n", "import": "", "docstring": "// Implement a function that takes an non-negative integer and returns an array of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// CountUpTo(5) => [2,3]\n// CountUpTo(11) => [2,3,5,7]\n// CountUpTo(0) => []\n// CountUpTo(20) => [2,3,5,7,11,13,17,19]\n// CountUpTo(1) => []\n// CountUpTo(18) => [2,3,5,7,11,13,17]\n", "declaration": "\nfunc CountUpTo(n int) []int {\n", "canonical_solution": "\tprimes := make([]int, 0)\n\tfor i := 2; i < n; i++ {\n\t\tis_prime := true\n\t\tfor j := 2; j < i; j++ {\n\t\t\tif i%j == 0 {\n\t\t\t\tis_prime = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif is_prime {\n\t\t\tprimes = append(primes, i)\n\t\t}\n\t}\n\treturn primes\n}\n\n", "test": "func TestCountUpTo(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 3}, CountUpTo(5))\n\tassert.Equal([]int{2, 3, 5}, CountUpTo(6))\n\tassert.Equal([]int{2, 3, 5}, CountUpTo(7))\n\tassert.Equal([]int{2, 3, 5, 7}, CountUpTo(10))\n\tassert.Equal([]int{}, CountUpTo(0))\n\tassert.Equal([]int{2, 3, 5, 7, 11, 13, 17, 19}, CountUpTo(22))\n\tassert.Equal([]int{}, CountUpTo(1))\n\tassert.Equal([]int{2, 3, 5, 7, 11, 13, 17}, CountUpTo(18))\n\tassert.Equal([]int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, CountUpTo(47))\n\tassert.Equal([]int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}, CountUpTo(101))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCountUpTo(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 3}, CountUpTo(5))\n\tassert.Equal([]int{2, 3, 5, 7}, CountUpTo(11))\n\tassert.Equal([]int{}, CountUpTo(0))\n\tassert.Equal([]int{2, 3, 5, 7, 11, 13, 17, 19}, CountUpTo(20))\n\tassert.Equal([]int{}, CountUpTo(1))\n\tassert.Equal([]int{2, 3, 5, 7, 11, 13, 17}, CountUpTo(18))\n}\n"}
{"task_id": "Go/97", "prompt": "import (\n\t\"math\"\n)\n\n// Complete the function that takes two integers and returns\n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// Multiply(148, 412) should return 16.\n// Multiply(19, 28) should return 72.\n// Multiply(2020, 1851) should return 0.\n// Multiply(14,-15) should return 20.\nfunc Multiply(a, b int) int {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// Complete the function that takes two integers and returns\n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// Multiply(148, 412) should return 16.\n// Multiply(19, 28) should return 72.\n// Multiply(2020, 1851) should return 0.\n// Multiply(14,-15) should return 20.\n", "declaration": "\nfunc Multiply(a, b int) int {\n", "canonical_solution": "\treturn int(math.Abs(float64(a%10)) * math.Abs(float64(b%10)))\n}\n\n", "test": "func TestMultiply(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(16, Multiply(148, 412))\n\tassert.Equal(72, Multiply(19, 28))\n\tassert.Equal(0, Multiply(2020, 1851))\n\tassert.Equal(20, Multiply(14, -15))\n\tassert.Equal(42, Multiply(76, 67))\n\tassert.Equal(49, Multiply(17, 27))\n\tassert.Equal(0, Multiply(0, 1))\n\tassert.Equal(0, Multiply(0, 0))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMultiply(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(16, Multiply(148, 412))\n\tassert.Equal(72, Multiply(19, 28))\n\tassert.Equal(0, Multiply(2020, 1851))\n\tassert.Equal(20, Multiply(14, -15))\n}\n"}
{"task_id": "Go/98", "prompt": "import (\n\t\"strings\"\n)\n\n// Given a string s, count the number of uppercase vowels in even indices.\n// \n// For example:\n// CountUpper('aBCdEf') returns 1\n// CountUpper('abcdefg') returns 0\n// CountUpper('dBBE') returns 0\nfunc CountUpper(s string) int {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Given a string s, count the number of uppercase vowels in even indices.\n// \n// For example:\n// CountUpper('aBCdEf') returns 1\n// CountUpper('abcdefg') returns 0\n// CountUpper('dBBE') returns 0\n", "declaration": "\nfunc CountUpper(s string) int {\n", "canonical_solution": "\tcount := 0\n\trunes := []rune(s)\n\tfor i := 0; i < len(runes); i += 2 {\n\t\tif strings.ContainsRune(\"AEIOU\", runes[i]) {\n\t\t\tcount += 1\n\t\t}\n\t}\n\treturn count\n}\n\n", "test": "func TestCountUpper(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, CountUpper(\"aBCdEf\"))\n\tassert.Equal(0, CountUpper(\"abcdefg\"))\n\tassert.Equal(0, CountUpper(\"dBBE\"))\n\tassert.Equal(0, CountUpper(\"B\"))\n\tassert.Equal(1, CountUpper(\"U\"))\n\tassert.Equal(0, CountUpper(\"\"))\n\tassert.Equal(2, CountUpper(\"EEEE\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCountUpper(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, CountUpper(\"aBCdEf\"))\n\tassert.Equal(0, CountUpper(\"abcdefg\"))\n\tassert.Equal(0, CountUpper(\"dBBE\"))\n}\n"}
{"task_id": "Go/99", "prompt": "import (\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// \n// Examples\n// >>> ClosestInteger(\"10\")\n// 10\n// >>> ClosestInteger(\"15.3\")\n// 15\n// \n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example ClosestInteger(\"14.5\") should\n// return 15 and ClosestInteger(\"-14.5\") should return -15.\nfunc ClosestInteger(value string) int {\n", "import": "import (\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n)\n", "docstring": "// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// \n// Examples\n// >>> ClosestInteger(\"10\")\n// 10\n// >>> ClosestInteger(\"15.3\")\n// 15\n// \n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example ClosestInteger(\"14.5\") should\n// return 15 and ClosestInteger(\"-14.5\") should return -15.\n", "declaration": "\nfunc ClosestInteger(value string) int {\n", "canonical_solution": "\tif strings.Count(value, \".\") == 1 {\n\t\t// remove trailing zeros\n\t\tfor value[len(value)-1] == '0' {\n\t\t\tvalue = value[:len(value)-1]\n\t\t}\n\t}\n\tvar res float64\n\tnum, _ := strconv.ParseFloat(value, 64)\n\tif len(value) >= 2 && value[len(value)-2:] == \".5\" {\n\t\tif num > 0 {\n\t\t\tres = math.Ceil(num)\n\t\t} else {\n\t\t\tres = math.Floor(num)\n\t\t}\n\t} else if len(value) > 0 {\n\t\tres = math.Round(num)\n\t} else {\n\t\tres = 0\n\t}\n\n\treturn int(res)\n}\n\n", "test": "func TestClosestInteger(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(10, ClosestInteger(\"10\"))\n\tassert.Equal(15, ClosestInteger(\"14.5\"))\n\tassert.Equal(-16, ClosestInteger(\"-15.5\"))\n\tassert.Equal(15, ClosestInteger(\"15.3\"))\n\tassert.Equal(0, ClosestInteger(\"0\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestClosestInteger(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(10, ClosestInteger(\"10\"))\n\tassert.Equal(15, ClosestInteger(\"15.3\"))\n}\n"}
{"task_id": "Go/100", "prompt": "\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a list, where element at index\n// i represents the number of stones in the level (i+1).\n// \n// Examples:\n// >>> MakeAPile(3)\n// [3, 5, 7]\nfunc MakeAPile(n int) []int {\n", "import": "", "docstring": "// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a list, where element at index\n// i represents the number of stones in the level (i+1).\n// \n// Examples:\n// >>> MakeAPile(3)\n// [3, 5, 7]\n", "declaration": "\nfunc MakeAPile(n int) []int {\n", "canonical_solution": "\tresult := make([]int, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tresult = append(result, n+2*i)\n\t}\n\treturn result\n}\n\n", "test": "func TestMakeAPile(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{3, 5, 7}, MakeAPile(3))\n\tassert.Equal([]int{4, 6, 8, 10}, MakeAPile(4))\n\tassert.Equal([]int{5, 7, 9, 11, 13}, MakeAPile(5))\n\tassert.Equal([]int{6, 8, 10, 12, 14, 16}, MakeAPile(6))\n\tassert.Equal([]int{8, 10, 12, 14, 16, 18, 20, 22}, MakeAPile(8))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMakeAPile(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{3, 5, 7}, MakeAPile(3))\n}\n"}
{"task_id": "Go/101", "prompt": "import (\n\t\"strings\"\n)\n\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return an array of the words.\n// \n// For example:\n// WordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n// WordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nfunc WordsString(s string) []string {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return an array of the words.\n// \n// For example:\n// WordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n// WordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n", "declaration": "\nfunc WordsString(s string) []string {\n", "canonical_solution": "\ts_list := make([]rune, 0)\n\n\tfor _, c := range s {\n\t\tif c == ',' {\n\t\t\ts_list = append(s_list, ' ')\n\t\t} else {\n\t\t\ts_list = append(s_list, c)\n\t\t}\n\t}\n\treturn strings.Fields(string(s_list))\n}\n\n", "test": "func TestWordsString(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}, WordsString(\"Hi, my name is John\"))\n\tassert.Equal([]string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}, WordsString(\"One, two, three, four, five, six\"))\n\tassert.Equal([]string{}, WordsString(\"\"))\n\tassert.Equal([]string{\"Hi\", \"my\", \"name\"}, WordsString(\"Hi, my name\"))\n\tassert.Equal([]string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}, WordsString(\"One,, two, three, four, five, six,\"))\n\tassert.Equal([]string{\"ahmed\", \"gamal\"}, WordsString(\"ahmed     , gamal\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestWordsString(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}, WordsString(\"Hi, my name is John\"))\n\tassert.Equal([]string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}, WordsString(\"One, two, three, four, five, six\"))\n}\n"}
{"task_id": "Go/102", "prompt": "\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If\n// there's no such number, then the function should return -1.\n// \n// For example:\n// ChooseNum(12, 15) = 14\n// ChooseNum(13, 12) = -1\nfunc ChooseNum(x, y int) int {\n", "import": "", "docstring": "// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If\n// there's no such number, then the function should return -1.\n// \n// For example:\n// ChooseNum(12, 15) = 14\n// ChooseNum(13, 12) = -1\n", "declaration": "\nfunc ChooseNum(x, y int) int {\n", "canonical_solution": "\tif x > y {\n\t\treturn -1\n\t}\n\tif y % 2 == 0 {\n\t\treturn y\n\t}\n\tif x == y {\n\t\treturn -1\n\t}\n\treturn y - 1\n}\n\n", "test": "func TestChooseNum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(14, ChooseNum(12,15))\n\tassert.Equal(-1, ChooseNum(13,12))\n\tassert.Equal(12354, ChooseNum(33,12354))\n\tassert.Equal(-1, ChooseNum(5234,5233))\n\tassert.Equal(28, ChooseNum(6,29))\n\tassert.Equal(-1, ChooseNum(27,10))\n\tassert.Equal(-1, ChooseNum(7,7))\n\tassert.Equal(546, ChooseNum(546,546))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestChooseNum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(14, ChooseNum(12,15))\n\tassert.Equal(-1, ChooseNum(13,12))\n}\n"}
{"task_id": "Go/103", "prompt": "import (\n\t\"fmt\"\n\t\"math\"\n)\n\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m).\n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// RoundedAvg(1, 5) => \"0b11\"\n// RoundedAvg(7, 5) => -1\n// RoundedAvg(10, 20) => \"0b1111\"\n// RoundedAvg(20, 33) => \"0b11010\"\nfunc RoundedAvg(n, m int) interface{} {\n", "import": "import (\n\t\"fmt\"\n\t\"math\"\n)\n", "docstring": "// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m).\n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// RoundedAvg(1, 5) => \"0b11\"\n// RoundedAvg(7, 5) => -1\n// RoundedAvg(10, 20) => \"0b1111\"\n// RoundedAvg(20, 33) => \"0b11010\"\n", "declaration": "\nfunc RoundedAvg(n, m int) interface{} {\n", "canonical_solution": "\tif m < n {\n\t\treturn -1\n\t}\n\tsummation := 0\n\tfor i := n;i < m+1;i++{\n\t\tsummation += i\n\t}\n\treturn fmt.Sprintf(\"0b%b\", int(math.Round(float64(summation)/float64(m - n + 1))))\n}\n\n", "test": "func TestRoundedAvg(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"0b11\", RoundedAvg(1, 5))\n\tassert.Equal(\"0b1010\", RoundedAvg(7, 13))\n\tassert.Equal(\"0b1111001011\", RoundedAvg(964, 977))\n\tassert.Equal(\"0b1111100101\", RoundedAvg(996, 997))\n\tassert.Equal(\"0b1011000010\", RoundedAvg(560, 851))\n\tassert.Equal(\"0b101101110\", RoundedAvg(185, 546))\n\tassert.Equal(\"0b110101101\", RoundedAvg(362, 496))\n\tassert.Equal(\"0b1001110010\", RoundedAvg(350, 902))\n\tassert.Equal(\"0b11010111\", RoundedAvg(197, 233))\n\tassert.Equal(-1, RoundedAvg(7, 5))\n\tassert.Equal(-1, RoundedAvg(5, 1))\n\tassert.Equal(\"0b101\", RoundedAvg(5, 5))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRoundedAvg(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"0b11\", RoundedAvg(1, 5))\n\tassert.Equal(-1, RoundedAvg(7, 5))\n\tassert.Equal(\"0b1111\", RoundedAvg(10, 20))\n\tassert.Equal(\"0b11011\", RoundedAvg(20, 33))\n}\n"}
{"task_id": "Go/104", "prompt": "import (\n\t\"sort\"\n\t\"strconv\"\n)\n\n// Given a list of positive integers x. return a sorted list of all\n// elements that hasn't any even digit.\n// \n// Note: Returned list should be sorted in increasing order.\n// \n// For example:\n// >>> UniqueDigits([15, 33, 1422, 1])\n// [1, 15, 33]\n// >>> UniqueDigits([152, 323, 1422, 10])\n// []\nfunc UniqueDigits(x []int) []int {\n", "import": "import (\n\t\"sort\"\n\t\"strconv\"\n)\n", "docstring": "// Given a list of positive integers x. return a sorted list of all\n// elements that hasn't any even digit.\n// \n// Note: Returned list should be sorted in increasing order.\n// \n// For example:\n// >>> UniqueDigits([15, 33, 1422, 1])\n// [1, 15, 33]\n// >>> UniqueDigits([152, 323, 1422, 10])\n// []\n", "declaration": "\nfunc UniqueDigits(x []int) []int {\n", "canonical_solution": "\todd_digit_elements := make([]int, 0)\n\tOUTER:\n\tfor _, i := range x {\n\t\tfor _, c := range strconv.Itoa(i) {\n\t\t\tif (c - '0') % 2 == 0 {\n\t\t\t\tcontinue OUTER\n\t\t\t}\n\t\t}\n\t\t\todd_digit_elements = append(odd_digit_elements, i)\n\t}\n\tsort.Slice(odd_digit_elements, func(i, j int) bool {\n\t\treturn odd_digit_elements[i] < odd_digit_elements[j]\n\t})\n\treturn odd_digit_elements\n}\n\n", "test": "func TestUniqueDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 15, 33}, UniqueDigits([]int{15, 33, 1422, 1}))\n\tassert.Equal([]int{}, UniqueDigits([]int{152, 323, 1422, 10}))\n\tassert.Equal([]int{111, 151}, UniqueDigits([]int{12345, 2033, 111, 151}))\n\tassert.Equal([]int{31, 135}, UniqueDigits([]int{135, 103, 31}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestUniqueDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 15, 33}, UniqueDigits([]int{15, 33, 1422, 1}))\n\tassert.Equal([]int{}, UniqueDigits([]int{152, 323, 1422, 10}))\n}\n"}
{"task_id": "Go/105", "prompt": "import (\n\t\"sort\"\n)\n\n// Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting array, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// \n// For example:\n// arr = [2, 1, 1, 4, 5, 8, 2, 3]\n// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n// -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n// return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n// \n// If the array is empty, return an empty array:\n// arr = []\n// return []\n// \n// If the array has any strange number ignore it:\n// arr = [1, -1 , 55]\n// -> sort arr -> [-1, 1, 55]\n// -> reverse arr -> [55, 1, -1]\n// return = ['One']\nfunc ByLength(arr []int)[]string {\n", "import": "import (\n\t\"sort\"\n)\n", "docstring": "// Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting array, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// \n// For example:\n// arr = [2, 1, 1, 4, 5, 8, 2, 3]\n// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n// -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n// return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n// \n// If the array is empty, return an empty array:\n// arr = []\n// return []\n// \n// If the array has any strange number ignore it:\n// arr = [1, -1 , 55]\n// -> sort arr -> [-1, 1, 55]\n// -> reverse arr -> [55, 1, -1]\n// return = ['One']\n", "declaration": "\nfunc ByLength(arr []int)[]string {\n", "canonical_solution": "\tdic := map[int]string{\n\t\t1: \"One\",\n\t\t2: \"Two\",\n\t\t3: \"Three\",\n\t\t4: \"Four\",\n\t\t5: \"Five\",\n\t\t6: \"Six\",\n\t\t7: \"Seven\",\n\t\t8: \"Eight\",\n\t\t9: \"Nine\",\n\t}\n\tsort.Slice(arr, func(i, j int) bool {\n\t\treturn arr[i] > arr[j]\n\t})\n\tnew_arr := make([]string, 0)\n\tfor _, item := range arr {\n\t\tif v, ok := dic[item]; ok {\n\t\t\tnew_arr = append(new_arr, v)\n\t\t}\n\t}\n\treturn new_arr\n}\n\n", "test": "func TestByLength(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}, ByLength([]int{2, 1, 1, 4, 5, 8, 2, 3}))\n\tassert.Equal([]string{}, ByLength([]int{}))\n\tassert.Equal([]string{\"One\"}, ByLength([]int{1, -1 , 55}))\n\tassert.Equal([]string{\"Three\", \"Two\", \"One\"}, ByLength([]int{1, -1, 3, 2}))\n\tassert.Equal([]string{\"Nine\", \"Eight\", \"Four\"}, ByLength([]int{9, 4, 8}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestByLength(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}, ByLength([]int{2, 1, 1, 4, 5, 8, 2, 3}))\n\tassert.Equal([]string{}, ByLength([]int{}))\n\tassert.Equal([]string{\"One\"}, ByLength([]int{1, -1 , 55}))\n\tassert.Equal([]string{\"Three\", \"Two\", \"One\"}, ByLength([]int{1, -1, 3, 2}))\n\tassert.Equal([]string{\"Nine\", \"Eight\", \"Four\"}, ByLength([]int{9, 4, 8}))\n}\n"}
{"task_id": "Go/106", "prompt": " \n// Implement the Function F that takes n as a parameter,\n// and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// F(5) == [1, 2, 6, 24, 15]\nfunc F(n int) []int {\n", "import": "", "docstring": "\n// Implement the Function F that takes n as a parameter,\n// and returns a list oF size n, such that the value oF the element at index i is the Factorial oF i iF i is even\n// or the sum oF numbers From 1 to i otherwise.\n// i starts From 1.\n// the Factorial oF i is the multiplication oF the numbers From 1 to i (1 * 2 * ... * i).\n// Example:\n// F(5) == [1, 2, 6, 24, 15]\n", "declaration": "\nfunc F(n int) []int {\n", "canonical_solution": "\tret := make([]int, 0, 5)\n\tfor i:=1;i<n+1;i++{\n\t\tif i%2 == 0 {\n\t\t\tx := 1\n\t\t\tfor j:=1;j<i+1;j++{\n\t\t\t\tx*=j\n\t\t\t}\n\t\t\tret = append(ret, x)\n\t\t}else {\n\t\t\tx := 0\n\t\t\tfor j:=1;j<i+1;j++{\n\t\t\t\tx+=j\n\t\t\t}\n\t\t\tret = append(ret, x)\n\t\t}\n\t}\n\treturn ret\n}\n\n", "test": "func TestF(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 2, 6, 24, 15}, F(5))\n\tassert.Equal([]int{1, 2, 6, 24, 15, 720, 28}, F(7))\n\tassert.Equal([]int{1}, F(1))\n\tassert.Equal([]int{1,2,6}, F(3))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestF(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 2, 6, 24, 15}, F(5))\n}\n"}
{"task_id": "Go/107", "prompt": "import (\n\t\"strconv\"\n)\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// \n// Example 1:\n// \n// Input: 3\n// Output: (1, 2)\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// \n// Example 2:\n// \n// Input: 12\n// Output: (4, 6)\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// \n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nfunc EvenOddPalindrome(n int) [2]int {\n", "import": "import (\n\t\"strconv\"\n)\n", "docstring": "// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// \n// Example 1:\n// \n// Input: 3\n// Output: (1, 2)\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// \n// Example 2:\n// \n// Input: 12\n// Output: (4, 6)\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// \n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\n", "declaration": "\nfunc EvenOddPalindrome(n int) [2]int {\n", "canonical_solution": "\tis_palindrome := func (n int) bool {\n\t\ts := strconv.Itoa(n)\n\t\tfor i := 0;i < len(s)>>1;i++ {\n\t\t\tif s[i] != s[len(s)-i-1] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\teven_palindrome_count := 0\n\todd_palindrome_count := 0\n\n\tfor i :=1;i<n+1;i++ {\n\t\tif i%2 == 1 && is_palindrome(i){\n\t\t\t\todd_palindrome_count ++\n\t\t} else if i%2 == 0 && is_palindrome(i) {\n\t\t\teven_palindrome_count ++\n\t\t}\n\t}\n\treturn [2]int{even_palindrome_count, odd_palindrome_count}\n}\n\n", "test": "func TestEvenOddPalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]int{8,13}, EvenOddPalindrome(123))\n\tassert.Equal([2]int{4,6}, EvenOddPalindrome(12))\n\tassert.Equal([2]int{1,2}, EvenOddPalindrome(3))\n\tassert.Equal([2]int{6,8}, EvenOddPalindrome(63))\n\tassert.Equal([2]int{5,6}, EvenOddPalindrome(25))\n\tassert.Equal([2]int{4,6}, EvenOddPalindrome(19))\n\tassert.Equal([2]int{4,5}, EvenOddPalindrome(9))\n\tassert.Equal([2]int{0,1}, EvenOddPalindrome(1))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestEvenOddPalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]int{4,6}, EvenOddPalindrome(12))\n\tassert.Equal([2]int{1,2}, EvenOddPalindrome(3))\n}\n"}
{"task_id": "Go/108", "prompt": "import (\n\t\"math\"\n\t\"strconv\"\n)\n\n// Write a function CountNums which takes an array of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> CountNums([]) == 0\n// >>> CountNums([-1, 11, -11]) == 1\n// >>> CountNums([1, 1, 2]) == 3\nfunc CountNums(arr []int) int {\n", "import": "import (\n\t\"math\"\n\t\"strconv\"\n)\n", "docstring": "// Write a function CountNums which takes an array of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> CountNums([]) == 0\n// >>> CountNums([-1, 11, -11]) == 1\n// >>> CountNums([1, 1, 2]) == 3\n", "declaration": "\nfunc CountNums(arr []int) int {\n", "canonical_solution": "\tdigits_sum:= func (n int) int {\n\t\tneg := 1\n\t\tif n < 0 {\n\t\t\t n, neg = -1 * n, -1 \n\t\t}\n\t\tr := make([]int,0)\n\t\tfor _, c := range strconv.Itoa(n) {\n\t\t\tr = append(r, int(c-'0'))\n\t\t}\n\t\tr[0] *= neg\n\t\tsum := 0\n\t\tfor _, i := range r {\n\t\t\tsum += i\n\t\t}\n\t\treturn sum\n\t}\n\tcount := 0\n\tfor _, i := range arr {\n\t\tx := digits_sum(i)\n\t\tif x > 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n", "test": "func TestCountNums(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, CountNums([]int{}))\n\tassert.Equal(0, CountNums([]int{-1, -2, 0}))\n\tassert.Equal(6, CountNums([]int{1, 1, 2, -2, 3, 4, 5}))\n\tassert.Equal(5, CountNums([]int{1, 6, 9, -6, 0, 1, 5}))\n\tassert.Equal(4, CountNums([]int{1, 100, 98, -7, 1, -1}))\n\tassert.Equal(5, CountNums([]int{12, 23, 34, -45, -56, 0}))\n\tassert.Equal(1, CountNums([]int{-0, int(math.Pow(1, 0))}))\n\tassert.Equal(1, CountNums([]int{1}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"math\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCountNums(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0+0*int(math.Pow(0, 0)), CountNums([]int{}))\n\tassert.Equal(1, CountNums([]int{-1, 11, -11}))\n\tassert.Equal(3, CountNums([]int{1, 1, 2}))\n}\n"}
{"task_id": "Go/109", "prompt": "import (\n\t\"math\"\n\t\"sort\"\n)\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will be randomly ordered. Your task is to determine if\n// it is possible to get an array sorted in non-decreasing order by performing\n// the following operation on the given array:\n// You are allowed to perform right shift operation any number of times.\n// \n// One right shift operation means shifting all elements of the array by one\n// position in the right direction. The last element of the array will be moved to\n// the starting position in the array i.e. 0th index.\n// \n// If it is possible to obtain the sorted array by performing the above operation\n// then return true else return false.\n// If the given array is empty then return true.\n// \n// Note: The given list is guaranteed to have unique elements.\n// \n// For Example:\n// \n// MoveOneBall([3, 4, 5, 1, 2])==>true\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given array.\n// MoveOneBall([3, 5, 4, 1, 2])==>false\n// Explanation:It is not possible to get non-decreasing order for the given\n// array by performing any number of right shift operations.\nfunc MoveOneBall(arr []int) bool {\n", "import": "import (\n\t\"math\"\n\t\"sort\"\n)\n", "docstring": "// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will be randomly ordered. Your task is to determine if\n// it is possible to get an array sorted in non-decreasing order by performing\n// the following operation on the given array:\n// You are allowed to perform right shift operation any number of times.\n// \n// One right shift operation means shifting all elements of the array by one\n// position in the right direction. The last element of the array will be moved to\n// the starting position in the array i.e. 0th index.\n// \n// If it is possible to obtain the sorted array by performing the above operation\n// then return true else return false.\n// If the given array is empty then return true.\n// \n// Note: The given list is guaranteed to have unique elements.\n// \n// For Example:\n// \n// MoveOneBall([3, 4, 5, 1, 2])==>true\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given array.\n// MoveOneBall([3, 5, 4, 1, 2])==>false\n// Explanation:It is not possible to get non-decreasing order for the given\n// array by performing any number of right shift operations.\n", "declaration": "\nfunc MoveOneBall(arr []int) bool {\n", "canonical_solution": "\tif len(arr)==0 {\n\t  return true\n\t}\n\tsorted_array := make([]int, len(arr))\n\tcopy(sorted_array, arr)\n\tsort.Slice(sorted_array, func(i, j int) bool {\n\t\treturn sorted_array[i] < sorted_array[j]\n\t})    \n\tmin_value := math.MaxInt\n\tmin_index := -1\n\tfor i, x := range arr {\n\t\tif i < min_value {\n\t\t\tmin_index, min_value = i, x\n\t\t}\n\t}\n\tmy_arr := make([]int, len(arr[min_index:]))\n\tcopy(my_arr, arr[min_index:])\n\tmy_arr = append(my_arr, arr[0:min_index]...)\n\tfor i :=0;i<len(arr);i++ {\n\t  if my_arr[i]!=sorted_array[i]{\n\t\treturn false\n\t  }\n\t}\n\treturn true\n}\n\n", "test": "func TestMoveOneBall(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, MoveOneBall([]int{3, 4, 5, 1, 2}))\n\tassert.Equal(true, MoveOneBall([]int{3, 5, 10, 1, 2}))\n\tassert.Equal(false, MoveOneBall([]int{4, 3, 1, 2}))\n\tassert.Equal(false, MoveOneBall([]int{3, 5, 4, 1, 2}))\n\tassert.Equal(true, MoveOneBall([]int{}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMoveOneBall(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, MoveOneBall([]int{3, 4, 5, 1, 2}))\n\tassert.Equal(false, MoveOneBall([]int{3, 5, 4, 1, 2}))\n}\n"}
{"task_id": "Go/110", "prompt": "\n// In this problem, you will implement a function that takes two lists of numbers,\n// and determines whether it is possible to perform an Exchange of elements\n// between them to make lst1 a list of only even numbers.\n// There is no limit on the number of Exchanged elements between lst1 and lst2.\n// If it is possible to Exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// Exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n// Exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n// It is assumed that the input lists will be non-empty.\nfunc Exchange(lst1, lst2 []int) string {\n", "import": "", "docstring": "// In this problem, you will implement a function that takes two lists of numbers,\n// and determines whether it is possible to perform an Exchange of elements\n// between them to make lst1 a list of only even numbers.\n// There is no limit on the number of Exchanged elements between lst1 and lst2.\n// If it is possible to Exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// Exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n// Exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n// It is assumed that the input lists will be non-empty.\n", "declaration": "\nfunc Exchange(lst1, lst2 []int) string {\n", "canonical_solution": "\todd := 0\n\teven := 0\n\tfor _, i := range lst1 {\n\t\tif i%2 == 1 {\n\t\t\todd++\n\t\t}\n\t}\n\tfor _, i := range lst2 {\n\t\tif i%2 == 0 {\n\t\t\teven++\n\t\t}\n\t}\n\tif even >= odd {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}\n\t\t\t\n\n", "test": "func TestExchange(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"YES\", Exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}))\n\tassert.Equal(\"NO\", Exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}))\n\tassert.Equal(\"YES\", Exchange([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}))\n\tassert.Equal(\"YES\", Exchange([]int{5, 7, 3}, []int{2, 6, 4}))\n\tassert.Equal(\"NO\", Exchange([]int{5, 7, 3}, []int{2, 6, 3}))\n\tassert.Equal(\"NO\", Exchange([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}))\n\tassert.Equal(\"YES\", Exchange([]int{100, 200}, []int{200, 200}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestExchange(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"YES\", Exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}))\n\tassert.Equal(\"NO\", Exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}))\n}\n"}
{"task_id": "Go/111", "prompt": "import (\n\t\"strings\"\n)\n\n// Given a string representing a space separated lowercase letters, return a dictionary\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// \n// Example:\n// Histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n// Histogram('a b b a') == {'a': 2, 'b': 2}\n// Histogram('a b c a b') == {'a': 2, 'b': 2}\n// Histogram('b b b b a') == {'b': 4}\n// Histogram('') == {}\nfunc Histogram(test string) map[rune]int {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Given a string representing a space separated lowercase letters, return a dictionary\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// \n// Example:\n// Histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n// Histogram('a b b a') == {'a': 2, 'b': 2}\n// Histogram('a b c a b') == {'a': 2, 'b': 2}\n// Histogram('b b b b a') == {'b': 4}\n// Histogram('') == {}\n", "declaration": "\nfunc Histogram(test string) map[rune]int {\n", "canonical_solution": "\tdict1 := make(map[rune]int)\n\tlist1 := strings.Fields(test)\n\tt := 0\n\tcount := func(lst []string, v string) int {\n\t\tcnt := 0\n\t\tfor _, i := range lst {\n\t\t\tif i == v {\n\t\t\t\tcnt++\n\t\t\t}\n\t\t}\n\t\treturn cnt\n\t}\n\tfor _, i := range list1 {\n\t\tif c := count(list1, i); c>t && i!=\"\" {\n\t\t\tt=c\n\t\t}\n\t}\n\tif t>0 {\n\t\tfor _, i := range list1 {\n\t\t\tif count(list1, i)==t {\n\t\t\t\tdict1[[]rune(i)[0]]=t\n\t\t\t}\n\t\t}\n\t}\n\treturn dict1\n}\n\n", "test": "func TestHistogram(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(map[rune]int{'a':2,'b': 2}, Histogram(\"a b b a\"))\n\tassert.Equal(map[rune]int{'a': 2, 'b': 2}, Histogram(\"a b c a b\"))\n\tassert.Equal(map[rune]int{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, Histogram(\"a b c d g\"))\n\tassert.Equal(map[rune]int{'r': 1,'t': 1,'g': 1}, Histogram(\"r t g\"))\n\tassert.Equal(map[rune]int{'b': 4}, Histogram(\"b b b b a\"))\n\tassert.Equal(map[rune]int{}, Histogram(\"\"))\n\tassert.Equal(map[rune]int{'a': 1}, Histogram(\"a\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestHistogram(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(map[rune]int{'a':2,'b': 2}, Histogram(\"a b b a\"))\n\tassert.Equal(map[rune]int{'a': 2, 'b': 2}, Histogram(\"a b c a b\"))\n\tassert.Equal(map[rune]int{'a': 1,'b': 1,'c': 1}, Histogram(\"a b c\"))\n\tassert.Equal(map[rune]int{'b': 4}, Histogram(\"b b b b a\"))\n\tassert.Equal(map[rune]int{}, Histogram(\"\"))\n}\n"}
{"task_id": "Go/112", "prompt": "import (\n\t\"strings\"\n)\n\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n// For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n// For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\nfunc ReverseDelete(s,c string) [2]interface{} {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n// For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n// For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n", "declaration": "\nfunc ReverseDelete(s,c string) [2]interface{} {\n", "canonical_solution": "\trs := make([]rune, 0)\n\tfor _, r := range s {\n\t\tif !strings.ContainsRune(c, r) {\n\t\t\trs = append(rs, r)\n\t\t}\n\t}\n\tt := true\n\tfor i := 0;i < len(rs)>>1;i++ {\n\t\tif rs[i] != rs[len(rs)-i-1] {\n\t\t\tt=false\n\t\t\tbreak\n\t\t}\n\t}\n\treturn [2]interface{}{string(rs), t}\n}\n\n", "test": "func TestReverseDelete(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]interface{}{\"bcd\", false}, ReverseDelete(\"abcde\",\"ae\"))\n\tassert.Equal([2]interface{}{\"acdef\", false}, ReverseDelete(\"abcdef\", \"b\"))\n\tassert.Equal([2]interface{}{\"cdedc\", true}, ReverseDelete(\"abcdedcba\",\"ab\"))\n\tassert.Equal([2]interface{}{\"dik\", false}, ReverseDelete(\"dwik\",\"w\"))\n\tassert.Equal([2]interface{}{\"\", true}, ReverseDelete(\"a\",\"a\"))\n\tassert.Equal([2]interface{}{\"abcdedcba\", true}, ReverseDelete(\"abcdedcba\",\"\"))\n\tassert.Equal([2]interface{}{\"abcdedcba\", true}, ReverseDelete(\"abcdedcba\",\"v\"))\n\tassert.Equal([2]interface{}{\"abba\", true}, ReverseDelete(\"vabba\",\"v\"))\n\tassert.Equal([2]interface{}{\"\", true}, ReverseDelete(\"mamma\",\"mia\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestReverseDelete(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]interface{}{\"bcd\", false}, ReverseDelete(\"abcde\",\"ae\"))\n\tassert.Equal([2]interface{}{\"acdef\", false}, ReverseDelete(\"abcdef\", \"b\"))\n\tassert.Equal([2]interface{}{\"cdedc\", true}, ReverseDelete(\"abcdedcba\",\"ab\"))\n}\n"}
{"task_id": "Go/113", "prompt": "import (\n\t\"fmt\"\n)\n\n// Given a list of strings, where each string consists of only digits, return a list.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// \n// >>> OddCount(['1234567'])\n// [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n// >>> OddCount(['3',\"11111111\"])\n// [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n// \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nfunc OddCount(lst []string) []string {\n", "import": "import (\n\t\"fmt\"\n)\n", "docstring": "// Given a list of strings, where each string consists of only digits, return a list.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// \n// >>> OddCount(['1234567'])\n// [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n// >>> OddCount(['3',\"11111111\"])\n// [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n// \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n", "declaration": "\nfunc OddCount(lst []string) []string {\n", "canonical_solution": "\tres := make([]string, 0, len(lst))\n\tfor _, arr := range lst {\n\t\tn := 0\n\t\tfor _, d := range arr {\n\t\t\tif (d - '0') % 2 == 1 {\n\t\t\t\tn++\n\t\t\t}\n\t\t}\n\t\tres = append(res, fmt.Sprintf(\"the number of odd elements %dn the str%dng %d of the %dnput.\", n,n,n,n))\n\t}\n\treturn res\n}\n\n", "test": "func TestOddCount(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}, OddCount([]string{\"1234567\"}))\n\tassert.Equal([]string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}, OddCount([]string{\"3\", \"11111111\"}))\n\tassert.Equal([]string{\n\t\t\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n\t\t\"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n\t\t\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n\t}, OddCount([]string{\"271\", \"137\", \"314\"}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestOddCount(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}, OddCount([]string{\"1234567\"}))\n\tassert.Equal([]string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}, OddCount([]string{\"3\", \"11111111\"}))\n}\n"}
{"task_id": "Go/114", "prompt": "import (\n\t\"math\"\n)\n\n// Given an array of integers nums, find the minimum sum of any non-empty sub-array\n// of nums.\n// Example\n// Minsubarraysum([2, 3, 4, 1, 2, 4]) == 1\n// Minsubarraysum([-1, -2, -3]) == -6\nfunc Minsubarraysum(nums []int) int {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// Given an array of integers nums, find the minimum sum of any non-empty sub-array\n// of nums.\n// Example\n// Minsubarraysum([2, 3, 4, 1, 2, 4]) == 1\n// Minsubarraysum([-1, -2, -3]) == -6\n", "declaration": "\nfunc Minsubarraysum(nums []int) int {\n", "canonical_solution": "\tmax_sum := 0\n\ts := 0\n\tfor _, num := range nums {\n\t\ts += -num\n\t\tif s < 0 {\n\t\t\ts = 0\n\t\t}\n\t\tif s > max_sum {\n\t\t\tmax_sum = s\n\t\t}\n\t}\n\tif max_sum == 0 {\n\t\tmax_sum = math.MinInt\n\t\tfor _, i := range nums {\n\t\t\tif -i > max_sum {\n\t\t\t\tmax_sum = -i\n\t\t\t}\n\t\t}\n\t}\n\treturn -max_sum\n}\n\n", "test": "func TestMinSubArraySum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, Minsubarraysum([]int{2, 3, 4, 1, 2, 4}))\n\tassert.Equal(-6, Minsubarraysum([]int{-1, -2, -3}))\n\tassert.Equal(-14, Minsubarraysum([]int{-1, -2, -3, 2, -10}))\n\tassert.Equal(-9999999999999999, Minsubarraysum([]int{-9999999999999999}))\n\tassert.Equal(0, Minsubarraysum([]int{0, 10, 20, 1000000}))\n\tassert.Equal(-6, Minsubarraysum([]int{-1, -2, -3, 10, -5}))\n\tassert.Equal(-6, Minsubarraysum([]int{100, -1, -2, -3, 10, -5}))\n\tassert.Equal(3, Minsubarraysum([]int{10, 11, 13, 8, 3, 4}))\n\tassert.Equal(-33, Minsubarraysum([]int{100, -33, 32, -1, 0, -2}))\n\tassert.Equal(-10, Minsubarraysum([]int{-10}))\n\tassert.Equal(7, Minsubarraysum([]int{7}))\n\tassert.Equal(-1, Minsubarraysum([]int{1, -1}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMinSubArraySum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, Minsubarraysum([]int{2, 3, 4, 1, 2, 4}))\n\tassert.Equal(-6, Minsubarraysum([]int{-1, -2, -3}))\n}\n"}
{"task_id": "Go/115", "prompt": "import (\n\t\"math\"\n)\n\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it,\n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// \n// Example 1:\n// Input:\n// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n// bucket_capacity : 1\n// Output: 6\n// \n// Example 2:\n// Input:\n// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n// bucket_capacity : 2\n// Output: 5\n// \n// Example 3:\n// Input:\n// grid : [[0,0,0], [0,0,0]]\n// bucket_capacity : 5\n// Output: 0\n// \n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nfunc MaxFill(grid [][]int, capacity int) int {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it,\n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// \n// Example 1:\n// Input:\n// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n// bucket_capacity : 1\n// Output: 6\n// \n// Example 2:\n// Input:\n// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n// bucket_capacity : 2\n// Output: 5\n// \n// Example 3:\n// Input:\n// grid : [[0,0,0], [0,0,0]]\n// bucket_capacity : 5\n// Output: 0\n// \n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n", "declaration": "\nfunc MaxFill(grid [][]int, capacity int) int {\n", "canonical_solution": "\tresult := 0\n\tfor _, arr := range grid {\n\t\tsum := 0\n\t\tfor _, i := range arr {\n\t\t\tsum += i\n\t\t}\n\t\tresult += int(math.Ceil(float64(sum) / float64(capacity)))\n\t}\n\treturn result\n}\n\n", "test": "func TestMaxFill(t *testing.T) {\n  assert := assert.New(t)\n  assert.Equal(6, MaxFill([][]int{{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1))\n  assert.Equal(5, MaxFill([][]int{{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2))\n  assert.Equal(0, MaxFill([][]int{{0,0,0}, {0,0,0}}, 5))\n  assert.Equal(4, MaxFill([][]int{{1,1,1,1}, {1,1,1,1}}, 2))\n  assert.Equal(2, MaxFill([][]int{{1,1,1,1}, {1,1,1,1}}, 9))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMaxFill(t *testing.T) {\n  assert := assert.New(t)\n  assert.Equal(6, MaxFill([][]int{{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1))\n  assert.Equal(5, MaxFill([][]int{{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2))\n  assert.Equal(0, MaxFill([][]int{{0,0,0}, {0,0,0}}, 5))\n}\n"}
{"task_id": "Go/116", "prompt": "import (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// In this Kata, you have to sort an array of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// \n// It must be implemented like this:\n// >>> SortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n// >>> SortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n// >>> SortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfunc SortArray(arr []int) []int {\n", "import": "import (\n\t\"fmt\"\n\t\"sort\"\n)\n", "docstring": "// In this Kata, you have to sort an array of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// \n// It must be implemented like this:\n// >>> SortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n// >>> SortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n// >>> SortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n", "declaration": "\nfunc SortArray(arr []int) []int {\n", "canonical_solution": "\tsort.Slice(arr, func(i, j int) bool {\n\t\treturn arr[i] < arr[j]\n\t})\n\tsort.Slice(arr, func(i, j int) bool {\n\t\tkey := func(x int) int {\n\t\t\tb := fmt.Sprintf(\"%b\", x)\n\t\t\tcnt := 0\n\t\t\tfor _, r := range b {\n\t\t\t\tif r == '1' {\n\t\t\t\t    cnt++\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cnt\n\t\t}\n\t\treturn key(arr[i]) < key(arr[j])\n\t})\n\treturn arr\n}\n\n", "test": "func TestSortArray(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 2, 4, 3, 5}, SortArray([]int{1,5,2,3,4}))\n\tassert.Equal([]int{-4, -2, -6, -5, -3}, SortArray([]int{-2,-3,-4,-5,-6}))\n\tassert.Equal([]int{0, 1, 2, 4, 3}, SortArray([]int{1,0,2,3,4}))\n\tassert.Equal([]int{}, SortArray([]int{}))\n\tassert.Equal([]int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77}, SortArray([]int{2,5,77,4,5,3,5,7,2,3,4}))\n\tassert.Equal([]int{32, 3, 5, 6, 12, 44}, SortArray([]int{3,6,44,12,32,5}))\n\tassert.Equal([]int{2, 4, 8, 16, 32}, SortArray([]int{2,4,8,16,32}))\n\tassert.Equal([]int{2, 4, 8, 16, 32}, SortArray([]int{2,4,8,16,32}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortArray(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 2, 4, 3, 5}, SortArray([]int{1,5,2,3,4}))\n\tassert.Equal([]int{-4, -2, -6, -5, -3}, SortArray([]int{-2,-3,-4,-5,-6}))\n\tassert.Equal([]int{0, 1, 2, 4, 3}, SortArray([]int{1,0,2,3,4}))\n}\n"}
{"task_id": "Go/117", "prompt": "import (\n\t\"bytes\"\n\t\"strings\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement\n// a function that returns a list of all words from string s that contain exactly\n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// SelectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// SelectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// SelectWords(\"simple white space\", 2) ==> []\n// SelectWords(\"Hello world\", 4) ==> [\"world\"]\n// SelectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc SelectWords(s string, n int) []string {\n", "import": "import (\n\t\"bytes\"\n\t\"strings\"\n)\n", "docstring": "// Given a string s and a natural number n, you have been tasked to implement\n// a function that returns a list of all words from string s that contain exactly\n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// SelectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// SelectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// SelectWords(\"simple white space\", 2) ==> []\n// SelectWords(\"Hello world\", 4) ==> [\"world\"]\n// SelectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n", "declaration": "\nfunc SelectWords(s string, n int) []string {\n", "canonical_solution": "\tresult := make([]string, 0)\n\tfor _, word := range strings.Fields(s) {\n\t\tn_consonants := 0\n\t\tlower := strings.ToLower(word)\n\t\tfor i := 0;i < len(word); i++ {\n\t\t\tif !bytes.Contains([]byte(\"aeiou\"), []byte{lower[i]}) {\n\t\t\t\tn_consonants++\n\t\t\t}\n\t\t}\n\t\tif n_consonants == n{\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\treturn result\n}\n\n", "test": "func TestSelectWords(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"little\"}, SelectWords(\"Mary had a little lamb\", 4))\n\tassert.Equal([]string{\"Mary\", \"lamb\"}, SelectWords(\"Mary had a little lamb\", 3))\n\tassert.Equal([]string{}, SelectWords(\"simple white space\", 2))\n\tassert.Equal([]string{\"world\"}, SelectWords(\"Hello world\", 4))\n\tassert.Equal([]string{\"Uncle\"}, SelectWords(\"Uncle sam\", 3))\n\tassert.Equal([]string{}, SelectWords(\"\", 4))\n\tassert.Equal([]string{\"b\", \"c\", \"d\", \"f\"}, SelectWords(\"a b c d e f\", 1))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSelectWords(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"little\"}, SelectWords(\"Mary had a little lamb\", 4))\n\tassert.Equal([]string{\"Mary\", \"lamb\"}, SelectWords(\"Mary had a little lamb\", 3))\n\tassert.Equal([]string{}, SelectWords(\"simple white space\", 2))\n\tassert.Equal([]string{\"world\"}, SelectWords(\"Hello world\", 4))\n\tassert.Equal([]string{\"Uncle\"}, SelectWords(\"Uncle sam\", 3))\n}\n"}
{"task_id": "Go/118", "prompt": "import (\n\t\"bytes\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between\n// two consonants from the right side of the word (case sensitive).\n// \n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition.\n// \n// You may assume that the given string contains English letter only.\n// \n// Example:\n// GetClosestVowel(\"yogurt\") ==> \"u\"\n// GetClosestVowel(\"FULL\") ==> \"U\"\n// GetClosestVowel(\"quick\") ==> \"\"\n// GetClosestVowel(\"ab\") ==> \"\"\nfunc GetClosestVowel(word string) string {\n", "import": "import (\n\t\"bytes\"\n)\n", "docstring": "// You are given a word. Your task is to find the closest vowel that stands between\n// two consonants from the right side of the word (case sensitive).\n// \n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition.\n// \n// You may assume that the given string contains English letter only.\n// \n// Example:\n// GetClosestVowel(\"yogurt\") ==> \"u\"\n// GetClosestVowel(\"FULL\") ==> \"U\"\n// GetClosestVowel(\"quick\") ==> \"\"\n// GetClosestVowel(\"ab\") ==> \"\"\n", "declaration": "\nfunc GetClosestVowel(word string) string {\n", "canonical_solution": "\tif len(word) < 3 {\n\t\treturn \"\"\n\t}\n\n\tvowels := []byte(\"aeiouAEOUI\")\n\tfor i := len(word)-2; i > 0; i-- {\n\t\tif bytes.Contains(vowels, []byte{word[i]}) {\n\t\t\tif !bytes.Contains(vowels, []byte{word[i+1]}) && !bytes.Contains(vowels, []byte{word[i-1]}) {\n\t\t\t\treturn string(word[i])\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\n", "test": "func TestGetClosestVowel(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"u\", GetClosestVowel(\"yogurt\"))\n\tassert.Equal(\"u\", GetClosestVowel(\"full\"))\n\tassert.Equal(\"\", GetClosestVowel(\"easy\"))\n\tassert.Equal(\"\", GetClosestVowel(\"eAsy\"))\n\tassert.Equal(\"\", GetClosestVowel(\"ali\"))\n\tassert.Equal(\"a\", GetClosestVowel(\"bad\"))\n\tassert.Equal(\"o\", GetClosestVowel(\"most\"))\n\tassert.Equal(\"\", GetClosestVowel(\"ab\"))\n\tassert.Equal(\"\", GetClosestVowel(\"ba\"))\n\tassert.Equal(\"\", GetClosestVowel(\"quick\"))\n\tassert.Equal(\"i\", GetClosestVowel(\"anime\"))\n\tassert.Equal(\"\", GetClosestVowel(\"Asia\"))\n\tassert.Equal(\"o\", GetClosestVowel(\"Above\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGetClosestVowel(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"u\", GetClosestVowel(\"yogurt\"))\n\tassert.Equal(\"U\", GetClosestVowel(\"FULL\"))\n\tassert.Equal(\"\", GetClosestVowel(\"ab\"))\n\tassert.Equal(\"\", GetClosestVowel(\"quick\"))\n}\n"}
{"task_id": "Go/119", "prompt": "\n// You are given a list of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// \n// Examples:\n// MatchParens(['()(', ')']) == 'Yes'\n// MatchParens([')', ')']) == 'No'\nfunc MatchParens(lst []string) string {\n", "import": "", "docstring": "// You are given a list of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// \n// Examples:\n// MatchParens(['()(', ')']) == 'Yes'\n// MatchParens([')', ')']) == 'No'\n", "declaration": "\nfunc MatchParens(lst []string) string {\n", "canonical_solution": "\tcheck := func(s string) bool {\n\t\tval := 0\n\t\tfor _, i := range s {\n\t\t\tif i == '(' {\n\t\t\t\tval++\n\t\t\t} else {\n\t\t\t\tval--\n\t\t\t}\n\t\t\tif val < 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn val == 0\n\t}\n\n\tS1 := lst[0] + lst[1]\n\tS2 := lst[1] + lst[0]\n\tif check(S1) || check(S2) {\n\t\treturn \"Yes\"\n\t}\n\treturn \"No\"\n}\n\n", "test": "func TestMatchParens(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Yes\", MatchParens([]string{\"()(\", \")\"}))\n\tassert.Equal(\"No\", MatchParens([]string{\")\", \")\"}))\n\tassert.Equal(\"No\", MatchParens([]string{\"(()(())\", \"())())\"}))\n\tassert.Equal(\"Yes\", MatchParens([]string{\")())\", \"(()()(\"}))\n\tassert.Equal(\"Yes\", MatchParens([]string{\"(())))\", \"(()())((\"}))\n\tassert.Equal(\"No\", MatchParens([]string{\"()\", \"())\"}))\n\tassert.Equal(\"Yes\", MatchParens([]string{\"(()(\", \"()))()\"}))\n\tassert.Equal(\"No\", MatchParens([]string{\"((((\", \"((())\"}))\n\tassert.Equal(\"No\", MatchParens([]string{\")(()\", \"(()(\"}))\n\tassert.Equal(\"No\", MatchParens([]string{\")(\", \")(\"}))\n\tassert.Equal(\"Yes\", MatchParens([]string{\"(\", \")\"}))\n\tassert.Equal(\"Yes\", MatchParens([]string{\")\", \"(\"}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMatchParens(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Yes\", MatchParens([]string{\"()(\", \")\"}))\n\tassert.Equal(\"No\", MatchParens([]string{\")\", \")\"}))\n}\n"}
{"task_id": "Go/120", "prompt": "import (\n\t\"sort\"\n)\n\n// Given an array arr of integers and a positive integer k, return a sorted list\n// of length k with the Maximum k numbers in arr.\n// \n// Example 1:\n// \n// Input: arr = [-3, -4, 5], k = 3\n// Output: [-4, -3, 5]\n// \n// Example 2:\n// \n// Input: arr = [4, -4, 4], k = 2\n// Output: [4, 4]\n// \n// Example 3:\n// \n// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n// Output: [2]\n// \n// Note:\n// 1. The length of the array will be in the range of [1, 1000].\n// 2. The elements in the array will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nfunc Maximum(arr []int, k int) []int {\n", "import": "import (\n\t\"sort\"\n)\n", "docstring": "// Given an array arr of integers and a positive integer k, return a sorted list\n// of length k with the Maximum k numbers in arr.\n// \n// Example 1:\n// \n// Input: arr = [-3, -4, 5], k = 3\n// Output: [-4, -3, 5]\n// \n// Example 2:\n// \n// Input: arr = [4, -4, 4], k = 2\n// Output: [4, 4]\n// \n// Example 3:\n// \n// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n// Output: [2]\n// \n// Note:\n// 1. The length of the array will be in the range of [1, 1000].\n// 2. The elements in the array will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\n", "declaration": "\nfunc Maximum(arr []int, k int) []int {\n", "canonical_solution": "\tif k == 0 {\n\t\treturn []int{}\n\t}\n\tsort.Slice(arr, func(i, j int) bool {\n\t\treturn arr[i] < arr[j]\n\t})\n\treturn arr[len(arr)-k:]\n}\n\n", "test": "func TestMaximum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{-4, -3, 5}, Maximum([]int{-3, -4, 5}, 3))\n\tassert.Equal([]int{4, 4}, Maximum([]int{4, -4, 4}, 2))\n\tassert.Equal([]int{2}, Maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1))\n\tassert.Equal([]int{2, 20, 123}, Maximum([]int{123, -123, 20, 0 , 1, 2, -3}, 3))\n\tassert.Equal([]int{0, 1, 2, 20}, Maximum([]int{-123, 20, 0 , 1, 2, -3}, 4))\n\tassert.Equal([]int{-13, -8, 0, 0, 3, 5, 15}, Maximum([]int{5, 15, 0, 3, -13, -8, 0}, 7))\n\tassert.Equal([]int{3, 5}, Maximum([]int{-1, 0, 2, 5, 3, -10}, 2))\n\tassert.Equal([]int{5}, Maximum([]int{1, 0, 5, -7}, 1))\n\tassert.Equal([]int{-4, 4}, Maximum([]int{4, -4}, 2))\n\tassert.Equal([]int{-10, 10}, Maximum([]int{-10, 10}, 2))\n\tassert.Equal([]int{}, Maximum([]int{1, 2, 3, -23, 243, -400, 0}, 0))\n  }\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMaximum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{-4, -3, 5}, Maximum([]int{-3, -4, 5}, 3))\n\tassert.Equal([]int{4, 4}, Maximum([]int{4, -4, 4}, 2))\n\tassert.Equal([]int{2}, Maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1))\n  }\n"}
{"task_id": "Go/121", "prompt": "\n// Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n// \n// Examples\n// Solution([5, 8, 7, 1]) ==> 12\n// Solution([3, 3, 3, 3, 3]) ==> 9\n// Solution([30, 13, 24, 321]) ==>0\nfunc Solution(lst []int) int {\n", "import": "", "docstring": "// Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n// \n// Examples\n// Solution([5, 8, 7, 1]) ==> 12\n// Solution([3, 3, 3, 3, 3]) ==> 9\n// Solution([30, 13, 24, 321]) ==>0\n", "declaration": "\nfunc Solution(lst []int) int {\n", "canonical_solution": "\tsum:=0\n\tfor i, x := range lst {\n\t\tif i&1==0&&x&1==1 {\n\t\t\tsum+=x\n\t\t}\n\t}\n\treturn sum\n}\n\n", "test": "func TestSolution(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(12, Solution([]int{5, 8, 7, 1}))\n\tassert.Equal(9, Solution([]int{3, 3, 3, 3, 3}))\n\tassert.Equal(0, Solution([]int{30, 13, 24, 321}))\n\tassert.Equal(5, Solution([]int{5, 9}))\n\tassert.Equal(0, Solution([]int{2, 4, 8}))\n\tassert.Equal(23, Solution([]int{30, 13, 23, 32}))\n\tassert.Equal(3, Solution([]int{3, 13, 2, 9}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSolution(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(12, Solution([]int{5, 8, 7, 1}))\n\tassert.Equal(9, Solution([]int{3, 3, 3, 3, 3}))\n\tassert.Equal(0, Solution([]int{30, 13, 24, 321}))\n}\n"}
{"task_id": "Go/122", "prompt": "import (\n\t\"strconv\"\n)\n\n// Given a non-empty array of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// \n// Example:\n// \n// Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n// Output: 24 # sum of 21 + 3\n// \n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nfunc AddElements(arr []int, k int) int {\n", "import": "import (\n\t\"strconv\"\n)\n", "docstring": "// Given a non-empty array of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// \n// Example:\n// \n// Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n// Output: 24 # sum of 21 + 3\n// \n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\n", "declaration": "\nfunc AddElements(arr []int, k int) int {\n", "canonical_solution": "\tsum := 0\n\tfor _, elem := range arr[:k] {\n\t\tif len(strconv.Itoa(elem)) <= 2 {\n\t\t\tsum += elem\n\t\t}\n\t}\n\treturn sum\n}\n\n", "test": "func TestAddElements(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(-4, AddElements([]int{1,-2,-3,41,57,76,87,88,99}, 3))\n\tassert.Equal(0, AddElements([]int{111,121,3,4000,5,6}, 2))\n\tassert.Equal(125, AddElements([]int{11,21,3,90,5,6,7,8,9}, 4))\n\tassert.Equal(24, AddElements([]int{111,21,3,4000,5,6,7,8,9}, 4))\n\tassert.Equal(1, AddElements([]int{1}, 1))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestAddElements(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(24, AddElements([]int{111,21,3,4000,5,6,7,8,9}, 4))\n}\n"}
{"task_id": "Go/123", "prompt": "import (\n\t\"sort\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// \n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the\n// previous term as follows: if the previous term is even, the next term is one half of\n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// \n// Note:\n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// \n// For example:\n// GetOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\nfunc GetOddCollatz(n int) []int {\n", "import": "import (\n\t\"sort\"\n)\n", "docstring": "// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// \n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the\n// previous term as follows: if the previous term is even, the next term is one half of\n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// \n// Note:\n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// \n// For example:\n// GetOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n", "declaration": "\nfunc GetOddCollatz(n int) []int {\n", "canonical_solution": "\todd_collatz := make([]int, 0)\n\tif n&1==1 {\n\t\todd_collatz = append(odd_collatz, n)\n\t}\n\tfor n > 1 {\n\t\tif n &1==0 {\n\t\t\tn>>=1\n\t\t} else {\n\t\t\tn = n*3 + 1\n\t\t}            \n\t\tif n&1 == 1 {\n\t\t\todd_collatz = append(odd_collatz, n)\n\t\t}\n\t}\n\tsort.Slice(odd_collatz, func(i, j int) bool {\n\t\treturn odd_collatz[i] < odd_collatz[j]\n\t})\n\treturn odd_collatz\n}\n\n", "test": "func TestGetOddCollatz(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 5, 7, 11, 13, 17}, GetOddCollatz(14))\n\tassert.Equal([]int{1, 5}, GetOddCollatz(5))\n\tassert.Equal([]int{1, 3, 5}, GetOddCollatz(12))\n\tassert.Equal([]int{1}, GetOddCollatz(1))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGetOddCollatz(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 5}, GetOddCollatz(5))\n}\n"}
{"task_id": "Go/124", "prompt": "import (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// \n// for example:\n// ValidDate('03-11-2000') => true\n// \n// ValidDate('15-01-2012') => false\n// \n// ValidDate('04-0-2040') => false\n// \n// ValidDate('06-04-2020') => true\n// \n// ValidDate('06/04/2020') => false\nfunc ValidDate(date string) bool {\n", "import": "import (\n\t\"strconv\"\n\t\"strings\"\n)\n", "docstring": "// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// \n// for example:\n// ValidDate('03-11-2000') => true\n// \n// ValidDate('15-01-2012') => false\n// \n// ValidDate('04-0-2040') => false\n// \n// ValidDate('06-04-2020') => true\n// \n// ValidDate('06/04/2020') => false\n", "declaration": "\nfunc ValidDate(date string) bool {\n", "canonical_solution": "\tisInArray := func(arr []int, i int) bool {\n\t\tfor _, x := range arr {\n\t\t\tif i == x {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tdate = strings.TrimSpace(date)\n\tsplit := strings.SplitN(date, \"-\", 3)\n\tif len(split) != 3 {\n\t\treturn false\n\t}\n\tmonth, err := strconv.Atoi(split[0])\n\tif err != nil {\n\t\treturn false\n\t}\n\tday, err := strconv.Atoi(split[1])\n\tif err != nil {\n\t\treturn false\n\t}\n\t_, err = strconv.Atoi(split[2])\n\tif err != nil {\n\t\treturn false\n\t}\n\tif month < 1 || month > 12 {\n\t\treturn false\n\t}\n\t\n\tif isInArray([]int{1,3,5,7,8,10,12}, month) && day < 1 || day > 31 {\n\t\treturn false\n\t}\n\tif isInArray([]int{4,6,9,11}, month) && day < 1 || day > 30 {\n\t\treturn false\n\t}\n\tif month == 2 && day < 1 || day > 29 {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n", "test": "func TestValidDate(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, ValidDate(\"03-11-2000\"))\n\tassert.Equal(false, ValidDate(\"15-01-2012\"))\n\tassert.Equal(false, ValidDate(\"04-0-2040\"))\n\tassert.Equal(true, ValidDate(\"06-04-2020\"))\n\tassert.Equal(true, ValidDate(\"01-01-2007\"))\n\tassert.Equal(false, ValidDate(\"03-32-2011\"))\n\tassert.Equal(false, ValidDate(\"\"))\n\tassert.Equal(false, ValidDate(\"04-31-3000\"))\n\tassert.Equal(true, ValidDate(\"06-06-2005\"))\n\tassert.Equal(false, ValidDate(\"21-31-2000\"))\n\tassert.Equal(true, ValidDate(\"04-12-2003\"))\n\tassert.Equal(false, ValidDate(\"04122003\"))\n\tassert.Equal(false, ValidDate(\"20030412\"))\n\tassert.Equal(false, ValidDate(\"2003-04\"))\n\tassert.Equal(false, ValidDate(\"2003-04-12\"))\n\tassert.Equal(false, ValidDate(\"04-2003\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestValidDate(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, ValidDate(\"03-11-2000\"))\n\tassert.Equal(false, ValidDate(\"15-01-2012\"))\n\tassert.Equal(false, ValidDate(\"04-0-2040\"))\n\tassert.Equal(true, ValidDate(\"06-04-2020\"))\n\tassert.Equal(false, ValidDate(\"06/04/2020\"))\n}\n"}
{"task_id": "Go/125", "prompt": "import (\n\t\"strings\"\n)\n\n// Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// SplitWords(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n// SplitWords(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n// SplitWords(\"abcdef\") == 3\nfunc SplitWords(txt string) interface{} {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// SplitWords(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n// SplitWords(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n// SplitWords(\"abcdef\") == 3\n", "declaration": "\nfunc SplitWords(txt string) interface{} {\n", "canonical_solution": "\tif strings.Contains(txt, \" \") {\n\t\treturn strings.Fields(txt)\n\t} else if strings.Contains(txt, \",\") {\n\t\treturn strings.Split(txt, \",\")\n\t}\n\tcnt := 0\n\tfor _, r := range txt {\n\t\tif 'a' <= r && r <= 'z' && (r-'a')&1==1 {\n\t\t\tcnt++\n\t\t}\n\t}\n\treturn cnt\n}\n\n", "test": "func TestSplitWords(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"Hello\", \"world!\"}, SplitWords(\"Hello world!\"))\n\tassert.Equal([]string{\"Hello\", \"world!\"}, SplitWords(\"Hello,world!\"))\n\tassert.Equal([]string{\"Hello\", \"world,!\"}, SplitWords(\"Hello world,!\"))\n\tassert.Equal([]string{\"Hello,Hello,world\", \"!\"}, SplitWords(\"Hello,Hello,world !\"))\n\tassert.Equal(3, SplitWords(\"abcdef\"))\n\tassert.Equal(2, SplitWords(\"aaabb\"))\n\tassert.Equal(1, SplitWords(\"aaaBb\"))\n\tassert.Equal(0, SplitWords(\"\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSplitWords(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"Hello\", \"world!\"}, SplitWords(\"Hello world!\"))\n\tassert.Equal([]string{\"Hello\", \"world!\"}, SplitWords(\"Hello,world!\"))\n\tassert.Equal(3, SplitWords(\"abcdef\"))\n}\n"}
{"task_id": "Go/126", "prompt": "\n// Given a list of numbers, return whether or not they are sorted\n// in ascending order. If list has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// \n// Examples\n// IsSorted([5]) \u279e true\n// IsSorted([1, 2, 3, 4, 5]) \u279e true\n// IsSorted([1, 3, 2, 4, 5]) \u279e false\n// IsSorted([1, 2, 3, 4, 5, 6]) \u279e true\n// IsSorted([1, 2, 3, 4, 5, 6, 7]) \u279e true\n// IsSorted([1, 3, 2, 4, 5, 6, 7]) \u279e false\n// IsSorted([1, 2, 2, 3, 3, 4]) \u279e true\n// IsSorted([1, 2, 2, 2, 3, 4]) \u279e false\nfunc IsSorted(lst []int) bool {\n", "import": "", "docstring": "// Given a list of numbers, return whether or not they are sorted\n// in ascending order. If list has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// \n// Examples\n// IsSorted([5]) \u279e true\n// IsSorted([1, 2, 3, 4, 5]) \u279e true\n// IsSorted([1, 3, 2, 4, 5]) \u279e false\n// IsSorted([1, 2, 3, 4, 5, 6]) \u279e true\n// IsSorted([1, 2, 3, 4, 5, 6, 7]) \u279e true\n// IsSorted([1, 3, 2, 4, 5, 6, 7]) \u279e false\n// IsSorted([1, 2, 2, 3, 3, 4]) \u279e true\n// IsSorted([1, 2, 2, 2, 3, 4]) \u279e false\n", "declaration": "\nfunc IsSorted(lst []int) bool {\n", "canonical_solution": "\tcount_digit := make(map[int]int)\n\tfor _, i := range lst {\n\t\tcount_digit[i] = 0\n\t}\n\tfor _, i := range lst {\n\t\tcount_digit[i]++\n\t}\n\tfor _, i := range lst {\n\t\tif count_digit[i] > 2 {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i := 1;i < len(lst);i++ {\n\t\tif lst[i-1] > lst[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\t\n\n", "test": "func TestIsSorted(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, IsSorted([]int{5}))\n\tassert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5}))\n\tassert.Equal(false, IsSorted([]int{1, 3, 2, 4, 5}))\n\tassert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5, 6, 7}))\n\tassert.Equal(false, IsSorted([]int{1, 3, 2, 4, 5, 6, 7}))\n\tassert.Equal(true, IsSorted([]int{}))\n\tassert.Equal(true, IsSorted([]int{1}))\n\tassert.Equal(false, IsSorted([]int{3, 2, 1}))\n\tassert.Equal(false, IsSorted([]int{1, 2, 2, 2, 3, 4}))\n\tassert.Equal(false, IsSorted([]int{1, 2, 3, 3, 3, 4}))\n\tassert.Equal(true, IsSorted([]int{1, 2, 2, 3, 3, 4}))\n\tassert.Equal(true, IsSorted([]int{1, 2, 3, 4}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsSorted(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, IsSorted([]int{5}))\n\tassert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5}))\n\tassert.Equal(false, IsSorted([]int{1, 3, 2, 4, 5}))\n\tassert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(true, IsSorted([]int{1, 2, 3, 4, 5, 6, 7}))\n\tassert.Equal(false, IsSorted([]int{1, 3, 2, 4, 5, 6, 7}))\n\tassert.Equal(false, IsSorted([]int{1, 2, 2, 2, 3, 4}))\n\tassert.Equal(true, IsSorted([]int{1, 2, 2, 3, 3, 4}))\n}\n"}
{"task_id": "Go/127", "prompt": "\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of Intersection of these two\n// intervals is a prime number.\n// Example, the Intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the Intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// \n// \n// [input/output] samples:\n// Intersection((1, 2), (2, 3)) ==> \"NO\"\n// Intersection((-1, 1), (0, 4)) ==> \"NO\"\n// Intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfunc Intersection(interval1 [2]int, interval2 [2]int) string {\n", "import": "", "docstring": "// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of Intersection of these two\n// intervals is a prime number.\n// Example, the Intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the Intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// \n// \n// [input/output] samples:\n// Intersection((1, 2), (2, 3)) ==> \"NO\"\n// Intersection((-1, 1), (0, 4)) ==> \"NO\"\n// Intersection((-3, -1), (-5, 5)) ==> \"YES\"\n", "declaration": "\nfunc Intersection(interval1 [2]int, interval2 [2]int) string {\n", "canonical_solution": "\tis_prime := func(num int) bool {\n\t\tif num == 1 || num == 0 {\n\t\t\treturn false\n\t\t}\n\t\tif num == 2 {\n\t\t\treturn true\n\t\t}\n\t\tfor i := 2;i < num;i++ {\n\t\t\tif num%i == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tl := interval1[0]\n\tif interval2[0] > l {\n\t\tl = interval2[0]\n\t}\n\tr := interval1[1]\n\tif interval2[1] < r {\n\t\tr = interval2[1]\n\t}\n\tlength := r - l\n\tif length > 0 && is_prime(length) {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}\n\n", "test": "func TestIntersection(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"NO\", Intersection([2]int{1, 2}, [2]int{2, 3}))\n\tassert.Equal(\"NO\", Intersection([2]int{-1, 1}, [2]int{0, 4}))\n\tassert.Equal(\"YES\", Intersection([2]int{-3, -1}, [2]int{-5, 5}))\n\tassert.Equal(\"YES\", Intersection([2]int{-2, 2}, [2]int{-4, 0}))\n\tassert.Equal(\"NO\", Intersection([2]int{-11, 2}, [2]int{-1, -1}))\n\tassert.Equal(\"NO\", Intersection([2]int{1, 2}, [2]int{3, 5}))\n\tassert.Equal(\"NO\", Intersection([2]int{1, 2}, [2]int{1, 2}))\n\tassert.Equal(\"NO\", Intersection([2]int{-2, -2}, [2]int{-3, -2}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIntersection(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"NO\", Intersection([2]int{1, 2}, [2]int{2, 3}))\n\tassert.Equal(\"NO\", Intersection([2]int{-1, 1}, [2]int{0, 4}))\n\tassert.Equal(\"YES\", Intersection([2]int{-3, -1}, [2]int{-5, 5}))\n}\n"}
{"task_id": "Go/128", "prompt": "import (\n\t\"math\"\n)\n\n// You are given an array arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the array, represented by 1, -1 or 0.\n// Note: return nil for empty arr.\n// \n// Example:\n// >>> ProdSigns([1, 2, 2, -4]) == -9\n// >>> ProdSigns([0, 1]) == 0\n// >>> ProdSigns([]) == nil\nfunc ProdSigns(arr []int) interface{} {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// You are given an array arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the array, represented by 1, -1 or 0.\n// Note: return nil for empty arr.\n// \n// Example:\n// >>> ProdSigns([1, 2, 2, -4]) == -9\n// >>> ProdSigns([0, 1]) == 0\n// >>> ProdSigns([]) == nil\n", "declaration": "\nfunc ProdSigns(arr []int) interface{} {\n", "canonical_solution": "\tif len(arr) == 0 {\n\t\treturn nil\n\t}\n\tcnt := 0\n\tsum := 0\n\tfor _, i := range arr {\n\t\tif i == 0 {\n\t\t\treturn 0\n\t\t}\n\t\tif i < 0 {\n\t\t\tcnt++\n\t\t}\n\t\tsum += int(math.Abs(float64(i)))\n\t}\n\n\tprod := int(math.Pow(-1, float64(cnt)))\n\treturn prod * sum\n}\n\n", "test": "func TestProdSigns(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(-9, ProdSigns([]int{1, 2, 2, -4}))\n\tassert.Equal(0, ProdSigns([]int{0, 1}))\n\tassert.Equal(-10, ProdSigns([]int{1, 1, 1, 2, 3, -1, 1}))\n\tassert.Equal(nil, ProdSigns([]int{}))\n\tassert.Equal(20, ProdSigns([]int{2, 4,1, 2, -1, -1, 9}))\n\tassert.Equal(4, ProdSigns([]int{-1, 1, -1, 1}))\n\tassert.Equal(-4, ProdSigns([]int{-1, 1, 1, 1}))\n\tassert.Equal(0, ProdSigns([]int{-1, 1, 1, 0}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestProdSigns(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(-9, ProdSigns([]int{1, 2, 2, -4}))\n\tassert.Equal(0, ProdSigns([]int{0, 1}))\n\tassert.Equal(nil, ProdSigns([]int{}))\n}\n"}
{"task_id": "Go/129", "prompt": "\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// \n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered lists of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered list of the values on the cells that the minimum path go through.\n// \n// Examples:\n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [1, 2, 1]\n// \n// Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n// Output: [1]\nfunc Minpath(grid [][]int, k int) []int {\n", "import": "", "docstring": "// Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// \n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered lists of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered list of the values on the cells that the minimum path go through.\n// \n// Examples:\n// \n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [1, 2, 1]\n// \n// Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n// Output: [1]\n", "declaration": "\nfunc Minpath(grid [][]int, k int) []int {\n", "canonical_solution": "\tn := len(grid)\n\tval := n * n + 1\n\tfor i:= 0;i < n; i++ {\n\t\tfor j := 0;j < n;j++ {\n\t\t\tif grid[i][j] == 1 {\n\t\t\t\ttemp := make([]int, 0)\n\t\t\t\tif i != 0 {\n\t\t\t\t    temp = append(temp, grid[i - 1][j])\n\t\t\t\t}\n\n\t\t\t\tif j != 0 {\n\t\t\t\t    temp = append(temp, grid[i][j - 1])\n\t\t\t\t}\n\n\t\t\t\tif i != n - 1 {\n\t\t\t\t    temp = append(temp, grid[i + 1][j])\n\t\t\t\t}\n\n\t\t\t\tif j != n - 1 {\n\t\t\t\t    temp = append(temp, grid[i][j + 1])\n\t\t\t\t}\n\t\t\t\tfor _, x := range temp {\n\t\t\t\t    if x < val {\n\t\t\t\t        val = x\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans := make([]int, 0, k)\n\tfor i := 0;i < k;i++ {\n\t\tif i & 1 == 0 {\n\t\t\tans = append(ans,  1)\n\t\t} else {\n\t\t\tans = append(ans,  val)\n\t\t}\n\t}\n\treturn ans\n}\n\n", "test": "func TestMinPath(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 2, 1}, Minpath([][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3))\n\tassert.Equal([]int{1}, Minpath([][]int{{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1))\n\tassert.Equal([]int{1, 2, 1, 2}, Minpath([][]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4))\n\tassert.Equal([]int{1, 10, 1, 10, 1, 10, 1}, Minpath([][]int{{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7))\n\tassert.Equal([]int{1, 7, 1, 7, 1}, Minpath([][]int{{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5))\n\tassert.Equal([]int{1, 6, 1, 6, 1, 6, 1, 6, 1}, Minpath([][]int{{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9))\n\tassert.Equal([]int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6}, Minpath([][]int{{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12))\n\tassert.Equal([]int{1, 3, 1, 3, 1, 3, 1, 3}, Minpath([][]int{{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8))\n\tassert.Equal([]int{1, 5, 1, 5, 1, 5, 1, 5}, Minpath([][]int{{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8))\n\tassert.Equal([]int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2}, Minpath([][]int{{1, 2}, {3, 4}}, 10))\n\tassert.Equal([]int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3}, Minpath([][]int{{1, 3}, {3, 2}}, 10))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMinPath(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{1, 2, 1}, Minpath([][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3))\n\tassert.Equal([]int{1}, Minpath([][]int{{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1))\n}\n"}
{"task_id": "Go/130", "prompt": "\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// Tri(1) = 3\n// Tri(n) = 1 + n / 2, if n is even.\n// Tri(n) =  Tri(n - 1) + Tri(n - 2) + Tri(n + 1), if n is odd.\n// For example:\n// Tri(2) = 1 + (2 / 2) = 2\n// Tri(4) = 3\n// Tri(3) = Tri(2) + Tri(1) + Tri(4)\n// = 2 + 3 + 3 = 8\n// You are given a non-negative integer number n, you have to a return a list of the\n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// Tri(3) = [1, 3, 2, 8]\nfunc Tri(n int) []float64 {\n", "import": "", "docstring": "// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// Tri(1) = 3\n// Tri(n) = 1 + n / 2, if n is even.\n// Tri(n) =  Tri(n - 1) + Tri(n - 2) + Tri(n + 1), if n is odd.\n// For example:\n// Tri(2) = 1 + (2 / 2) = 2\n// Tri(4) = 3\n// Tri(3) = Tri(2) + Tri(1) + Tri(4)\n// = 2 + 3 + 3 = 8\n// You are given a non-negative integer number n, you have to a return a list of the\n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// Tri(3) = [1, 3, 2, 8]\n", "declaration": "\nfunc Tri(n int) []float64 {\n", "canonical_solution": "\tif n == 0 {\n\t\treturn []float64{1}\n\t}\n\tmy_tri := []float64{1, 3}\n\tfor i := 2; i < n + 1; i++ {\n\t\tif i &1 == 0 {\n\t\t\tmy_tri = append(my_tri, float64(i) / 2 + 1)\n\t\t} else {\n\t\t\tmy_tri = append(my_tri, my_tri[i - 1] + my_tri[i - 2] + (float64(i) + 3) / 2)\n\t\t}\n\t}\n\treturn my_tri\n}\n\n", "test": "func TestTri(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]float64{1, 3, 2.0, 8.0}, Tri(3))\n\tassert.Equal([]float64{1, 3, 2.0, 8.0, 3.0}, Tri(4))\n\tassert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0}, Tri(5))\n\tassert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0}, Tri(6))\n\tassert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0}, Tri(7))\n\tassert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0}, Tri(8))\n\tassert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0}, Tri(9))\n\tassert.Equal([]float64{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0}, Tri(20))\n\tassert.Equal([]float64{1}, Tri(0))\n\tassert.Equal([]float64{1, 3}, Tri(1))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTri(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]float64{1, 3, 2.0, 8.0}, Tri(3))\n}\n"}
{"task_id": "Go/131", "prompt": "import (\n\t\"strconv\"\n)\n\n// Given a positive integer n, return the product of the odd Digits.\n// Return 0 if all Digits are even.\n// For example:\n// Digits(1)  == 1\n// Digits(4)  == 0\n// Digits(235) == 15\nfunc Digits(n int) int {\n", "import": "import (\n\t\"strconv\"\n)\n", "docstring": "// Given a positive integer n, return the product of the odd Digits.\n// Return 0 if all Digits are even.\n// For example:\n// Digits(1)  == 1\n// Digits(4)  == 0\n// Digits(235) == 15\n", "declaration": "\nfunc Digits(n int) int {\n", "canonical_solution": "\tproduct := 1\n\todd_count := 0\n\tfor _, digit := range strconv.Itoa(n) {\n\t\tint_digit := int(digit-'0')\n\t\tif int_digit&1 == 1 {\n\t\t\tproduct= product*int_digit\n\t\t\todd_count++\n\t\t}\n\t}\n\tif odd_count==0 {\n\t\treturn 0\n\t}\n\treturn product\n}\n\n", "test": "func TestDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(5, Digits(5))\n\tassert.Equal(5, Digits(54))\n\tassert.Equal(1, Digits(120))\n\tassert.Equal(5, Digits(5014))\n\tassert.Equal(315, Digits(98765))\n\tassert.Equal(2625, Digits(5576543))\n\tassert.Equal(0, Digits(2468))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, Digits(1))\n\tassert.Equal(0, Digits(4))\n\tassert.Equal(15, Digits(235))\n}\n"}
{"task_id": "Go/132", "prompt": "\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets\n// where at least one bracket in the subsequence is nested.\n// \n// IsNested('[[]]') \u279e true\n// IsNested('[]]]]]]][[[[[]') \u279e false\n// IsNested('[][]') \u279e false\n// IsNested('[]') \u279e false\n// IsNested('[[][]]') \u279e true\n// IsNested('[[]][[') \u279e true\nfunc IsNested(s string) bool {\n", "import": "", "docstring": "// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets\n// where at least one bracket in the subsequence is nested.\n// \n// IsNested('[[]]') \u279e true\n// IsNested('[]]]]]]][[[[[]') \u279e false\n// IsNested('[][]') \u279e false\n// IsNested('[]') \u279e false\n// IsNested('[[][]]') \u279e true\n// IsNested('[[]][[') \u279e true\n", "declaration": "\nfunc IsNested(s string) bool {\n", "canonical_solution": "\topening_bracket_index := make([]int, 0)\n\tclosing_bracket_index := make([]int, 0)\n\tfor i:=0;i < len(s);i++ {\n\t\tif s[i] == '[' {\n\t\t\topening_bracket_index = append(opening_bracket_index, i)\n\t\t} else {\n\t\t\tclosing_bracket_index = append(closing_bracket_index, i)\n\t\t}\n\t}\n\tfor i := 0;i < len(closing_bracket_index)>>1;i++ {\n\t\tclosing_bracket_index[i], closing_bracket_index[len(closing_bracket_index)-i-1] = closing_bracket_index[len(closing_bracket_index)-i-1], closing_bracket_index[i]\n\t}\n\tcnt := 0\n\ti := 0\n\tl := len(closing_bracket_index)\n\tfor _, idx := range opening_bracket_index {\n\t\tif i < l && idx < closing_bracket_index[i] {\n\t\t\tcnt++\n\t\t\ti++\n\t\t}\n\t}\n\treturn cnt >= 2\n}\n\n\t\n\n", "test": "func TestIsNested(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, IsNested(\"[[]]\"))\n\tassert.Equal(false, IsNested(\"[]]]]]]][[[[[]\"))\n\tassert.Equal(false, IsNested(\"[][]\"))\n\tassert.Equal(false, IsNested(\"'[]'\"))\n\tassert.Equal(true, IsNested(\"[[[[]]]]\"))\n\tassert.Equal(false, IsNested(\"[]]]]]]]]]]\"))\n\tassert.Equal(true, IsNested(\"[][][[]]\"))\n\tassert.Equal(false, IsNested(\"[[]\"))\n\tassert.Equal(false, IsNested(\"[]]\"))\n\tassert.Equal(true, IsNested(\"[[]][[\"))\n\tassert.Equal(true, IsNested(\"[[][]]\"))\n\tassert.Equal(false, IsNested(\"\"))\n\tassert.Equal(false, IsNested(\"[[[[[[[[\"))\n\tassert.Equal(false, IsNested(\"]]]]]]]]\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsNested(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, IsNested(\"[[]]\"))\n\tassert.Equal(false, IsNested(\"[]]]]]]][[[[[]\"))\n\tassert.Equal(false, IsNested(\"[][]\"))\n\tassert.Equal(false, IsNested(\"'[]'\"))\n\tassert.Equal(true, IsNested(\"[[]][[\"))\n\tassert.Equal(true, IsNested(\"[[][]]\"))\n}\n"}
{"task_id": "Go/133", "prompt": "import (\n\t\"math\"\n)\n\n// You are given a list of numbers.\n// You need to return the sum of squared numbers in the given list,\n// round each element in the list to the upper int(Ceiling) first.\n// Examples:\n// For lst = [1,2,3] the output should be 14\n// For lst = [1,4,9] the output should be 98\n// For lst = [1,3,5,7] the output should be 84\n// For lst = [1.4,4.2,0] the output should be 29\n// For lst = [-2.4,1,1] the output should be 6\nfunc SumSquares(lst []float64) int {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// You are given a list of numbers.\n// You need to return the sum of squared numbers in the given list,\n// round each element in the list to the upper int(Ceiling) first.\n// Examples:\n// For lst = [1,2,3] the output should be 14\n// For lst = [1,4,9] the output should be 98\n// For lst = [1,3,5,7] the output should be 84\n// For lst = [1.4,4.2,0] the output should be 29\n// For lst = [-2.4,1,1] the output should be 6\n", "declaration": "\nfunc SumSquares(lst []float64) int {\n", "canonical_solution": "\tsquared := 0\n\tfor _, i := range lst {\n\t\tsquared += int(math.Pow(math.Ceil(i), 2))\n\t}\n\treturn squared\n}\n\n", "test": "func TestSumSquares(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(14, SumSquares([]float64{1,2,3}))\n\tassert.Equal(14, SumSquares([]float64{1.0,2,3}))\n\tassert.Equal(84, SumSquares([]float64{1,3,5,7}))\n\tassert.Equal(29, SumSquares([]float64{1.4,4.2,0}))\n\tassert.Equal(6, SumSquares([]float64{-2.4,1,1}))\n\tassert.Equal(10230, SumSquares([]float64{100,1,15,2}))\n\tassert.Equal(200000000, SumSquares([]float64{10000,10000}))\n\tassert.Equal(75, SumSquares([]float64{-1.4,4.6,6.3}))\n\tassert.Equal(1086, SumSquares([]float64{-1.4,17.9,18.9,19.9}))\n\tassert.Equal(0, SumSquares([]float64{0}))\n\tassert.Equal(1, SumSquares([]float64{-1}))\n\tassert.Equal(2, SumSquares([]float64{-1,1,0}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSumSquares(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(14, SumSquares([]float64{1,2,3}))\n\tassert.Equal(98, SumSquares([]float64{1,4,9}))\n\tassert.Equal(84, SumSquares([]float64{1,3,5,7}))\n\tassert.Equal(29, SumSquares([]float64{1.4,4.2,0}))\n\tassert.Equal(6, SumSquares([]float64{-2.4,1,1}))\n}\n"}
{"task_id": "Go/134", "prompt": "import (\n\t\"strings\"\n)\n\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// \n// Examples:\n// CheckIfLastCharIsALetter(\"apple pie\") \u279e false\n// CheckIfLastCharIsALetter(\"apple pi e\") \u279e true\n// CheckIfLastCharIsALetter(\"apple pi e \") \u279e false\n// CheckIfLastCharIsALetter(\"\") \u279e false\nfunc CheckIfLastCharIsALetter(txt string) bool {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// \n// Examples:\n// CheckIfLastCharIsALetter(\"apple pie\") \u279e false\n// CheckIfLastCharIsALetter(\"apple pi e\") \u279e true\n// CheckIfLastCharIsALetter(\"apple pi e \") \u279e false\n// CheckIfLastCharIsALetter(\"\") \u279e false\n", "declaration": "\nfunc CheckIfLastCharIsALetter(txt string) bool {\n", "canonical_solution": "\tsplit := strings.Split(txt, \" \")\n\tcheck := strings.ToLower(split[len(split)-1])\n\tif len(check) == 1 && 'a' <= check[0] && check[0] <= 'z' {\n\t\treturn true\n\t}\n\treturn false\n}\n\n", "test": "func TestCheckIfLastCharIsALetter(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"apple\"))\n\tassert.Equal(true, CheckIfLastCharIsALetter(\"apple pi e\"))\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"eeeee\"))\n\tassert.Equal(true, CheckIfLastCharIsALetter(\"A\"))\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"Pumpkin pie \"))\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"Pumpkin pie 1\"))\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"\"))\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"eeeee e \"))\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"apple pie\"))\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"apple pi e \"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCheckIfLastCharIsALetter(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, CheckIfLastCharIsALetter(\"apple pi e\"))\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"\"))\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"apple pie\"))\n\tassert.Equal(false, CheckIfLastCharIsALetter(\"apple pi e \"))\n}\n"}
{"task_id": "Go/135", "prompt": "\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given array will not contain\n// duplicate values.\n// \n// Examples:\n// CanArrange([1,2,4,3,5]) = 3\n// CanArrange([1,2,3]) = -1\nfunc CanArrange(arr []int) int {\n", "import": "", "docstring": "// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given array will not contain\n// duplicate values.\n// \n// Examples:\n// CanArrange([1,2,4,3,5]) = 3\n// CanArrange([1,2,3]) = -1\n", "declaration": "\nfunc CanArrange(arr []int) int {\n", "canonical_solution": "\tind:=-1\n\ti:=1\n\tfor i<len(arr) {\n\t  if arr[i]<arr[i-1] {\n\t\tind=i\n\t  }\n\t  i++\n\t}\n\treturn ind\n}\n\n", "test": "func TestCanArrange(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, CanArrange([]int{1,2,4,3,5}))\n\tassert.Equal(-1, CanArrange([]int{1,2,4,5}))\n\tassert.Equal(2, CanArrange([]int{1,4,2,5,6,7,8,9,10}))\n\tassert.Equal(4, CanArrange([]int{4,8,5,7,3}))\n\tassert.Equal(-1, CanArrange([]int{}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCanArrange(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, CanArrange([]int{1,2,4,3,5}))\n\tassert.Equal(-1, CanArrange([]int{1,2,3}))\n}\n"}
{"task_id": "Go/136", "prompt": "\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n// If there is no negative or positive integers, return them as nil.\n// \n// Examples:\n// LargestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (nil, 1)\n// LargestSmallestIntegers([]) == (nil, nil)\n// LargestSmallestIntegers([0]) == (nil, nil)\nfunc LargestSmallestIntegers(lst []int) [2]interface{}{\n", "import": "", "docstring": "// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n// If there is no negative or positive integers, return them as nil.\n// \n// Examples:\n// LargestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (nil, 1)\n// LargestSmallestIntegers([]) == (nil, nil)\n// LargestSmallestIntegers([0]) == (nil, nil)\n", "declaration": "\nfunc LargestSmallestIntegers(lst []int) [2]interface{}{\n", "canonical_solution": "\tsmallest := make([]int, 0)\n\tlargest := make([]int, 0)\n\tfor _, x := range lst {\n\t\tif x < 0 {\n\t\t\tsmallest = append(smallest, x)\n\t\t} else if x > 0 {\n\t\t\tlargest = append(largest, x)\n\t\t}\n\t}\n\tvar result [2]interface{}\n\tif len(smallest) == 0 {\n\t\tresult[0] = nil\n\t} else {\n\t\tmax := smallest[0]\n\t\tfor i := 1;i < len(smallest);i++ {\n\t\t\tif smallest[i] > max {\n\t\t\t\tmax = smallest[i]\n\t\t\t}\n\t\t}\n\t\tresult[0] = max\n\t}\n\tif len(largest) == 0 {\n\t\tresult[1] = nil\n\t} else {\n\t\tmin := largest[0]\n\t\tfor i := 1;i < len(largest);i++ {\n\t\t\tif largest[i] < min {\n\t\t\t\tmin = largest[i]\n\t\t\t}\n\t\t}\n\t\tresult[1] = min\n\t}\n\treturn result\n}\n\n", "test": "func TestLargestSmallestIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]interface{}{nil, 1}, LargestSmallestIntegers([]int{2, 4, 1, 3, 5, 7}))\n\tassert.Equal([2]interface{}{nil, 1}, LargestSmallestIntegers([]int{2, 4, 1, 3, 5, 7, 0}))\n\tassert.Equal([2]interface{}{-2, 1}, LargestSmallestIntegers([]int{1, 3, 2, 4, 5, 6, -2}))\n\tassert.Equal([2]interface{}{-7, 2}, LargestSmallestIntegers([]int{4, 5, 3, 6, 2, 7, -7}))\n\tassert.Equal([2]interface{}{-9, 2}, LargestSmallestIntegers([]int{7, 3, 8, 4, 9, 2, 5, -9}))\n\tassert.Equal([2]interface{}{nil, nil}, LargestSmallestIntegers([]int{}))\n\tassert.Equal([2]interface{}{nil, nil}, LargestSmallestIntegers([]int{0}))\n\tassert.Equal([2]interface{}{-1, nil}, LargestSmallestIntegers([]int{-1, -3, -5, -6}))\n\tassert.Equal([2]interface{}{-1, nil}, LargestSmallestIntegers([]int{-1, -3, -5, -6, 0}))\n\tassert.Equal([2]interface{}{-3, 1}, LargestSmallestIntegers([]int{-6, -4, -4, -3, 1}))\n\tassert.Equal([2]interface{}{-3, 1}, LargestSmallestIntegers([]int{-6, -4, -4, -3, -100, 1}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestLargestSmallestIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]interface{}{nil, 1}, LargestSmallestIntegers([]int{2, 4, 1, 3, 5, 7}))\n\tassert.Equal([2]interface{}{nil, nil}, LargestSmallestIntegers([]int{}))\n\tassert.Equal([2]interface{}{nil, nil}, LargestSmallestIntegers([]int{0}))\n}\n"}
{"task_id": "Go/137", "prompt": "import (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return nil if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// \n// CompareOne(1, 2.5) \u279e 2.5\n// CompareOne(1, \"2,3\") \u279e \"2,3\"\n// CompareOne(\"5,1\", \"6\") \u279e \"6\"\n// CompareOne(\"1\", 1) \u279e nil\nfunc CompareOne(a, b interface{}) interface{} {\n", "import": "import (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n", "docstring": "// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return nil if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// \n// CompareOne(1, 2.5) \u279e 2.5\n// CompareOne(1, \"2,3\") \u279e \"2,3\"\n// CompareOne(\"5,1\", \"6\") \u279e \"6\"\n// CompareOne(\"1\", 1) \u279e nil\n", "declaration": "\nfunc CompareOne(a, b interface{}) interface{} {\n", "canonical_solution": "\ttemp_a := fmt.Sprintf(\"%v\", a)\n\ttemp_b := fmt.Sprintf(\"%v\", b)\n\ttemp_a = strings.ReplaceAll(temp_a, \",\", \".\")\n\ttemp_b = strings.ReplaceAll(temp_b, \",\", \".\")\n\tfa, _ := strconv.ParseFloat(temp_a, 64)\n\tfb, _ := strconv.ParseFloat(temp_b, 64)\n\t\n\tif fa == fb {\n\t\treturn nil\n\t}\n\tif fa > fb {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n\n", "test": "func TestCompareOne(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, CompareOne(1, 2))\n\tassert.Equal(2.5, CompareOne(1, 2.5))\n\tassert.Equal(3, CompareOne(2, 3))\n\tassert.Equal(6, CompareOne(5, 6))\n\tassert.Equal(\"2,3\", CompareOne(1, \"2,3\"))\n\tassert.Equal(\"6\", CompareOne(\"5,1\", \"6\"))\n\tassert.Equal(\"2\", CompareOne(\"1\", \"2\"))\n\tassert.Equal(nil, CompareOne(\"1\", 1))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCompareOne(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2.5, CompareOne(1, 2.5))\n\tassert.Equal(\"2,3\", CompareOne(1, \"2,3\"))\n\tassert.Equal(\"6\", CompareOne(\"5,1\", \"6\"))\n\tassert.Equal(nil, CompareOne(\"1\", 1))\n}\n"}
{"task_id": "Go/138", "prompt": "\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// IsEqualToSumEven(4) == false\n// IsEqualToSumEven(6) == false\n// IsEqualToSumEven(8) == true\nfunc IsEqualToSumEven(n int) bool {\n", "import": "", "docstring": "// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// IsEqualToSumEven(4) == false\n// IsEqualToSumEven(6) == false\n// IsEqualToSumEven(8) == true\n", "declaration": "\nfunc IsEqualToSumEven(n int) bool {\n", "canonical_solution": "\treturn n&1 == 0 && n >= 8\n}\n\n", "test": "func TestIsEqualToSumEven(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, IsEqualToSumEven(4))\n\tassert.Equal(false, IsEqualToSumEven(6))\n\tassert.Equal(true, IsEqualToSumEven(8))\n\tassert.Equal(true, IsEqualToSumEven(10))\n\tassert.Equal(false, IsEqualToSumEven(11))\n\tassert.Equal(true, IsEqualToSumEven(12))\n\tassert.Equal(false, IsEqualToSumEven(13))\n\tassert.Equal(true, IsEqualToSumEven(16))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIsEqualToSumEven(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, IsEqualToSumEven(4))\n\tassert.Equal(false, IsEqualToSumEven(6))\n\tassert.Equal(true, IsEqualToSumEven(8))\n}\n"}
{"task_id": "Go/139", "prompt": "\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// \n// For example:\n// >>> SpecialFactorial(4)\n// 288\n// \n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nfunc SpecialFactorial(n int) int {\n", "import": "", "docstring": "// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// \n// For example:\n// >>> SpecialFactorial(4)\n// 288\n// \n// The function will receive an integer as input and should return the special\n// factorial of this integer.\n", "declaration": "\nfunc SpecialFactorial(n int) int {\n", "canonical_solution": "\tfact_i := 1\n\tspecial_fact := 1\n\tfor i := 1; i <= n; i++ {\n\t\tfact_i *= i\n\t\tspecial_fact *= fact_i\n\t}\n\treturn special_fact\n}\n\n", "test": "func TestSpecialFactorial(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(288, SpecialFactorial(4))\n\tassert.Equal(34560, SpecialFactorial(5))\n\tassert.Equal(125411328000, SpecialFactorial(7))\n\tassert.Equal(1, SpecialFactorial(1))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSpecialFactorial(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(288, SpecialFactorial(4))\n}\n"}
{"task_id": "Go/140", "prompt": "\n// Given a string text, replace all spaces in it with underscores,\n// and if a string has more than 2 consecutive spaces,\n// then replace all consecutive spaces with -\n// \n// FixSpaces(\"Example\") == \"Example\"\n// FixSpaces(\"Example 1\") == \"Example_1\"\n// FixSpaces(\" Example 2\") == \"_Example_2\"\n// FixSpaces(\" Example   3\") == \"_Example-3\"\nfunc FixSpaces(text string) string {\n", "import": "", "docstring": "// Given a string text, replace all spaces in it with underscores,\n// and if a string has more than 2 consecutive spaces,\n// then replace all consecutive spaces with -\n// \n// FixSpaces(\"Example\") == \"Example\"\n// FixSpaces(\"Example 1\") == \"Example_1\"\n// FixSpaces(\" Example 2\") == \"_Example_2\"\n// FixSpaces(\" Example   3\") == \"_Example-3\"\n", "declaration": "\nfunc FixSpaces(text string) string {\n", "canonical_solution": "\tnew_text := make([]byte, 0)\n\ti := 0\n\tstart, end := 0, 0\n\tfor i < len(text) {\n\t\tif text[i] == ' ' {\n\t\t\tend++\n\t\t} else {\n\t\t\tswitch {\n\t\t\tcase end - start > 2:\n\t\t\t\tnew_text = append(new_text, '-')\n\t\t\tcase end - start > 0:\n\t\t\t\tfor n := 0;n < end-start;n++ {\n\t\t\t\t    new_text = append(new_text, '_')\n\t\t\t\t}\n\t\t\t}\n\t\t\tnew_text = append(new_text, text[i])\n\t\t\tstart, end = i+1, i+1\n\t\t}\n\t\ti+=1\n\t}\n\tif end - start > 2 {\n\t\tnew_text = append(new_text, '-')\n\t} else if end - start > 0 {\n\t\tnew_text = append(new_text, '_')\n\t}\n\treturn string(new_text)\n}\n\n", "test": "func TestFixSpaces(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Example\", FixSpaces(\"Example\"))\n\tassert.Equal(\"Mudasir_Hanif_\", FixSpaces(\"Mudasir Hanif \"))\n\tassert.Equal(\"Yellow_Yellow__Dirty__Fellow\", FixSpaces(\"Yellow Yellow  Dirty  Fellow\"))\n\tassert.Equal(\"Exa-mple\", FixSpaces(\"Exa   mple\"))\n\tassert.Equal(\"-Exa_1_2_2_mple\", FixSpaces(\"   Exa 1 2 2 mple\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFixSpaces(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Example\", FixSpaces(\"Example\"))\n\tassert.Equal(\"Example_1\", FixSpaces(\"Example 1\"))\n\tassert.Equal(\"_Example_2\", FixSpaces(\" Example 2\"))\n\tassert.Equal(\"_Example-3\", FixSpaces(\" Example   3\"))\n}\n"}
{"task_id": "Go/141", "prompt": "import (\n\t\"strings\"\n)\n\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions\n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from\n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// FileNameCheck(\"example.txt\") # => 'Yes'\n// FileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\nfunc FileNameCheck(file_name string) string {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions\n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from\n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// FileNameCheck(\"example.txt\") # => 'Yes'\n// FileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n", "declaration": "\nfunc FileNameCheck(file_name string) string {\n", "canonical_solution": "\tsuf := []string{\"txt\", \"exe\", \"dll\"}\n\tlst := strings.Split(file_name, \".\")\n\tisInArray := func (arr []string, x string) bool {\n\t\tfor _, y := range arr {\n\t\t\tif x == y {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tswitch {\n\tcase len(lst) != 2:\n\t\treturn \"No\"\n\tcase !isInArray(suf, lst[1]):\n\t\treturn \"No\"\n\tcase len(lst[0]) == 0:\n\t\treturn \"No\"\n\tcase 'a' > strings.ToLower(lst[0])[0] || strings.ToLower(lst[0])[0] > 'z':\n\t\treturn \"No\"\n\t}\n\tt := 0\n\tfor _, c := range lst[0] {\n\t\tif '0' <= c && c <= '9' {\n\t\t\tt++\n\t\t}\n\t}\n\tif t > 3 {\n\t\treturn \"No\"\n\t}\n\treturn \"Yes\"\n}\n\n", "test": "func TestFileNameCheck(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Yes\", FileNameCheck(\"example.txt\"))\n\tassert.Equal(\"No\", FileNameCheck(\"1example.dll\"))\n\tassert.Equal(\"No\", FileNameCheck(\"s1sdf3.asd\"))\n\tassert.Equal(\"Yes\", FileNameCheck(\"K.dll\"))\n\tassert.Equal(\"Yes\", FileNameCheck(\"MY16FILE3.exe\"))\n\tassert.Equal(\"No\", FileNameCheck(\"His12FILE94.exe\"))\n\tassert.Equal(\"No\", FileNameCheck(\"_Y.txt\"))\n\tassert.Equal(\"No\", FileNameCheck(\"?aREYA.exe\"))\n\tassert.Equal(\"No\", FileNameCheck(\"/this_is_valid.dll\"))\n\tassert.Equal(\"No\", FileNameCheck(\"this_is_valid.wow\"))\n\tassert.Equal(\"Yes\", FileNameCheck(\"this_is_valid.txt\"))\n\tassert.Equal(\"No\", FileNameCheck(\"this_is_valid.txtexe\"))\n\tassert.Equal(\"No\", FileNameCheck(\"#this2_i4s_5valid.ten\"))\n\tassert.Equal(\"No\", FileNameCheck(\"@this1_is6_valid.exe\"))\n\tassert.Equal(\"No\", FileNameCheck(\"this_is_12valid.6exe4.txt\"))\n\tassert.Equal(\"No\", FileNameCheck(\"all.exe.txt\"))\n\tassert.Equal(\"Yes\", FileNameCheck(\"I563_No.exe\"))\n\tassert.Equal(\"Yes\", FileNameCheck(\"Is3youfault.txt\"))\n\tassert.Equal(\"Yes\", FileNameCheck(\"no_one#knows.dll\"))\n\tassert.Equal(\"No\", FileNameCheck(\"1I563_Yes3.exe\"))\n\tassert.Equal(\"No\", FileNameCheck(\"I563_Yes3.txtt\"))\n\tassert.Equal(\"No\", FileNameCheck(\"final..txt\"))\n\tassert.Equal(\"No\", FileNameCheck(\"final132\"))\n\tassert.Equal(\"No\", FileNameCheck(\"_f4indsartal132.\"))\n\tassert.Equal(\"No\", FileNameCheck(\".txt\"))\n\tassert.Equal(\"No\", FileNameCheck(\"s.\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFileNameCheck(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Yes\", FileNameCheck(\"example.txt\"))\n\tassert.Equal(\"No\", FileNameCheck(\"1example.dll\"))\n}\n"}
{"task_id": "Go/142", "prompt": "import (\n\t\"math\"\n)\n\n// This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n// change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n// \n// Examples:\n// For lst = [1,2,3] the output should be 6\n// For lst = []  the output should be 0\n// For lst = [-1,-5,2,-1,-5]  the output should be -126\nfunc SumSquares(lst []int) int {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n// change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n// \n// Examples:\n// For lst = [1,2,3] the output should be 6\n// For lst = []  the output should be 0\n// For lst = [-1,-5,2,-1,-5]  the output should be -126\n", "declaration": "\nfunc SumSquares(lst []int) int {\n", "canonical_solution": "\tresult := make([]int, 0)\n\tfor i := 0;i < len(lst);i++ {\n\t\tswitch {\n\t\tcase i %3 == 0:\n\t\t\tresult = append(result, int(math.Pow(float64(lst[i]), 2)))\n\t\tcase i % 4 == 0 && i%3 != 0:\n\t\t\tresult = append(result, int(math.Pow(float64(lst[i]), 3)))\n\t\tdefault:\n\t\t\tresult = append(result, lst[i])\n\t\t}\n\t}\n\tsum := 0\n\tfor _, x := range result {\n\t\tsum += x\n\t}\n\treturn sum\n}\n\n", "test": "func TestSumSquares(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, SumSquares([]int{1,2,3}))\n\tassert.Equal(14, SumSquares([]int{1,4,9}))\n\tassert.Equal(0, SumSquares([]int{}))\n\tassert.Equal(9, SumSquares([]int{1,1,1,1,1,1,1,1,1}))\n\tassert.Equal(-3, SumSquares([]int{-1,-1,-1,-1,-1,-1,-1,-1,-1}))\n\tassert.Equal(0, SumSquares([]int{0}))\n\tassert.Equal(-126, SumSquares([]int{-1,-5,2,-1,-5}))\n\tassert.Equal(3030, SumSquares([]int{-56,-99,1,0,-2}))\n\tassert.Equal(0, SumSquares([]int{-1,0,0,0,0,0,0,0,-1}))\n\tassert.Equal(-14196, SumSquares([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}))\n\tassert.Equal(-1448, SumSquares([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSumSquares(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, SumSquares([]int{1,2,3}))\n\tassert.Equal(0, SumSquares([]int{}))\n\tassert.Equal(-126, SumSquares([]int{-1,-5,2,-1,-5}))\n}\n"}
{"task_id": "Go/143", "prompt": "import (\n\t\"strings\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// \n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// \n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// \n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc WordsInSentence(sentence string) string {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// \n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// \n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// \n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\n", "declaration": "\nfunc WordsInSentence(sentence string) string {\n", "canonical_solution": "\tnew_lst := make([]string, 0)\n\tfor _, word := range strings.Fields(sentence) {\n\t\tflg := 0\n\t\tif len(word) == 1 {\n\t\t\tflg = 1\n\t\t}\n\t\tfor i := 2;i < len(word);i++ {\n\t\t\tif len(word)%i == 0 {\n\t\t\t\tflg = 1\n\t\t\t}\n\t\t}\n\t\tif flg == 0 || len(word) == 2 {\n\t\t\tnew_lst = append(new_lst, word)\n\t\t}\n\t}\n\treturn strings.Join(new_lst, \" \")\n}\n\n", "test": "func TestWordsInSentence(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"is\", WordsInSentence(\"This is a test\"))\n\tassert.Equal(\"go for\", WordsInSentence(\"lets go for swimming\"))\n\tassert.Equal(\"there is no place\", WordsInSentence(\"there is no place available here\"))\n\tassert.Equal(\"Hi am Hussein\", WordsInSentence(\"Hi I am Hussein\"))\n\tassert.Equal(\"go for it\", WordsInSentence(\"go for it\"))\n\tassert.Equal(\"\", WordsInSentence(\"here\"))\n\tassert.Equal(\"is\", WordsInSentence(\"here is\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestWordsInSentence(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"is\", WordsInSentence(\"This is a test\"))\n\tassert.Equal(\"go for\", WordsInSentence(\"lets go for swimming\"))\n}\n"}
{"task_id": "Go/144", "prompt": "import (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Your task is to implement a function that will Simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// \n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// \n// Simplify(\"1/5\", \"5/1\") = true\n// Simplify(\"1/6\", \"2/1\") = false\n// Simplify(\"7/10\", \"10/2\") = false\nfunc Simplify(x, n string) bool {\n", "import": "import (\n\t\"strconv\"\n\t\"strings\"\n)\n", "docstring": "// Your task is to implement a function that will Simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// \n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// \n// Simplify(\"1/5\", \"5/1\") = true\n// Simplify(\"1/6\", \"2/1\") = false\n// Simplify(\"7/10\", \"10/2\") = false\n", "declaration": "\nfunc Simplify(x, n string) bool {\n", "canonical_solution": "\txx := strings.Split(x, \"/\")\n\tnn := strings.Split(n, \"/\")\n\ta, _ := strconv.Atoi(xx[0])\n\tb, _ := strconv.Atoi(xx[1])\n\tc, _ := strconv.Atoi(nn[0])\n\td, _ := strconv.Atoi(nn[1])\n\tnumerator := float64(a*c)\n\tdenom := float64(b*d)\n\treturn numerator/denom == float64(int(numerator/denom))\n}\n\n", "test": "func TestSimplify(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, Simplify(\"1/5\", \"5/1\"))\n\tassert.Equal(false, Simplify(\"1/6\", \"2/1\"))\n\tassert.Equal(true, Simplify(\"5/1\", \"3/1\"))\n\tassert.Equal(false, Simplify(\"7/10\", \"10/2\"))\n\tassert.Equal(true, Simplify(\"2/10\", \"50/10\"))\n\tassert.Equal(true, Simplify(\"7/2\", \"4/2\"))\n\tassert.Equal(true, Simplify(\"11/6\", \"6/1\"))\n\tassert.Equal(false, Simplify(\"2/3\", \"5/2\"))\n\tassert.Equal(false, Simplify(\"5/2\", \"3/5\"))\n\tassert.Equal(true, Simplify(\"2/4\", \"8/4\"))\n\tassert.Equal(true, Simplify(\"2/4\", \"4/2\"))\n\tassert.Equal(true, Simplify(\"1/5\", \"5/1\"))\n\tassert.Equal(false, Simplify(\"1/5\", \"1/5\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSimplify(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, Simplify(\"1/5\", \"5/1\"))\n\tassert.Equal(false, Simplify(\"1/6\", \"2/1\"))\n\tassert.Equal(false, Simplify(\"7/10\", \"10/2\"))\n}\n"}
{"task_id": "Go/145", "prompt": "import (\n\t\"sort\"\n\t\"strconv\"\n)\n\n// Write a function which sorts the given list of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original list.\n// \n// For example:\n// >>> OrderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n// >>> OrderByPoints([]) == []\nfunc OrderByPoints(nums []int) []int {\n", "import": "import (\n\t\"sort\"\n\t\"strconv\"\n)\n", "docstring": "// Write a function which sorts the given list of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original list.\n// \n// For example:\n// >>> OrderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n// >>> OrderByPoints([]) == []\n", "declaration": "\nfunc OrderByPoints(nums []int) []int {\n", "canonical_solution": "\tdigits_sum := func (n int) int {\n\t\tneg := 1\n\t\tif n < 0 {\n\t\t\tn, neg = -1 * n, -1 \n\t\t}\n\t\tsum := 0\n\t\tfor i, c := range strconv.Itoa(n) {\n\t\t\tif i == 0 {\n\t\t\t\tsum += int(c-'0')*neg\n\t\t\t} else {\n\t\t\t\tsum += int(c-'0')\n\t\t\t}\n\t\t}\n\t\treturn sum\n\t}\n\tsort.SliceStable(nums, func(i, j int) bool {\n\t\treturn digits_sum(nums[i]) < digits_sum(nums[j])\n\t})\n\treturn nums\n}\n\n", "test": "func TestOrderByPoints(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{-1, -11, 1, -12, 11}, OrderByPoints([]int{1, 11, -1, -11, -12}))\n\tassert.Equal([]int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}, OrderByPoints([]int{1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46}))\n\tassert.Equal([]int{}, OrderByPoints([]int{}))\n\tassert.Equal([]int{-3, -32, -98, -11, 1, 2, 43, 54}, OrderByPoints([]int{1, -11, -32, 43, 54, -98, 2, -3}))\n\tassert.Equal([]int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}, OrderByPoints([]int{1,2,3,4,5,6,7,8,9,10,11}))\n\tassert.Equal([]int{-76, -21, 0, 4, 23, 6, 6}, OrderByPoints([]int{0,6,6,-76,-21,23,4}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestOrderByPoints(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{-1, -11, 1, -12, 11}, OrderByPoints([]int{1, 11, -1, -11, -12}))\n\tassert.Equal([]int{}, OrderByPoints([]int{}))\n}\n"}
{"task_id": "Go/146", "prompt": "import (\n\t\"strconv\"\n)\n\n// Write a function that takes an array of numbers as input and returns\n// the number of elements in the array that are greater than 10 and both\n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// Specialfilter([15, -73, 14, -15]) => 1\n// Specialfilter([33, -2, -3, 45, 21, 109]) => 2\nfunc Specialfilter(nums []int) int {\n", "import": "import (\n\t\"strconv\"\n)\n", "docstring": "// Write a function that takes an array of numbers as input and returns\n// the number of elements in the array that are greater than 10 and both\n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// Specialfilter([15, -73, 14, -15]) => 1\n// Specialfilter([33, -2, -3, 45, 21, 109]) => 2\n", "declaration": "\nfunc Specialfilter(nums []int) int {\n", "canonical_solution": "\tcount := 0\n\tfor _, num := range nums {\n\t\tif num > 10 {\n\t\t\tnumber_as_string := strconv.Itoa(num)\n\t\t\tif number_as_string[0]&1==1 && number_as_string[len(number_as_string)-1]&1==1 {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}        \n\treturn count\n}\n\n", "test": "func TestSpecialFilter(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, Specialfilter([]int{5, -2, 1, -5}))\n\tassert.Equal(1, Specialfilter([]int{15, -73, 14, -15}))\n\tassert.Equal(2, Specialfilter([]int{33, -2, -3, 45, 21, 109}))\n\tassert.Equal(4, Specialfilter([]int{43, -12, 93, 125, 121, 109}))\n\tassert.Equal(3, Specialfilter([]int{71, -2, -33, 75, 21, 19}))\n\tassert.Equal(0, Specialfilter([]int{1}))\n\tassert.Equal(0, Specialfilter([]int{}))\n}               \n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSpecialFilter(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, Specialfilter([]int{15, -73, 14, -15}))\n\tassert.Equal(2, Specialfilter([]int{33, -2, -3, 45, 21, 109}))\n}               \n"}
{"task_id": "Go/147", "prompt": "\n// You are given a positive integer n. You have to create an integer array a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n// and a[i] + a[j] + a[k] is a multiple of 3.\n// \n// Example :\n// Input: n = 5\n// Output: 1\n// Explanation:\n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nfunc GetMaxTriples(n int) int {\n", "import": "", "docstring": "// You are given a positive integer n. You have to create an integer array a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n// and a[i] + a[j] + a[k] is a multiple of 3.\n// \n// Example :\n// Input: n = 5\n// Output: 1\n// Explanation:\n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\n", "declaration": "\nfunc GetMaxTriples(n int) int {\n", "canonical_solution": "\tA := make([]int, 0)\n\tfor i := 1;i <= n;i++ {\n\t\tA = append(A, i*i-i+1)\n\t}\n\tans := 0\n\tfor i := 0;i < n;i++ {\n\t\tfor j := i + 1;j < n;j++ {\n\t\t\tfor k := j + 1;k < n;k++ {\n\t\t\t\tif (A[i]+A[j]+A[k])%3 == 0 {\n\t\t\t\t    ans++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\n", "test": "func TestGetMaxTriples(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, GetMaxTriples(5))\n\tassert.Equal(4, GetMaxTriples(6))\n\tassert.Equal(36, GetMaxTriples(10))\n\tassert.Equal(53361, GetMaxTriples(100))\n} \n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGetMaxTriples(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, GetMaxTriples(5))\n} \n"}
{"task_id": "Go/148", "prompt": "\n// There are eight planets in our solar system: the closerst to the Sun\n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2.\n// The function should return a tuple containing all planets whose orbits are\n// located between the orbit of planet1 and the orbit of planet2, sorted by\n// the proximity to the sun.\n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names.\n// Examples\n// Bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// Bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n// Bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nfunc Bf(planet1, planet2 string) []string {\n", "import": "", "docstring": "// There are eight planets in our solar system: the closerst to the Sun\n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2.\n// The function should return a tuple containing all planets whose orbits are\n// located between the orbit of planet1 and the orbit of planet2, sorted by\n// the proximity to the sun.\n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names.\n// Examples\n// Bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// Bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n// Bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n", "declaration": "\nfunc Bf(planet1, planet2 string) []string {\n", "canonical_solution": "\tplanet_names := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tpos1 := -1\n\tpos2 := -1\n\tfor i, x := range planet_names {\n\t\tif planet1 == x {\n\t\t\tpos1 = i\n\t\t}\n\t\tif planet2 == x {\n\t\t\tpos2 = i\n\t\t}\n\t}\n\tif pos1 == -1 || pos2 == -1 || pos1 == pos2 {\n\t\treturn []string{}\n\t}\n\tif pos1 < pos2 {\n\t\treturn planet_names[pos1 + 1: pos2]\n\t}\n\treturn planet_names[pos2 + 1 : pos1]\n}\n\n", "test": "func TestBf(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"Saturn\", \"Uranus\"}, Bf(\"Jupiter\", \"Neptune\"))\n\tassert.Equal([]string{\"Venus\"}, Bf(\"Earth\", \"Mercury\"))\n\tassert.Equal([]string{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}, Bf(\"Mercury\", \"Uranus\"))\n\tassert.Equal([]string{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}, Bf(\"Neptune\", \"Venus\"))\n\tassert.Equal([]string{}, Bf(\"Earth\", \"Earth\"))\n\tassert.Equal([]string{}, Bf(\"Mars\", \"Earth\"))\n\tassert.Equal([]string{}, Bf(\"Jupiter\", \"Makemake\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestBf(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"Saturn\", \"Uranus\"}, Bf(\"Jupiter\", \"Neptune\"))\n\tassert.Equal([]string{\"Venus\"}, Bf(\"Earth\", \"Mercury\"))\n\tassert.Equal([]string{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}, Bf(\"Mercury\", \"Uranus\"))\n\tassert.Equal([]string{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}, Bf(\"Neptune\", \"Venus\"))\n\tassert.Equal([]string{}, Bf(\"Earth\", \"Earth\"))\n\tassert.Equal([]string{}, Bf(\"Mars\", \"Earth\"))\n\tassert.Equal([]string{}, Bf(\"Jupiter\", \"Makemake\"))\n}\n"}
{"task_id": "Go/149", "prompt": "import (\n\t\"sort\"\n)\n\n// Write a function that accepts a list of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted list with a sorted order,\n// The list is always a list of strings and never an array of numbers,\n// and it may contain duplicates.\n// The order of the list should be ascending by length of each word, and you\n// should return the list sorted by that rule.\n// If two words have the same length, sort the list alphabetically.\n// The function should return a list of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n// assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfunc SortedListSum(lst []string) []string {\n", "import": "import (\n\t\"sort\"\n)\n", "docstring": "// Write a function that accepts a list of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted list with a sorted order,\n// The list is always a list of strings and never an array of numbers,\n// and it may contain duplicates.\n// The order of the list should be ascending by length of each word, and you\n// should return the list sorted by that rule.\n// If two words have the same length, sort the list alphabetically.\n// The function should return a list of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n// assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n", "declaration": "\nfunc SortedListSum(lst []string) []string {\n", "canonical_solution": "\tsort.SliceStable(lst, func(i, j int) bool {\n\t\treturn lst[i] < lst[j]\n\t})\n\tnew_lst := make([]string, 0)\n\tfor _, i := range lst {\n\t\tif len(i)&1==0 {\n\t\t\tnew_lst = append(new_lst, i)\n\t\t}\n\t}\n\tsort.SliceStable(new_lst, func(i, j int) bool {\n\t\treturn len(new_lst[i]) < len(new_lst[j])\n\t})\n\treturn new_lst\n}\n\n", "test": "func TestSortedListSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"aa\"}, SortedListSum([]string{\"aa\", \"a\", \"aaa\"}))\n\tassert.Equal([]string{\"AI\", \"asdf\", \"school\"}, SortedListSum([]string{\"school\", \"AI\", \"asdf\", \"b\"}))\n\tassert.Equal([]string{}, SortedListSum([]string{\"d\", \"b\", \"c\", \"a\"}))\n\tassert.Equal([]string{\"abcd\", \"dcba\"}, SortedListSum([]string{\"d\", \"dcba\", \"abcd\", \"a\"}))\n\tassert.Equal([]string{\"AI\", \"ai\", \"au\"}, SortedListSum([]string{\"AI\", \"ai\", \"au\"}))\n\tassert.Equal([]string{}, SortedListSum([]string{\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}))\n\tassert.Equal([]string{\"cc\", \"dd\", \"aaaa\", \"bbbb\"}, SortedListSum([]string{\"aaaa\", \"bbbb\", \"dd\", \"cc\"}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSortedListSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]string{\"aa\"}, SortedListSum([]string{\"aa\", \"a\", \"aaa\"}))\n\tassert.Equal([]string{\"ab\", \"cd\"}, SortedListSum([]string{\"ab\", \"a\", \"aaa\", \"cd\"}))\n}\n"}
{"task_id": "Go/150", "prompt": "\n// A simple program which should return the value of x if n is\n// a prime number and should return the value of y otherwise.\n// \n// Examples:\n// for XOrY(7, 34, 12) == 34\n// for XOrY(15, 8, 5) == 5\nfunc XOrY(n, x, y int) int {\n", "import": "", "docstring": "// A simple program which should return the value of x if n is\n// a prime number and should return the value of y otherwise.\n// \n// Examples:\n// for XOrY(7, 34, 12) == 34\n// for XOrY(15, 8, 5) == 5\n", "declaration": "\nfunc XOrY(n, x, y int) int {\n", "canonical_solution": "\tif n == 1 {\n\t\treturn y\n\t}\n\tfor i := 2;i < n;i++ {\n\t\tif n % i == 0 {\n\t\t\treturn y\n\t\t}\n\t}\n\treturn x\n}\n\n", "test": "func TestXOrY(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(34, XOrY(7, 34, 12))\n\tassert.Equal(5, XOrY(15, 8, 5))\n\tassert.Equal(33, XOrY(3, 33, 5212))\n\tassert.Equal(3, XOrY(1259, 3, 52))\n\tassert.Equal(-1, XOrY(7919, -1, 12))\n\tassert.Equal(583, XOrY(3609, 1245, 583))\n\tassert.Equal(129, XOrY(91, 56, 129))\n\tassert.Equal(1234, XOrY(6, 34, 1234))\n\tassert.Equal(0, XOrY(1, 2, 0))\n\tassert.Equal(2, XOrY(2, 2, 0))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestXOrY(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(34, XOrY(7, 34, 12))\n\tassert.Equal(5, XOrY(15, 8, 5))\n}\n"}
{"task_id": "Go/151", "prompt": "import (\n\t\"math\"\n)\n\n// Given a list of numbers, return the sum of squares of the numbers\n// in the list that are odd. Ignore numbers that are negative or not integers.\n// \n// DoubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n// DoubleTheDifference([-1, -2, 0]) == 0\n// DoubleTheDifference([9, -2]) == 81\n// DoubleTheDifference([0]) == 0\n// \n// If the input list is empty, return 0.\nfunc DoubleTheDifference(lst []float64) int {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// Given a list of numbers, return the sum of squares of the numbers\n// in the list that are odd. Ignore numbers that are negative or not integers.\n// \n// DoubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n// DoubleTheDifference([-1, -2, 0]) == 0\n// DoubleTheDifference([9, -2]) == 81\n// DoubleTheDifference([0]) == 0\n// \n// If the input list is empty, return 0.\n", "declaration": "\nfunc DoubleTheDifference(lst []float64) int {\n", "canonical_solution": "\tsum := 0\n\tfor _, i := range lst {\n\t\tif i > 0 && math.Mod(i, 2) != 0 && i == float64(int(i)) {\n\t\t\tsum += int(math.Pow(i, 2))\n\t\t}\n\t}\n\treturn sum\n}\n\n", "test": "func TestDoubleTheDifference(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(0, DoubleTheDifference([]float64{}))\n\tassert.Equal(25, DoubleTheDifference([]float64{5, 4}))\n\tassert.Equal(0, DoubleTheDifference([]float64{0.1, 0.2, 0.3}))\n\tassert.Equal(0, DoubleTheDifference([]float64{-10, -20, -30}))\n\tassert.Equal(0, DoubleTheDifference([]float64{-1, -2, 8}))\n\tassert.Equal(34, DoubleTheDifference([]float64{0.2, 3, 5}))\n\tlst := make([]float64, 0)\n\todd_sum := 0\n\tvar i float64\n\tfor i = -99; i < 100; i+= 2 {\n\t\tlst = append(lst, float64(i))\n\t\tif math.Mod(i, 2) != 0 && i > 0 {\n\t\t\todd_sum +=int(math.Pow(i, 2))\n\t\t}\n\t}\n\tassert.Equal(odd_sum, DoubleTheDifference(lst))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestDoubleTheDifference(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(10, DoubleTheDifference([]float64{1,3,2,0}))\n\tassert.Equal(0, DoubleTheDifference([]float64{-1,-2,0}))\n\tassert.Equal(81, DoubleTheDifference([]float64{9,-2}))\n\tassert.Equal(0, DoubleTheDifference([]float64{0}))\n}\n"}
{"task_id": "Go/152", "prompt": "import (\n\t\"math\"\n)\n\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two arrays of scores and guesses of equal length, where each index shows a match.\n// Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// \n// \n// example:\n// \n// Compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n// Compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\nfunc Compare(game,guess []int) []int {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two arrays of scores and guesses of equal length, where each index shows a match.\n// Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// \n// \n// example:\n// \n// Compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n// Compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n", "declaration": "\nfunc Compare(game,guess []int) []int {\n", "canonical_solution": "\tans := make([]int, 0, len(game))\n\tfor i := range game {\n\t\tans = append(ans, int(math.Abs(float64(game[i]-guess[i]))))\n\t}\n\treturn ans\n}\n\n", "test": "func TestCompare(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{0,0,0,0,3,3}, Compare([]int{1,2,3,4,5,1}, []int{1,2,3,4,2,-2}))\n\tassert.Equal([]int{4,4,1,0,0,6}, Compare([]int{0,5,0,0,0,4}, []int{4,1,1,0,0,-2}))\n\tassert.Equal([]int{0,0,0,0,3,3}, Compare([]int{1,2,3,4,5,1}, []int{1,2,3,4,2,-2}))\n\tassert.Equal([]int{0,0,0,0,0,0}, Compare([]int{0,0,0,0,0,0}, []int{0,0,0,0,0,0}))\n\tassert.Equal([]int{2,4,6}, Compare([]int{1,2,3}, []int{-1,-2,-3}))\n\tassert.Equal([]int{2,0,0,1}, Compare([]int{1,2,3,5}, []int{-1,2,3,4}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCompare(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{0,0,0,0,3,3}, Compare([]int{1,2,3,4,5,1}, []int{1,2,3,4,2,-2}))\n\tassert.Equal([]int{4,4,1,0,0,6}, Compare([]int{0,5,0,0,0,4}, []int{4,1,1,0,0,-2}))\n}\n"}
{"task_id": "Go/153", "prompt": "import (\n\t\"math\"\n)\n\n// You will be given the name of a class (a string) and a list of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters\n// in the extension's name, the strength is given by the fraction CAP - SM.\n// You should find the strongest extension and return a string in this\n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the list.\n// For example, if you are given \"Slices\" as the class and a list of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n// (its strength is -1).\n// Example:\n// for StrongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc StrongestExtension(class_name string, extensions []string) string {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// You will be given the name of a class (a string) and a list of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters\n// in the extension's name, the strength is given by the fraction CAP - SM.\n// You should find the strongest extension and return a string in this\n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the list.\n// For example, if you are given \"Slices\" as the class and a list of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n// (its strength is -1).\n// Example:\n// for StrongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n", "declaration": "\nfunc StrongestExtension(class_name string, extensions []string) string {\n", "canonical_solution": "\tstrong := extensions[0]\n\t\n\tmy_val := math.MinInt\n\tfor _, s := range extensions {\n\t\tcnt0, cnt1 := 0, 0\n\t\tfor _, c := range s {\n\t\t\tswitch {\n\t\t\tcase 'A' <= c && c <= 'Z':\n\t\t\t\tcnt0++\n\t\t\tcase 'a' <= c && c <= 'z':\n\t\t\t\tcnt1++\n\t\t\t}\n\t\t}\n\t\tval := cnt0-cnt1\n\t\tif val > my_val {\n\t\t\tstrong = s\n\t\t\tmy_val = val\n\t\t}\n\t}\n\treturn class_name + \".\" + strong\n}\n\n", "test": "func TestStrongestExtension(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Watashi.eIGHt8OKe\", StrongestExtension(\"Watashi\", []string{\"tEN\", \"niNE\", \"eIGHt8OKe\"}))\n\tassert.Equal(\"Boku123.YEs.WeCaNe\", StrongestExtension(\"Boku123\", []string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))\n\tassert.Equal(\"__YESIMHERE.NuLl__\", StrongestExtension(\"__YESIMHERE\", []string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))\n\tassert.Equal(\"K.TAR\", StrongestExtension(\"K\", []string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))\n\tassert.Equal(\"__HAHA.123\", StrongestExtension(\"__HAHA\", []string{\"Tab\", \"123\", \"781345\", \"-_-\"}))\n\tassert.Equal(\"YameRore.okIWILL123\", StrongestExtension(\"YameRore\", []string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))\n\tassert.Equal(\"finNNalLLly.WoW\", StrongestExtension(\"finNNalLLly\", []string{\"Die\", \"NowW\", \"Wow\", \"WoW\"}))\n\tassert.Equal(\"_.Bb\", StrongestExtension(\"_\", []string{\"Bb\", \"91245\"}))\n\tassert.Equal(\"Sp.671235\", StrongestExtension(\"Sp\", []string{\"671235\", \"Bb\"}))\n}\n\t\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStrongestExtension(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"my_class.AA\", StrongestExtension(\"my_class\", []string{\"AA\", \"Be\", \"CC\"}))\n}\n"}
{"task_id": "Go/154", "prompt": "\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// CycpatternCheck(\"abcd\",\"abd\") => false\n// CycpatternCheck(\"hello\",\"ell\") => true\n// CycpatternCheck(\"whassup\",\"psus\") => false\n// CycpatternCheck(\"abab\",\"baa\") => true\n// CycpatternCheck(\"efef\",\"eeff\") => false\n// CycpatternCheck(\"himenss\",\"simen\") => true\nfunc CycpatternCheck(a , b string) bool {\n", "import": "", "docstring": "// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// CycpatternCheck(\"abcd\",\"abd\") => false\n// CycpatternCheck(\"hello\",\"ell\") => true\n// CycpatternCheck(\"whassup\",\"psus\") => false\n// CycpatternCheck(\"abab\",\"baa\") => true\n// CycpatternCheck(\"efef\",\"eeff\") => false\n// CycpatternCheck(\"himenss\",\"simen\") => true\n", "declaration": "\nfunc CycpatternCheck(a , b string) bool {\n", "canonical_solution": "\tl := len(b)\n\tpat := b + b\n\tfor i := 0;i < len(a) - l + 1; i++ {\n\t\tfor j := 0;j<l + 1;j++ {\n\t\t\tif a[i:i+l] == pat[j:j+l] {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n", "test": "func TestCycpatternCheck(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, CycpatternCheck(\"xyzw\", \"xyw\"))\n\tassert.Equal(true, CycpatternCheck(\"yello\", \"ell\"))\n\tassert.Equal(false, CycpatternCheck(\"whattup\", \"ptut\"))\n\tassert.Equal(true, CycpatternCheck(\"efef\", \"fee\"))\n\tassert.Equal(false, CycpatternCheck(\"abab\", \"aabb\"))\n\tassert.Equal(true, CycpatternCheck(\"winemtt\", \"tinem\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestCycpatternCheck(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(false, CycpatternCheck(\"abcd\", \"abd\"))\n\tassert.Equal(true, CycpatternCheck(\"hello\", \"ell\"))\n\tassert.Equal(false, CycpatternCheck(\"whasup\", \"psus\"))\n\tassert.Equal(true, CycpatternCheck(\"abab\", \"baa\"))\n\tassert.Equal(false, CycpatternCheck(\"efef\", \"eeff\"))\n\tassert.Equal(true, CycpatternCheck(\"himenss\", \"simen\"))\n}\n"}
{"task_id": "Go/155", "prompt": "import (\n\t\"strconv\"\n)\n\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// \n// Example:\n// EvenOddCount(-12) ==> (1, 1)\n// EvenOddCount(123) ==> (1, 2)\nfunc EvenOddCount(num int) [2]int {\n", "import": "import (\n\t\"strconv\"\n)\n", "docstring": "// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// \n// Example:\n// EvenOddCount(-12) ==> (1, 1)\n// EvenOddCount(123) ==> (1, 2)\n", "declaration": "\nfunc EvenOddCount(num int) [2]int {\n", "canonical_solution": "\teven_count := 0\n\todd_count := 0\n\tif num < 0 {\n\t\tnum = -num\n\t}\n\tfor _, r := range strconv.Itoa(num) {\n\t\tif r&1==0 {\n\t\t\teven_count++\n\t\t} else {\n\t\t\todd_count++\n\t\t}\n\t}\n\treturn [2]int{even_count, odd_count}\n}\n\n", "test": "func TestEvenOddCount(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]int{0, 1}, EvenOddCount(7))\n\tassert.Equal([2]int{1, 1}, EvenOddCount(-78))\n\tassert.Equal([2]int{2, 2}, EvenOddCount(3452))\n\tassert.Equal([2]int{3, 3}, EvenOddCount(346211))\n\tassert.Equal([2]int{3, 3}, EvenOddCount(-345821))\n\tassert.Equal([2]int{1, 0}, EvenOddCount(-2))\n\tassert.Equal([2]int{2, 3}, EvenOddCount(-45347))\n\tassert.Equal([2]int{1, 0}, EvenOddCount(0))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestEvenOddCount(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([2]int{1, 1}, EvenOddCount(-12))\n\tassert.Equal([2]int{1, 2}, EvenOddCount(123))\n}\n"}
{"task_id": "Go/156", "prompt": "import (\n\t\"strings\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// \n// Examples:\n// >>> IntToMiniRoman(19) == 'xix'\n// >>> IntToMiniRoman(152) == 'clii'\n// >>> IntToMiniRoman(426) == 'cdxxvi'\nfunc IntToMiniRoman(number int) string {\n", "import": "import (\n\t\"strings\"\n)\n", "docstring": "// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// \n// Examples:\n// >>> IntToMiniRoman(19) == 'xix'\n// >>> IntToMiniRoman(152) == 'clii'\n// >>> IntToMiniRoman(426) == 'cdxxvi'\n", "declaration": "\nfunc IntToMiniRoman(number int) string {\n", "canonical_solution": "\tnum := []int{1, 4, 5, 9, 10, 40, 50, 90,  \n\t\t   100, 400, 500, 900, 1000}\n\tsym := []string{\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n\t\t   \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}\n\ti := 12\n\tres := \"\"\n\tfor number != 0 {\n\t\tdiv := number / num[i] \n\t\tnumber %= num[i] \n\t\tfor div != 0 {\n\t\t\tres += sym[i] \n\t\t\tdiv--\n\t\t}\n\t\ti--\n\t}\n\treturn strings.ToLower(res)\n}\n\n", "test": "func TestIntToMiniRoman(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"xix\", IntToMiniRoman(19))\n\tassert.Equal(\"clii\", IntToMiniRoman(152))\n\tassert.Equal(\"ccli\", IntToMiniRoman(251))\n\tassert.Equal(\"cdxxvi\", IntToMiniRoman(426))\n\tassert.Equal(\"d\", IntToMiniRoman(500))\n\tassert.Equal(\"i\", IntToMiniRoman(1))\n\tassert.Equal(\"iv\", IntToMiniRoman(4))\n\tassert.Equal(\"xliii\", IntToMiniRoman(43))\n\tassert.Equal(\"xc\", IntToMiniRoman(90))\n\tassert.Equal(\"xciv\", IntToMiniRoman(94))\n\tassert.Equal(\"dxxxii\", IntToMiniRoman(532))\n\tassert.Equal(\"cm\", IntToMiniRoman(900))\n\tassert.Equal(\"cmxciv\", IntToMiniRoman(994))\n\tassert.Equal(\"m\", IntToMiniRoman(1000))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIntToMiniRoman(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"xix\", IntToMiniRoman(19))\n\tassert.Equal(\"clii\", IntToMiniRoman(152))\n\tassert.Equal(\"cdxxvi\", IntToMiniRoman(426))\n}\n"}
{"task_id": "Go/157", "prompt": "\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or\n// 90 degree.\n// Example:\n// RightAngleTriangle(3, 4, 5) == true\n// RightAngleTriangle(1, 2, 3) == false\nfunc RightAngleTriangle(a, b, c int) bool {\n", "import": "", "docstring": "// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or\n// 90 degree.\n// Example:\n// RightAngleTriangle(3, 4, 5) == true\n// RightAngleTriangle(1, 2, 3) == false\n", "declaration": "\nfunc RightAngleTriangle(a, b, c int) bool {\n", "canonical_solution": "\treturn a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b\n}\n\n", "test": "func TestRightAngleTriangle(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, RightAngleTriangle(3, 4, 5))\n\tassert.Equal(false, RightAngleTriangle(1, 2, 3))\n\tassert.Equal(true, RightAngleTriangle(10, 6, 8))\n\tassert.Equal(false, RightAngleTriangle(2, 2, 2))\n\tassert.Equal(true, RightAngleTriangle(7, 24, 25))\n\tassert.Equal(false, RightAngleTriangle(10, 5, 7))\n\tassert.Equal(true, RightAngleTriangle(5, 12, 13))\n\tassert.Equal(true, RightAngleTriangle(15, 8, 17))\n\tassert.Equal(true, RightAngleTriangle(48, 55, 73))\n\tassert.Equal(false, RightAngleTriangle(1, 1, 1))\n\tassert.Equal(false, RightAngleTriangle(2, 2, 10))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRightAngleTriangle(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, RightAngleTriangle(3, 4, 5))\n\tassert.Equal(false, RightAngleTriangle(1, 2, 3))\n}\n"}
{"task_id": "Go/158", "prompt": "import (\n\t\"sort\"\n)\n\n// Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// \n// FindMax([\"name\", \"of\", \"string\"]) == \"string\"\n// FindMax([\"name\", \"enam\", \"game\"]) == \"enam\"\n// FindMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nfunc FindMax(words []string) string {\n", "import": "import (\n\t\"sort\"\n)\n", "docstring": "// Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// \n// FindMax([\"name\", \"of\", \"string\"]) == \"string\"\n// FindMax([\"name\", \"enam\", \"game\"]) == \"enam\"\n// FindMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n", "declaration": "\nfunc FindMax(words []string) string {\n", "canonical_solution": "\tkey := func (word string) (int, string) {\n\t\tset := make(map[rune]struct{})\n\t\tfor _, r := range word {\n\t\t\tset[r] = struct{}{}\n\t\t}\n\t\treturn -len(set), word\n\t}\n\tsort.SliceStable(words, func(i, j int) bool {\n\t\tia, ib := key(words[i])\n\t\tja, jb := key(words[j])\n\t\tif ia == ja {\n\t\t\treturn ib < jb\n\t\t}\n\t\treturn ia < ja\n\t})\n\treturn words[0]\n}\n\n", "test": "func TestFindMax(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"string\", FindMax([]string{\"name\", \"of\", \"string\"}))\n\tassert.Equal(\"enam\", FindMax([]string{\"name\", \"enam\", \"game\"}))\n\tassert.Equal(\"aaaaaaa\", FindMax([]string{\"aaaaaaa\", \"bb\", \"cc\"}))\n\tassert.Equal(\"abc\", FindMax([]string{\"abc\", \"cba\"}))\n\tassert.Equal(\"footbott\", FindMax([]string{\"play\", \"this\", \"game\", \"of\", \"footbott\"}))\n\tassert.Equal(\"gonna\", FindMax([]string{\"we\", \"are\", \"gonna\", \"rock\"}))\n\tassert.Equal(\"nation\", FindMax([]string{\"we\", \"are\", \"a\", \"mad\", \"nation\"}))\n\tassert.Equal(\"this\", FindMax([]string{\"this\", \"is\", \"a\", \"prrk\"}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFindMax(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"string\", FindMax([]string{\"name\", \"of\", \"string\"}))\n\tassert.Equal(\"enam\", FindMax([]string{\"name\", \"enam\", \"game\"}))\n\tassert.Equal(\"aaaaaaa\", FindMax([]string{\"aaaaaaa\", \"bb\", \"cc\"}))\n}\n"}
{"task_id": "Go/159", "prompt": "\n// You're a hungry rabbit, and you already have Eaten a certain number of carrots,\n// but now you need to Eat more carrots to complete the day's meals.\n// you should return an array of [ total number of Eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will Eat all remaining carrots, but will still be hungry.\n// \n// Example:\n// * Eat(5, 6, 10) -> [11, 4]\n// * Eat(4, 8, 9) -> [12, 1]\n// * Eat(1, 10, 10) -> [11, 0]\n// * Eat(2, 11, 5) -> [7, 0]\n// \n// Variables:\n// @number : integer\n// the number of carrots that you have Eaten.\n// @need : integer\n// the number of carrots that you need to Eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// \n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// \n// Have fun :)\nfunc Eat(number, need, remaining int) []int {\n", "import": "", "docstring": "// You're a hungry rabbit, and you already have Eaten a certain number of carrots,\n// but now you need to Eat more carrots to complete the day's meals.\n// you should return an array of [ total number of Eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will Eat all remaining carrots, but will still be hungry.\n// \n// Example:\n// * Eat(5, 6, 10) -> [11, 4]\n// * Eat(4, 8, 9) -> [12, 1]\n// * Eat(1, 10, 10) -> [11, 0]\n// * Eat(2, 11, 5) -> [7, 0]\n// \n// Variables:\n// @number : integer\n// the number of carrots that you have Eaten.\n// @need : integer\n// the number of carrots that you need to Eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// \n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// \n// Have fun :)\n", "declaration": "\nfunc Eat(number, need, remaining int) []int {\n", "canonical_solution": "\tif(need <= remaining) {\n\t\treturn []int{ number + need , remaining-need }\n\t}\n\treturn []int{ number + remaining , 0}\n}\n\n", "test": "func TestEat(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{11, 4}, Eat(5, 6, 10))\n\tassert.Equal([]int{12, 1}, Eat(4, 8, 9))\n\tassert.Equal([]int{11, 0}, Eat(1, 10, 10))\n\tassert.Equal([]int{7, 0}, Eat(2, 11, 5))\n\tassert.Equal([]int{9, 2}, Eat(4, 5, 7))\n\tassert.Equal([]int{5, 0}, Eat(4, 5, 1))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestEat(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{11, 4}, Eat(5, 6, 10))\n\tassert.Equal([]int{12, 1}, Eat(4, 8, 9))\n\tassert.Equal([]int{11, 0}, Eat(1, 10, 10))\n\tassert.Equal([]int{7, 0}, Eat(2, 11, 5))\n}\n"}
{"task_id": "Go/160", "prompt": "import (\n\t\"math\"\n)\n\n// Given two lists operator, and operand. The first list has basic algebra operations, and\n// the second list is a list of integers. Use the two given lists to build the algebric\n// expression and return the evaluation of this expression.\n// \n// The basic algebra operations:\n// Addition ( + )\n// Subtraction ( - )\n// Multiplication ( * )\n// Floor division ( // )\n// Exponentiation ( ** )\n// \n// Example:\n// operator['+', '*', '-']\n// array = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// \n// Note:\n// The length of operator list is equal to the length of operand list minus one.\n// Operand is a list of of non-negative integers.\n// Operator list has at least one operator, and operand list has at least two operands.\nfunc DoAlgebra(operator []string, operand []int) int {\n", "import": "import (\n\t\"math\"\n)\n", "docstring": "// Given two lists operator, and operand. The first list has basic algebra operations, and\n// the second list is a list of integers. Use the two given lists to build the algebric\n// expression and return the evaluation of this expression.\n// \n// The basic algebra operations:\n// Addition ( + )\n// Subtraction ( - )\n// Multiplication ( * )\n// Floor division ( // )\n// Exponentiation ( ** )\n// \n// Example:\n// operator['+', '*', '-']\n// array = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// \n// Note:\n// The length of operator list is equal to the length of operand list minus one.\n// Operand is a list of of non-negative integers.\n// Operator list has at least one operator, and operand list has at least two operands.\n", "declaration": "\nfunc DoAlgebra(operator []string, operand []int) int {\n", "canonical_solution": "\thigher := func(a, b string) bool {\n\t\tif b == \"*\" || b == \"//\" || b == \"**\" {\n\t\t\treturn false\n\t\t}\n\t\tif a == \"*\" || a == \"//\" || a == \"**\" {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfor len(operand) > 1 {\n\t\tpos := 0\n\t\tsign := operator[0]\n\t\tfor i, str := range operator {\n\t\t\tif higher(str, sign) {\n\t\t\t\tsign = str\n\t\t\t\tpos = i\n\t\t\t}\n\t\t}\n\t\tswitch sign {\n\t\tcase \"+\":\n\t\t\toperand[pos] += operand[pos+1]\n\t\tcase \"-\":\n\t\t\toperand[pos] -= operand[pos+1]\n\t\tcase \"*\":\n\t\t\toperand[pos] *= operand[pos+1]\n\t\tcase \"//\":\n\t\t\toperand[pos] /= operand[pos+1]\n\t\tcase \"**\":\n\t\t\toperand[pos] = int(math.Pow(float64(operand[pos]), float64(operand[pos+1])))\n\t\t}\n\t\toperator = append(operator[:pos], operator[pos+1:]...)\n\t\toperand = append(operand[:pos+1], operand[pos+2:]...)\n\t}\n\treturn operand [0]\n}\n\n", "test": "func TestDoAlgebra(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(37, DoAlgebra([]string{\"**\", \"*\", \"+\"}, []int{2, 3, 4, 5}))\n\tassert.Equal(9, DoAlgebra([]string{\"+\", \"*\", \"-\"}, []int{2, 3, 4, 5}))\n\tassert.Equal(8, DoAlgebra([]string{\"//\", \"*\"}, []int{7, 3, 4}))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": ""}
{"task_id": "Go/161", "prompt": "\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa,\n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// Solve(\"1234\") = \"4321\"\n// Solve(\"ab\") = \"AB\"\n// Solve(\"#a@C\") = \"#A@c\"\nfunc Solve(s string) string {\n", "import": "", "docstring": "// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa,\n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// Solve(\"1234\") = \"4321\"\n// Solve(\"ab\") = \"AB\"\n// Solve(\"#a@C\") = \"#A@c\"\n", "declaration": "\nfunc Solve(s string) string {\n", "canonical_solution": "\tflg := 0\n\tnew_str := []rune(s)\n\tfor i, r := range new_str {\n\t\tif ('a' <= r && r <= 'z') || ('A' <= r && r <= 'Z') {\n\t\t\tif 'a' <= r && r <= 'z' {\n\t\t\t\tnew_str[i] = r - 'a' + 'A'\n\t\t\t} else {\n\t\t\t\tnew_str[i] = r - 'A' + 'a'\n\t\t\t}\n\t\t\tflg = 1\n\t\t}\n\t}\n\tif flg == 0 {\n\t\tfor i := 0;i < len(new_str)>>1;i++ {\n\t\t\tnew_str[i], new_str[len(new_str)-i-1] = new_str[len(new_str)-i-1], new_str[i]\n\t\t}\n\t}\n\treturn string(new_str)\n}\n\n", "test": "func TestSolve(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"aSdF\", Solve(\"AsDf\"))\n\tassert.Equal(\"4321\", Solve(\"1234\"))\n\tassert.Equal(\"AB\", Solve(\"ab\"))\n\tassert.Equal(\"#A@c\", Solve(\"#a@C\"))\n\tassert.Equal(\"#aSDFw^45\", Solve(\"#AsdfW^45\"))\n\tassert.Equal(\"2@6#\", Solve(\"#6@2\"))\n\tassert.Equal(\"#$A^d\", Solve(\"#$a^D\"))\n\tassert.Equal(\"#CCC\", Solve(\"#ccc\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSolve(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"4321\", Solve(\"1234\"))\n\tassert.Equal(\"AB\", Solve(\"ab\"))\n\tassert.Equal(\"#A@c\", Solve(\"#a@C\"))\n}\n"}
{"task_id": "Go/162", "prompt": "import (\n\t\"crypto/md5\"\n\t\"fmt\"\n)\n\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return nil.\n// \n// >>> StringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\nfunc StringToMd5(text string) interface{} {\n", "import": "import (\n\t\"crypto/md5\"\n\t\"fmt\"\n)\n", "docstring": "// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return nil.\n// \n// >>> StringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n", "declaration": "\nfunc StringToMd5(text string) interface{} {\n", "canonical_solution": "\tif text == \"\" {\n\t\treturn nil\n\t}\n\treturn fmt.Sprintf(\"%x\", md5.Sum([]byte(text)))\n}\n\n", "test": "func TestStringToMd5(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"3e25960a79dbc69b674cd4ec67a72c62\", StringToMd5(\"Hello world\"))\n\tassert.Equal(nil, StringToMd5(\"\"))\n\tassert.Equal(\"0ef78513b0cb8cef12743f5aeb35f888\", StringToMd5(\"A B C\"))\n\tassert.Equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", StringToMd5(\"password\"))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"crypto/md5\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestStringToMd5(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"3e25960a79dbc69b674cd4ec67a72c62\", StringToMd5(\"Hello world\"))\n}\n"}
{"task_id": "Go/163", "prompt": "\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// \n// For example:\n// GenerateIntegers(2, 8) => [2, 4, 6, 8]\n// GenerateIntegers(8, 2) => [2, 4, 6, 8]\n// GenerateIntegers(10, 14) => []\nfunc GenerateIntegers(a, b int) []int {\n", "import": "", "docstring": "// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// \n// For example:\n// GenerateIntegers(2, 8) => [2, 4, 6, 8]\n// GenerateIntegers(8, 2) => [2, 4, 6, 8]\n// GenerateIntegers(10, 14) => []\n", "declaration": "\nfunc GenerateIntegers(a, b int) []int {\n", "canonical_solution": "\tmin := func (a, b int) int {\n\t\tif a > b {\n\t\t\treturn b\n\t\t}\n\t\treturn a\n\t}\n\tmax := func (a, b int) int {\n\t\tif a > b {\n\t\t\treturn a\n\t\t}\n\t\treturn b\n\t}\n\tlower := max(2, min(a, b))\n\tupper := min(8, max(a, b))\n\tans := make([]int, 0)\n\tfor i := lower;i <= upper;i++ {\n\t\tif i&1==0 {\n\t\t\tans = append(ans, i)\n\t\t}\n\t}\n\treturn ans\n}\n\n", "test": "func TestGenerateIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 4, 6, 8}, GenerateIntegers(2, 10))\n\tassert.Equal([]int{2, 4, 6, 8}, GenerateIntegers(10, 2))\n\tassert.Equal([]int{2, 4, 6, 8}, GenerateIntegers(132, 2))\n\tassert.Equal([]int{}, GenerateIntegers(17, 89))\n}\n", "test_setup": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestGenerateIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal([]int{2, 4, 6, 8}, GenerateIntegers(2, 8))\n\tassert.Equal([]int{2, 4, 6, 8}, GenerateIntegers(8, 2))\n\tassert.Equal([]int{}, GenerateIntegers(10, 14))\n}\n"}
