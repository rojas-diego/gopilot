{"sample": "package main\n\nimport \"fmt\"\n\n// PrintPrimeNumbers prints prime numbers up to a given limit.\nfunc PrintPrimeNumbers(limit int) {\n\tfor num := 2; num <= limit; num++ {\n\t\tisPrime := true\n\t\tfor i := 2; i < num; i++ {\n\t\t\tif num%i == 0 {\n\t\t\t\tisPrime = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif isPrime {\n\t\t\tfmt.Println(num)\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"cloud.google.com/go/bigtable\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\tprojectID := \"my-project\"\n\tinstanceID := \"my-instance\"\n\ttableID := \"my-table\"\n\n\tclient, err := bigtable.NewClient(ctx, projectID, instanceID)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\tdefer client.Close()\n\n\ttable := client.Open(tableID)\n\n\tmut := bigtable.NewMutation()\n\tmut.Set(\"cf\", \"field1\", bigtable.Now(), []byte(\"value1\"))\n\tif err := table.Apply(ctx, \"row1\", mut); err != nil {\n\t\tlog.Fatalf(\"Failed to apply mutation: %v\", err)\n\t}\n\n\trow, err := table.ReadRow(ctx, \"row1\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read row: %v\", err)\n\t}\n\n\tfor col, val := range row {\n\t\tfmt.Printf(\"Column Family: %s\\tColumn Qualifier: %s\\tValue: %s\\n\", col.Family(), col.Qualifier(), val.Value)\n\t}\n\n\terr = bigtable.ExportTill(ctx, table, time.Now())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to export till: %v\", err)\n\t}\n\n\tlog.Println(\"Export complete\")\n}"}
{"sample": "package captchagen\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/png\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/dchest/captcha\"\n)\n\nfunc GenerateCaptcha(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"image/png\")\n\n\tvar buf bytes.Buffer\n\timg := captcha.NewImage(\"\", captcha.StdWidth, captcha.StdHeight)\n\tif err := png.Encode(&buf, img); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tid := captcha.New()\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\tcaptcha.SetCustomRescaler(func(width, height int) (int, int) {\n\t\treturn captcha.StdWidth, captcha.StdHeight\n\t})\n\tcaptcha.SetCustomFilter(func(r rune) bool {\n\t\treturn r >= 'a' && r <= 'z'\n\t})\n\tcaptcha.SetCustomFonts([]string{\"comic.ttf\", \"arial.ttf\"})\n\tcaptcha.SetCustomWidth(200)\n\tcaptcha.SetCustomHeight(100)\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif _, err := io.Copy(w, &buf); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n}\n\nfunc ValidateCaptcha(w http.ResponseWriter, r *http.Request) {\n\tid := r.FormValue(\"id\")\n\tdigits := r.FormValue(\"digits\")\n\n\tif captcha.VerifyString(id, digits) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"Captcha verified successfully\"))\n\t} else {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write([]byte(\"Invalid captcha\"))\n\t}\n}\n\nfunc GenerateBase64Captcha() (string, string, error) {\n\timg := captcha.NewImage(\"\", captcha.StdWidth, captcha.StdHeight)\n\tvar buf bytes.Buffer\n\tif err := png.Encode(&buf, img); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tid := captcha.New()\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\tcaptcha.SetCustomRescaler(func(width, height int) (int, int) {\n\t\treturn captcha.StdWidth, captcha.StdHeight\n\t})\n\tcaptcha.SetCustomFilter(func(r rune) bool {\n\t\treturn r >= 'a' && r <= 'z'\n\t})\n\tcaptcha.SetCustomFonts([]string{\"comic.ttf\", \"arial.ttf\"})\n\tcaptcha.SetCustomWidth(200)\n\tcaptcha.SetCustomHeight(100)\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tb64 := base64.StdEncoding.EncodeToString(buf.Bytes())\n\treturn id, b64, nil\n}\n\nfunc ValidateBase64Captcha(id, digits string) bool {\n\treturn captcha.VerifyString(id, digits)\n}\n\nfunc GenerateRandomString(length int) string {\n\tconst letters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-\"\n\tbytes := make([]byte, length)\n\tif _, err := rand.Read(bytes); err != nil {\n\t\treturn \"\"\n\t}\n\tfor i, b := range bytes {\n\t\tbytes[i] = letters[b%byte(len(letters))]\n\t}\n\treturn string(bytes)\n}\n\nfunc GenerateCaptchaURL() string {\n\treturn \"/captcha?r=\" + strconv.FormatInt(time.Now().UnixNano(), 10)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintSumOfDigits(12345)\n}\n\n// Function to print the sum of digits in a number\nfunc PrintSumOfDigits(n int) {\n\tsum := 0\n\tfor n != 0 {\n\t\tsum += n % 10\n\t\tn /= 10\n\t}\n\tfmt.Println(sum)\n}"}
{"sample": "func ExtractHeaders(r *http.Request) map[string]string {\n\theaders := make(map[string]string)\n\tfor name, values := range r.Header {\n\t\tfor _, value := range values {\n\t\t\theaders[name] = value\n\t\t}\n\t}\n\treturn headers\n}\n\nfunc AddHeaders(w http.ResponseWriter, headers map[string]string) {\n\tfor name, value := range headers {\n\t\tw.Header().Set(name, value)\n\t}\n}"}
{"sample": "package main\n\nfunc main() {\n\tfmt.Println(IsEven(4))\n}\n\nfunc IsEven(n int) bool {\n\treturn n%2 == 0\n}"}
{"sample": "package telnetclient\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc TelnetClient() {\n\tconn, err := net.Dial(\"tcp\", \"localhost:23\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"Enter text: \")\n\t\tscanner.Scan()\n\t\ttext := scanner.Text()\n\n\t\tif text == \"quit\" {\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Fprintf(conn, text+\"\\n\")\n\n\t\tmessage, err := bufio.NewReader(conn).ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Print(\"Message from server: \" + message)\n\t}\n}"}
{"sample": "func prepareStatement(tx *sql.Tx, query string) (*sql.Stmt, error) {\n\tstmt, err := tx.Prepare(query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn stmt, nil\n}\n"}
{"sample": "package main\n\nimport \"path/filepath\"\n\nfunc main() {\n\tfiles, _ := filepath.Glob(\"*.txt\")\n\tfmt.Println(files)\n}"}
{"sample": "func main() {\n\tresp, err := http.Get(\"https://api.example.com/data\")\n\tif err != nil {\n\t\tfmt.Println(\"Error making HTTP request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "package grpc\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"github.com/mycompany/myproject/protos\"\n)\n\ntype server struct{}\n\nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &pb.HelloResponse{Message: fmt.Sprintf(\"Hello %s!\", in.GetName())}, nil\n}\n\nfunc StartServer() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\tlog.Println(\"Starting gRPC server on port 50051...\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}\n\nfunc SayHello() {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewGreeterClient(conn)\n\tname := \"John\"\n\tr, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"Greeting: %s\", r.GetMessage())\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintTable prints the multiplication table of a given number up to a specified limit.\nfunc PrintTable(num, limit int) {\n\tfor i := 1; i <= limit; i++ {\n\t\tresult := num * i\n\t\tfmt.Printf(\"%d x %d = %d\\n\", num, i, result)\n\t}\n}"}
{"sample": "func CreateBucket(svc *s3.S3, bucketName string) error {\n\t_, err := svc.CreateBucket(&s3.CreateBucketInput{\n\t\tBucket: aws.String(bucketName),\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc ListBuckets(svc *s3.S3) ([]*s3.Bucket, error) {\n\tresult, err := svc.ListBuckets(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result.Buckets, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// CapitalizeString capitalizes the first letter of a given string.\nfunc CapitalizeString(str string) string {\n\treturn strings.Title(str)\n}"}
{"sample": "type Queue struct {\n\titems []int\n}\n\nfunc (q *Queue) Enqueue(item int) {\n\tq.items = append(q.items, item)\n}\n\nfunc (q *Queue) Dequeue() int {\n\tremoved := q.items[0]\n\tq.items = q.items[1:]\n\treturn removed\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype KeyValue struct {\n\tKey   string\n\tValue int\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfrequency := make(map[string]int)\n\n\tfmt.Println(\"Enter text, followed by an empty line:\")\n\n\t// Loop over lines of text\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\n\t\t// End loop if user enters an empty line\n\t\tif len(strings.TrimSpace(line)) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Split line by spaces into words\n\t\twords := strings.Split(line, \" \")\n\n\t\t// Loop over words and update frequency count\n\t\tfor _, word := range words {\n\t\t\tif len(word) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfrequency[strings.ToLower(word)]++\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"reading standard input:\", err)\n\t\treturn\n\t}\n\n\t// Convert frequency map into a slice to allow sorting\n\tvar kvPairs []KeyValue\n\tfor k, v := range frequency {\n\t\tkvPairs = append(kvPairs, KeyValue{k, v})\n\t}\n\n\t// Sort the slice\n\tsort.Slice(kvPairs, func(i, j int) bool {\n\t\treturn kvPairs[i].Value > kvPairs[j].Value\n\t})\n\n\t// Print the results\n\tfmt.Println(\"Word Frequency Count:\")\n\tfor _, kv := range kvPairs {\n\t\tfmt.Printf(\"%s: %d\\n\", kv.Key, kv.Value)\n\t}\n}"}
{"sample": "// Check if a number is positive\nfunc IsPositive(num int) bool {\n\treturn num > 0\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\te.GET(\"/users\", func(c echo.Context) error {\n\t\treturn c.JSON(http.StatusOK, []string{\"Alice\", \"Bob\", \"Charlie\"})\n\t})\n\n\te.POST(\"/users\", func(c echo.Context) error {\n\t\tuser := new(User)\n\t\tif err := c.Bind(user); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.JSON(http.StatusCreated, user)\n\t})\n\n\te.Start(\":8080\")\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype Order struct {\n\tID    string `json:\"id,omitempty\"`\n\tTotal float64 `json:\"total,omitempty\"`\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/orders\", GetOrders).Methods(\"GET\")\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc GetOrders(w http.ResponseWriter, r *http.Request) {\n\torders := []Order{{ID: \"1\", Total: 59.99}}\n\tjson.NewEncoder(w).Encode(orders)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(AddTwoNumbers(2, 3))\n}\n\n// Function to add two numbers\nfunc AddTwoNumbers(a, b int) int {\n\treturn a + b\n}"}
{"sample": "func commitTransaction(tx *sql.Tx) error {\n\terr := tx.Commit()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "// ReturnErrorOrResult returns an error if exists, else returns a result\nfunc ReturnErrorOrResult(err error, result string) (string, error) {\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn result, nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/nbari/violetear\"\n)\n\nfunc UseVioletear() {\n\trouter := violetear.New()\n\n\trouter.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, Violetear!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", router)\n}\n"}
{"sample": "package main\n\nfunc RemoveDuplicates(arr []int) []int {\n\tresult := []int{}\n\tvisited := map[int]bool{}\n\tfor _, num := range arr {\n\t\tif !visited[num] {\n\t\t\tvisited[num] = true\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n"}  
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype customError struct {\n\treason string\n}\n\nfunc (e *customError) Error() string {\n\treturn fmt.Sprintf(\"Error: %v\", e.reason)\n}\n\nfunc main() {\n\targs := os.Args[1:]\n\n\tif len(args) == 0 {\n\t\tce := &customError{\"no arguments provided\"}\n\t\tfmt.Println(ce)\n\t\tos.Exit(1)\n\t}\n\n\tjoinedArgs := strings.Join(args, \" \")\n\tfmt.Printf(\"Arguments: %v\\n\", joinedArgs)\n}"}
{"sample": "file, err := os.Open(\"file.gz\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\ngzReader, err := gzip.NewReader(file)\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer gzReader.Close()\ncontent, err := ioutil.ReadAll(gzReader)\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Println(string(content))\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"encoding/json\"\n\t\"os\"\n)\n\n// Configuration represents the application configuration\n\ntype Configuration struct {\n\tName   string `json:\"name\"`\n\tServer string `json:\"server\"`\n}\n\nfunc main() {\n\tconfig := Configuration{}\n\n\tfile, err := os.Open(\"config.json\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening config file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tdecoder := json.NewDecoder(file)\n\terr = decoder.Decode(&config)\n\tif err != nil {\n\t\tfmt.Println(\"Error decoding JSON:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Config:\", config)\n}"}
{"sample": "package value\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype compareIntFunc func(a, b int64) bool\n\n// IntSlice holds a slice of int64 values\ntype IntSlice struct {\n\tvalsPtr *[]int64\n}\n\n// NewIntSlice makes a new IntSlice with the given int64 values.\nfunc NewIntSlice(vals ...int64) *IntSlice {\n\tslice := make([]int64, len(vals))\n\n\tcopy(slice, vals)\n\n\treturn &IntSlice{valsPtr: &slice}\n}\n\n// NewIntSliceFromPtr makes a new IntSlice with the given pointer to int64 values.\nfunc NewIntSliceFromPtr(valsPtr *[]int64) *IntSlice {\n\treturn &IntSlice{valsPtr: valsPtr}\n}\n\n// Set changes the int64 values.\nfunc (v *IntSlice) Set(vals []int64) { *v.valsPtr = vals }\n\n// Type return TypeInt.\nfunc (v *IntSlice) Type() Type { return TypeInt }\n\n// IsSlice returns true.\nfunc (v *IntSlice) IsSlice() bool { return true }\n\n// Clone produce a clone that is identical except for the backing pointer.\nfunc (v *IntSlice) Clone() Value { return NewIntSlice(*v.valsPtr...) }\n\n// Parse sets the values from the given string.\nfunc (v *IntSlice) Parse(str string) error {\n\tsubstrings := strings.Split(str, \",\")\n\tvals := make([]int64, len(substrings))\n\n\tfor i := 0; i < len(substrings); i++ {\n\t\tsubstr := strings.TrimSpace(substrings[i])\n\n\t\tval, err := strconv.ParseInt(substr, 10, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvals[i] = val\n\t}\n\n\t*v.valsPtr = vals\n\n\treturn nil\n}\n\n// SlicePointer returns the pointer for storage of slice values.\nfunc (v *IntSlice) SlicePointer() interface{} { return v.valsPtr }\n\n// Slice returns the int64 slice values.\nfunc (v *IntSlice) Slice() interface{} { return *v.valsPtr }\n\n// Len returns the number of slice elements.\nfunc (v *IntSlice) Len() int { return len(*v.valsPtr) }\n\n// Equal checks if length and values of given slice equal the current.\n// Returns a non-nil error if types do not match.\nfunc (v *IntSlice) Equal(v2 Slice) (bool, error) {\n\tif err := CheckType(TypeInt, v2.Type()); err != nil {\n\t\treturn false, err\n\t}\n\n\tvals1 := *v.valsPtr\n\tvals2 := v2.Slice().([]int64)\n\n\tif len(vals1) != len(vals2) {\n\t\treturn false, nil\n\t}\n\n\tfor i, val1 := range vals1 {\n\t\tif val1 != vals2[i] {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\n\treturn true, nil\n}\n\n// Greater checks if all values of the current slice are greater than that of\n// the given single.\n// Returns a non-nil error if types do not match.\nfunc (v *IntSlice) Greater(v2 Single) (bool, error) {\n\treturn compareInts(*v.valsPtr, v2, intGreater)\n}\n\n// GreaterEqual checks if all values of the current slice are greater or equal\n// to the given single.\n// Returns a non-nil error if types do not match.\nfunc (v *IntSlice) GreaterEqual(v2 Single) (bool, error) {\n\treturn compareInts(*v.valsPtr, v2, intGreaterEqual)\n}\n\n// Less checks if all values of the current slice are less than that of\n// the given single.\n// Returns a non-nil error if types do not match.\nfunc (v *IntSlice) Less(v2 Single) (bool, error) {\n\treturn compareInts(*v.valsPtr, v2, intLess)\n}\n\n// LessEqual checks if all values of the current slice are less or equal\n// to the given single.\n// Returns a non-nil error if types do not match.\nfunc (v *IntSlice) LessEqual(v2 Single) (bool, error) {\n\treturn compareInts(*v.valsPtr, v2, intLessEqual)\n}\n\n// Contains checks if the given single value is equal to one of the\n// current slice values.\n// Returns a non-nil error if types do not match.\nfunc (v *IntSlice) Contains(v2 Single) (bool, error) {\n\tif err := CheckType(TypeInt, v2.Type()); err != nil {\n\t\treturn false, err\n\t}\n\n\tvals := *v.valsPtr\n\tval2 := v2.Value().(int64)\n\n\tfor _, val1 := range vals {\n\t\tif val1 == val2 {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc compareInts(vals []int64, v2 Single, f compareIntFunc) (bool, error) {\n\tif err := CheckType(TypeInt, v2.Type()); err != nil {\n\t\treturn false, err\n\t}\n\n\tif len(vals) == 0 {\n\t\treturn false, nil\n\t}\n\n\tval2 := v2.Value().(int64)\n\n\tfor _, val1 := range vals {\n\t\tif !f(val1, val2) {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\treturn true, nil\n}\n\nfunc intGreater(a, b int64) bool {\n\treturn a > b\n}\n\nfunc intGreaterEqual(a, b int64) bool {\n\treturn a >= b\n}\n\nfunc intLess(a, b int64) bool {\n\treturn a < b\n}\n\nfunc intLessEqual(a, b int64) bool {\n\treturn a <= b\n}\n"}
{"sample": "// Timer represents a simple timer.\ntype Timer struct {\n\tstart time.Time\n}\n\n// NewTimer creates a new Timer and starts it.\nfunc NewTimer() *Timer {\n\treturn &Timer{start: time.Now()}\n}\n\n// Elapsed returns the duration since the timer was started.\nfunc (t *Timer) Elapsed() time.Duration {\n\treturn time.Since(t.start)\n}"}
{"sample": "x := 42\nptr := &x\nfmt.Printf(\"Value of x: %d\\n\", *ptr)\n"}
{"sample": "package main\n\nimport \"strings\"\n\nfunc main() {\n\tstr := \"Hello, World!\"\n\tfmt.Println(strings.Contains(str, \"World\"))\n}"}
{"sample": "func BinarySearch(arr []int, target int) int {\n\treturn binarySearch(arr, target, 0, len(arr)-1)\n}\n\nfunc binarySearch(arr []int, target int, low int, high int) int {\n\tif high >= low {\n\t\tmid := low + (high-low)/2\n\t\tif arr[mid] == target {\n\t\t\treturn mid\n\t\t}\n\t\tif arr[mid] > target {\n\t\t\treturn binarySearch(arr, target, low, mid-1)\n\t\t}\n\t\treturn binarySearch(arr, target, mid+1, high)\n\t}\n\treturn -1\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Println(\"Goroutine 1:\", i)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Println(\"Goroutine 2:\", i)\n\t\t}\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"All Goroutines are done!\")\n}"}
{"sample": "// Enable automatic HTTP to HTTPS redirection for the server\nfunc EnableHTTPtoHTTPSRedirection(server *http.Server, httpsPort string) {\n\tserver.Handler = http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {\n\t\tredirectURL := \"https://\" + request.Host + \":\" + httpsPort + request.URL.String()\n\t\thttp.Redirect(response, request, redirectURL, http.StatusMovedPermanently)\n\t})\n}\n"}
{"sample": "func main() {\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\treader := bufio.NewReader(file)\n\n\tfor {\n\t\tline, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfmt.Println(\"Error reading line:\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(line)\n\t}\n}"}
{"sample": "// RetryOnErrorWithDelay retries a function if it returns an error, with a delay between each try\nfunc RetryOnErrorWithDelay(fn func() error, retries int, delay time.Duration) error {\n\tfor i := 0; i < retries; i++ {\n\t\terr := fn()\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\ttime.Sleep(delay)\n\t}\n\treturn fmt.Errorf(\"failed after %d retries\", retries)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"encoding/json\"\n)\n\nfunc SendJSONRequest() {\n\tclient := &http.Client{}\n\tdata := map[string]interface{}{\n\t\t\"name\": \"John Doe\",\n\t\t\"age\": 30,\n\t}\n\n\tjsonData, _ := json.Marshal(data)\n\n\trequest, _ := http.NewRequest(\"POST\", \"https://example.com\", bytes.NewBuffer(jsonData))\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresponse, _ := client.Do(request)\n\tdefer response.Body.Close()\n\n\t// Handle the response\n}\n"}
{"sample": "// Count the number of vowels in a string\nfunc CountVowels(str string) int {\n\tcount := 0\n\tvowels := \"aeiou\"\n\tfor _, char := range str {\n\t\tif strings.ContainsRune(vowels, char) {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n"}
{"sample": "package dnsserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"github.com/miekg/dns\"\n)\n\nfunc handleRequest(w dns.ResponseWriter, r *dns.Msg) {\n\tm := new(dns.Msg)\n\tm.SetReply(r)\n\tq := r.Question[0]\n\tswitch q.Qtype {\n\tcase dns.TypeA:\n\t\trr, err := dns.NewRR(fmt.Sprintf(\"%s A %s\", q.Name, \"127.0.0.1\"))\n\t\tif err == nil {\n\t\t\tm.Answer = append(m.Answer, rr)\n\t\t}\n\tdefault:\n\t\tlog.Printf(\"Unsupported query type: %d\\n\", q.Qtype)\n\t}\n\tw.WriteMsg(m)\n}\n\nfunc StartServer() {\n\tdns.HandleFunc(\".\", handleRequest)\n\taddr := net.JoinHostPort(\"127.0.0.1\", \"53\")\n\tserver := &dns.Server{Addr: addr, Net: \"udp\"}\n\tlog.Printf(\"Starting DNS server on %s\\n\", addr)\n\terr := server.ListenAndServe()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %s\\n\", err.Error())\n\t\tos.Exit(1)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/aws/aws-lambda-go/events\"\n\t\"github.com/aws/aws-lambda-go/lambda\"\n)\n\ntype Request events.APIGatewayProxyRequest\n\ntype Response struct {\n\tBody       string `json:\"body\"`\n\tStatusCode int    `json:\"statusCode\"`\n}\n\nfunc handleRequest(ctx context.Context, req Request) (Response, error) {\n\tfmt.Println(req.Body)\n\n\tresponse := Response{\n\t\tBody:       \"Hello, World!\",\n\t\tStatusCode: 200,\n\t}\n\n\treturn response, nil\n}\n\nfunc main() {\n\tlambda.Start(handleRequest)\n}\n\n// This snippet shows a simple AWS Lambda function using Golang to return a \"Hello, World!\" HTTP response with a status code of 200 via a JSON response. It relies on the AWS Lambda Go SDK for interfacing with the AWS Lambda service. The function can be deployed with ease provided the necessary configuration settings for deployment are in place."}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadFile reads and returns the content of a file.\nfunc ReadFile(filePath string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// WriteFile writes the content to a file.\nfunc WriteFile(filePath string, content []byte) error {\n\treturn ioutil.WriteFile(filePath, content, 0644)\n}"}
{"sample": "package gcsapi\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\n\t\"cloud.google.com/go/storage\"\n)\n\ntype GCSClient struct {\n\tclient *storage.Client\n}\n\nfunc NewClient(ctx context.Context, projectID string) (*GCSClient, error) {\n\tclient, err := storage.NewClient(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create client: %v\", err)\n\t}\n\treturn &GCSClient{client: client}, nil\n}\n\nfunc (c *GCSClient) ReadObject(bucket, object string, w io.Writer) error {\n\trc, err := c.client.Bucket(bucket).Object(object).NewReader(context.Background())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create reader: %v\", err)\n\t}\n\tdefer rc.Close()\n\n\tif _, err := io.Copy(w, rc); err != nil {\n\t\treturn fmt.Errorf(\"failed to copy object contents: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *GCSClient) WriteObject(bucket, object string, r io.Reader) error {\n\twc := c.client.Bucket(bucket).Object(object).NewWriter(context.Background())\n\tif _, err := io.Copy(wc, r); err != nil {\n\t\treturn fmt.Errorf(\"failed to write object contents: %v\", err)\n\t}\n\tif err := wc.Close(); err != nil {\n\t\treturn fmt.Errorf(\"failed to close object writer: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *GCSClient) DeleteObject(bucket, object string) error {\n\tif err := c.client.Bucket(bucket).Object(object).Delete(context.Background()); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete object: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *GCSClient) ListObjects(bucket string) ([]string, error) {\n\tvar objects []string\n\tit := c.client.Bucket(bucket).Objects(context.Background(), nil)\n\tfor {\n\t\tobj, err := it.Next()\n\t\tif err == storage.ErrIteratorDone {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to iterate objects: %v\", err)\n\t\t}\n\t\tobjects = append(objects, obj.Name)\n\t}\n\treturn objects, nil\n}\n\nfunc (c *GCSClient) Close() error {\n\tif err := c.client.Close(); err != nil {\n\t\tlog.Printf(\"failed to close client: %v\", err)\n\t}\n\treturn nil\n}"}
{"sample": "// Redirect the request to the specified URL\nfunc Redirect(response http.ResponseWriter, request *http.Request, url string) {\n\thttp.Redirect(response, request, url, http.StatusFound)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d processing job %d\\n\", id, j)\n\t\ttime.Sleep(time.Duration(rand.Intn(5)) * time.Second)\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tvar wg sync.WaitGroup\n\n\tfor w := 1; w <= 3; w++ {\n\t\twg.Add(1)\n\t\tgo worker(w, jobs, results, &wg)\n\t}\n\n\tfor j := 1; j <= 9; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n\n\tfor i := 1; i <= 9; i++ {\n\t\tfmt.Println(<-results)\n\t}\n}"}
{"sample": "func queryRows(stmt *sql.Stmt, args ...interface{}) (*sql.Rows, error) {\n\trows, err := stmt.Query(args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn rows, nil\n}\n"}
{"sample": "package roaming\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/andrewflash/benam-lora-network-server/internal/config\"\n\t\"github.com/andrewflash/benam-lora-network-server/internal/test\"\n\t\"github.com/andrewflash/lorawan\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestIsRoamingDevAddr(t *testing.T) {\n\tnetID = lorawan.NetID{1, 2, 3}\n\n\tt.Run(\"DevAddr is roaming\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\troamingEnabled = true\n\n\t\tdevAddr := lorawan.DevAddr{6, 7, 8, 9}\n\t\tdevAddr.SetAddrPrefix(lorawan.NetID{3, 2, 1})\n\n\t\tassert.True(IsRoamingDevAddr(devAddr))\n\t})\n\n\tt.Run(\"DevAddr is not roaming\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\troamingEnabled = true\n\n\t\tdevAddr := lorawan.DevAddr{6, 7, 8, 9}\n\t\tdevAddr.SetAddrPrefix(netID)\n\n\t\tassert.False(IsRoamingDevAddr(devAddr))\n\t})\n\n\tt.Run(\"DevAddr is roaming, roaming disabled\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\troamingEnabled = false\n\n\t\tdevAddr := lorawan.DevAddr{6, 7, 8, 9}\n\t\tdevAddr.SetAddrPrefix(lorawan.NetID{3, 2, 1})\n\n\t\tassert.False(IsRoamingDevAddr(devAddr))\n\t})\n}\n\nfunc TestGetClientForNetID(t *testing.T) {\n\tassert := require.New(t)\n\n\tconf := test.GetConfig()\n\tconf.Roaming.Servers = []config.RoamingServer{\n\t\t{\n\t\t\tNetID:          lorawan.NetID{6, 6, 6},\n\t\t\tPassiveRoaming: true,\n\t\t},\n\t}\n\tassert.NoError(Setup(conf))\n\n\tt.Run(\"Roaming agreement\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\tc, err := GetClientForNetID(lorawan.NetID{6, 6, 6})\n\t\tassert.NoError(err)\n\t\tassert.NotNil(c)\n\t})\n\n\tt.Run(\"No roaming agreement\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\t_, err := GetClientForNetID(lorawan.NetID{6, 6, 7})\n\t\tassert.Equal(ErrNoAgreement, errors.Cause(err))\n\t})\n\n\tt.Run(\"No roaming agreement, default client enabled\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\tconf.Roaming.Default.Enabled = true\n\t\tconf.Roaming.Default.PassiveRoaming = true\n\t\tassert.NoError(Setup(conf))\n\n\t\tc, err := GetClientForNetID(lorawan.NetID{6, 6, 7})\n\t\tassert.NoError(err)\n\t\tassert.NotNil(c)\n\t})\n}\n\nfunc TestGetPassiveRoamingLifetime(t *testing.T) {\n\tassert := require.New(t)\n\n\tconf := test.GetConfig()\n\tconf.Roaming.Servers = []config.RoamingServer{\n\t\t{\n\t\t\tNetID:                  lorawan.NetID{6, 6, 6},\n\t\t\tPassiveRoaming:         true,\n\t\t\tPassiveRoamingLifetime: time.Hour,\n\t\t},\n\t}\n\tassert.NoError(Setup(conf))\n\n\tt.Run(\"Roaming agreement\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\tassert.Equal(time.Hour, GetPassiveRoamingLifetime(lorawan.NetID{6, 6, 6}))\n\t})\n\n\tt.Run(\"No roaming agreement\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\tassert.Equal(time.Duration(0), GetPassiveRoamingLifetime(lorawan.NetID{6, 6, 7}))\n\t})\n\n\tt.Run(\"Default roaming agreement\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\n\t\tconf := test.GetConfig()\n\t\tconf.Roaming.Servers = []config.RoamingServer{\n\t\t\t{\n\t\t\t\tNetID:                  lorawan.NetID{6, 6, 6},\n\t\t\t\tPassiveRoaming:         true,\n\t\t\t\tPassiveRoamingLifetime: time.Hour,\n\t\t\t},\n\t\t}\n\t\tconf.Roaming.Default.Enabled = true\n\t\tconf.Roaming.Default.PassiveRoamingLifetime = time.Minute\n\t\tassert.NoError(Setup(conf))\n\n\t\tassert.Equal(time.Minute, GetPassiveRoamingLifetime(lorawan.NetID{6, 6, 7}))\n\t})\n}\n\nfunc TestGetPassiveRoamingKEKLabel(t *testing.T) {\n\tassert := require.New(t)\n\tconf := test.GetConfig()\n\tconf.Roaming.Servers = []config.RoamingServer{\n\t\t{\n\t\t\tNetID:                  lorawan.NetID{6, 6, 6},\n\t\t\tPassiveRoaming:         true,\n\t\t\tPassiveRoamingKEKLabel: \"test-kek\",\n\t\t},\n\t}\n\tassert.NoError(Setup(conf))\n\n\tt.Run(\"Roaming agreement\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\tassert.Equal(\"test-kek\", GetPassiveRoamingKEKLabel(lorawan.NetID{6, 6, 6}))\n\t})\n\n\tt.Run(\"No roaming agreement\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\tassert.Equal(\"\", GetPassiveRoamingKEKLabel(lorawan.NetID{6, 6, 7}))\n\t})\n\n\tt.Run(\"Default roaming agreement\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\t\tconf := test.GetConfig()\n\t\tconf.Roaming.Servers = []config.RoamingServer{\n\t\t\t{\n\t\t\t\tNetID:                  lorawan.NetID{6, 6, 6},\n\t\t\t\tPassiveRoaming:         true,\n\t\t\t\tPassiveRoamingKEKLabel: \"test-kek\",\n\t\t\t},\n\t\t}\n\t\tconf.Roaming.Default.Enabled = true\n\t\tconf.Roaming.Default.PassiveRoamingKEKLabel = \"default-kek\"\n\t\tassert.NoError(Setup(conf))\n\n\t\tassert.Equal(\"default-kek\", GetPassiveRoamingKEKLabel(lorawan.NetID{6, 6, 7}))\n\t})\n}\n\nfunc TestGetNetIDsForDevAddr(t *testing.T) {\n\tassert := require.New(t)\n\tconf := test.GetConfig()\n\tconf.Roaming.Servers = []config.RoamingServer{\n\t\t{\n\t\t\tNetID:                  lorawan.NetID{6, 6, 6},\n\t\t\tPassiveRoaming:         true,\n\t\t\tPassiveRoamingKEKLabel: \"test-kek\",\n\t\t},\n\t}\n\tassert.NoError(Setup(conf))\n\n\tt.Run(\"Roaming agreement\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\n\t\tdevAddr := lorawan.DevAddr{6, 7, 8, 9}\n\t\tdevAddr.SetAddrPrefix(lorawan.NetID{6, 6, 6})\n\n\t\tassert.Equal([]lorawan.NetID{{6, 6, 6}}, GetNetIDsForDevAddr(devAddr))\n\t})\n\n\tt.Run(\"No roaming agreement\", func(t *testing.T) {\n\t\tassert := require.New(t)\n\n\t\tdevAddr := lorawan.DevAddr{6, 7, 8, 9}\n\t\tdevAddr.SetAddrPrefix(lorawan.NetID{6, 6, 7})\n\n\t\tassert.Len(GetNetIDsForDevAddr(devAddr), 0)\n\t})\n}\n"}
{"sample": "package main\n\n// This function opens a file\nfunc OpenFile(filename string) (*os.File, error) {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn file, nil\n}\n\n// This function reads from an open file\nfunc ReadFile(file *os.File) ([]byte, error) {\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn content, nil\n}\n\nfunc main() {\n\tfile, err := OpenFile(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\tcontent, err := ReadFile(file)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(content))\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttimer := time.NewTimer(2 * time.Second)\n\tdefer timer.Stop()\n\n\t<-timer.C\n\tfmt.Println(\"Timer expired\")\n}"}
{"sample": "// Making a map\n\nm := make(map[string]int)\n"}
{"sample": "package command\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/spf13/cobra\"\n)\n\nconst defaultAddress = \"http://localhost:64210/\"\n\nfunc NewHealthCmd() *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:     \"health\",\n\t\tAliases: []string{},\n\t\tShort:   \"Health check HTTP server\",\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif len(args) > 1 {\n\t\t\t\treturn fmt.Errorf(\"Too many arguments provided, expected 0 or 1\")\n\t\t\t}\n\t\t\taddress := defaultAddress\n\t\t\tif len(args) == 1 {\n\t\t\t\taddress = args[0]\n\t\t\t}\n\t\t\thealthAddress := address + \"health\"\n\t\t\tresp, err := http.Get(healthAddress)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\t\t\tif resp.StatusCode != 204 {\n\t\t\t\treturn fmt.Errorf(\"/health responded with status code %d, expected 204\", resp.StatusCode)\n\t\t\t}\n\t\t\tlog.Printf(\"%s ok\", healthAddress)\n\t\t\treturn nil\n\t\t},\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"bytes\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"text/template\"\n)\n\n// NOTE: Instead of using this script we are using bazel's go_embed_data.\n// This script may be removed in the future.\n\nvar (\n\tin         = flag.String(\"in\", \"\", \"The path to the directory that contains text files.\")\n\tout        = flag.String(\"out\", \"\", \"The path to put the generated go file.\")\n\toutPackage = flag.String(\"out-package\", \"\", \"The go package for generated file.\")\n\n\tcodeTemplate = `\npackage {{ .Package }}\n\nvar (\n{{- range $name, $data := .Data }}\n\t{{ formatName $name }} = {{ formatString $data }}\n{{- end }}\n)\n`\n)\n\nfunc main() {\n\tflag.Parse()\n\tif err := validateFlags(); err != nil {\n\t\tlog.Fatalf(\"invalidate flag: %v\", err)\n\t}\n\n\tlicense, err := os.ReadFile(\"./hack/boilerplate.go.txt\")\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to read license file: %v\", err)\n\t}\n\n\tdata, err := loadData(*in)\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to load data from %s: %v\", *in, err)\n\t}\n\n\tvar maxNameLength = 0\n\tfor k := range data {\n\t\tif maxNameLength < len(k) {\n\t\t\tmaxNameLength = len(k)\n\t\t}\n\t}\n\tformat := \"%-\" + fmt.Sprintf(\"%d\", maxNameLength) + \"s\"\n\tformatName := func(s string) string {\n\t\treturn fmt.Sprintf(format, s)\n\t}\n\n\tfileTemplate := string(license) + codeTemplate\n\ttmpl, err := template.New(\"template\").\n\t\tFuncs(template.FuncMap{\n\t\t\t\"formatName\":   formatName,\n\t\t\t\"formatString\": formatString,\n\t\t}).\n\t\tParse(fileTemplate)\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to make template: %v\", err)\n\t}\n\n\tgeneratedCode, err := renderTemplate(tmpl, map[string]interface{}{\n\t\t\"Package\":    *outPackage,\n\t\t\"Data\":       data,\n\t\t\"NameLength\": 50,\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to render go file: %v\", err)\n\t}\n\n\tif err = os.WriteFile(*out, []byte(generatedCode), os.ModePerm); err != nil {\n\t\tlog.Fatalf(\"unable to write go file to %s: %v\", *out, err)\n\t}\n\tlog.Printf(\"successfully generated file: %s\", *out)\n}\n\nfunc validateFlags() error {\n\tif *in == \"\" {\n\t\treturn fmt.Errorf(\"in is required\")\n\t}\n\tif *out == \"\" {\n\t\treturn fmt.Errorf(\"out is required\")\n\t}\n\tif *outPackage == \"\" {\n\t\treturn fmt.Errorf(\"out-package is required\")\n\t}\n\treturn nil\n}\n\nfunc loadData(root string) (map[string]interface{}, error) {\n\tdata := make(map[string]interface{})\n\terr := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif path == root {\n\t\t\treturn nil\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\t\tif !info.Mode().IsRegular() {\n\t\t\treturn nil\n\t\t}\n\t\tbytes, err := os.ReadFile(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdata[filepath.Base(path)] = bytes\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n\nfunc formatString(bytes []byte) string {\n\treturn fmt.Sprintf(\"%#v\", string(bytes))\n}\n\nfunc renderTemplate(tmpl *template.Template, data map[string]interface{}) (string, error) {\n\tbuf := new(bytes.Buffer)\n\tif err := tmpl.Execute(buf, data); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn buf.String(), nil\n}\n"}
{"sample": "package mapping_test\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/mrrtf/pigiron/mapping\"\n)\n\nfunc UnmarshalTestRandomPos(data []byte) (TestRandomPos, error) {\n\tvar r TestRandomPos\n\terr := json.Unmarshal(data, &r)\n\treturn r, err\n}\n\nfunc (r *TestRandomPos) Marshal() ([]byte, error) {\n\treturn json.Marshal(r)\n}\n\ntype TestRandomPos struct {\n\tTestpositions []Testposition `json:\"testpositions\"`\n}\n\ntype Testposition struct {\n\tDe      mapping.DEID `json:\"de\"`\n\tBending BoolString   `json:\"bending\"`\n\tOutside BoolString   `json:\"isoutside,omitempty\"`\n\tX       float64      `json:\"x\"`\n\tY       float64      `json:\"y\"`\n\tPX      float64      `json:\"px\"`\n\tPY      float64      `json:\"py\"`\n\tSX      float64      `json:\"sx\"`\n\tSY      float64      `json:\"sy\"`\n\tDsid    int64        `json:\"dsid\"`\n\tDsch    int64        `json:\"dsch\"`\n}\n\nfunc (tp Testposition) String() string {\n\treturn fmt.Sprintf(\"DE %4d %s X %v Y %v Outside %v -> fecID %d fecChannel %d PX %v PY %v SX %v SY %v\",\n\t\ttp.De, mapping.PlaneAbbreviation(tp.isBendingPlane()), tp.X, tp.Y, tp.Outside == \"true\",\n\t\ttp.Dsid, tp.Dsch, tp.PX, tp.PY, tp.SX, tp.SY)\n}\n\nfunc (tp Testposition) isBendingPlane() bool {\n\treturn tp.Bending == \"true\"\n}\n\nfunc (tp Testposition) isOutside() bool {\n\treturn tp.Outside == \"true\"\n}\n\ntype BoolString string\n\nconst (\n\tFalse BoolString = \"false\"\n\tTrue  BoolString = \"true\"\n)\n"}
{"sample": "package yaml_test\n\nimport (\n    \"testing\"\n    \"reflect\"\n    \"github.com/stretchr/testify/assert\"\n    \"gopkg.in/yaml.v2\"\n)\n\ntype Config struct {\n    Name string `yaml:\"name\"`\n    Age  int    `yaml:\"age\"`\n}\n\nfunc TestYaml(t *testing.T) {\n    input := []byte(`name: John\nage: 30`)\n    expected := &Config{\n        Name: \"John\",\n        Age:  30,\n    }\n\n    var c Config\n    err := yaml.Unmarshal(input, &c)\n\n    if err != nil {\n        t.Fatalf(\"error: %v\", err)\n    }\n\n    if !reflect.DeepEqual(c, *expected) {\n        t.Fatalf(\"Expected %v, but got %v\", expected, c)\n    }\n\n    output, err := yaml.Marshal(&c)\n    if err != nil {\n        t.Fatalf(\"error: %v\", err)\n    }\n\n    assert.Equal(t, string(input), string(output))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})\n\n\thttp.HandleFunc(\"/about\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"About page\")\n\t})\n\n\thttp.HandleFunc(\"/contact\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Contact page\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype Customer struct {\n\tID   string `json:\"id,omitempty\"`\n\tName string `json:\"name,omitempty\"`\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/customers\", GetCustomers).Methods(\"GET\")\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc GetCustomers(w http.ResponseWriter, r *http.Request) {\n\tcustomers := []Customer{{ID: \"1\", Name: \"Jane Doe\"}}\n\tjson.NewEncoder(w).Encode(customers)\n}"}
{"sample": "package git\n\nimport \"strings\"\n\ntype GitUrl struct {\n\tProtocol string\n\tUser     string\n\tToken    string\n\tRepo     string\n}\n\nfunc (g *GitUrl) SetUser(newUser string) {\n\tif len(newUser) > 0 {\n\t\tg.User = newUser\n\t}\n}\n\nfunc (g *GitUrl) SetToken(newToken string) {\n\tif len(newToken) > 0 {\n\t\tg.Token = newToken\n\t}\n}\n\nfunc (g *GitUrl) ToUrl() string {\n\tif len(g.Token) > 0 && len(g.User) > 0 {\n\t\treturn g.Protocol + \"//\" + g.User + \":\" + g.Token + \"@\" + g.Repo\n\t}\n\tif len(g.User) > 0 {\n\t\treturn g.Protocol + \"//\" + g.User + \"@\" + g.Repo\n\t}\n\treturn g.Protocol + \"//\" + g.Repo\n}\n\nfunc NewGitUrl(url string) *GitUrl {\n\tsplittetAfterProtocol := strings.Split(url, \"//\")\n\tsplittedAfterCredentials := strings.Split(splittetAfterProtocol[1], \"@\")\n\tcredentialsSplitted := strings.Split(splittedAfterCredentials[0], \":\")\n\tif len(credentialsSplitted) == 2 {\n\t\treturn &GitUrl{\n\t\t\tsplittetAfterProtocol[0],\n\t\t\tcredentialsSplitted[0],\n\t\t\tcredentialsSplitted[1],\n\t\t\tsplittedAfterCredentials[1],\n\t\t}\n\t} else {\n\t\tif len(splittedAfterCredentials) == 2 {\n\n\t\t\treturn &GitUrl{\n\t\t\t\tsplittetAfterProtocol[0],\n\t\t\t\tsplittedAfterCredentials[0],\n\t\t\t\t\"\",\n\t\t\t\tsplittedAfterCredentials[1],\n\t\t\t}\n\t\t} else {\n\t\t\treturn &GitUrl{\n\t\t\t\tsplittetAfterProtocol[0],\n\t\t\t\t\"\",\n\t\t\t\t\"\",\n\t\t\t\tsplittedAfterCredentials[0],\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// CountOccurrences counts the number of occurrences of a substring in a given string.\nfunc CountOccurrences(str, substr string) int {\n\treturn strings.Count(str, substr)\n}"}
{"sample": "func main() {\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\treader := bufio.NewReader(file)\n\n\tfor {\n\t\tline, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfmt.Println(\"Error reading line:\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(line)\n\t}\n}"}
{"sample": "file, err := os.OpenFile(\"file.txt\", os.O_APPEND|os.O_WRONLY, 0644)\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\n_, err = file.Write([]byte(\"Appending text\\n\"))\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport \"os\"\n\nfunc main() {\n\tuser := os.Getenv(\"USER\")\n\tfmt.Println(user)\n}"}
{"sample": "// Find the minimum element in an array\nfunc FindMin(arr []int) int {\n\tmin := arr[0]\n\tfor i := 1; i < len(arr); i++ {\n\t\tif arr[i] < min {\n\t\t\tmin = arr[i]\n\t\t}\n\t}\n\treturn min\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"ls\", \"-l\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tfmt.Println(\"Error running command:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(output))\n}"}
{"sample": "package main\n\n// ErrorWithMessage returns an error with a custom message\nfunc ErrorWithMessage(err error, message string) error {\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: %w\", message, err)\n\t}\n\treturn nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\tfiles, err := ioutil.ReadDir(\".\")\n\tif err != nil {\n\t\tfmt.Println(\"Error reading directory:\", err)\n\t\treturn\n\t}\n\n\tfor _, file := range files {\n\t\tfmt.Println(file.Name())\n\t}\n}"}
{"sample": "func main() {\n\tperson := Person{Name: \"John Doe\", Age: 30}\n\n\tdata, err := json.Marshal(person)\n\tif err != nil {\n\t\tfmt.Println(\"Error marshaling JSON:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(data))\n}"}
{"sample": "package main\n\n// Decode gob data from a file\nfunc main() {\n\tdata := \"\"\n\tfile, _ := os.Open(\"file.gob\")\n\tdefer file.Close()\n\tdecoder := gob.NewDecoder(file)\n\terr := decoder.Decode(&data)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/smtp\"\n)\n\nfunc sendEmail(to []string, subj string, message string) error {\n\ttype PlainAuthV2 struct {\n\t\tidentity, username, password string\n\t\thost                         string\n\t   }\n\n\tconf := &tls.Config{\n\t\tInsecureSkipVerify: true,\n\t\tServerName:         remote.ServerName,\n\t}\n   //Update SMTP server configuration to your email server's configuration. Taken from net.conn example in the Off"}
{"sample": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"io\"\n\t\"os\"\n)\n\n// ReadCSVFile reads a CSV file and returns its content as a slice of records.\nfunc ReadCSVFile(filePath string) ([][]string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\trecords, err := reader.ReadAll()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn records, nil\n}\n\n// WriteCSVFile writes a slice of records to a CSV file.\nfunc WriteCSVFile(filePath string, records [][]string) error {\n\tfile, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\terr = writer.WriteAll(records)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twriter.Flush()\n\treturn writer.Error()\n}"}
{"sample": "// Calculate the average of a slice of numbers\nfunc CalculateAverage(numbers []float64) float64 {\n\tsum := 0.0\n\tfor _, num := range numbers {\n\t\tsum += num\n\t}\n\treturn sum / float64(len(numbers))\n}\n"}
{"sample": "package main\n\n// ErrorOrNil returns error message or 'nil' if error is nil\nfunc ErrorOrNil(err error) string {\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\treturn \"nil\"\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintAreaOfSquare(5)\n}\n\n// Function to print the area of a square\nfunc PrintAreaOfSquare(side float64) {\n\tfmt.Println(side * side)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int) {\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", id, j)\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Printf(\"Worker %d finished job %d\\n\", id, j)\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tfor w := 1; w <= 3; w++ {\n\t\tgo worker(w, jobs, results)\n\t}\n\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\tfor a := 1; a <= 5; a++ {\n\t\t<-results\n\t}\n}"}
{"sample": "func main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/mydb\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to MySQL:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE IF NOT EXISTS users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255))\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating table:\", err)\n\t\treturn\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (name) VALUES ('John Doe')\")\n\tif err != nil {\n\t\tfmt.Println(\"Error inserting into table:\", err)\n\t\treturn\n\t}\n\n\trows, err := db.Query(\"SELECT id, name FROM users\")\n\tif err != nil {\n\t\tfmt.Println(\"Error querying table:\", err)\n\t\treturn\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\terr = rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error scanning row:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Println(id, name)\n\t}\n}"}
{"sample": "// Read the request body as a string\nfunc ReadRequestBody(request *http.Request) (string, error) {\n\tbody, err := ioutil.ReadAll(request.Body)\n\treturn string(body), err\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintFactorial(5)\n}\n\n// Function to print the factorial of a number\nfunc PrintFactorial(n int) {\n\tresult := 1\n\tfor i := 2; i <= n; i++ {\n\t\tresult *= i\n\t}\n\tfmt.Println(result)\n}"}
{"sample": "func dropForeignKey(db *sql.DB) error {\n\tstmt, err := db.Prepare(\"ALTER TABLE users DROP CONSTRAINT fk_user_id\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package main\n\nfunc main() {\n\tfmt.Println(isEqual(2, 2))\n}\n\nfunc isEqual(x, y int) bool {\n\treturn x == y\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc SetRequestHeaders() {\n\tclient := &http.Client{}\n\trequest, _ := http.NewRequest(\"GET\", \"https://example.com\", nil)\n\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\trequest.Header.Set(\"Authorization\", \"Bearer TOKEN\")\n\n\tresponse, _ := client.Do(request)\n\tdefer response.Body.Close()\n\n\t// Handle the response\n}\n"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "// FileSize returns the size of a file.\nfunc FileSize(filePath string) (int64, error) {\n\tinfo, err := os.Stat(filePath)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn info.Size(), nil\n}\n\n// FileExists checks whether a file exists.\nfunc FileExists(filePath string) bool {\n\t_, err := os.Stat(filePath)\n\treturn !os.IsNotExist(err)\n}"}
{"sample": "package bits\n\n/**\n * Given a word, returns array of words, prefix of which is word\n */\nfunc (f *FrozenTrie) GetSuggestedWords(word string, limit int) []string {\n\tvar result []string\n\n\tnode := f.GetRoot()\n\n\t// find the node corresponding to the last char of input\n\tfor _, runeValue := range word {\n\t\tvar child FrozenTrieNode\n\t\tvar j uint = 0\n\t\tfor ; j < node.GetChildCount(); j++ {\n\t\t\tchild = node.GetChild(j)\n\t\t\tif child.letter == string(runeValue) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// not found, return.\n\t\tif j == node.GetChildCount() {\n\t\t\treturn result\n\t\t}\n\n\t\tnode = child\n\t}\n\n\t// The node corresponding to the last letter of word is found.\n\t// Use this node as root. traversing the trie in level order.\n\treturn f.traverseSubTrie(node, word, limit)\n}\n\nfunc (f *FrozenTrie) traverseSubTrie(node FrozenTrieNode, prefix string, limit int) []string {\n\tvar result []string\n\n\tvar level []FrozenTrieNode\n\tlevel = append(level, node)\n\tvar prefixLevel []string\n\tprefixLevel = append(prefixLevel, prefix)\n\n\tfor len(level) > 0 {\n\t\tnodeNow := level[0]\n\t\tlevel = level[1:]\n\t\tprefixNow := prefixLevel[0]\n\t\tprefixLevel = prefixLevel[1:]\n\n\t\t// if the prefix is a legal word.\n\t\tif nodeNow.final {\n\t\t\tresult = append(result, prefixNow)\n\t\t\tif len(result) > limit {\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\n\t\tvar i uint = 0\n\t\tfor ; i < nodeNow.GetChildCount(); i++ {\n\t\t\tchild := nodeNow.GetChild(i)\n\t\t\tlevel = append(level, child)\n\t\t\tprefixLevel = append(prefixLevel, prefixNow+child.letter)\n\t\t}\n\t}\n\n\treturn result\n}\n"}
{"sample": "package md2html\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/gomarkdown/markdown\"\n)\n\nfunc Convert(filepath string) (string, error) {\n\tfile, err := ioutil.ReadFile(filepath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read file: %v\", err)\n\t}\n\n\thtml := markdown.ToHTML(file, nil, nil)\n\n\tvar buffer bytes.Buffer\n\tbuffer.Write(html)\n\n\treturn buffer.String(), nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(\"Goroutine 1:\", i)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(\"Goroutine 2:\", i)\n\t\t}\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines have finished executing\")\n}"}
{"sample": "package dnstap\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc dialAndSend(t *testing.T, network, address string) *FrameStreamSockOutput {\n\tvar addr net.Addr\n\tvar err error\n\tswitch network {\n\tcase \"unix\":\n\t\taddr, err = net.ResolveUnixAddr(network, address)\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\taddr, err = net.ResolveTCPAddr(network, address)\n\tdefault:\n\t\terr = fmt.Errorf(\"invalid network %s\", network)\n\t}\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar out *FrameStreamSockOutput\n\toutputChan := make(chan *FrameStreamSockOutput)\n\n\tgo func() {\n\t\to, err := NewFrameStreamSockOutput(addr)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\to.SetDialer(&net.Dialer{Timeout: time.Second})\n\t\to.SetTimeout(time.Second)\n\t\to.SetRetryInterval(time.Second)\n\n\t\toutputChan <- o\n\t}()\n\n\tselect {\n\tcase out = <-outputChan:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"can't create a new encoder\")\n\t}\n\n\tgo out.RunOutputLoop()\n\tout.GetOutputChannel() <- []byte(\"frame\")\n\treturn out\n}\n\nfunc readOne(t *testing.T, out chan []byte) {\n\tselect {\n\tcase <-out:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timed out waiting for frame\")\n\t}\n}\n\n// Test if dnstap can accept multiple connections on the socket\nfunc TestMultiConn(t *testing.T) {\n\tin, err := NewFrameStreamSockInputFromPath(\"dnstap.sock\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tout := make(chan []byte)\n\tgo in.ReadInto(out)\n\n\t// send two framestream messages on different connections\n\tdefer dialAndSend(t, \"unix\", \"dnstap.sock\").Close()\n\tdefer dialAndSend(t, \"unix\", \"dnstap.sock\").Close()\n\n\treadOne(t, out)\n\treadOne(t, out)\n}\n\nfunc TestReconnect(t *testing.T) {\n\t// Find an open port on localhost by opening a listener on an\n\t// unspecified port, querying its address, then closing it.\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tladdr := l.Addr()\n\tl.Close()\n\n\tdefer dialAndSend(t, laddr.Network(), laddr.String()).Close()\n\tdefer dialAndSend(t, laddr.Network(), laddr.String()).Close()\n\ttime.Sleep(1500 * time.Millisecond)\n\tl, err = net.Listen(laddr.Network(), laddr.String())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tin := NewFrameStreamSockInput(l)\n\tout := make(chan []byte)\n\tgo in.ReadInto(out)\n\treadOne(t, out)\n\treadOne(t, out)\n}\n"}
{"sample": "func CreateGzipFile(inputFile, outputFile string) error {\n\treader, err := os.Open(inputFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer reader.Close()\n\n\twriter, err := os.Create(outputFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer writer.Close()\n\n\tgzipWriter := gzip.NewWriter(writer)\n\tdefer gzipWriter.Close()\n\n\t_, err = io.Copy(gzipWriter, reader)\n\treturn err\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\tsqlite3 \"github.com/mattn/go-sqlite3\"\n\t\"gorm.io/driver/sqlite\"\n\t\"gorm.io/gorm\"\n)\n\ntype User struct {\n\tgorm.Model\n\tName       string\n\tEmail      string `gorm:\"unique;not null\"`\n\tAge        uint8\n\tBirthdate  time.Time\n\tCreditCard CreditCard `gorm:\"foreignKey:UserID\"`\n}\n\ntype CreditCard struct {\n\tgorm.Model\n\tUserID     uint\n\tNumber     string\n\tExpiration string\n}\n\nfunc main() {\n\tdb, err := gorm.Open(sqlite.Open(\"test.db\"), &gorm.Config{})\n\tif err != nil {\n\t\tpanic(\"failed to connect database\")\n\t}\n\n\t// Make sure foreign key constraints are enabled\n\tsqlDB, err := db.DB()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer sqlDB.Close()\n\n\tif v, ok := sqlDB.Driver().(*sqlite3.SQLiteDriver); ok {\n\t\tv.Connector.EnableForeignKeys(true) // Enable foreign key constraints\n\t}\n\n\t// Automigrate the database\n\tif err := db.AutoMigrate(&User{}, &CreditCard{}); err != nil {\n\t\tlog.Fatalf(\"Failed to auto migrate: %v\", err)\n\t}\n\n\t// Create a user and their credit card\n\tuser := User{\n\t\tName:      \"John\",\n\t\tEmail:     \"john@gmail.com\",\n\t\tAge:       25,\n\t\tBirthdate: time.Date(1996, 5, 18, 0, 0, 0, 0, time.UTC),\n\t\tCreditCard: CreditCard{\n\t\t\tNumber:     \"1234567890123456\",\n\t\t\tExpiration: \"12/22\",\n\t\t},\n\t}\n\n\tif err := db.Create(&user).Error; err != nil {\n\t\tlog.Fatalf(\"Failed to create user: %v\", err)\n\t}\n\n\t// Find user by email\n\tvar foundUser User\n\tif err := db.Where(\"email = ?\", \"john@gmail.com\").First(&foundUser).Error; err != nil {\n\t\tlog.Fatalf(\"Failed to find user: %v\", err)\n\t}\n\tfmt.Printf(\"Found user: %+v\\n\", foundUser)\n}"}
{"sample": "package pubsub\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"cloud.google.com/go/pubsub\"\n)\n\ntype PubSubManager struct {\n\tclient *pubsub.Client\n\ttopic  *pubsub.Topic\n}\n\nfunc NewPubSubManager(ctx context.Context, projectID, topicName string) (*PubSubManager, error) {\n\tclient, err := pubsub.NewClient(ctx, projectID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create client: %v\", err)\n\t}\n\n\ttopic := client.Topic(topicName)\n\n\treturn &PubSubManager{\n\t\tclient: client,\n\t\ttopic:  topic,\n\t}, nil\n}\n\nfunc (m *PubSubManager) Publish(ctx context.Context, msg []byte) error {\n\tres := m.topic.Publish(ctx, &pubsub.Message{\n\t\tData: msg,\n\t})\n\n\tid, err := res.Get(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to publish message: %v\", err)\n\t}\n\n\tlog.Printf(\"Published message with ID: %s\", id)\n\n\treturn nil\n}\n\nfunc (m *PubSubManager) Close() error {\n\treturn m.client.Close()\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--batch-size\", argparse.Int, 32, \"Batch size\")\nparser.AddArgument(\"--num-epochs\", argparse.Int, 10, \"Number of epochs\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--weight-decay\", argparse.Float, 0.001, \"Weight decay\")\nparser.AddArgument(\"--dropout\", argparse.Float, 0.5, \"Dropout rate\")\nparser.AddArgument(\"--mode\", argparse.String, \"train\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\nparser.AddArgument(\"--debug\", argparse.Bool, false, \"Enable debug mode\")\nparser.AddArgument(\"--gpu\", argparse.Bool, true, \"Enable GPU usage\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 8, \"Number of threads\")\n"}
{"sample": "// Using for loop\n\nfor i := 0; i < 10; i++ {\n\tfmt.Println(i)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, wg *sync.WaitGroup, jobs <-chan int, results chan<- int) {\n\tdefer wg.Done()\n\n\tfor j := range jobs {\n\t\tfmt.Printf(\"worker %d started job %d\\n\", id, j)\n\t\ttime.Sleep(time.Duration(rand.Intn(3)) * time.Second)\n\t\tfmt.Printf(\"worker %d finished job %d\\n\", id, j)\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo worker(i, &wg, jobs, results)\n\t}\n\n\tfor j := 1; j <= 20; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n\n\tfor a := 1; a <= 20; a++ {\n\t\tfmt.Println(<-results)\n\t}\n}"}
{"sample": "err = os.Chmod(\"file.txt\", 0644)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ttrackList := make([]string, 3)\n\n\ttrackList[0] = \"One Love\"\n\ttrackList[1] = \"Three Little Birds\"\n\n\tprintPlaylist(trackList)\n\n\t// Add a new song to the list\n\ttrackList = append(trackList, \"No Woman, No Cry\")\n\n\tprintPlaylist(trackList)\n\n\t// Remove the second track from the playlist\n\ttrackList = removeTrackFromPlaylist(trackList, 1)\n\n\tprintPlaylist(trackList)\n}\n\nfunc printPlaylist(trackList []string) {\n\tfmt.Println(\"-------- TRACKLIST --------\")\n\tfor i, track := range trackList {\n\t\tfmt.Printf(\"%v. %v\\n\", i+1, track)\n\t}\n}\n\nfunc removeTrackFromPlaylist(trackList []string, index int) []string {\n\ttrackList = append(trackList[:index], trackList[index+1:]...)\n\treturn trackList\n}"}
{"sample": "// Create and start an HTTP server with the specified handler\nfunc StartServer(addr string, handler http.Handler) error {\n\treturn http.ListenAndServe(addr, handler)\n}\n"}
{"sample": "package raftkvstore\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/hashicorp/raft\"\n\traftboltdb \"github.com/hashicorp/raft-boltdb\"\n)\n\ntype KVStore struct {\n\traftDir     string\n\traftBind    string\n\tmux         *mux.Router\n\tdbPath      string\n\traftServer  *raft.Raft\n\traftStorage *raftboltdb.BoltStore\n\tfsm         *fsm\n}\n\nfunc NewKVStore(bind string, raftDir string, dbPath string) *KVStore {\n\tkv := &KVStore{\n\t\traftDir:    raftDir,\n\t\traftBind:   bind,\n\t\tdbPath:     dbPath,\n\t}\n\tkv.setupMux()\n\tkv.setupRaft()\n\treturn kv\n}\n\nfunc (kv *KVStore) Start() {\n\tlog.Println(\"Starting Raft KV store...\")\n\tif err := kv.raftServer.BootstrapCluster(raft.Configuration{\n\t\tServers: []raft.Server{\n\t\t\t{\n\t\t\t\tID:      kv.raftServer.BindAddress,\n\t\t\t\tAddress: raft.ServerAddress(kv.raftServer.BindAddress),\n\t\t\t},\n\t\t},\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tkv.raftServer.Start()\n\tkv.mux.PathPrefix(\"/\").Handler(kv.raftServer.HTTPHandler(kv.mux))\n\thttp.ListenAndServe(kv.raftBind, kv.mux)\n}\n\nfunc (kv *KVStore) setupMux() {\n\tkv.mux = mux.NewRouter()\n\tkv.mux.HandleFunc(\"/get/{key}\", kv.getHandler).Methods(\"GET\")\n\tkv.mux.HandleFunc(\"/set/{key}/{value}\", kv.setHandler).Methods(\"POST\")\n}\n\nfunc (kv *KVStore) setupRaft() {\n\tconfig := raft.DefaultConfig()\n\tconfig.LocalID = raft.ServerID(kv.raftBind)\n\tconfig.CommitTimeout = time.Second\n\n\tlogStore, err := raftboltdb.NewBoltStore(fmt.Sprintf(\"%s/%s\", kv.raftDir, \"log.db\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tkv.raftStorage, err = raftboltdb.NewBoltStore(fmt.Sprintf(\"%s/%s\", kv.raftDir, \"raft.db\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsnapshotStore, err := raft.NewFileSnapshotStore(kv.raftDir, 1, os.Stdout)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\traftServer, err := raft.NewRaft(config, &fsm{}, logStore, kv.raftStorage,\n\t\tsnapshotStore, newTransport(kv.raftBind))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tkv.raftServer = raftServer\n}\n\nfunc (kv *KVStore) setHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tkey := vars[\"key\"]\n\tvalue := vars[\"value\"]\n\tlog.Printf(\"Received set request for key=%v\", key)\n\n\tcmd := &setCommand{Key: key, Value: value}\n\tb, err := json.Marshal(cmd)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfuture := kv.raftServer.Apply(b, time.Second)\n\tif err := future.Error(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc (kv *KVStore) getHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tkey := vars[\"key\"]\n\tlog.Printf(\"Received get request for key=%v\", key)\n\n\tvalue, err := kv.getValueFromRaft(key)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif value == \"\" {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tw.Write([]byte(value))\n}\n\nfunc (kv *KVStore) getValueFromRaft(key string) (string, error) {\n\tf := kv.raftServer.FutureFor(command{\n\t\tId:      strconv.FormatInt(time.Now().UnixNano(), 10),\n\t\tCommand: getCommand{Key: key},\n\t})\n\tif err := f.Error(); err != nil {\n\t\treturn \"\", err\n\t}\n\tres := f.Response().(string)\n\treturn res, nil\n}"}
{"sample": "func prepareStatement(db *sql.DB, query string) (*sql.Stmt, error) {\n\tstmt, err := db.Prepare(query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn stmt, nil\n}\n"}
{"sample": "func StartHTTPServer(addr string, handler http.Handler) *http.Server {\n\tsrv := &http.Server{\n\t\tAddr:    addr,\n\t\tHandler: handler,\n\t}\n\tgo func() {\n\t\tif err := srv.ListenAndServe(); err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"ListenAndServe(): %v\", err)\n\t\t}\n\t}()\n\treturn srv\n}\n\nfunc StopHTTPServer(srv *http.Server) {\n\tif err := srv.Shutdown(context.Background()); err != nil {\n\t\tlog.Printf(\"HTTP server Shutdown: %v\", err)\n\t}\n}"}
{"sample": "func closeStatement(stmt *sql.Stmt) error {\n\terr := stmt.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package test\n\nimport (\n\t\"fmt\"\n\t\"github.com/lmendes86/Kalbi/sip/message\"\n\t\"github.com/lmendes86/Kalbi/authentication\"\n\t\"testing\"\n)\n\nfunc TestSIPParser(t *testing.T) {\n\tbyteMsg := []byte(msg)\n\tx := message.Parse(byteMsg)\n\n\tfmt.Println(authentication.MD5Challange(\"02922401513\", \"thevoicefactory.co.uk\", \"Chuckie93@\", \"sip:thevoicefactory.co.uk\", \"BroadWorksXiv8la38lT5rbw3uBW\", \"slmssmsf\", \"00000001\", \"auth\", \"REGISTER\"))\n\t\n\tif string(x.Req.Method) != \"INVITE\" {\n\t\tt.Error(\"Method line not parsed\")\n\t}\n}\n"}
{"sample": "package main\n\nfunc CalculateAverage(numbers []float64) float64 {\n\tsum := 0.0\n\tfor _, num := range numbers {\n\t\tsum += num\n\t}\n\treturn sum / float64(len(numbers))\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\t// create an empty slice of integers\n\tnumbers := []int{}\n\n\t// add elements to the slice using the append function\n\tnumbers = append(numbers, 1, 2, 3, 4, 5)\n\n\t// print the length of the slice using the len function\n\tfmt.Printf(\"Length of numbers: %d\\n\", len(numbers))\n\n\t// print the elements of the slice using a for loop\n\tfor i, num := range numbers {\n\t\tfmt.Printf(\"Element %d: %d\\n\", i, num)\n\t}\n\n\t// iterate over the slice with a range loop, incrementing the elements by 1\n\tfor i := range numbers {\n\t\tnumbers[i]++\n\t}\n\n\t// print the updated elements of the slice\n\tfmt.Println(\"Updated numbers:\")\n\tfor _, num := range numbers {\n\t\tfmt.Println(num)\n\t}\n}"}
{"sample": "func GCD(a, b int) int {\n\tfor b != 0 {\n\t\ttemp := b\n\t\tb = a % b\n\t\ta = temp\n\t}\n\treturn a\n}\n\nfunc LCM(a, b int) int {\n\treturn a * b / GCD(a, b)\n}"}
{"sample": "package blockchain\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n//\n// Code generated by Microsoft (R) AutoRest Code Generator.\n// Changes may cause incorrect behavior and will be lost if the code is regenerated.\n\n// MemberProvisioningState enumerates the values for member provisioning state.\ntype MemberProvisioningState string\n\nconst (\n\t// Deleting ...\n\tDeleting MemberProvisioningState = \"Deleting\"\n\t// Failed ...\n\tFailed MemberProvisioningState = \"Failed\"\n\t// NotSpecified ...\n\tNotSpecified MemberProvisioningState = \"NotSpecified\"\n\t// Stale ...\n\tStale MemberProvisioningState = \"Stale\"\n\t// Succeeded ...\n\tSucceeded MemberProvisioningState = \"Succeeded\"\n\t// Updating ...\n\tUpdating MemberProvisioningState = \"Updating\"\n)\n\n// PossibleMemberProvisioningStateValues returns an array of possible values for the MemberProvisioningState const type.\nfunc PossibleMemberProvisioningStateValues() []MemberProvisioningState {\n\treturn []MemberProvisioningState{Deleting, Failed, NotSpecified, Stale, Succeeded, Updating}\n}\n\n// NameAvailabilityReason enumerates the values for name availability reason.\ntype NameAvailabilityReason string\n\nconst (\n\t// NameAvailabilityReasonAlreadyExists ...\n\tNameAvailabilityReasonAlreadyExists NameAvailabilityReason = \"AlreadyExists\"\n\t// NameAvailabilityReasonInvalid ...\n\tNameAvailabilityReasonInvalid NameAvailabilityReason = \"Invalid\"\n\t// NameAvailabilityReasonNotSpecified ...\n\tNameAvailabilityReasonNotSpecified NameAvailabilityReason = \"NotSpecified\"\n)\n\n// PossibleNameAvailabilityReasonValues returns an array of possible values for the NameAvailabilityReason const type.\nfunc PossibleNameAvailabilityReasonValues() []NameAvailabilityReason {\n\treturn []NameAvailabilityReason{NameAvailabilityReasonAlreadyExists, NameAvailabilityReasonInvalid, NameAvailabilityReasonNotSpecified}\n}\n\n// NodeProvisioningState enumerates the values for node provisioning state.\ntype NodeProvisioningState string\n\nconst (\n\t// NodeProvisioningStateDeleting ...\n\tNodeProvisioningStateDeleting NodeProvisioningState = \"Deleting\"\n\t// NodeProvisioningStateFailed ...\n\tNodeProvisioningStateFailed NodeProvisioningState = \"Failed\"\n\t// NodeProvisioningStateNotSpecified ...\n\tNodeProvisioningStateNotSpecified NodeProvisioningState = \"NotSpecified\"\n\t// NodeProvisioningStateSucceeded ...\n\tNodeProvisioningStateSucceeded NodeProvisioningState = \"Succeeded\"\n\t// NodeProvisioningStateUpdating ...\n\tNodeProvisioningStateUpdating NodeProvisioningState = \"Updating\"\n)\n\n// PossibleNodeProvisioningStateValues returns an array of possible values for the NodeProvisioningState const type.\nfunc PossibleNodeProvisioningStateValues() []NodeProvisioningState {\n\treturn []NodeProvisioningState{NodeProvisioningStateDeleting, NodeProvisioningStateFailed, NodeProvisioningStateNotSpecified, NodeProvisioningStateSucceeded, NodeProvisioningStateUpdating}\n}\n\n// Protocol enumerates the values for protocol.\ntype Protocol string\n\nconst (\n\t// ProtocolCorda ...\n\tProtocolCorda Protocol = \"Corda\"\n\t// ProtocolNotSpecified ...\n\tProtocolNotSpecified Protocol = \"NotSpecified\"\n\t// ProtocolParity ...\n\tProtocolParity Protocol = \"Parity\"\n\t// ProtocolQuorum ...\n\tProtocolQuorum Protocol = \"Quorum\"\n)\n\n// PossibleProtocolValues returns an array of possible values for the Protocol const type.\nfunc PossibleProtocolValues() []Protocol {\n\treturn []Protocol{ProtocolCorda, ProtocolNotSpecified, ProtocolParity, ProtocolQuorum}\n}\n"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--batch-size\", argparse.Int, 32, \"Batch size\")\nparser.AddArgument(\"--num-epochs\", argparse.Int, 10, \"Number of epochs\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--weight-decay\", argparse.Float, 0.001, \"Weight decay\")\nparser.AddArgument(\"--dropout\", argparse.Float, 0.5, \"Dropout rate\")\nparser.AddArgument(\"--mode\", argparse.String, \"train\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\nparser.AddArgument(\"--debug\", argparse.Bool, false, \"Enable debug mode\")\nparser.AddArgument(\"--gpu\", argparse.Bool, true, \"Enable GPU usage\")\n"}
{"sample": "// Encode a value as URL query parameter\nfunc EncodeQueryParam(value string) string {\n\treturn url.QueryEscape(value)\n}\n"}
{"sample": "package grpcserv\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\ntype server struct{}\n\nfunc (s *server) SayHello(ctx context.Context, in *HelloRequest) (*HelloReply, error) {\n\treturn &HelloReply{Message: \"Hello \" + in.Name}, nil\n}\n\nfunc StartServer() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tRegisterGreeterServer(s, &server{})\n\treflection.Register(s)\n\tfmt.Println(\"Server started on port 50051\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "type StringSet struct {\n\tset map[string]struct{}\n\tmu  sync.Mutex\n}\n\nfunc (s *StringSet) Add(value string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.set[value] = struct{}{}\n}\n\nfunc (s *StringSet) Contains(value string) bool {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\t_, exists := s.set[value]\n\treturn exists\n}"}
{"sample": "type Task struct {\n\tID    int\n\tTitle string\n\tDone  bool\n}\n\ntype TaskList struct {\n\tTasks []*Task\n\tmu    sync.Mutex\n}\n\nfunc (tl *TaskList) AddTask(task *Task) {\n\ttl.mu.Lock()\n\tdefer tl.mu.Unlock()\n\ttl.Tasks = append(tl.Tasks, task)\n}\n\nfunc (tl *TaskList) MarkTaskAsDone(id int) {\n\ttl.mu.Lock()\n\tdefer tl.mu.Unlock()\n\tfor _, task := range tl.Tasks {\n\t\tif task.ID == id {\n\t\t\ttask.Done = true\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tch := make(chan int)\n\n\twg.Add(2)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tch <- i\n\t\t}\n\t\tclose(ch)\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := range ch {\n\t\t\tfmt.Println(i)\n\t\t}\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"Done!\")\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// CountOccurrences counts the number of occurrences of a substring in a given string.\nfunc CountOccurrences(str, substr string) int {\n\treturn strings.Count(str, substr)\n}"}
{"sample": "package chatserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nfunc handleConnections(w http.ResponseWriter, r *http.Request) {\n\t// Upgrade initial GET request to a websocket\n\tws, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ws.Close()\n\n\t// Register our new client\n\tclients[ws] = true\n\n\tfor {\n\t\tvar msg Message\n\t\t// Read in a new message as JSON and map it to a Message object\n\t\terr := ws.ReadJSON(&msg)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\tdelete(clients, ws)\n\t\t\tbreak\n\t\t}\n\t\t// Send the newly received message to the broadcast channel\n\t\tbroadcast <- msg\n\t}\n}\n\nfunc handleMessages() {\n\tfor {\n\t\t// Grab the next message from the broadcast channel\n\t\tmsg := <-broadcast\n\t\t// Send it out to every client that is currently connected\n\t\tfor client := range clients {\n\t\t\terr := client.WriteJSON(msg)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t\tclient.Close()\n\t\t\t\tdelete(clients, client)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc StartServer() {\n\t// Create a simple file server\n\tfs := http.FileServer(http.Dir(\"public\"))\n\thttp.Handle(\"/\", fs)\n\n\t// Configure websocket route\n\thttp.HandleFunc(\"/ws\", handleConnections)\n\n\t// Start listening for incoming chat messages\n\tgo handleMessages()\n\n\t// Start the server on localhost port 8080 and log any errors\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err)\n\t}\n}"}
{"sample": "package pigeonholesort\n\nfunc PigeonholeSort(arr []int) []int {\n\tmin := arr[0]\n\tmax := arr[0]\n\tn := len(arr)\n\n\tfor i := 1; i < n; i++ {\n\t\tif arr[i] < min {\n\t\t\tmin = arr[i]\n\t\t}\n\t\tif arr[i] > max {\n\t\t\tmax = arr[i]\n\t\t}\n\t}\n\n\trangeSize := max - min + 1\n\n\tholes := make([]int, rangeSize)\n\n\tfor i := 0; i < n; i++ {\n\t\tholes[arr[i]-min]++\n\t}\n\n\tindex := 0\n\tfor i := 0; i < rangeSize; i++ {\n\t\tfor holes[i] > 0 {\n\t\t\tarr[index] = i + min\n\t\t\tindex++\n\t\t\tholes[i]--\n\t\t}\n\t}\n\n\treturn arr\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintSumOfArray([]int{1, 2, 3, 4, 5})\n}\n\n// Function to print the sum of elements in an array\nfunc PrintSumOfArray(arr []int) {\n\tsum := 0\n\tfor _, value := range arr {\n\t\tsum += value\n\t}\n\tfmt.Println(sum)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"log\"\n)\n\nfunc LogRequests() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tlog.Printf(\"[%s] %s %s\", r.Method, r.URL.Path, r.RemoteAddr)\n\n\t\tfmt.Fprintf(w, \"Hello, World!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n"}
{"sample": "package main\n\n// Truncate a file\nfunc main() {\n\terr := os.Truncate(\"file.txt\", 100)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "// Error handling with if statement\n\nerr := doSomething()\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package kafkaclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/segmentio/kafka-go\"\n)\n\nfunc processMessages(ctx context.Context, r *kafka.Reader) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t\tm, err := r.ReadMessage(ctx)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Printf(\"Received message: %s\\n\", string(m.Value))\n\t\t\t// process message here\n\t\t}\n\t}\n}\n\nfunc startKafkaClient() {\n\tbrokers := []string{\"localhost:9092\"}\n\ttopic := \"my-topic\"\n\tgroupID := \"my-group\"\n\n\tr := kafka.NewReader(kafka.ReaderConfig{\n\t\tBrokers:  brokers,\n\t\tTopic:    topic,\n\t\tGroupID:  groupID,\n\t\tMinBytes: 10e3, // 10KB\n\t\tMaxBytes: 10e6, // 10MB\n\t})\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tgo processMessages(ctx, r)\n\n\tsigterm := make(chan os.Signal, 1)\n\tsignal.Notify(sigterm, os.Interrupt)\n\tselect {\n\tcase <-sigterm:\n\t\tlog.Println(\"Received SIGTERM, shutting down gracefully\")\n\tcase <-ctx.Done():\n\t\tlog.Println(\"Context cancelled, shutting down gracefully\")\n\t}\n\n\tif err := r.Close(); err != nil {\n\t\tlog.Fatalf(\"Error closing reader: %v\", err)\n\t}\n}\n\nfunc main() {\n\tstartKafkaClient()\n\ttime.Sleep(time.Second * 10)\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(\"Enter the string to split:\")\n\treader := bufio.NewReader(os.Stdin)\n\tstr, _ := reader.ReadString('\\n')\n\tfmt.Println(\"Enter the separator character:\")\n\tsep, _ := reader.ReadString('\\n')\n\n\t// Removing newline characters\n\tstr = strings.TrimSuffix(str, \"\\n\")\n\tsep = strings.TrimSuffix(sep, \"\\n\")\n\n\tresult := strings.Split(str, sep)\n\tfmt.Printf(\"Result: %v\\n\", result)\n}"}
{"sample": "package main\n\nimport \"os\"\n\nfunc main() {\n\tfmt.Println(os.Getwd())\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\n// FetchURL fetches the content of a URL using an HTTP GET request.\nfunc FetchURL(url string) (string, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintIsNumberOdd(11)\n}\n\n// Function to check if a number is odd\nfunc PrintIsNumberOdd(n int) {\n\tfmt.Println(n%2 != 0)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName    string   `json:\"name\"`\n\tAge     int      `json:\"age,omitempty\"`\n\tEmail   string   `json:\"email,omitempty\"`\n\tHobbies []string `json:\"hobbies,omitempty\"`\n}\n\nfunc main() {\n\tpersonJSON := `\n\t{\n\t\t\"name\": \"John Doe\",\n\t\t\"age\": 30,\n\t\t\"hobbies\": [\"reading\", \"cooking\"]\n\t}`\n\n\tvar person Person\n\tif err := json.Unmarshal([]byte(personJSON), &person); err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(person) // Person{Name:\"John Doe\", Age:30, Email:\"\", Hobbies:[reading cooking]}\n\n\tnewPerson := Person{\n\t\tName: \"Jane Smith\",\n\t}\n\n\tnewPersonJSON, err := json.Marshal(newPerson)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(string(newPersonJSON)) // {\"name\":\"Jane Smith\"}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tnumWorkers := 5\n\tjobs := make(chan int, numWorkers*2) // buffer jobs to prevent deadlock\n\n\t// Add jobs to channel\n\tgo func() {\n\t\tfor i := 0; i < numWorkers*2; i++ {\n\t\t\tjobs <- i\n\t\t}\n\t\tclose(jobs)\n\t}()\n\n\t// Start worker goroutines\n\tfor i := 0; i < numWorkers; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor job := range jobs {\n\t\t\t\tfmt.Printf(\"Worker %d handling job %d\\n\", id, job)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\t// Wait for workers to finish\n\twg.Wait()\n\tfmt.Println(\"All jobs complete\")\n}"}
{"sample": "func OpenFile(filename string) (*os.File, error) {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open file: %v\", err)\n\t}\n\treturn file, nil\n}\n\nfunc ReadFile(file *os.File) ([]byte, error) {\n\tbytes, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read file: %v\", err)\n\t}\n\treturn bytes, nil\n}\n\nfunc CloseFile(file *os.File) error {\n\tif err := file.Close(); err != nil {\n\t\treturn fmt.Errorf(\"failed to close file: %v\", err)\n\t}\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc ServeWebSocket() {\n\thttp.HandleFunc(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, _ := websocket.Upgrade(w, r, nil, 1024, 1024)\n\t\tdefer conn.Close()\n\n\t\tfor {\n\t\t\tmessageType, message, _ := conn.ReadMessage()\n\t\t\tfmt.Println(string(message))\n\n\t\t\t// Handle the received message\n\n\t\t\tconn.WriteMessage(messageType, []byte(\"Received\"))\n\t\t}\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n"}
{"sample": "// Reverse a string\nfunc ReverseString(str string) string {\n\trunes := []rune(str)\n\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n\t\trunes[i], runes[j] = runes[j], runes[i]\n\t}\n\treturn string(runes)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\tpath := \"/path/to/directory\"\n\n\terr := filepath.Walk(path, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error walking path:\", err)\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Println(path)\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tfmt.Println(\"Error walking path:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "package tcpconn\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc StartServer(port string) {\n\tlistener, err := net.Listen(\"tcp\", \":\"+port)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting TCP server:\", err)\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\tfmt.Println(\"TCP server started on port\", port)\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\tbuffer := make([]byte, 1024)\n\n\tfor {\n\t\tbytesRead, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading from connection:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Println(\"Received message:\", string(buffer[:bytesRead]))\n\n\t\t_, err = conn.Write([]byte(\"Message received\"))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error writing to connection:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc ConnectToServer(address string) {\n\tconn, err := net.Dial(\"tcp\", address)\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to server:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tmessage := []byte(\"Hello, server!\")\n\t_, err = conn.Write(message)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending message to server:\", err)\n\t\treturn\n\t}\n\n\tbuffer := make([]byte, 1024)\n\tbytesRead, err := conn.Read(buffer)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading from connection:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Received response:\", string(buffer[:bytesRead]))\n}"}
{"sample": "// HashPassword hashes a password using bcrypt.\nfunc HashPassword(password string) (string, error) {\n\tbytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(bytes), nil\n}\n\n// CheckPasswordHash checks a password against a hashed password.\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}"}
{"sample": "package performanceservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"models\"\n\t\"time\"\n)\n\ntype PerformanceService struct {\n\trepo models.PerformanceRepository\n}\n\nfunc NewPerformanceService(repo models.PerformanceRepository) *PerformanceService {\n\treturn &PerformanceService{\n\t\trepo: repo,\n\t}\n}\n\nfunc (s *PerformanceService) CreatePerformance(ctx context.Context, performance *models.Performance) error {\n\tif performance.EmployeeID == \"\" {\n\t\treturn errors.New(\"employee id is required\")\n\t}\n\n\tif performance.ManagerID == \"\" {\n\t\treturn errors.New(\"manager id is required\")\n\t}\n\n\tif performance.Rating < 1 || performance.Rating > 5 {\n\t\treturn errors.New(\"rating should be between 1 and 5\")\n\t}\n\n\tperformance.CreatedAt = time.Now().UTC()\n\n\treturn s.repo.CreatePerformance(ctx, performance)\n}\n\nfunc (s *PerformanceService) GetPerformance(ctx context.Context, id string) (*models.Performance, error) {\n\treturn s.repo.GetPerformance(ctx, id)\n}\n\nfunc (s *PerformanceService) GetPerformances(ctx context.Context, employeeID string, from, to time.Time) ([]*models.Performance, error) {\n\treturn s.repo.GetPerformances(ctx, employeeID, from, to)\n}\n\nfunc (s *PerformanceService) GetManagerPerformances(ctx context.Context, managerID string, from, to time.Time) ([]*models.Performance, error) {\n\treturn s.repo.GetManagerPerformances(ctx, managerID, from, to)\n}"}
{"sample": "package achievementservice\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n)\n\ntype Achievement struct {\n\tID          int\n\tName        string\n\tDescription string\n}\n\ntype AchievementService struct {\n\tdb *sql.DB\n}\n\nfunc NewAchievementService(db *sql.DB) *AchievementService {\n\treturn &AchievementService{db: db}\n}\n\nfunc (s *AchievementService) CreateAchievement(a *Achievement) error {\n\tif a == nil {\n\t\treturn errors.New(\"achievement is nil\")\n\t}\n\n\tstmt, err := s.db.Prepare(\"INSERT INTO achievements(name, description) VALUES(?, ?)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tresult, err := stmt.Exec(a.Name, a.Description)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tid, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ta.ID = int(id)\n\n\treturn nil\n}\n\nfunc (s *AchievementService) GetAchievement(id int) (*Achievement, error) {\n\tstmt, err := s.db.Prepare(\"SELECT id, name, description FROM achievements WHERE id = ?\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\trow := stmt.QueryRow(id)\n\n\tvar a Achievement\n\terr = row.Scan(&a.ID, &a.Name, &a.Description)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &a, nil\n}\n\nfunc (s *AchievementService) UpdateAchievement(a *Achievement) error {\n\tif a == nil {\n\t\treturn errors.New(\"achievement is nil\")\n\t}\n\n\tstmt, err := s.db.Prepare(\"UPDATE achievements SET name = ?, description = ? WHERE id = ?\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(a.Name, a.Description, a.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *AchievementService) DeleteAchievement(id int) error {\n\tstmt, err := s.db.Prepare(\"DELETE FROM achievements WHERE id = ?\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *AchievementService) ListAchievements() ([]*Achievement, error) {\n\trows, err := s.db.Query(\"SELECT id, name, description FROM achievements\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tachievements := make([]*Achievement, 0)\n\tfor rows.Next() {\n\t\tvar a Achievement\n\t\terr := rows.Scan(&a.ID, &a.Name, &a.Description)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tachievements = append(achievements, &a)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn achievements, nil\n}\n\nfunc (a *Achievement) String() string {\n\treturn fmt.Sprintf(\"ID: %d, Name: %s, Description: %s\", a.ID, a.Name, a.Description)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintIsNumberEven(10)\n}\n\n// Function to check if a number is even\nfunc PrintIsNumberEven(n int) {\n\tfmt.Println(n%2 == 0)\n}"}
{"sample": "package udp_test\n\nimport (\n\t\"net\"\n\t\"testing\"\n)\n\nfunc TestUDPConnection(t *testing.T) {\n\taddr := \"127.0.0.1:8080\"\n\n\tconn, err := net.Dial(\"udp\", addr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tmsg := []byte(\"Hello from client!\")\n\tif _, err := conn.Write(msg); err != nil {\n\t\tt.Fatalf(\"Failed to send message: %v\", err)\n\t}\n\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to receive message: %v\", err)\n\t}\n\n\tif string(buf[:n]) != \"Hello from server!\" {\n\t\tt.Fatalf(\"Expected 'Hello from server!', but got '%s'\", string(buf[:n]))\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"bufio\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tfmt.Println(scanner.Text())\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Println(\"Error scanning file:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "func RunCommand(name string, args ...string) ([]byte, error) {\n\tcmd := exec.Command(name, args...)\n\treturn cmd.Output()\n}\n\nfunc RunCommandWithInput(name string, input []byte, args ...string) ([]byte, error) {\n\tcmd := exec.Command(name, args...)\n\tcmd.Stdin = bytes.NewBuffer(input)\n\treturn cmd.Output()\n}"}
{"sample": "package jobqueue\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype Job struct {\n\tID     int\n\tStatus string\n}\n\ntype JobQueue struct {\n\tjobs      []*Job\n\tmaxLength int\n\tmu        sync.Mutex\n}\n\nfunc NewJobQueue(maxLength int) *JobQueue {\n\treturn &JobQueue{\n\t\tjobs:      []*Job{},\n\t\tmaxLength: maxLength,\n\t}\n}\n\nfunc (jq *JobQueue) AddJob(j *Job) error {\n\tjq.mu.Lock()\n\tdefer jq.mu.Unlock()\n\n\tif len(jq.jobs) >= jq.maxLength {\n\t\treturn fmt.Errorf(\"job queue is full\")\n\t}\n\n\tjq.jobs = append(jq.jobs, j)\n\n\treturn nil\n}\n\nfunc (jq *JobQueue) GetJob() *Job {\n\tjq.mu.Lock()\n\tdefer jq.mu.Unlock()\n\n\tif len(jq.jobs) == 0 {\n\t\treturn nil\n\t}\n\n\tjob := jq.jobs[0]\n\tjq.jobs = jq.jobs[1:]\n\n\treturn job\n}\n\nfunc (jq *JobQueue) Length() int {\n\tjq.mu.Lock()\n\tdefer jq.mu.Unlock()\n\n\treturn len(jq.jobs)\n}"}
{"sample": "err := doSomething()\nif err != nil {\n\tlog.Fatalf(\"Error: %v\", err)\n}\n"}
{"sample": "type Cacher interface {\n\tGet(key string) (interface{} error)\n\tSet(key string, value interface{}) error\n}\n\nfunc CacheMiddleware(cacher Cacher, next http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tkey := r.URL.Path\n\t\tif value, err := cacher.Get(key); err == nil && value != nil {\n\t\t\tfmt.Fprint(w, value)\n\t\t\treturn\n\t\t}\n\n\t\trecorder := httptest.NewRecorder()\n\t\tnext(recorder, r)\n\n\t\tres := recorder.Result()\n\t\tbody, _ := ioutil.ReadAll(res.Body)\n\t\tcacher.Set(key, string(body))\n\n\t\tw.WriteHeader(res.StatusCode)\n\t\tw.Write(body)\n\t}\n}"}
{"sample": "package emailrouter\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/smtp\"\n\t\"strings\"\n)\n\ntype Email struct {\n\tTo      []string\n\tSubject string\n\tBody    string\n}\n\ntype EmailService struct {\n\tSMTPHost string\n\tSMTPPort int\n\tUsername string\n\tPassword string\n}\n\nfunc (es *EmailService) SendEmail(e *Email) error {\n\tauth := smtp.PlainAuth(\"\", es.Username, es.Password, es.SMTPHost)\n\n\tto := strings.Join(e.To, \",\")\n\n\tmsg := fmt.Sprintf(\"To: %s\\r\\nSubject: %s\\r\\n\\r\\n%s\", to, e.Subject, e.Body)\n\n\terr := smtp.SendMail(fmt.Sprintf(\"%s:%d\", es.SMTPHost, es.SMTPPort), auth, es.Username, e.To, []byte(msg))\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\ntype EmailRouter struct {\n\tEmailServices map[string]*EmailService\n}\n\nfunc (er *EmailRouter) RouteEmail(e *Email, service string) error {\n\tes, ok := er.EmailServices[service]\n\tif !ok {\n\t\treturn fmt.Errorf(\"Email service not found\")\n\t}\n\n\treturn es.SendEmail(e)\n}"}
{"sample": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc fetch(url, method, data string) (string, error) {\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, strings.NewReader(data))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(bodyBytes), nil\n}\n\nfunc main() {\n\tresponse, err := fetch(\"https://jsonplaceholder.typicode.com/posts/1\", \"GET\", \"\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Println(response)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(num int) {\n\t\t\tdefer wg.Done()\n\t\t\tfmt.Printf(\"Goroutine %d\\n\", num)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package main\n\nfunc FindMax(numbers []int) int {\n\tmax := numbers[0]\n\tfor _, num := range numbers {\n\t\tif num > max {\n\t\t\tmax = num\n\t\t}\n\t}\n\treturn max\n}\n"}
{"sample": "package main\n\nimport \"os\"\n\nfunc main() {\n\targs := os.Args\n\tPrintArgs(args)\n}\n\nfunc PrintArgs(args []string) {\n\tfor i := range args {\n\t\tfmt.Println(args[i])\n\t}\n}"}
{"sample": "func main() {\n\tticker := time.NewTicker(1 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\tfmt.Println(\"Tick\")\n\t}\n}"}
{"sample": "func main() {\n\tcmd := exec.Command(\"ls\", \"-l\")\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\terr := cmd.Run()\n\tif err != nil {\n\t\tfmt.Println(\"Error running command:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "package util\n\nimport (\n\t\"bufio\"\n\t\"compress/gzip\"\n\t\"fmt\"\n\t\"github.com/cespare/xxhash\"\n\t\"github.com/satori/go.uuid\"\n\t\"github.com/tjones879/fake/structs\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/url\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar rootDir = \"/home/jones/fake\"\n\nfunc getFileHash(contents string) (hash uint64) {\n\thash = xxhash.Sum64String(contents)\n\treturn\n}\n\n/*\nTake the hash of a file and get its correct file path.\nPad the front of the hash with 0's and split into 5\ngroups of 4 digits.\n*/\nfunc getPathByHash(hash uint64) (path string) {\n\tvar filePath [5]string\n\tj := 0\n\tres := \"\"\n\thashStr := fmt.Sprintf(\"%020d\", hash)\n\n\tfor i, r := range hashStr {\n\t\tres = res + string(r)\n\t\tif i > 0 && (i+1)%4 == 0 {\n\t\t\tfilePath[j] = res\n\t\t\tres = \"\"\n\t\t\tj++\n\t\t}\n\t}\n\n\tpath = rootDir\n\tfor _, s := range filePath {\n\t\tpath += \"/\" + s\n\t}\n\treturn\n}\n\n/*\nGet the file name of a page by taking the host, path, and queries.\nLimit the name to the last 30 characters.\n*/\nfunc getFileNameByURL(uri string) (name string) {\n\tmax := func(a, b int) int {\n\t\tif a > b {\n\t\t\treturn a\n\t\t}\n\t\treturn b\n\t}\n\n\tlink, _ := url.Parse(uri)\n\trunes := []rune(link.Host + link.Path + link.RawQuery)\n\tchars := max(len(runes)-30, 0)\n\tname = string(runes[chars:])\n\tname = strings.Replace(name, \"/\", \"-\", -1)\n\tname = strings.Replace(name, \".\", \"-\", -1)\n\treturn\n}\n\n/*\nCompress a file's contents into the passed bytes buffer.\n*/\nfunc compressFile(buf *bufio.Writer, contents string) {\n\tzw := gzip.NewWriter(buf)\n\t_, err := zw.Write([]byte(contents))\n\tif err != nil {\n\t\tfmt.Println(\"compressFile:\", err)\n\t}\n\tif err = zw.Close(); err != nil {\n\t\tfmt.Println(\"compressFile:\", err)\n\t}\n\treturn\n}\n\n/*\nDecompress file\n*/\nfunc decompressFile(buf io.Reader) string {\n\tzr, err := gzip.NewReader(buf)\n\tif err != nil {\n\t\tfmt.Println(\"1)decompressFile:\", err)\n\t}\n\tcontents, err := ioutil.ReadAll(zr)\n\tif err != nil {\n\t\tfmt.Println(\"2)decompressFile:\", err)\n\t}\n\tzr.Close()\n\treturn string(contents)\n}\n\n// CreateStorage TODO\nfunc CreateStorage(hash uint64, uri, contents string) (file structs.FileStorage) {\n\tfile.Hash = strconv.FormatUint(hash, 10)\n\tfile.Directory = getPathByHash(hash)\n\tfile.Name = getFileNameByURL(uri)\n\tfile.Contents = contents\n\tfile.UID = uuid.NewV4().String()\n\treturn\n}\n\n// SaveFile TODO\nfunc SaveFile(f *structs.FileStorage) {\n\tif !f.FileExists() {\n\t\tos.MkdirAll(f.Directory, 0777)\n\t\tfd, err := os.OpenFile(f.Directory+\"/\"+f.Name, os.O_CREATE|os.O_WRONLY, 0666)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"SaveFile:\", err)\n\t\t}\n\t\twriter := bufio.NewWriter(fd)\n\t\tcompressFile(writer, f.Contents)\n\t\t_ = writer.Flush()\n\t\tfd.Close()\n\t}\n}\n\n/*\nLoadFile will load and decompress a file by name and hash\n*/\nfunc LoadFile(f *structs.FileStorage) {\n\tif f.FileExists() {\n\t\tfd, err := os.OpenFile(f.Directory+\"/\"+f.Name, os.O_RDONLY, 0666)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"LoadFile:\", err)\n\t\t}\n\t\tf.Contents = decompressFile(fd)\n\t\tfd.Close()\n\t}\n}\n"}
{"sample": "package bigcsv\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n)\n\nfunc processCSV(filename string) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\n\t// Set the number of expected fields\n\treader.FieldsPerRecord = 3\n\n\t// Read the header row\n\theader, err := reader.Read()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create a channel to receive the rows\n\trowChan := make(chan []string)\n\n\t// Create a wait group to wait for all the workers to finish\n\tvar wg sync.WaitGroup\n\n\t// Start 10 workers to process the rows concurrently\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor row := range rowChan {\n\t\t\t\t// Process the row\n\t\t\t\tfmt.Println(row)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Read the rows and send them to the workers\n\tfor {\n\t\trow, err := reader.Read()\n\t\tif err != nil {\n\t\t\tif err.Error() == \"EOF\" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\trowChan <- row\n\t}\n\n\t// Close the channel to signal the workers to finish\n\tclose(rowChan)\n\n\t// Wait for all the workers to finish\n\twg.Wait()\n\n\treturn nil\n}"}
{"sample": "func main() {\n\ttmpl, err := template.ParseFiles(\"template.html\")\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing template:\", err)\n\t\treturn\n\t}\n\n\tdata := struct{\n\t\tName string\n\t\tAge  int\n\t}{\n\t\tName: \"John Doe\",\n\t\tAge:  30,\n\t}\n\n\terr = tmpl.Execute(os.Stdout, data)\n\tif err != nil {\n\t\tfmt.Println(\"Error executing template:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "package postgres\n\nimport (\n\t\"fmt\"\n\t\"github.com/wzslr321/models\"\n\t\"github.com/wzslr321/settings\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/logger\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n)\n\nvar DB *gorm.DB\n\nfunc checkError(err error) {\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc InitPostgre() {\n\tvar err error\n\n\tvar newLogger = logger.New(\n\t\tlog.New(os.Stdout, \"\\r\\n\", log.LstdFlags),\n\t\tlogger.Config{\n\t\t\tSlowThreshold: time.Second,\n\t\t\tLogLevel:      logger.Silent,\n\t\t\tColorful:      true,\n\t\t},\n\t)\n\n\tvar s = settings.PostgresSettings\n\n\tdsn := fmt.Sprintf(\n\t\t\"host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=%s\",\n\t\ts.Host, s.User, s.Password, s.DBName, s.Addr, s.SSLMode, s.TimeZone,\n\t)\n\n\tDB, err = gorm.Open(postgres.New(postgres.Config{\n\t\tDSN: dsn,\n\t}), &gorm.Config{\n\t\tLogger: newLogger,\n\t})\n\tcheckError(err)\n\n\t_ = DB.AutoMigrate(\n\t\t&models.Post{},\n\t)\n\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\turls := []string{\"https://example.com\", \"https://google.com\", \"https://github.com\"}\n\tresults := make(chan string, len(urls))\n\tvar wg sync.WaitGroup\n\n\tfor _, url := range urls {\n\t\twg.Add(1)\n\t\tgo func(u string) {\n\t\t\tdefer wg.Done()\n\t\t\tresp, err := http.Get(u)\n\t\t\tif err != nil {\n\t\t\t\tresults <- fmt.Sprintf(\"Error fetching %s: %s\", u, err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\tresults <- fmt.Sprintf(\"Error reading response body for %s: %s\", u, err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- string(body)\n\t\t}(url)\n\t}\n\n\twg.Wait()\n\tclose(results)\n\n\tfor result := range results {\n\t\tfmt.Println(result)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/spf13/cobra\"\n)\n\nvar rootCmd = &cobra.Command{\n\tUse:   \"myapp\",\n\tShort: \"A brief description of my app\",\n\tLong:  `A longer description that explains more about what my app does and how it works`,\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tfmt.Println(\"Hello, World!\")\n\t},\n}\n\nfunc main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n}"}
{"sample": "package main\n\n// This function reads from a gzip file\nfunc ReadGzipFile(filename string) ([]byte, error) {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\tgzReader, err := gzip.NewReader(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer gzReader.Close()\n\tcontent, err := ioutil.ReadAll(gzReader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn content, nil\n}\n\n// This function writes to a gzip file\nfunc WriteGzipFile(filename string, data []byte) error {\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tgzWriter := gzip.NewWriter(file)\n\tdefer gzWriter.Close()\n\t_, err = gzWriter.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\terr := WriteGzipFile(\"file.txt.gz\", []byte(\"Hello, World!\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcontent, err := ReadGzipFile(\"file.txt.gz\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(content))\n}\n"}
{"sample": "package main\n\nfunc GetStringLength(str string) int {\n\treturn len(str)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/lib/pq\"\n)\n\ntype User struct {\n\tID        int\n\tFirstName string\n\tLastName  string\n\tEmail     string\n\tCreatedAt time.Time\n}\n\nvar db *sql.DB\n\nfunc main() {\n\tconnStr := \"postgres://user:password@localhost/dbname?sslmode=disable\"\n\n\tgo func() {\n\t\tif err := createTables(); err != nil {\n\t\t\tlog.Fatalf(\"Error creating tables: %v\", err)\n\t\t}\n\t}()\n\n\tvar err error\n\tdb, err = sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error connecting to database: %v\", err)\n\t}\n\n\tlog.Println(\"Connected to database\")\n\tdefer db.Close()\n\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/{id}\", getUser).Methods(http.MethodGet)\n\tr.HandleFunc(\"/\", createUser).Methods(http.MethodPost)\n\n\tlog.Println(\"Server started on port 8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}\n\nfunc getUser(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\n\tquery := `\n\t\tSELECT id, first_name, last_name, email, created_at\n\t\tFROM users\n\t\tWHERE id=$1\n\t`\n\n\tuser := User{}\n\tif err := db.QueryRow(query, id).Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.CreatedAt); err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\tfmt.Fprint(w, \"User not found\")\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Error getting user %s: %v\", id, err)\n\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, \"Oops, something went wrong. Please try again later.\")\n\t\treturn\n\t}\n\n\tfmt.Fprint(w, user)\n}\n\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n\tfirstName := r.FormValue(\"first_name\")\n\tlastName := r.FormValue(\"last_name\")\n\temail := r.FormValue(\"email\")\n\n\tif firstName == \"\" || lastName == \"\" || email == \"\" {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, \"Please provide first name, last name, and email\")\n\t\treturn\n\t}\n\n\tquery := `\n\t\tINSERT INTO users (first_name, last_name, email, created_at)\n\t\tVALUES ($1, $2, $3, $4)\n\t\tRETURNING id\n\t`\n\n\tid := 0\n\tif err := db.QueryRow(query, firstName, lastName, email, time.Now()).Scan(&id); err != nil {\n\t\tif err, ok := err.(*pq.Error); ok {\n\t\t\tswitch err.Code.Name() {\n\t\t\tcase \"unique_violation\":\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\tfmt.Fprint(w, \"This email is already registered. Please use another email address.\")\n\t\t\tcase \"check_violation\":\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\tfmt.Fprint(w, \"Please provide a valid email\")\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"Error creating user: %v\", err)\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\tfmt.Fprint(w, \"Oops, something went wrong. Please try again later.\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Error creating user: %v\", err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, \"Oops, something went wrong. Please try again later.\")\n\t\treturn\n\t}\n\n\t// Return the ID of the created user in the response body\n\tfmt.Fprint(w, id)\n}\n\nfunc createTables() error {\n\tconnStr := \"postgres://user:password@localhost/dbname?sslmode=disable\"\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to connect to database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\tquery := `\n\t\tCREATE TABLE IF NOT EXISTS users (\n\t\t\tid SERIAL PRIMARY KEY,\n\t\t\tfirst_name VARCHAR(100) NOT NULL,\n\t\t\tlast_name VARCHAR(100) NOT NULL,\n\t\t\temail VARCHAR(100) NOT NULL UNIQUE CHECK (email ~* '^[a-z0-9._%+\\-]+@[a-z0-9.\\-]+\\.[a-z]{2,}$'),\n\t\t\tcreated_at TIMESTAMPTZ DEFAULT NOW()\n\t\t)\n\t`\n\tif _, err := db.Exec(query); err != nil {\n\t\treturn fmt.Errorf(\"Failed to create users table: %v\", err)\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(GenerateFactorial(5))\n}\n\n// Function to generate factorial of a number\nfunc GenerateFactorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * GenerateFactorial(n-1)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// CountOccurrences counts the number of occurrences of a substring in a given string.\nfunc CountOccurrences(str, substr string) int {\n\treturn strings.Count(str, substr)\n}"}
{"sample": "// LogErrorAndSendEmail logs the error and sends an email (dummy function)\nfunc LogErrorAndSendEmail(err error) {\n\tif err != nil {\n\t\tlog.Println(err)\n\t\t// Assume SendEmail is defined\n\t\t// SendEmail(\"admin@domain.com\", \"An error occurred\", err.Error())\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"data.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tstat, err := file.Stat()\n\tif err != nil {\n\t\tfmt.Println(\"Error getting file information:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"File size:\", stat.Size(), \"bytes\")\n}"}
{"sample": "package neo4jclient\n\nimport (\n\t\"fmt\"\n\t\"github.com/neo4j/neo4j-go-driver/v4/neo4j\"\n)\n\ntype Neo4jClient struct {\n\tdriver neo4j.Driver\n}\n\nfunc NewNeo4jClient(uri, username, password string) (*Neo4jClient, error) {\n\tdriver, err := neo4j.NewDriver(uri, neo4j.BasicAuth(username, password, \"\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Neo4jClient{driver: driver}, nil\n}\n\nfunc (c *Neo4jClient) Close() error {\n\treturn c.driver.Close()\n}\n\nfunc (c *Neo4jClient) Run(query string, params map[string]interface{}) ([][]interface{}, error) {\n\tsession := c.driver.NewSession(neo4j.SessionConfig{})\n\tdefer session.Close()\n\n\tresult, err := session.Run(query, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rows [][]interface{}\n\tfor result.Next() {\n\t\trow := make([]interface{}, len(result.Record().Values))\n\t\tfor i, value := range result.Record().Values {\n\t\t\trow[i] = value\n\t\t}\n\t\trows = append(rows, row)\n\t}\n\n\tif err := result.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn rows, nil\n}\n\nfunc (c *Neo4jClient) GetNode(id int64) (map[string]interface{}, error) {\n\tquery := \"MATCH (n) WHERE id(n) = $id RETURN n\"\n\tparams := map[string]interface{}{\"id\": id}\n\n\trows, err := c.Run(query, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(rows) == 0 {\n\t\treturn nil, fmt.Errorf(\"node not found\")\n\t}\n\n\treturn rows[0][0].(neo4j.Node).Props(), nil\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--host\", argparse.String, \"localhost\", \"Server host\")\nparser.AddArgument(\"--port\", argparse.Int, 8080, \"Server port\")\n"}
{"sample": "slice := make([]int, 5)\n"}
{"sample": "// Read the response body as a string\nfunc ReadBody(response *http.Response) (string, error) {\n\tbody, err := ioutil.ReadAll(response.Body)\n\treturn string(body), err\n}\n"}
{"sample": "package main\n\n// IfErrorThenPanic checks if an error exists, if so, panics\nfunc IfErrorThenPanic(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"}
{"sample": "package bloomfilter\n\nimport (\n\t\"hash/fnv\"\n\t\"math\"\n)\n\ntype BloomFilter struct {\n\tbitset []bool\n\tk      uint\n}\n\nfunc New(m uint, k uint) *BloomFilter {\n\treturn &BloomFilter{\n\t\tbitset: make([]bool, m),\n\t\tk:      k,\n\t}\n}\n\nfunc (bf *BloomFilter) Add(item []byte) {\n\thash1, hash2 := bf.getHashes(item)\n\n\tfor i := uint(0); i < bf.k; i++ {\n\t\tindex := (hash1 + i*hash2) % uint(len(bf.bitset))\n\t\tbf.bitset[index] = true\n\t}\n}\n\nfunc (bf *BloomFilter) Contains(item []byte) bool {\n\thash1, hash2 := bf.getHashes(item)\n\n\tfor i := uint(0); i < bf.k; i++ {\n\t\tindex := (hash1 + i*hash2) % uint(len(bf.bitset))\n\t\tif !bf.bitset[index] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (bf *BloomFilter) getHashes(item []byte) (uint, uint) {\n\thasher1 := fnv.New32()\n\thasher2 := fnv.New32a()\n\n\thasher1.Write(item)\n\thasher2.Write(item)\n\n\thash1 := uint(hasher1.Sum32())\n\thash2 := uint(hasher2.Sum32())\n\n\treturn hash1, hash2\n}\n\nfunc (bf *BloomFilter) GetFalsePositiveRate(n uint) float64 {\n\treturn math.Pow(1-math.Exp(-float64(bf.k)*float64(n)/float64(len(bf.bitset))), float64(bf.k))\n}"}
{"sample": "func main() {\n\tstr := \"hello world\"\n\twords := strings.Fields(str)\n\n\tfor _, word := range words {\n\t\tfmt.Println(word)\n\t}\n}"}
{"sample": "package main\n\n// IfErrorPrintStackTrace checks if an error exists, if so, prints the stack trace\nfunc IfErrorPrintStackTrace(err error) {\n\tif err != nil {\n\t\tfmt.Printf(\"%+v\", err)\n\t}\n}\n"}
{"sample": "// ConvertErrorToJSON converts an error to a JSON string (dummy function)\nfunc ConvertErrorToJSON(err error) string {\n\t// Let's assume err has fields 'Type' and 'Message'\n\t// return json.Marshal(err)\n\treturn \"\"\n}\n"}
{"sample": "items := []int{1, 2, 3}\nitems = append(items, 4, 5)\n"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc main() {\n\t// Open connection to database\n\tdb, err := sql.Open(\"mysql\", \"username:password@tcp(database.host:port)/database_name\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Ping database to check if connection is successful\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Define handler function for root path\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Query database for users\n\t\trows, err := db.Query(\"SELECT * FROM users\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer rows.Close()\n\n\t\t// Process rows and send data in response\n\t\tvar data string\n\t\tfor rows.Next() {\n\t\t\tvar id int\n\t\t\tvar name string\n\t\t\terr := rows.Scan(&id, &name)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tdata += fmt.Sprintf(\"ID: %d, Name: %s\\n\", id, name)\n\t\t}\n\n\t\t// Send data in response\n\t\tfmt.Fprintf(w, data)\n\t})\n\n\t// Start server\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"}
{"sample": "package rangedbserver_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/status\"\n\t\"google.golang.org/grpc/test/bufconn\"\n\n\t\"github.com/inklabs/rangedb/pkg/clock/provider/sequentialclock\"\n\t\"github.com/inklabs/rangedb/pkg/grpc/rangedbpb\"\n\t\"github.com/inklabs/rangedb/pkg/grpc/rangedbserver\"\n\t\"github.com/inklabs/rangedb/pkg/jsontools\"\n\t\"github.com/inklabs/rangedb/provider/inmemorystore\"\n\t\"github.com/inklabs/rangedb/rangedbtest\"\n)\n\nfunc ExampleRangeDBServer_Save_failureResponse() {\n\t// Given\n\tinMemoryStore := inmemorystore.New(\n\t\tinmemorystore.WithClock(sequentialclock.New()),\n\t)\n\trangedbtest.BindEvents(inMemoryStore)\n\n\t// Setup gRPC server\n\tbufListener := bufconn.Listen(7)\n\tserver := grpc.NewServer()\n\tdefer server.Stop()\n\trangeDBServer, err := rangedbserver.New(rangedbserver.WithStore(inMemoryStore))\n\tPrintError(err)\n\tdefer rangeDBServer.Stop()\n\trangedbpb.RegisterRangeDBServer(server, rangeDBServer)\n\tgo func() {\n\t\tPrintError(server.Serve(bufListener))\n\t}()\n\n\t// Setup gRPC connection\n\tdialer := grpc.WithContextDialer(func(context.Context, string) (net.Conn, error) {\n\t\treturn bufListener.Dial()\n\t})\n\tconnCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\tconn, err := grpc.DialContext(connCtx, \"bufnet\", dialer, grpc.WithInsecure(), grpc.WithBlock())\n\tPrintError(err)\n\tdefer Close(conn)\n\n\t// Setup gRPC client\n\trangeDBClient := rangedbpb.NewRangeDBClient(conn)\n\tctx, done := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer done()\n\trequest := &rangedbpb.SaveRequest{\n\t\tStreamName: \"thing-141b39d2b9854f8093ef79dc47dae6af\",\n\t\tEvents: []*rangedbpb.Event{\n\t\t\t{\n\t\t\t\tAggregateType: \"thing\",\n\t\t\t\tAggregateID:   \"141b39d2b9854f8093ef79dc47dae6af\",\n\t\t\t\tEventType:     \"ThingWasDone\",\n\t\t\t\tData:          `{\"id\":\"141b39d2b9854f8093ef79dc47dae6af\",\"number\":100}`,\n\t\t\t\tMetadata:      \"\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tAggregateType: \"thing\",\n\t\t\t\tAggregateID:   \"141b39d2b9854f8093ef79dc47dae6af\",\n\t\t\t\tEventType:     \"ThingWasDone\",\n\t\t\t\tData:          `{invalid-json`,\n\t\t\t\tMetadata:      \"\",\n\t\t\t},\n\t\t},\n\t}\n\n\t// When\n\t_, err = rangeDBClient.Save(ctx, request)\n\tfmt.Println(err)\n\n\tfor _, detail := range status.Convert(err).Details() {\n\t\tfailureResponse := detail.(*rangedbpb.SaveFailureResponse)\n\n\t\tbody, err := json.Marshal(failureResponse)\n\t\tPrintError(err)\n\n\t\tfmt.Println(jsontools.PrettyJSON(body))\n\t}\n\n\t// Output:\n\t// rpc error: code = InvalidArgument desc = unable to read event data: invalid character 'i' looking for beginning of object key string\n\t// {\n\t//   \"Message\": \"unable to read event data: invalid character 'i' looking for beginning of object key string\"\n\t// }\n}\n"}
{"sample": "// IfErrorThenPanic checks if an error exists, if so, panics\nfunc IfErrorThenPanic(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\n// FetchURL fetches the content of a URL using an HTTP GET request.\nfunc FetchURL(url string) (string, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil\n}"}
{"sample": "package reviewservice\n\nimport (\n\t\"errors\"\n\t\"log\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Review struct {\n\tID       uuid.UUID\n\tCustomer string\n\tRating   int\n\tComment  string\n}\n\ntype ReviewService struct {\n\tReviews []Review\n}\n\nfunc (rs *ReviewService) AddReview(customer string, rating int, comment string) (uuid.UUID, error) {\n\tif customer == \"\" {\n\t\treturn uuid.Nil, errors.New(\"customer name cannot be empty\")\n\t}\n\tif rating < 1 || rating > 5 {\n\t\treturn uuid.Nil, errors.New(\"rating must be between 1 and 5\")\n\t}\n\n\tid := uuid.New()\n\treview := Review{\n\t\tID:       id,\n\t\tCustomer: customer,\n\t\tRating:   rating,\n\t\tComment:  comment,\n\t}\n\n\trs.Reviews = append(rs.Reviews, review)\n\n\tlog.Printf(\"Added new review: %v\", review)\n\n\treturn id, nil\n}\n\nfunc (rs *ReviewService) GetReviews() []Review {\n\treturn rs.Reviews\n}"}
{"sample": "package httpclient\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc Get(url string) ([]byte, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n\nfunc Post(url string, data []byte) ([]byte, error) {\n\tresp, err := http.Post(url, \"application/json\", bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n\nfunc main() {\n\turl := \"https://jsonplaceholder.typicode.com/posts/1\"\n\tresp, err := Get(url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(resp))\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintMultiples prints multiples of a given number up to a specified limit.\nfunc PrintMultiples(num, limit int) {\n\tfor i := 1; i <= limit; i++ {\n\t\tfmt.Println(num * i)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jinzhu/gorm\"\n\t_ \"github.com/jinzhu/gorm/dialects/mysql\"\n)\n\ntype Person struct {\n\tgorm.Model\n\tName string `gorm:\"column:name\"`\n\tAge  int    `gorm:\"column:age\"`\n}\n\nfunc main() {\n\tdb, err := gorm.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/mydb?charset=utf8mb4&parseTime=True&loc=Local\")\n\tif err != nil {\n\t\tlog.Fatalf(\"error opening db: %v\", err)\n\t}\n\tdefer db.Close()\n\n\tdb.AutoMigrate(&Person{})\n\n\tp1 := Person{Name: \"John\", Age: 25}\n\tdb.Create(&p1)\n\n\tvar p2 Person\n\tdb.First(&p2)\n\tfmt.Printf(\"Person: %v\\n\", p2)\n\n\tp2.Age = 26\n\tdb.Save(&p2)\n\n\tvar people []Person\n\tdb.Find(&people)\n\tfmt.Printf(\"People: %v\\n\", people)\n}"}
{"sample": "package kubeclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/tools/clientcmd\"\n)\n\nfunc getClient() (*kubernetes.Clientset, error) {\n\tvar config *rest.Config\n\tvar err error\n\n\tif os.Getenv(\"KUBERNETES_SERVICE_HOST\") != \"\" && os.Getenv(\"KUBERNETES_SERVICE_PORT\") != \"\" {\n\t\tconfig, err = rest.InClusterConfig()\n\t} else {\n\t\tkubeconfig := os.Getenv(\"KUBECONFIG\")\n\t\tconfig, err = clientcmd.BuildConfigFromFlags(\"\", kubeconfig)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclientset, err := kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn clientset, nil\n}\n\nfunc getPods(namespace string) error {\n\tclientset, err := getClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpods, err := clientset.CoreV1().Pods(namespace).List(context.Background(), metav1.ListOptions{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"There are %d pods in the cluster\\n\", len(pods.Items))\n\n\treturn nil\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--config\", argparse.String, \"config.yaml\", \"Config file\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 4, \"Number of threads\")\nparser.AddArgument(\"--max-iter\", argparse.Int, 1000, \"Maximum number of iterations\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--batch-size\", argparse.Int, 16, \"Batch size\")\nparser.AddArgument(\"--mode\", argparse.String, \"default\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\nparser.AddArgument(\"--debug\", argparse.Bool, false, \"Enable debug mode\")\nparser.AddArgument(\"--gpu\", argparse.Bool, true, \"Enable GPU usage\")\n"}
{"sample": "// File represents a file.\ntype File struct {\n\tname string\n\tsize int64\n}\n\n// NewFile creates a new File.\nfunc NewFile(name string, size int64) *File {\n\treturn &File{name, size}\n}\n\n// Rename renames the File.\nfunc (f *File) Rename(name string) {\n\tf.name = name\n}\n\n// Resize resizes the File.\nfunc (f *File) Resize(size int64) {\n\tf.size = size\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintNumbersInDescendingOrder([]int{5, 2, 8, 6, 1, 9, 3, 7, 4})\n}\n\n// Function to print numbers in descending order\nfunc PrintNumbersInDescendingOrder(arr []int) {\n\tsort.Sort(sort.Reverse(sort.IntSlice(arr)))\n\tfmt.Println(arr)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Greet greets a person with the given name.\nfunc Greet(name string) {\n\tfmt.Printf(\"Hello, %s!\", name)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintIsArraySorted([]int{1, 2, 3, 4, 5})\n}\n\n// Function to check if an array is sorted in ascending order\nfunc PrintIsArraySorted(arr []int) {\n\tfor i := 0; i < len(arr)-1; i++ {\n\t\tif arr[i] > arr[i+1] {\n\t\t\tfmt.Println(false)\n\t\t\treturn\n\t\t}\n\t}\n\tfmt.Println(true)\n}"}
{"sample": "// Circle represents a circle.\ntype Circle struct {\n\tradius float64\n}\n\n// NewCircle creates a new Circle.\nfunc NewCircle(radius float64) *Circle {\n\treturn &Circle{radius}\n}\n\n// Area calculates the area of the Circle.\nfunc (c *Circle) Area() float64 {\n\treturn math.Pi * c.radius * c.radius\n}\n\n// Perimeter calculates the perimeter of the Circle.\nfunc (c *Circle) Perimeter() float64 {\n\treturn 2 * math.Pi * c.radius\n}"}
{"sample": "func (l *LinkedList) Find(data int) *Node {\n\tcurrent := l.Head\n\tfor current != nil {\n\t\tif current.Data == data {\n\t\t\treturn current\n\t\t}\n\t\tcurrent = current.Next\n\t}\n\treturn nil\n}"}
{"sample": "package commentservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/jackc/pgx/v4/pgxpool\"\n)\n\ntype Comment struct {\n\tID      uuid.UUID\n\tPostID  uuid.UUID\n\tContent string\n}\n\ntype CommentService struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewCommentService(db *pgxpool.Pool) *CommentService {\n\treturn &CommentService{db: db}\n}\n\nfunc (s *CommentService) CreateComment(ctx context.Context, postID uuid.UUID, content string) (uuid.UUID, error) {\n\tcommentID, err := uuid.NewRandom()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn uuid.Nil, errors.New(\"failed to generate comment ID\")\n\t}\n\n\tsql := \"INSERT INTO comments (id, post_id, content) VALUES ($1, $2, $3)\"\n\tif _, err := s.db.Exec(ctx, sql, commentID, postID, content); err != nil {\n\t\tlog.Println(err)\n\t\treturn uuid.Nil, errors.New(\"failed to create comment\")\n\t}\n\n\treturn commentID, nil\n}\n\nfunc (s *CommentService) GetCommentsByPostID(ctx context.Context, postID uuid.UUID) ([]Comment, error) {\n\tsql := \"SELECT id, post_id, content FROM comments WHERE post_id = $1\"\n\trows, err := s.db.Query(ctx, sql, postID)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, errors.New(\"failed to get comments\")\n\t}\n\tdefer rows.Close()\n\n\tcomments := []Comment{}\n\tfor rows.Next() {\n\t\tvar comment Comment\n\t\tif err := rows.Scan(&comment.ID, &comment.PostID, &comment.Content); err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn nil, errors.New(\"failed to scan comment\")\n\t\t}\n\t\tcomments = append(comments, comment)\n\t}\n\n\treturn comments, nil\n}"}
{"sample": "package fiborecursion\n\nfunc fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\n\treturn fibonacci(n-1) + fibonacci(n-2)\n}"}
{"sample": "// Fibonacci calculates the nth fibonacci number.\nfunc Fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\treturn Fibonacci(n-1) + Fibonacci(n-2)\n}\n\n// Factorial calculates the factorial of n.\nfunc Factorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * Factorial(n-1)\n}"}
{"sample": "package releaseservice\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"releaseservice/models\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype ReleaseService struct{}\n\nfunc (s *ReleaseService) CreateRelease(ctx context.Context, req *models.CreateReleaseRequest) (*models.CreateReleaseResponse, error) {\n\trelease := models.Release{\n\t\tName:        req.Name,\n\t\tVersion:     req.Version,\n\t\tDescription: req.Description,\n\t\tDate:        time.Now(),\n\t}\n\n\tif err := release.Create(); err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, fmt.Errorf(\"failed to create release\")\n\t}\n\n\treturn &models.CreateReleaseResponse{\n\t\tId: release.Id,\n\t}, nil\n}\n\nfunc (s *ReleaseService) GetRelease(ctx context.Context, req *models.GetReleaseRequest) (*models.GetReleaseResponse, error) {\n\trelease, err := models.GetRelease(req.Id)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, fmt.Errorf(\"failed to get release\")\n\t}\n\n\treturn &models.GetReleaseResponse{\n\t\tName:        release.Name,\n\t\tVersion:     release.Version,\n\t\tDescription: release.Description,\n\t\tDate:        release.Date.Format(\"2006-01-02\"),\n\t}, nil\n}\n\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := models.NewReleaseServiceClient(conn)\n\n\treq := &models.CreateReleaseRequest{\n\t\tName:        \"MyApp\",\n\t\tVersion:     \"1.0.0\",\n\t\tDescription: \"Initial release\",\n\t}\n\n\tres, err := client.CreateRelease(context.Background(), req)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create release: %v\", err)\n\t}\n\n\tfmt.Printf(\"Release created with ID: %s\\n\", res.Id)\n\n\tgetReq := &models.GetReleaseRequest{\n\t\tId: res.Id,\n\t}\n\n\tgetRes, err := client.GetRelease(context.Background(), getReq)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to get release: %v\", err)\n\t}\n\n\tfmt.Printf(\"Release: %v\\n\", getRes)\n}"}
{"sample": "// IgnoreErrorAndContinue ignores the error and continues execution\nfunc IgnoreErrorAndContinue(err error) {\n\t_ = err\n\t// Continue execution...\n}\n"}
{"sample": "http.HandleFunc(\"/posts\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle posts endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get posts\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create post\")\n\t}\n})\n"}
{"sample": "// ErrorHandlerInGoroutine handles an error within a goroutine\nfunc ErrorHandlerInGoroutine(err *error) {\n\tgo func() {\n\t\tif err := recover(); err != nil {\n\t\t\t*err = fmt.Errorf(\"goroutine error: %v\", err)\n\t\t}\n\t}()\n}\n"}
{"sample": "// Making a HTTP request\n\nresp, err := http.Get(\"http://example.com\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer resp.Body.Close()\n"}
{"sample": "package jiraclient\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/andygrunwald/go-jira\"\n)\n\ntype JiraClient struct {\n\tclient *jira.Client\n}\n\nfunc NewJiraClient(url, username, password string) (*JiraClient, error) {\n\ttp := jira.BasicAuthTransport{\n\t\tUsername: username,\n\t\tPassword: password,\n\t}\n\n\tjiraClient, err := jira.NewClient(tp.Client(), url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &JiraClient{client: jiraClient}, nil\n}\n\nfunc (jc *JiraClient) GetIssue(issueID string) (*jira.Issue, error) {\n\tissue, _, err := jc.client.Issue.Get(issueID, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn issue, nil\n}\n\nfunc (jc *JiraClient) CreateIssue(projectKey, issueType, summary, description string) (*jira.Issue, error) {\n\tnewIssue := &jira.Issue{\n\t\tFields: &jira.IssueFields{\n\t\t\tProject: jira.Project{\n\t\t\t\tKey: projectKey,\n\t\t\t},\n\t\t\tSummary:     summary,\n\t\t\tDescription: description,\n\t\t\tType: jira.IssueType{\n\t\t\t\tName: issueType,\n\t\t\t},\n\t\t},\n\t}\n\n\tissue, _, err := jc.client.Issue.Create(newIssue)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn issue, nil\n}\n\nfunc (jc *JiraClient) SearchIssues(jql string) ([]jira.Issue, error) {\n\tsearchOptions := &jira.SearchOptions{\n\t\tMaxResults: 100,\n\t}\n\n\tissues, _, err := jc.client.Issue.Search(jql, searchOptions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn issues, nil\n}\n\nfunc (jc *JiraClient) AddComment(issueID, comment string) error {\n\tnewComment := &jira.Comment{\n\t\tBody: comment,\n\t}\n\n\t_, err := jc.client.Issue.AddComment(issueID, newComment)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "// Check if a string contains a specific substring\nfunc ContainsSubstring(str, substr string) bool {\n\treturn strings.Contains(str, substr)\n}\n"}
{"sample": "decoder := gob.NewDecoder(file)\nerr = decoder.Decode(&data)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package signals\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\nfunc HandleSignals() {\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\tfor {\n\t\tsig := <-sigChan\n\t\tswitch sig {\n\t\tcase syscall.SIGINT:\n\t\t\tfmt.Println(\"Received SIGINT signal\")\n\t\t\t// Handle SIGINT signal\n\t\t\treturn\n\t\tcase syscall.SIGTERM:\n\t\t\tfmt.Println(\"Received SIGTERM signal\")\n\t\t\t// Handle SIGTERM signal\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Received unknown signal\")\n\t\t\t// Handle unknown signal\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Fibonacci generates the Fibonacci sequence up to the specified limit.\nfunc Fibonacci(limit int) {\n\ta, b := 0, 1\n\tfmt.Println(a)\n\tfor b <= limit {\n\t\tfmt.Println(b)\n\t\ta, b = b, a+b\n\t}\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--model\", argparse.String, \"model.pt\", \"Model file\")\nparser.AddArgument(\"--data-dir\", argparse.String, \".\", \"Data directory\")\nparser.AddArgument(\"--batch-size\", argparse.Int, 32, \"Batch size\")\nparser.AddArgument(\"--num-epochs\", argparse.Int, 10, \"Number of epochs\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--weight-decay\", argparse.Float, 0.001, \"Weight decay\")\nparser.AddArgument(\"--dropout\", argparse.Float, 0.5, \"Dropout rate\")\nparser.AddArgument(\"--mode\", argparse.String, \"train\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc ServeHTTPS() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, HTTPS!\")\n\t})\n\n\thttp.ListenAndServeTLS(\":443\", \"cert.pem\", \"key.pem\", nil)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/urfave/negroni\"\n)\n\nfunc UseNegroni() {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, Negroni!\")\n\t})\n\n\tn := negroni.Classic()\n\tn.Use(negroni.HandlerFunc(middleware1))\n\tn.Use(negroni.HandlerFunc(middleware2))\n\tn.Use(negroni.HandlerFunc(middleware3))\n\tn.UseHandler(handler)\n\n\thttp.ListenAndServe(\":8080\", n)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc SendRequest() {\n\tclient := &http.Client{}\n\trequest, _ := http.NewRequest(\"GET\", \"https://example.com\", nil)\n\tresponse, _ := client.Do(request)\n\tdefer response.Body.Close()\n\n\t// Handle the response\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// CircleArea calculates the area of a circle given its radius.\nfunc CircleArea(radius float64) float64 {\n\treturn math.Pi * math.Pow(radius, 2)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"io\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\treader := bufio.NewReader(file)\n\n\tfor {\n\t\tline, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfmt.Println(\"Error reading line:\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(line)\n\t}\n}"}
{"sample": "func MergeSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\tmid := len(arr) / 2\n\tleft := MergeSort(arr[:mid])\n\tright := MergeSort(arr[mid:])\n\treturn Merge(left, right)\n}\n\nfunc Merge(left, right []int) []int {\n\tresult := make([]int, 0, len(left)+len(right))\n\tfor len(left) > 0 || len(right) > 0 {\n\t\tif len(left) == 0 {\n\t\t\treturn append(result, right...)\n\t\t}\n\t\tif len(right) == 0 {\n\t\t\treturn append(result, left...)\n\t\t}\n\t\tif left[0] <= right[0] {\n\t\t\tresult = append(result, left[0])\n\t\t\tleft = left[1:]\n\t\t} else {\n\t\t\tresult = append(result, right[0])\n\t\t\tright = right[1:]\n\t\t}\n\t}\n\treturn result\n}"}
{"sample": "package main\n\n// Join elements to form a valid file path\nfunc main() {\n\tpath := filepath.Join(\"dir\", \"file.txt\")\n\tfmt.Println(\"Joined path:\", path)\n}\n"}
{"sample": "// Find the index of a target value in an array\nfunc FindIndex(arr []int, target int) int {\n\tfor i, num := range arr {\n\t\tif num == target {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n"}
{"sample": "package pools\n\nimport (\n\tstructs \"github.com/akkeris/service-watcher-f5/structs\"\n\tutils \"github.com/akkeris/service-watcher-f5/utils\"\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/bitly/go-simplejson\"\n\t\"net/http\"\n)\n\nfunc BuildPool(appname string, port string, partition string, monitor string, nodes []string) structs.Poolspec {\n\n\tvar pool structs.Poolspec\n\tpool.Name = appname + \"-pool\"\n\tpool.Partition = partition\n\tpool.Monitor = monitor\n\tvar members []structs.Memberspec\n\n\tfor _, element := range nodes {\n\t\tvar member structs.Memberspec\n\t\tmember.Name = \"/\" + partition + \"/\" + element + \":\" + port\n\t\tmembers = append(members, member)\n\t}\n\tpool.Members = members\n\treturn pool\n\n}\n\nfunc AddPool(pool structs.Poolspec) {\n\n\tstr, err := json.Marshal(pool)\n\tif err != nil {\n\t\tfmt.Println(\"Error preparing request\")\n\t}\n\tjsonStr := []byte(string(str))\n\turlStr := utils.F5url + \"/mgmt/tm/ltm/pool\"\n\treq, _ := http.NewRequest(\"POST\", urlStr, bytes.NewBuffer(jsonStr))\n\treq.Header.Add(\"X-F5-Auth-Token\", utils.F5token)\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\tresp, err := utils.F5Client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tdefer resp.Body.Close()\n\tfmt.Printf(\"%v : Add Pool %v\\n\", resp.Status, pool.Name)\n\tif resp.StatusCode > 299 {\n\t\tbodyj, _ := simplejson.NewFromReader(resp.Body)\n\t\tfmt.Println(bodyj)\n\t}\n}\nfunc DeletePool(pool structs.Poolspec) {\n\n\turlStr := utils.F5url + \"/mgmt/tm/ltm/pool/~\" + pool.Partition + \"~\" + pool.Name\n\treq, _ := http.NewRequest(\"DELETE\", urlStr, nil)\n\treq.Header.Add(\"X-F5-Auth-Token\", utils.F5token)\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\tresp, err := utils.F5Client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tdefer resp.Body.Close()\n\tfmt.Printf(\"%v : Delete Pool %v\\n\", resp.Status, pool.Name)\n\tif resp.StatusCode > 299 {\n\t\tbodyj, _ := simplejson.NewFromReader(resp.Body)\n\t\tfmt.Println(bodyj)\n\t}\n\n}\n"}
{"sample": "// Calculate the sum of all elements in an array\nfunc CalculateSum(arr []int) int {\n\tsum := 0\n\tfor _, num := range arr {\n\t\tsum += num\n\t}\n\treturn sum\n}\n"}
{"sample": "package radixsort\n\nfunc getMax(arr []int) int {\n\tmax := arr[0]\n\tfor _, val := range arr {\n\t\tif val > max {\n\t\t\tmax = val\n\t\t}\n\t}\n\treturn max\n}\n\nfunc countSort(arr []int, exp int) []int {\n\tn := len(arr)\n\toutput := make([]int, n)\n\tcount := make([]int, 10)\n\n\tfor i := 0; i < n; i++ {\n\t\tindex := (arr[i] / exp) % 10\n\t\tcount[index]++\n\t}\n\n\tfor i := 1; i < 10; i++ {\n\t\tcount[i] += count[i-1]\n\t}\n\n\tfor i := n - 1; i >= 0; i-- {\n\t\tindex := (arr[i] / exp) % 10\n\t\toutput[count[index]-1] = arr[i]\n\t\tcount[index]--\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tarr[i] = output[i]\n\t}\n\n\treturn arr\n}\n\nfunc RadixSort(arr []int) []int {\n\tmax := getMax(arr)\n\n\tfor exp := 1; max/exp > 0; exp *= 10 {\n\t\tarr = countSort(arr, exp)\n\t}\n\n\treturn arr\n}"}
{"sample": "func main() {\n\tvar mu sync.Mutex\n\tvar counter int\n\n\tfor i := 0; i < 10; i++ {\n\t\tgo func() {\n\t\t\tmu.Lock()\n\t\t\tcounter++\n\t\t\tmu.Unlock()\n\t\t}()\n\t}\n\n\ttime.Sleep(1 * time.Second)\n\n\tmu.Lock()\n\tfmt.Println(\"Counter:\", counter)\n\tmu.Unlock()\n}"}
{"sample": "package main\n\nimport \"sync\"\n\nvar wg sync.WaitGroup\n\nfunc main() {\n\twg.Add(2)\n\tgo PrintHi()\n\tgo PrintBye()\n\twg.Wait()\n}\n\nfunc PrintHi() {\n\tfmt.Println(\"Hi!\")\n\twg.Done()\n}\n\nfunc PrintBye() {\n\tfmt.Println(\"Bye!\")\n\twg.Done()\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// IsPalindrome checks if a given string is a palindrome and returns true if it is.\nfunc IsPalindrome(str string) bool {\n\tfor i, j := 0, len(str)-1; i < j; i, j = i+1, j-1 {\n\t\tif str[i] != str[j] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintOddNumbers prints odd numbers up to a given limit.\nfunc PrintOddNumbers(limit int) {\n\tfor i := 1; i <= limit; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "/*\nLandscape omnikeeper REST API\n\nNo description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n\nAPI version: v1\n*/\n\n// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.\n\npackage okclient\n\nimport (\n\t\"encoding/json\"\n)\n\n// ChangeDataRequest struct for ChangeDataRequest\ntype ChangeDataRequest struct {\n\tSparseRows []SparseRow `json:\"sparseRows,omitempty\"`\n}\n\n// NewChangeDataRequest instantiates a new ChangeDataRequest object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewChangeDataRequest() *ChangeDataRequest {\n\tthis := ChangeDataRequest{}\n\treturn &this\n}\n\n// NewChangeDataRequestWithDefaults instantiates a new ChangeDataRequest object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewChangeDataRequestWithDefaults() *ChangeDataRequest {\n\tthis := ChangeDataRequest{}\n\treturn &this\n}\n\n// GetSparseRows returns the SparseRows field value if set, zero value otherwise (both if not set or set to explicit null).\nfunc (o *ChangeDataRequest) GetSparseRows() []SparseRow {\n\tif o == nil  {\n\t\tvar ret []SparseRow\n\t\treturn ret\n\t}\n\treturn o.SparseRows\n}\n\n// GetSparseRowsOk returns a tuple with the SparseRows field value if set, nil otherwise\n// and a boolean to check if the value has been set.\n// NOTE: If the value is an explicit nil, `nil, true` will be returned\nfunc (o *ChangeDataRequest) GetSparseRowsOk() (*[]SparseRow, bool) {\n\tif o == nil || o.SparseRows == nil {\n\t\treturn nil, false\n\t}\n\treturn &o.SparseRows, true\n}\n\n// HasSparseRows returns a boolean if a field has been set.\nfunc (o *ChangeDataRequest) HasSparseRows() bool {\n\tif o != nil && o.SparseRows != nil {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// SetSparseRows gets a reference to the given []SparseRow and assigns it to the SparseRows field.\nfunc (o *ChangeDataRequest) SetSparseRows(v []SparseRow) {\n\to.SparseRows = v\n}\n\nfunc (o ChangeDataRequest) MarshalJSON() ([]byte, error) {\n\ttoSerialize := map[string]interface{}{}\n\tif o.SparseRows != nil {\n\t\ttoSerialize[\"sparseRows\"] = o.SparseRows\n\t}\n\treturn json.Marshal(toSerialize)\n}\n\ntype NullableChangeDataRequest struct {\n\tvalue *ChangeDataRequest\n\tisSet bool\n}\n\nfunc (v NullableChangeDataRequest) Get() *ChangeDataRequest {\n\treturn v.value\n}\n\nfunc (v *NullableChangeDataRequest) Set(val *ChangeDataRequest) {\n\tv.value = val\n\tv.isSet = true\n}\n\nfunc (v NullableChangeDataRequest) IsSet() bool {\n\treturn v.isSet\n}\n\nfunc (v *NullableChangeDataRequest) Unset() {\n\tv.value = nil\n\tv.isSet = false\n}\n\nfunc NewNullableChangeDataRequest(val *ChangeDataRequest) *NullableChangeDataRequest {\n\treturn &NullableChangeDataRequest{value: val, isSet: true}\n}\n\nfunc (v NullableChangeDataRequest) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(v.value)\n}\n\nfunc (v *NullableChangeDataRequest) UnmarshalJSON(src []byte) error {\n\tv.isSet = true\n\treturn json.Unmarshal(src, &v.value)\n}\n\n\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tclient := &http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", \"https://api.example.com/data\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer YOUR_API_TOKEN\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error making request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"encoding/json\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype Item struct {\n\tID   string `json:\"id,omitempty\"`\n\tName string `json:\"name,omitempty\"`\n}\n\nvar items []Item\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/items\", GetItems).Methods(\"GET\")\n\trouter.HandleFunc(\"/items/{id}\", GetItem).Methods(\"GET\")\n\trouter.HandleFunc(\"/items\", CreateItem).Methods(\"POST\")\n\trouter.HandleFunc(\"/items/{id}\", DeleteItem).Methods(\"DELETE\")\n\tlog.Fatal(http.ListenAndServe(\":8000\", router))\n}\n\nfunc GetItems(w http.ResponseWriter, r *http.Request) {\n\tjson.NewEncoder(w).Encode(items)\n}\n\nfunc GetItem(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\tfor _, item := range items {\n\t\tif item.ID == params[\"id\"] {\n\t\t\tjson.NewEncoder(w).Encode(item)\n\t\t\treturn\n\t\t}\n\t}\n\tjson.NewEncoder(w).Encode(&Item{})\n}\n\nfunc CreateItem(w http.ResponseWriter, r *http.Request) {\n\tvar item Item\n\t_ = json.NewDecoder(r.Body).Decode(&item)\n\titems = append(items, item)\n\tjson.NewEncoder(w).Encode(items)\n}\n\nfunc DeleteItem(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\tfor index, item := range items {\n\t\tif item.ID == params[\"id\"] {\n\t\t\titems = append(items[:index], items[index+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\tjson.NewEncoder(w).Encode(items)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"encoding/json\"\n\t\"os\"\n)\n\n// Configuration represents the application configuration\n\ntype Configuration struct {\n\tName   string `json:\"name\"`\n\tServer string `json:\"server\"`\n}\n\nfunc main() {\n\tconfig := Configuration{}\n\n\tfile, err := os.Open(\"config.json\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening config file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tdecoder := json.NewDecoder(file)\n\terr = decoder.Decode(&config)\n\tif err != nil {\n\t\tfmt.Println(\"Error decoding JSON:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Config:\", config)\n}"}
{"sample": "// IfErrorThenWrap checks if an error exists, if so, wraps it in another error\nfunc IfErrorThenWrap(err error, wrapErr string) error {\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: %w\", wrapErr, err)\n\t}\n\treturn nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/unrolled/render\"\n)\n\nfunc main() {\n\trenderer := render.New()\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\trenderer.Text(w, http.StatusOK, \"Hello, World!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nfunc main() {\n\tm := make(map[string]int)\n\tm[\"Answer\"] = 42\n\tfmt.Println(m[\"Answer\"])\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype Book struct {\n\tID     string `json:\"id,omitempty\"`\n\tTitle  string `json:\"title,omitempty\"`\n\tAuthor string `json:\"author,omitempty\"`\n}\n\nvar books []Book\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/books\", GetBooks).Methods(\"GET\")\n\trouter.HandleFunc(\"/books/{id}\", GetBook).Methods(\"GET\")\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc GetBooks(w http.ResponseWriter, r *http.Request) {\n\tjson.NewEncoder(w).Encode(books)\n}\n\nfunc GetBook(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\tfor _, item := range books {\n\t\tif item.ID == params[\"id\"] {\n\t\t\tjson.NewEncoder(w).Encode(item)\n\t\t\treturn\n\t\t}\n\t}\n\tjson.NewEncoder(w).Encode(&Book{})\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\treq, err := http.NewRequest(\"GET\", \"https://golang.org/pkg/net/http/\\n\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tdata, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%s\\n\", data)\n}"}
{"sample": "func DownloadFile(URL, fileName string) error {\n\tresponse, err := http.Get(URL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer response.Body.Close()\n\n\tout, err := os.Create(fileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\t_, err = io.Copy(out, response.Body)\n\treturn err\n}\n\nfunc FileExists(filePath string) bool {\n\t_, err := os.Stat(filePath)\n\treturn !os.IsNotExist(err)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tclient := &http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", \"https://jsonplaceholder.typicode.com/todos/1\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "err = os.Rename(\"oldname.txt\", \"newname.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package clearbit\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/jarcoal/httpmock\"\n)\n\nfunc requestRecorder(out **http.Request, next httpmock.Responder) httpmock.Responder {\n\treturn func(req *http.Request) (*http.Response, error) {\n\t\t*out = req\n\t\treturn next(req)\n\t}\n}\n\nfunc TestClientEnrichPerson(t *testing.T) {\n\tvar (\n\t\temail  = \"user@example.com\"\n\t\tapiKey = \"clearbit-key\"\n\n\t\trequest *http.Request\n\t)\n\n\ttransport := httpmock.NewMockTransport()\n\ttransport.RegisterResponder(\n\t\t\"GET\",\n\t\tEnrichPersonStreamingURL,\n\t\trequestRecorder(\n\t\t\t&request,\n\t\t\thttpmock.NewBytesResponder(\n\t\t\t\t200,\n\t\t\t\treadFixture(t, \"enrichment_person_response\"),\n\t\t\t),\n\t\t),\n\t)\n\n\tclient := NewClient(apiKey, &http.Client{Transport: transport})\n\n\tperson, err := client.EnrichPerson(email)\n\tif err != nil {\n\t\tt.Fatal(\"EnrichPerson failed:\", err)\n\t}\n\n\tif person.ID == \"\" {\n\t\tt.Fatal(\"Expected person to be present\")\n\t}\n\n\texpectRequestWithAPIKey(t, request, apiKey)\n\n\trequestedEmail := request.URL.Query().Get(\"email\")\n\tif requestedEmail != email {\n\t\tt.Errorf(\"email param = %q, want %q\", requestedEmail, email)\n\t}\n}\n\nfunc TestClientEnrichPersonTransportError(t *testing.T) {\n\tvar (\n\t\tclient = NewClient(\"key\", &http.Client{\n\t\t\tTransport: httpmock.NewMockTransport(),\n\t\t})\n\t)\n\n\t_, err := client.EnrichPerson(\"email\")\n\tif err == nil {\n\t\tt.Fatal(\"EnrichPerson succeeded, should have failed\")\n\t}\n}\n\nfunc TestClientEnrichPersonClearbitError(t *testing.T) {\n\ttransport := httpmock.NewMockTransport()\n\ttransport.RegisterResponder(\n\t\t\"GET\",\n\t\tEnrichPersonStreamingURL,\n\t\thttpmock.NewStringResponder(\n\t\t\t404,\n\t\t\t`{\"error\": {\"type\": \"unknown_record\", \"message\": \"Unknown email address\"}}`,\n\t\t),\n\t)\n\n\tclient := NewClient(\"key\", &http.Client{\n\t\tTransport: transport,\n\t})\n\n\t_, err := client.EnrichPerson(\"email\")\n\tif err == nil {\n\t\tt.Fatal(\"Expected 404 to be an error\")\n\t}\n\n\terrorMessage := err.Error()\n\n\tif !strings.Contains(errorMessage, \"404\") {\n\t\tt.Errorf(\n\t\t\t\"Error message = %q, doesn't contain %q\",\n\t\t\terrorMessage,\n\t\t\t\"404\",\n\t\t)\n\t}\n\n\tif !strings.Contains(errorMessage, \"unknown_record\") {\n\t\tt.Errorf(\n\t\t\t\"Error message = %q, doesn't contain %q\",\n\t\t\terrorMessage,\n\t\t\t\"unknown_record\",\n\t\t)\n\t}\n\n\tif !strings.Contains(errorMessage, \"Unknown email address\") {\n\t\tt.Errorf(\n\t\t\t\"Error message = %q, doesn't contain %q\",\n\t\t\terrorMessage,\n\t\t\t\"Unknown email address\",\n\t\t)\n\t}\n}\n\nfunc TestClientEnrichCompany(t *testing.T) {\n\tvar (\n\t\tdomain = \"example.com\"\n\t\tapiKey = \"clearbit-key\"\n\n\t\trequest *http.Request\n\n\t\ttransport = httpmock.NewMockTransport()\n\t\tclient    = NewClient(apiKey, &http.Client{Transport: transport})\n\t)\n\n\ttransport.RegisterResponder(\n\t\t\"GET\",\n\t\tEnrichCompanyStreamingURL,\n\t\trequestRecorder(\n\t\t\t&request,\n\t\t\thttpmock.NewBytesResponder(\n\t\t\t\t200,\n\t\t\t\treadFixture(t, \"enrichment_company_response\"),\n\t\t\t),\n\t\t),\n\t)\n\n\tcompany, err := client.EnrichCompany(domain)\n\tif err != nil {\n\t\tt.Fatal(\"EnrichCompany failed:\", err)\n\t}\n\n\tif company.ID == \"\" {\n\t\tt.Fatal(\"Expected company to be present\")\n\t}\n\n\texpectRequestWithAPIKey(t, request, apiKey)\n\n\trequestedDomain := request.URL.Query().Get(\"domain\")\n\tif requestedDomain != domain {\n\t\tt.Errorf(\"domain param = %q, want %q\", requestedDomain, domain)\n\t}\n}\n\nfunc TestClientCombinedEnrich(t *testing.T) {\n\tvar (\n\t\temail  = \"user@example.com\"\n\t\tapiKey = \"clearbit-key\"\n\n\t\trequest *http.Request\n\n\t\ttransport = httpmock.NewMockTransport()\n\t\tclient    = NewClient(apiKey, &http.Client{Transport: transport})\n\t)\n\n\ttransport.RegisterResponder(\n\t\t\"GET\",\n\t\tEnrichCombinedStreamingURL,\n\t\trequestRecorder(\n\t\t\t&request,\n\t\t\thttpmock.NewBytesResponder(\n\t\t\t\t200,\n\t\t\t\treadFixture(t, \"enrichment_combined_response\"),\n\t\t\t),\n\t\t),\n\t)\n\n\tcombined, err := client.Enrich(email)\n\tif err != nil {\n\t\tt.Fatal(\"EnrichCombined failed:\", err)\n\t}\n\n\tif combined.Company.ID == \"\" {\n\t\tt.Fatal(\"Expected company to be present in combined response\")\n\t}\n\n\texpectRequestWithAPIKey(t, request, apiKey)\n\n\trequestedEmail := request.URL.Query().Get(\"email\")\n\tif requestedEmail != email {\n\t\tt.Errorf(\"email param = %q, want %q\", requestedEmail, email)\n\t}\n}\n\nfunc TestClientProspect(t *testing.T) {\n\tvar (\n\t\tdomain    = \"example.com\"\n\t\tname      = \"Jane\"\n\t\trole      = \"marketing\"\n\t\tseniority = \"executive\"\n\t\ttitles    = []string{\"VP\", \"CEO\"}\n\t\tapiKey    = \"clearbit-key\"\n\n\t\trequest *http.Request\n\n\t\ttransport = httpmock.NewMockTransport()\n\t\tclient    = NewClient(apiKey, &http.Client{Transport: transport})\n\t)\n\n\ttransport.RegisterResponder(\n\t\t\"GET\",\n\t\tProspectURL,\n\t\trequestRecorder(\n\t\t\t&request,\n\t\t\thttpmock.NewBytesResponder(\n\t\t\t\t200,\n\t\t\t\treadFixture(t, \"prospect_response\"),\n\t\t\t),\n\t\t),\n\t)\n\n\tprospects, err := client.Prospect(ProspectQuery{\n\t\tDomain:    domain,\n\t\tName:      name,\n\t\tRole:      role,\n\t\tSeniority: seniority,\n\t\tTitles:    titles,\n\t})\n\tif err != nil {\n\t\tt.Fatal(\"Prospect failed:\", err)\n\t}\n\n\tif len(prospects) == 0 {\n\t\tt.Fatal(\"Expected prospects to be present\")\n\t}\n\n\texpectRequestWithAPIKey(t, request, apiKey)\n\n\trequestedDomain := request.URL.Query().Get(\"domain\")\n\tif requestedDomain != domain {\n\t\tt.Errorf(\"domain param = %q, want %q\", requestedDomain, domain)\n\t}\n\n\trequestedName := request.URL.Query().Get(\"name\")\n\tif requestedName != name {\n\t\tt.Errorf(\"name param = %q, want %q\", requestedName, name)\n\t}\n\n\trequestedRole := request.URL.Query().Get(\"role\")\n\tif requestedRole != role {\n\t\tt.Errorf(\"role param = %q, want %q\", requestedRole, role)\n\t}\n\n\trequestedSeniority := request.URL.Query().Get(\"seniority\")\n\tif requestedSeniority != seniority {\n\t\tt.Errorf(\"seniority param = %q, want %q\", requestedSeniority, seniority)\n\t}\n\n\trequestedTitles := request.URL.Query()[\"titles[]\"]\n\tif !reflect.DeepEqual(requestedTitles, titles) {\n\t\tt.Errorf(\"titles param = %v, want %v\", requestedTitles, titles)\n\t}\n}\n\nfunc expectRequestWithAPIKey(t *testing.T, r *http.Request, apiKey string) {\n\tif r == nil {\n\t\tt.Fatal(\"Request not sent\")\n\t}\n\n\tusername, _, _ := r.BasicAuth()\n\tif username != apiKey {\n\t\tt.Errorf(\"basic auth username = %q, want %q\", username, apiKey)\n\t}\n}\n"}
{"sample": "func main() {\n\tstart := time.Now()\n\n\ttime.Sleep(2 * time.Second)\n\n\tduration := time.Since(start)\n\tfmt.Println(duration)\n}"}
{"sample": "package restprocessor\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc handleUsers(w http.ResponseWriter, r *http.Request) {\n\tswitch r.Method {\n\tcase \"GET\":\n\t\tgetUsers(w, r)\n\tcase \"POST\":\n\t\tcreateUser(w, r)\n\tdefault:\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n\tusers := []User{\n\t\t{ID: 1, Username: \"user1\", Email: \"user1@example.com\"},\n\t\t{ID: 2, Username: \"user2\", Email: \"user2@example.com\"},\n\t\t{ID: 3, Username: \"user3\", Email: \"user3@example.com\"},\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif err := json.NewEncoder(w).Encode(users); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n\tvar user User\n\tif err := json.NewDecoder(r.Body).Decode(&user); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Save user to database\n\n\tw.WriteHeader(http.StatusCreated)\n}"}
{"sample": "/**\n * Copyright (C) 2015 Red Hat, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Copyright 2016 The etcd Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage e2e\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/coreos/etcd/clientv3\"\n\t\"github.com/coreos/etcd/pkg/testutil\"\n)\n\nfunc TestCtlV3Migrate(t *testing.T) {\n\tdefer testutil.AfterTest(t)\n\n\tepc := setupEtcdctlTest(t, &configNoTLS, false)\n\tdefer func() {\n\t\tif errC := epc.Close(); errC != nil {\n\t\t\tt.Fatalf(\"error closing etcd processes (%v)\", errC)\n\t\t}\n\t}()\n\n\tkeys := make([]string, 3)\n\tvals := make([]string, 3)\n\tfor i := range keys {\n\t\tkeys[i] = fmt.Sprintf(\"foo_%d\", i)\n\t\tvals[i] = fmt.Sprintf(\"bar_%d\", i)\n\t}\n\tfor i := range keys {\n\t\tif err := etcdctlSet(epc, keys[i], vals[i]); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tdataDir := epc.procs[0].cfg.dataDirPath\n\tif err := epc.StopAll(); err != nil {\n\t\tt.Fatalf(\"error closing etcd processes (%v)\", err)\n\t}\n\n\tos.Setenv(\"ETCDCTL_API\", \"3\")\n\tdefer os.Unsetenv(\"ETCDCTL_API\")\n\tcx := ctlCtx{\n\t\tt:           t,\n\t\tcfg:         configNoTLS,\n\t\tdialTimeout: 7 * time.Second,\n\t\tepc:         epc,\n\t}\n\tif err := ctlV3Migrate(cx, dataDir, \"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tepc.procs[0].cfg.keepDataDir = true\n\tif err := epc.RestartAll(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// to ensure revision increment is continuous from migrated v2 data\n\tif err := ctlV3Put(cx, \"test\", \"value\", \"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcli, err := clientv3.New(clientv3.Config{\n\t\tEndpoints:   epc.grpcEndpoints(),\n\t\tDialTimeout: 3 * time.Second,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer cli.Close()\n\tresp, err := cli.Get(context.TODO(), \"test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(resp.Kvs) != 1 {\n\t\tt.Fatalf(\"len(resp.Kvs) expected 1, got %+v\", resp.Kvs)\n\t}\n\tif resp.Kvs[0].CreateRevision != 7 {\n\t\tt.Fatalf(\"resp.Kvs[0].CreateRevision expected 7, got %d\", resp.Kvs[0].CreateRevision)\n\t}\n}\n\nfunc ctlV3Migrate(cx ctlCtx, dataDir, walDir string) error {\n\tcmdArgs := append(cx.PrefixArgs(), \"migrate\", \"--data-dir\", dataDir, \"--wal-dir\", walDir)\n\treturn spawnWithExpects(cmdArgs, \"finished transforming keys\")\n}\n"}
{"sample": "package smsservice\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n)\n\ntype SMS struct {\n\tTo      string\n\tMessage string\n}\n\ntype SMSService interface {\n\tSendSMS(sms SMS) error\n}\n\ntype TwilioSMSService struct {\n\taccountSid string\n\tauthToken  string\n\tfromNumber string\n}\n\nfunc NewTwilioSMSService() *TwilioSMSService {\n\treturn &TwilioSMSService{\n\t\taccountSid: os.Getenv(\"TWILIO_ACCOUNT_SID\"),\n\t\tauthToken:  os.Getenv(\"TWILIO_AUTH_TOKEN\"),\n\t\tfromNumber: os.Getenv(\"TWILIO_FROM_NUMBER\"),\n\t}\n}\n\nfunc (t *TwilioSMSService) SendSMS(sms SMS) error {\n\tif t.accountSid == \"\" || t.authToken == \"\" || t.fromNumber == \"\" {\n\t\treturn errors.New(\"twilio credentials not set\")\n\t}\n\n\turlStr := fmt.Sprintf(\"https://api.twilio.com/2010-04-01/Accounts/%s/Messages.json\", t.accountSid)\n\n\tmsgData := url.Values{}\n\tmsgData.Set(\"To\", sms.To)\n\tmsgData.Set(\"From\", t.fromNumber)\n\tmsgData.Set(\"Body\", sms.Message)\n\tmsgDataReader := *strings.NewReader(msgData.Encode())\n\n\tclient := &http.Client{}\n\treq, _ := http.NewRequest(\"POST\", urlStr, &msgDataReader)\n\treq.SetBasicAuth(t.accountSid, t.authToken)\n\treq.Header.Add(\"Accept\", \"application/json\")\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tif resp.StatusCode >= 200 && resp.StatusCode < 300 {\n\t\tlog.Println(\"SMS sent successfully\")\n\t\treturn nil\n\t} else {\n\t\tlog.Println(\"Failed to send SMS\")\n\t\treturn errors.New(\"failed to send SMS\")\n\t}\n}"}
{"sample": "package blogservice\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/grpc-ecosystem/go-grpc-middleware\"\n\t\"github.com/grpc-ecosystem/go-grpc-middleware/logging/zap\"\n\t\"github.com/grpc-ecosystem/go-grpc-middleware/recovery\"\n\t\"github.com/grpc-ecosystem/grpc-gateway/runtime\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc\"\n\n\t\"blogpb\"\n)\n\ntype server struct {\n}\n\nfunc (*server) CreateBlog(ctx context.Context, req *blogpb.CreateBlogRequest) (*blogpb.CreateBlogResponse, error) {\n\tfmt.Printf(\"Create Blog request received: %v\", req)\n\treturn &blogpb.CreateBlogResponse{\n\t\tBlog: &blogpb.Blog{\n\t\t\tId:       \"123\",\n\t\t\tAuthorId: req.GetBlog().GetAuthorId(),\n\t\t\tTitle:    req.GetBlog().GetTitle(),\n\t\t\tContent:  req.GetBlog().GetContent(),\n\t\t},\n\t}, nil\n}\n\nfunc main() {\n\tlogger, _ := zap.NewDevelopment()\n\tdefer logger.Sync()\n\n\tlis, err := net.Listen(\"tcp\", \"0.0.0.0:50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(\n\t\tgrpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(\n\t\t\tgrpc_zap.UnaryServerInterceptor(logger),\n\t\t\tgrpc_recovery.UnaryServerInterceptor(),\n\t\t)),\n\t)\n\n\tblogpb.RegisterBlogServiceServer(s, &server{})\n\n\tgo func() {\n\t\tlog.Println(\"Starting gRPC server...\")\n\t\tif err := s.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\tmux := runtime.NewServeMux()\n\topts := []grpc.DialOption{grpc.WithInsecure()}\n\tif err := blogpb.RegisterBlogServiceHandlerFromEndpoint(context.Background(), mux, \"localhost:50051\", opts); err != nil {\n\t\tlog.Fatalf(\"Failed to register gateway: %v\", err)\n\t}\n\n\tlog.Println(\"Starting gateway server...\")\n\tif err := http.ListenAndServe(\":8080\", mux); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}"}
{"sample": "// Check if a string is empty\nfunc IsEmptyString(str string) bool {\n\treturn len(str) == 0\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi\"\n)\n\nfunc main() {\n\tr := chi.NewRouter()\n\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, world!\")\n\t})\n\n\tr.Get(\"/user/{userID}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tuserID := chi.URLParam(r, \"userID\")\n\t\tfmt.Fprintf(w, \"User ID: %s\", userID)\n\t})\n\n\thttp.ListenAndServe(\":8080\", r)\n}"}
{"sample": "package cred_helper_test\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"time\"\n\n\t\"code.cloudfoundry.org/lager\"\n\t\"github.com/patrickmn/go-cache\"\n\n\t\"code.cloudfoundry.org/app-autoscaler/src/autoscaler/cred_helper\"\n\n\t\"code.cloudfoundry.org/app-autoscaler/src/autoscaler/fakes\"\n\t\"code.cloudfoundry.org/app-autoscaler/src/autoscaler/models\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"CustomMetricCredHelper\", func() {\n\tvar (\n\t\tpolicyDB               *fakes.FakePolicyDB\n\t\tappId                  = \"testAppId\"\n\t\ttestUserName           = \"the-user-name\"\n\t\ttestPassword           = \"the-password\"\n\t\tuserProvidedCredential *models.Credential\n\t\tcredResult             *models.Credential\n\t\tcreds                  cred_helper.Credentials\n\t\tcredentialCache        cache.Cache\n\t)\n\n\tBeforeEach(func() {\n\t\tpolicyDB = &fakes.FakePolicyDB{}\n\t\tcredentialCache = *cache.New(10*time.Minute, -1)\n\n\t\tlogger := lager.NewLogger(\"custom_metrics_helper_test\")\n\t\tlogger.RegisterSink(lager.NewWriterSink(GinkgoWriter, lager.DEBUG))\n\n\t\tcreds = cred_helper.NewCustomMetricsCredHelperWithCache(policyDB, cred_helper.MaxRetry, credentialCache, 10*time.Minute, logger)\n\n\t})\n\tContext(\"CreateCredential\", func() {\n\t\tvar err error\n\t\tJustBeforeEach(func() {\n\t\t\tcredResult, err = creds.Create(appId, userProvidedCredential)\n\t\t})\n\t\tContext(\"when userProvideCredential is not nil\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tuserProvidedCredential = &models.Credential{\n\t\t\t\t\tUsername: testUserName,\n\t\t\t\t\tPassword: testPassword,\n\t\t\t\t}\n\t\t\t\tpolicyDB.SaveCredentialReturns(nil)\n\t\t\t})\n\t\t\tIt(\"saves the credential user provided\", func() {\n\n\t\t\t\tExpect(credResult.Username).To(Equal(testUserName))\n\t\t\t\tExpect(credResult.Password).To(Equal(testPassword))\n\t\t\t})\n\t\t})\n\t\tContext(\"when there is no error when calling policydb\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tpolicyDB.SaveCredentialReturns(nil)\n\t\t\t})\n\t\t\tContext(\"when credential does not exist\", func() {\n\t\t\t\tIt(\"should try saving only once and succeed\", func() {\n\t\t\t\t\tExpect(policyDB.SaveCredentialCallCount()).To(Equal(1))\n\t\t\t\t\tExpect(credResult).NotTo(BeNil())\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t})\n\t\t\t})\n\n\t\t})\n\t\tContext(\"when there is continuous error when calling policydb\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tpolicyDB.GetCredentialReturns(nil, sql.ErrNoRows)\n\t\t\t\tpolicyDB.SaveCredentialReturns(errors.New(\"dberror\"))\n\n\t\t\t})\n\t\t\tIt(\"should try MaxRetry times and return error\", func() {\n\t\t\t\tExpect(policyDB.SaveCredentialCallCount()).To(Equal(cred_helper.MaxRetry))\n\t\t\t\tExpect(credResult).To(BeNil())\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t})\n\t\t})\n\t})\n\tContext(\"DeleteCredential\", func() {\n\t\tvar err error\n\t\tJustBeforeEach(func() {\n\t\t\terr = creds.Delete(appId)\n\t\t})\n\t\tContext(\"when there is no error when calling policydb\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tpolicyDB.DeleteCredentialReturns(nil)\n\t\t\t})\n\t\t\tIt(\"should try only once and succeed\", func() {\n\t\t\t\tExpect(policyDB.DeleteCredentialCallCount()).To(Equal(1))\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t})\n\t\t})\n\t\tContext(\"when there is continuous error when calling policydb\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tpolicyDB.DeleteCredentialReturns(errors.New(\"dberror\"))\n\t\t\t})\n\t\t\tIt(\"should try MaxRetry times and return error\", func() {\n\t\t\t\tExpect(policyDB.DeleteCredentialCallCount()).To(Equal(cred_helper.MaxRetry))\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t})\n\t\t})\n\t})\n\n\tContext(\"ValidateCredentials\", func() {\n\t\tContext(\"credentials exists in the cache\", func() {\n\t\t\tIt(\"should get the credentials from cache without searching from database\", func() {\n\t\t\t\tstoredCredentials := &models.Credential{\n\t\t\t\t\tUsername: \"$2a$10$YnQNQYcvl/Q2BKtThOKFZ.KB0nTIZwhKr5q1pWTTwC/PUAHsbcpFu\",\n\t\t\t\t\tPassword: \"$2a$10$6nZ73cm7IV26wxRnmm5E1.nbk9G.0a4MrbzBFPChkm5fPftsUwj9G\",\n\t\t\t\t}\n\t\t\t\tcredentialCache.Set(\"an-app-id\", storedCredentials, 10*time.Minute)\n\n\t\t\t\tvalid, err := creds.Validate(\"an-app-id\", models.Credential{Username: \"username\", Password: \"password\"})\n\t\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t\tExpect(valid).To(Equal(true))\n\n\t\t\t\tExpect(policyDB.GetCredentialCallCount()).To(Equal(0))\n\t\t\t})\n\n\t\t})\n\n\t\tContext(\"credentials do not exists in the cache but exist in the database\", func() {\n\t\t\tIt(\"should get the credentials from database, add it to the cache\", func() {\n\t\t\t\tstoredCredentials := &models.Credential{\n\t\t\t\t\tUsername: \"$2a$10$YnQNQYcvl/Q2BKtThOKFZ.KB0nTIZwhKr5q1pWTTwC/PUAHsbcpFu\",\n\t\t\t\t\tPassword: \"$2a$10$6nZ73cm7IV26wxRnmm5E1.nbk9G.0a4MrbzBFPChkm5fPftsUwj9G\",\n\t\t\t\t}\n\n\t\t\t\tpolicyDB.GetCredentialReturns(storedCredentials, nil)\n\n\t\t\t\tvalid, err := creds.Validate(\"an-app-id\", models.Credential{Username: \"username\", Password: \"password\"})\n\t\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t\tExpect(valid).To(Equal(true))\n\n\t\t\t\tExpect(policyDB.GetCredentialCallCount()).To(Equal(1))\n\n\t\t\t\t//fills the cache\n\t\t\t\t_, found := credentialCache.Get(\"an-app-id\")\n\t\t\t\tExpect(found).To(Equal(true))\n\t\t\t})\n\t\t})\n\n\t\tContext(\"when credentials neither exists in the cache nor exist in the database\", func() {\n\t\t\tIt(\"should search in both cache & database and returns an error\", func() {\n\t\t\t\tpolicyDB.GetCredentialReturns(nil, errors.New(\"some error\"))\n\n\t\t\t\tvalid, err := creds.Validate(\"an-app-id\", models.Credential{Username: \"username\", Password: \"password\"})\n\t\t\t\tExpect(err).Should(HaveOccurred())\n\t\t\t\tExpect(valid).To(Equal(false))\n\n\t\t\t\tExpect(policyDB.GetCredentialCallCount()).To(Equal(1))\n\n\t\t\t\t//fills the cache\n\t\t\t\t_, found := credentialCache.Get(\"an-app-id\")\n\t\t\t\tExpect(found).To(Equal(false))\n\t\t\t})\n\t\t})\n\n\t\tContext(\"when a stale credentials exists in the cache\", func() {\n\t\t\tIt(\"should search in the database\", func() {\n\t\t\t\tcredentialCache.Set(\"an-app-id\", &models.Credential{Username: \"some-stale-hashed-username\", Password: \"some-stale-hashed-password\"}, 10*time.Minute)\n\n\t\t\t\tstoredCredentials := &models.Credential{\n\t\t\t\t\tUsername: \"$2a$10$YnQNQYcvl/Q2BKtThOKFZ.KB0nTIZwhKr5q1pWTTwC/PUAHsbcpFu\",\n\t\t\t\t\tPassword: \"$2a$10$6nZ73cm7IV26wxRnmm5E1.nbk9G.0a4MrbzBFPChkm5fPftsUwj9G\",\n\t\t\t\t}\n\n\t\t\t\tpolicyDB.GetCredentialReturns(storedCredentials, nil)\n\n\t\t\t\tvalid, err := creds.Validate(\"an-app-id\", models.Credential{Username: \"username\", Password: \"password\"})\n\t\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t\tExpect(valid).To(Equal(true))\n\n\t\t\t\tExpect(policyDB.GetCredentialCallCount()).To(Equal(1))\n\n\t\t\t\t//fills the cache\n\t\t\t\t_, found := credentialCache.Get(\"an-app-id\")\n\t\t\t\tExpect(found).To(Equal(true))\n\t\t\t})\n\t\t})\n\t})\n})\n"}
{"sample": "numbers := make([]int, 5)\n"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package xpathparser\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"github.com/antchfx/htmlquery\"\n)\n\nfunc extractData() error {\n\turl := \"https://example.com\"\n\tres, err := http.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\thtml, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdoc, err := htmlquery.Parse(bytes.NewReader(html))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnodes, err := htmlquery.QueryAll(doc, \"//div[contains(@class, 'article')]\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, node := range nodes {\n\t\ttitleNode := htmlquery.FindOne(node, \"//h2\")\n\t\ttitle := htmlquery.InnerText(titleNode)\n\t\tfmt.Println(title)\n\n\t\tcontentNode := htmlquery.FindOne(node, \"//div[contains(@class, 'content')]\")\n\t\tcontent := htmlquery.InnerText(contentNode)\n\t\tfmt.Println(content)\n\t}\n\n\treturn nil\n}"}
{"sample": "users := map[string]int{\"Alice\": 1, \"Bob\": 2}\ndelete(users, \"Alice\")\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tticker := time.NewTicker(1 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\tfmt.Println(\"Tick\")\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintNumbersInAscendingOrder([]int{5, 2, 8, 6, 1, 9, 3, 7, 4})\n}\n\n// Function to print numbers in ascending order\nfunc PrintNumbersInAscendingOrder(arr []int) {\n\tsort.Ints(arr)\n\tfmt.Println(arr)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/jmoiron/sqlx\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"google.golang.org/grpc\"\n\n\tpb \"myapp/protos\"\n)\n\ntype server struct{}\n\nfunc (s *server) CreateUser(ctx context.Context, in *pb.User) (*pb.Response, error) {\n\tdb, err := sqlx.Connect(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\tsqlStatement := `INSERT INTO users (name, email) VALUES (?, ?)`\n\n\t_, err = db.Exec(sqlStatement, in.Name, in.Email)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to execute query: %v\", err)\n\t}\n\n\treturn &pb.Response{Message: fmt.Sprintf(\"User %v created successfully\", in.Name)}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterUserServer(s, &server{})\n\tlog.Printf(\"Server starting on port %v...\\n\", lis.Addr().String())\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nfunc main() {\n\tswitchDemo(1)\n}\n\nfunc switchDemo(i int) {\n\tswitch i {\n\tcase 0:\n\t\tfmt.Println(\"Zero\")\n\tcase 1:\n\t\tfmt.Println(\"One\")\n\tdefault:\n\t\tfmt.Println(\"Unknown\")\n\t}\n}"}
{"sample": "if student.Age > 18 {\n\tfmt.Println(\"Adult student\")\n} else {\n\tfmt.Println(\"Minor student\")\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// IsPalindrome checks if a given string is a palindrome and returns true if it is.\nfunc IsPalindrome(str string) bool {\n\tfor i, j := 0, len(str)-1; i < j; i, j = i+1, j-1 {\n\t\tif str[i] != str[j] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"sample": "func Factorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * Factorial(n-1)\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package restapi\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\t_ \"github.com/lib/pq\"\n)\n\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n\tdb, err := sql.Open(\"postgres\", \"postgres://user:password@localhost/dbname?sslmode=disable\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tusers := []User{}\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Email)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(w).Encode(users)\n}\n\nfunc addUser(w http.ResponseWriter, r *http.Request) {\n\tdb, err := sql.Open(\"postgres\", \"postgres://user:password@localhost/dbname?sslmode=disable\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tvar user User\n\terr = json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (username, email) VALUES ($1, $2)\", user.Username, user.Email)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--model\", argparse.String, \"model.pt\", \"Model file\")\nparser.AddArgument(\"--data-dir\", argparse.String, \".\", \"Data directory\")\n"}
{"sample": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tresult := Sum(1, 2, 3, 4, 5)\n\tfmt.Println(result)\n}\n\nfunc Sum(nums ...int) int {\n\ttotal := 0\n\tfor _, num := range nums {\n\t\ttotal += num\n\t}\n\treturn total\n}"}
{"sample": "err = os.Chown(\"file.txt\", os.Getuid(), os.Getgid())\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package csvdataanalysis\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc analyzeCSVFile(filePath string) error {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\tvar total int\n\tvar max int\n\tvar min int\n\tvar count int\n\n\tfor {\n\t\trecord, err := reader.Read()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvalue, err := strconv.Atoi(record[0])\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ttotal += value\n\t\tcount++\n\n\t\tif value > max {\n\t\t\tmax = value\n\t\t}\n\n\t\tif value < min || min == 0 {\n\t\t\tmin = value\n\t\t}\n\t}\n\n\taverage := float64(total) / float64(count)\n\n\tfmt.Printf(\"Total: %d\\n\", total)\n\tfmt.Printf(\"Average: %.2f\\n\", average)\n\tfmt.Printf(\"Max: %d\\n\", max)\n\tfmt.Printf(\"Min: %d\\n\", min)\n\n\treturn nil\n}"}
{"sample": "func ReadConfigFile(filename string) (*viper.Viper, error) {\n\tv := viper.New()\n\tv.SetConfigFile(filename)\n\terr := v.ReadInConfig()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn v, nil\n}\n\nfunc GetConfigValue(v *viper.Viper, key string) interface{} {\n\treturn v.Get(key)\n}\n\nfunc SetConfigValue(v *viper.Viper, key string, value interface{}) {\n\tv.Set(key, value)\n}"}
{"sample": "func main() {\n\tstart := time.Now()\n\n\ttime.Sleep(2 * time.Second)\n\n\tduration := time.Since(start)\n\tfmt.Println(duration)\n}"}
{"sample": "package behaviorservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/jmoiron/sqlx\"\n)\n\ntype Behavior struct {\n\tID        uuid.UUID `db:\"id\"`\n\tUserID    uuid.UUID `db:\"user_id\"`\n\tEvent     string    `db:\"event\"`\n\tCreatedAt time.Time `db:\"created_at\"`\n}\n\ntype BehaviorService struct {\n\tDB *sqlx.DB\n}\n\nfunc (s *BehaviorService) LogBehavior(ctx context.Context, userID uuid.UUID, event string) error {\n\tif userID == uuid.Nil {\n\t\treturn errors.New(\"invalid user ID\")\n\t}\n\n\tif event == \"\" {\n\t\treturn errors.New(\"invalid event\")\n\t}\n\n\tbehavior := Behavior{\n\t\tID:        uuid.New(),\n\t\tUserID:    userID,\n\t\tEvent:     event,\n\t\tCreatedAt: time.Now(),\n\t}\n\n\t_, err := s.DB.NamedExecContext(ctx, \"INSERT INTO behaviors (id, user_id, event, created_at) VALUES (:id, :user_id, :event, :created_at)\", behavior)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn errors.New(\"failed to log behavior\")\n\t}\n\n\treturn nil\n}\n\nfunc (s *BehaviorService) GetBehaviorsByUser(ctx context.Context, userID uuid.UUID) ([]Behavior, error) {\n\tif userID == uuid.Nil {\n\t\treturn nil, errors.New(\"invalid user ID\")\n\t}\n\n\tvar behaviors []Behavior\n\terr := s.DB.SelectContext(ctx, &behaviors, \"SELECT * FROM behaviors WHERE user_id = $1\", userID)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, errors.New(\"failed to get behaviors\")\n\t}\n\n\treturn behaviors, nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintOddNumbers prints odd numbers up to a given limit.\nfunc PrintOddNumbers(limit int) {\n\tfor i := 1; i <= limit; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"github.com/go-chi/chi\"\n)\n\nfunc main() {\n\tr := chi.NewRouter()\n\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Welcome to the home page\")\n\t})\n\n\tr.Get(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"List of users\")\n\t})\n\n\tr.Post(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Create user\")\n\t})\n\n\tr.Get(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Get user with ID: %s\", chi.URLParam(r, \"id\"))\n\t})\n\n\tr.Put(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Update user with ID: %s\", chi.URLParam(r, \"id\"))\n\t})\n\n\tr.Delete(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Delete user with ID: %s\", chi.URLParam(r, \"id\"))\n\t})\n\n\thttp.ListenAndServe(\":8080\", r)\n}"}
{"sample": "package pushnotify\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/go-redis/redis\"\n\t\"github.com/nats-io/nats.go\"\n)\n\ntype PushService struct {\n\tnatsConn *nats.Conn\n\tredisCli *redis.Client\n}\n\nfunc NewPushService(natsURL string, redisURL string) (*PushService, error) {\n\tnatsConn, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\treturn nil, errors.New(\"failed to connect to nats\")\n\t}\n\n\tredisCli := redis.NewClient(&redis.Options{\n\t\tAddr: redisURL,\n\t})\n\n\tif _, err := redisCli.Ping().Result(); err != nil {\n\t\treturn nil, errors.New(\"failed to connect to redis\")\n\t}\n\n\treturn &PushService{\n\t\tnatsConn: natsConn,\n\t\tredisCli: redisCli,\n\t}, nil\n}\n\nfunc (ps *PushService) Send(notification Notification) error {\n\terr := ps.natsConn.Publish(notification.Topic(), notification)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to publish message to nats: %v\", err)\n\t}\n\n\tif err := ps.redisCli.Set(notification.Id(), notification.Content, 0).Err(); err != nil {\n\t\tlog.Printf(\"failed to save notification to redis: %v\\n\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (ps *PushService) Close() {\n\tps.natsConn.Close()\n\tps.redisCli.Close()\n\tlog.Println(\"push service closed\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadFile reads and returns the content of a file.\nfunc ReadFile(filePath string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// WriteFile writes the content to a file.\nfunc WriteFile(filePath string, content []byte) error {\n\treturn ioutil.WriteFile(filePath, content, 0644)\n}"}
{"sample": "// Check if a string is a palindrome\nfunc IsPalindrome(str string) bool {\n\tfor i := 0; i < len(str)/2; i++ {\n\t\tif str[i] != str[len(str)-1-i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"sample": "package couchdbclient\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Client struct {\n\tserverURL string\n}\n\nfunc NewClient(serverURL string) *Client {\n\treturn &Client{serverURL: serverURL}\n}\n\nfunc (c *Client) GetDatabaseInfo(dbName string) (map[string]interface{}, error) {\n\tresp, err := http.Get(c.serverURL + \"/\" + dbName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to get database info\")\n\t}\n\n\tvar result map[string]interface{}\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n\nfunc (c *Client) CreateDocument(dbName string, doc interface{}) (string, error) {\n\tdocBytes, err := json.Marshal(doc)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tresp, err := http.Post(c.serverURL+\"/\"+dbName, \"application/json\", bytes.NewReader(docBytes))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusCreated {\n\t\treturn \"\", errors.New(\"failed to create document\")\n\t}\n\n\tlocation := resp.Header.Get(\"Location\")\n\tparts := strings.Split(location, \"/\")\n\tdocID := parts[len(parts)-1]\n\n\treturn docID, nil\n}\n\nfunc (c *Client) GetDocument(dbName, docID string) (map[string]interface{}, error) {\n\tresp, err := http.Get(c.serverURL + \"/\" + dbName + \"/\" + docID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to get document\")\n\t}\n\n\tvar result map[string]interface{}\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n\nfunc (c *Client) DeleteDocument(dbName, docID, rev string) error {\n\treq, err := http.NewRequest(http.MethodDelete, c.serverURL+\"/\"+dbName+\"/\"+docID, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"If-Match\", rev)\n\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(\"failed to delete document\")\n\t}\n\n\treturn nil\n}\n\nfunc (c *Client) QueryView(dbName, designDoc, viewName string, params map[string]string) ([]map[string]interface{}, error) {\n\tquery := fmt.Sprintf(\"_design/%s/_view/%s\", designDoc, viewName)\n\tif len(params) > 0 {\n\t\tquery += \"?\"\n\t\tfor k, v := range params {\n\t\t\tquery += fmt.Sprintf(\"%s=%s&\", k, v)\n\t\t}\n\t\tquery = strings.TrimSuffix(query, \"&\")\n\t}\n\n\tresp, err := http.Get(c.serverURL + \"/\" + dbName + \"/\" + query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to query view\")\n\t}\n\n\tvar result struct {\n\t\tRows []struct {\n\t\t\tID    string                 `json:\"id\"`\n\t\t\tKey   interface{}            `json:\"key\"`\n\t\t\tValue map[string]interface{} `json:\"value\"`\n\t\t} `json:\"rows\"`\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar docs []map[string]interface{}\n\tfor _, row := range result.Rows {\n\t\tdoc := row.Value\n\t\tdoc[\"_id\"] = row.ID\n\t\tdoc[\"_rev\"] = \"\"\n\t\tdocs = append(docs, doc)\n\t}\n\n\treturn docs, nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tresult := Max(4, 7)\n\tfmt.Println(result)\n}\n\nfunc Max(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}"}
{"sample": "package main\n\nfunc ConvertToUpperCase(str string) string {\n\treturn strings.ToUpper(str)\n}\n"}
{"sample": "package main\n\n// WrapErrorWithMessage wraps an error with a new error message\nfunc WrapErrorWithMessage(err error, message string) error {\n\treturn fmt.Errorf(\"%s: %w\", message, err)\n}\n"}
{"sample": "package twitterbot\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/dghubble/go-twitter/twitter\"\n\t\"github.com/dghubble/oauth1\"\n)\n\nfunc replyToMentions() error {\n\tconfig := oauth1.NewConfig(os.Getenv(\"TWITTER_CONSUMER_KEY\"), os.Getenv(\"TWITTER_CONSUMER_SECRET\"))\n\ttoken := oauth1.NewToken(os.Getenv(\"TWITTER_ACCESS_TOKEN\"), os.Getenv(\"TWITTER_ACCESS_SECRET\"))\n\thttpClient := config.Client(oauth1.NoContext, token)\n\n\tclient := twitter.NewClient(httpClient)\n\n\tmentionsTimelineParams := &twitter.MentionTimelineParams{\n\t\tCount: 10,\n\t}\n\n\tmentions, _, err := client.Timelines.MentionTimeline(mentionsTimelineParams)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, mention := range mentions {\n\t\tif !mention.InReplyToUserID.Valid {\n\t\t\tcontinue\n\t\t}\n\t\ttweet := fmt.Sprintf(\"@%v Thanks for the mention! \ud83d\ude0a\", mention.User.ScreenName)\n\t\treplyParams := &twitter.StatusUpdateParams{\n\t\t\tInReplyToStatusID: mention.ID,\n\t\t\tStatus:           tweet,\n\t\t}\n\t\t_, _, err = client.Statuses.Update(tweet, replyParams)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tlog.Printf(\"Replied to mention from %v\\n\", mention.User.ScreenName)\n\t}\n\treturn nil\n}"}
{"sample": "package ldapauth\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/go-ldap/ldap/v3\"\n)\n\ntype LDAPAuth struct {\n\tURL      string\n\tBaseDN   string\n\tBindDN   string\n\tBindPass string\n}\n\nfunc (la *LDAPAuth) Authenticate(username, password string) error {\n\tl, err := ldap.DialURL(la.URL)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error connecting to LDAP server: %v\", err)\n\t}\n\tdefer l.Close()\n\n\tif err := l.Bind(la.BindDN, la.BindPass); err != nil {\n\t\treturn fmt.Errorf(\"error binding to LDAP server: %v\", err)\n\t}\n\n\tsearchRequest := ldap.NewSearchRequest(\n\t\tla.BaseDN,\n\t\tldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,\n\t\tfmt.Sprintf(\"(&(objectClass=person)(uid=%s))\", username),\n\t\t[]string{\"dn\"},\n\t\tnil,\n\t)\n\n\tsr, err := l.Search(searchRequest)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error searching LDAP server: %v\", err)\n\t}\n\n\tif len(sr.Entries) != 1 {\n\t\treturn fmt.Errorf(\"user not found or too many entries returned\")\n\t}\n\n\tuserDN := sr.Entries[0].DN\n\n\tif err := l.Bind(userDN, password); err != nil {\n\t\treturn fmt.Errorf(\"invalid credentials: %v\", err)\n\t}\n\n\tlog.Printf(\"User %s authenticated successfully\", username)\n\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a channel of strings\n\tmsgChan := make(chan string)\n\n\t// Start a goroutine\n\tgo func() {\n\t\t// Send a message into the channel after 2 seconds\n\t\ttime.Sleep(2 * time.Second)\n\t\tmsgChan <- \"Hello from the goroutine!\"\n\t}()\n\n\t// Wait for a message to be received from the channel\n\tmsg := <-msgChan\n\n\tfmt.Println(msg)\n}"}
{"sample": "package main\n\nfunc main() {\n\tresult := Cube(5)\n\tfmt.Println(result)\n}\n\nfunc Cube(n int) int {\n\treturn n * n * n\n}"}
{"sample": "err = os.Remove(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "values := []int{1, 2, 3}\nvalues = append(values, 4, 5)\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstartTime := time.Now()\n\n\t// Run some time-consuming operation\n\ttime.Sleep(2 * time.Second)\n\n\tendTime := time.Now()\n\tduration := endTime.Sub(startTime)\n\n\tfmt.Println(\"Operation took\", duration)\n}"}
{"sample": "func execStatement(stmt *sql.Stmt, args ...interface{}) (sql.Result, error) {\n\tresult, err := stmt.Exec(args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n"}
{"sample": "package imgur\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\t\"errors\"\n)\n\ntype imgurClient struct {\n\tclientId        string\n\tbaseUrl         string\n\thttpClient      *http.Client\n\tUserLimit       int\n\tUserRemaining   int\n\tUserReset       time.Time\n\tClientLimit     int\n\tClientRemaining int\n}\n\ntype Comment struct {\n\tId         int       `json:\"id\"`\n\tImageId    string    `json:\"image_id\"`\n\tComment    string    `json:\"comment\"`\n\tAuthor     string    `json:\"author\"`\n\tAuthorId   int       `json:\"author_id\"`\n\tOnAlbum    bool      `json:\"on_album\"`\n\tAlbumCover string    `json:\"album_cover\"`\n\tDateTime   int       `json:\"datetime\"`\n\tUps        int       `json:\"ups\"`\n\tDowns      int       `json:\"downs\"`\n\tPoints     int       `json:\"points\"`\n\tParentId   int       `json:\"parent_id\"`\n\tDeleted    bool      `json:\"deleted\"`\n\tChildren   []Comment `json:\"children\"`\n}\n\ntype Image struct {\n\tId          string `json:\"id\"`\n\tTitle       string `json:\"title\"`\n\tDescription string `json:\"description\"`\n\tDateTime    int    `json:\"datetime\"`\n\tType        string `json:\"type\"`\n\tAnimated    bool   `json:\"animated\"`\n\tWidth       int    `json:\"width\"`\n\tHeight      int    `json:\"height\"`\n\tSize        int    `json:\"size\"`\n\tViews       int    `json:\"views\"`\n\tBandwidth   int    `json:\"bandwidth\"`\n\tLink        string `json:\"link\"`\n\tNsfw        bool   `json:\"nsfw\"`\n\tSection     string `json:\"section\"`\n}\n\ntype ImgurGallery struct {\n\tId             string    `json:\"id\"`\n\tTitle          string    `json:\"title\"`\n\tDescription    string    `json:\"description\"`\n\tDateTime       int       `json:\"datetime\"`\n\tCover          string    `json:\"cover\"`\n\tNsfw           bool      `json:\"nsfw\"`\n\tCommentCount   int       `json:\"comment_count\"`\n\tCommentPreview []Comment `json:\"comment_preview\"`\n\tTopic          string    `json:\"topic\"`\n\tImageCount     int       `json:\"images_count\"`\n\tImages         []Image   `json:\"images\"`\n}\n\nconst baseImgurUrl = \"https://api.imgur.com/3\"\n\nfunc NewClient(clientId string) imgurClient {\n\tiClient := imgurClient{\n\t\tclientId:   clientId,\n\t\thttpClient: &http.Client{},\n\t\tbaseUrl:    baseImgurUrl,\n\t}\n\n\treturn iClient\n}\n\nfunc (c *imgurClient) get(url string, params map[string]string, r io.Reader) (*http.Response, error) {\n\trequest, err := http.NewRequest(\"GET\", c.baseUrl+url, r)\n\trequest.Header.Add(\"Authorization\", \"Client-ID \"+c.clientId)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvalues := request.URL.Query()\n\tfor k, s := range params {\n\t\tvalues.Add(k, s)\n\t}\n\trequest.URL.RawQuery = values.Encode()\n\tresp, err := c.httpClient.Do(request)\n\n\tc.UserLimit, _ = strconv.Atoi(resp.Header.Get(\"X-RateLimit-UserLimit\"))\n\tc.UserRemaining, _ = strconv.Atoi(resp.Header.Get(\"X-RateLimit-UserRemaining\"))\n\tuserResetInt, _ := strconv.ParseInt(resp.Header.Get(\"X-RateLimit-UserReset\"), 10, 64)\n\tc.ClientLimit, _ = strconv.Atoi(resp.Header.Get(\"X-RateLimit-ClientLimit\"))\n\tc.ClientRemaining, _ = strconv.Atoi(resp.Header.Get(\"X-RateLimit-ClientRemaining\"))\n\n\tc.UserReset = time.Unix(userResetInt, 0)\n\treturn resp, err\n}\n\nfunc (c *imgurClient) GetAlbum(url string, page, perPage int) ([]Image, error) {\n\timages := struct {\n\t\tData    []Image `json:\"data\"`\n\t\tSuccess bool    `json:\"success\"`\n\t\tStatus  int     `json:\"status\"`\n\t}{}\n\n\tparams := make(map[string]string)\n\n\tparams[\"page\"] = strconv.Itoa(page)\n\tparams[\"perPage\"] = strconv.Itoa(perPage)\n\n\tresp, err := c.get(url, params, nil)\n\n\tif err != nil {\n\t\treturn images.Data, err\n\t}\n\n\n\trespBytes, readErr := ioutil.ReadAll(resp.Body)\n\n\tif resp.StatusCode != 200 {\n\t\treturn  images.Data, errors.New(string(respBytes))\n\t}\n\n\tif readErr != nil {\n\t\treturn images.Data, readErr\n\t}\n\tmarshalErr := json.Unmarshal(respBytes, &images)\n\n\treturn images.Data, marshalErr\n}\n"}
{"sample": "package main\n\n// RecoverFromPanic recovers from a panic situation\nfunc RecoverFromPanic() {\n\tif r := recover(); r != nil {\n\t\tlog.Println(\"Recovered from\", r)\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Welcome to my website!\")\n\t})\n\n\tfs := http.FileServer(http.Dir(\"static/\"))\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs))\n\n\tlog.Println(\"Listening on :8080...\")\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(num int) {\n\t\t\tfmt.Printf(\"Goroutine %d\\n\", num)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package bookapi\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n\t\"models\"\n)\n\ntype BookAPI struct {\n\trouter *mux.Router\n}\n\nfunc NewBookAPI() *BookAPI {\n\treturn &BookAPI{\n\t\trouter: mux.NewRouter(),\n\t}\n}\n\nfunc (b *BookAPI) Start() {\n\tb.router.HandleFunc(\"/books\", b.getAllBooks).Methods(\"GET\")\n\tb.router.HandleFunc(\"/books/{id}\", b.getBook).Methods(\"GET\")\n\tb.router.HandleFunc(\"/books\", b.createBook).Methods(\"POST\")\n\tb.router.HandleFunc(\"/books/{id}\", b.updateBook).Methods(\"PUT\")\n\tb.router.HandleFunc(\"/books/{id}\", b.deleteBook).Methods(\"DELETE\")\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", b.router))\n}\n\nfunc (b *BookAPI) getAllBooks(w http.ResponseWriter, r *http.Request) {\n\tbooks, err := models.GetAllBooks()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(books)\n}\n\nfunc (b *BookAPI) getBook(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tbook, err := models.GetBook(id)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(book)\n}\n\nfunc (b *BookAPI) createBook(w http.ResponseWriter, r *http.Request) {\n\tvar book models.Book\n\tif err := json.NewDecoder(r.Body).Decode(&book); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif err := book.Create(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(book)\n}\n\nfunc (b *BookAPI) updateBook(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar book models.Book\n\tif err := json.NewDecoder(r.Body).Decode(&book); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif err := book.Update(id); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(book)\n}\n\nfunc (b *BookAPI) deleteBook(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif err := models.DeleteBook(id); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n}"}
{"sample": "select {\ncase <-ch1:\n\tfmt.Println(\"Received from ch1\")\ncase <-ch2:\n\tfmt.Println(\"Received from ch2\")\ndefault:\n\tfmt.Println(\"No data received\")\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/handlers\"\n)\n\nfunc EnableCORSWithHandlers() {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, CORS with Handlers!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", handlers.CORS(\n\t\thandlers.AllowedOrigins([]string{\"*\"}),\n\t\thandlers.AllowedMethods([]string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"}),\n\t\thandlers.AllowedHeaders([]string{\"Content-Type\"}),\n\t)(handler))\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// SortInts sorts a slice of integers in ascending order.\nfunc SortInts(nums []int) {\n\tsort.Ints(nums)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"example.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tstat, err := file.Stat()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tbs := make([]byte, stat.Size())\n\t_, err = file.Read(bs)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tstr := string(bs)\n\tfmt.Println(str)\n}"}
{"sample": "package concurhttp\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nfunc makeConcurrentRequests(urls []string) ([]string, error) {\n\tvar wg sync.WaitGroup\n\tvar mutex sync.Mutex\n\tvar results []string\n\terrors := make(chan error, len(urls))\n\n\tfor _, url := range urls {\n\t\twg.Add(1)\n\t\tgo func(url string) {\n\t\t\tdefer wg.Done()\n\n\t\t\tresp, err := http.Get(url)\n\t\t\tif err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tmutex.Lock()\n\t\t\tresults = append(results, string(body))\n\t\t\tmutex.Unlock()\n\t\t}(url)\n\t}\n\n\twg.Wait()\n\n\tselect {\n\tcase err := <-errors:\n\t\treturn nil, err\n\tdefault:\n\t\treturn results, nil\n\t}\n}\n\nfunc main() {\n\turls := []string{\"https://www.google.com\", \"https://www.facebook.com\", \"https://www.twitter.com\"}\n\tresults, err := makeConcurrentRequests(urls)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(results)\n}"}
{"sample": "// Handle HTTP OPTIONS method for CORS preflight requests\nfunc HandleOptionsMethod(response http.ResponseWriter, request *http.Request) {\n\tresponse.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tresponse.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n\tresponse.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type\")\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// GenerateRandomNumber generates a random number within the specified range.\nfunc GenerateRandomNumber(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}"}
{"sample": "// IfErrorThenLogAndReturnDefault checks if an error exists, if so, logs it and returns a default value\nfunc IfErrorThenLogAndReturnDefault(err error, defaultValue string) string {\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn defaultValue\n\t}\n\treturn \"\"\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tslice := []int{1, 2, 3, 4, 5, 6}\n\n\tdoubleSlice := double(slice)\n\n\tfmt.Println(doubleSlice)\n}\n\nfunc double(nums []int) []int {\n\tdoubleSlice := make([]int, len(nums))\n\n\tfor i, num := range nums {\n\t\tdoubleSlice[i] = num * 2\n\t}\n\n\treturn doubleSlice\n}"}
{"sample": "// Convert a string to lowercase\nfunc ToLowercase(str string) string {\n\treturn strings.ToLower(str)\n}\n"}
{"sample": "// IfErrorThenLog checks if an error exists, if so, logs it\nfunc IfErrorThenLog(err error) {\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n"}
{"sample": "walker := func(path string, info os.FileInfo, err error) error {\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Println(path)\n\treturn nil\n}\nfilepath.Walk(\".\", walker)\n"}
{"sample": "package main\n\n// Get the directory name of a file path\nfunc main() {\n\tabsPath, _ := filepath.Abs(\"file.txt\")\n\tdir := filepath.Dir(absPath)\n\tfmt.Println(\"Directory:\", dir)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\nfunc main() {\n\tdb, err := sql.Open(\"sqlite3\", \"./mydb.db\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Create table\n\t_, err = db.Exec(`CREATE TABLE IF NOT EXISTS users(\n\t\tid INTEGER PRIMARY KEY,\n\t\tname TEXT NOT NULL,\n\t\tage INTEGER NOT NULL DEFAULT 0\n\t);`)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Insert a user\n\tres, err := db.Exec(\"INSERT INTO users (name, age) VALUES (?, ?)\", \"Alice\", 27)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlastID, err := res.LastInsertId()\n\tfmt.Printf(\"Last inserted ID: %v\\n\", lastID)\n\n\t// Query all users\n\trows, err := db.Query(\"SELECT id, name, age FROM users\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\tvar age int\n\t\tif err := rows.Scan(&id, &name, &age); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Printf(\"User ID=%d, Name=%s, Age=%d\\n\", id, name, age)\n\t}\n}"}
{"sample": "package jobservice\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"models\"\n\t\"time\"\n)\n\nfunc createJob(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttitle := r.FormValue(\"title\")\n\tdescription := r.FormValue(\"description\")\n\tlocation := r.FormValue(\"location\")\n\tsalary := r.FormValue(\"salary\")\n\tcompany := r.FormValue(\"company\")\n\n\tjob := models.Job{\n\t\tTitle:       title,\n\t\tDescription: description,\n\t\tLocation:    location,\n\t\tSalary:      salary,\n\t\tCompany:     company,\n\t\tCreatedAt:   time.Now(),\n\t}\n\n\tif err := job.Create(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"Job created successfully\")\n}\n\nfunc applyJob(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tjobID := r.FormValue(\"job_id\")\n\tname := r.FormValue(\"name\")\n\temail := r.FormValue(\"email\")\n\tresume := r.FormValue(\"resume\")\n\n\tapplication := models.Application{\n\t\tJobID:  jobID,\n\t\tName:   name,\n\t\tEmail:  email,\n\t\tResume: resume,\n\t}\n\n\tif err := application.Create(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"Application submitted successfully\")\n}\n\nfunc getJobs(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"GET\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tjobs, err := models.GetJobs()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(jobs)\n}"}
{"sample": "files, err := ioutil.ReadDir(\".\")\nif err != nil {\n\tlog.Fatal(err)\n}\nfor _, file := range files {\n\tfmt.Println(file.Name())\n}\n"}
{"sample": "// IfErrorThenReplaceWithFormattedError checks if an error exists, if so, replaces it with a new formatted error\nfunc IfErrorThenReplaceWithFormattedError(err *error, format string, a ...interface{}) {\n\tif *err != nil {\n\t\t*err = fmt.Errorf(format, a...)\n\t}\n}\n"}
{"sample": "func dropIndex(tx *sql.Tx) error {\n\tstmt, err := tx.Prepare(\"DROP INDEX IF EXISTS idx_name\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package pdfgen\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os/exec\"\n\t\"text/template\"\n)\n\ntype Data struct {\n\tName string\n\tAge  int\n}\n\nfunc GeneratePDF(data Data) error {\n\thtmlTemplate, err := template.ParseFiles(\"template.html\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tvar tpl bytes.Buffer\n\tif err := htmlTemplate.Execute(&tpl, data); err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\thtmlBytes := tpl.Bytes()\n\n\tif err := ioutil.WriteFile(\"output.html\", htmlBytes, 0644); err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tcmd := exec.Command(\"wkhtmltopdf\", \"output.html\", \"output.pdf\")\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tfmt.Println(\"PDF generated successfully\")\n\treturn nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintAreaOfRectangle(5, 10)\n}\n\n// Function to print the area of a rectangle\nfunc PrintAreaOfRectangle(length, width float64) {\n\tfmt.Println(length * width)\n}"}
{"sample": "package stoogesort\n\nfunc StoogeSort(arr []int, l int, h int) {\n\tif l >= h {\n\t\treturn\n\t}\n\n\tif arr[l] > arr[h] {\n\t\tarr[l], arr[h] = arr[h], arr[l]\n\t}\n\n\tif h-l+1 > 2 {\n\t\tt := (h - l + 1) / 3\n\n\t\tStoogeSort(arr, l, h-t)\n\t\tStoogeSort(arr, l+t, h)\n\t\tStoogeSort(arr, l, h-t)\n\t}\n\n\treturn\n}"}
{"sample": "package yaml2json\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\n\t\"gopkg.in/yaml.v2\"\n)\n\ntype Config struct {\n\tName    string `yaml:\"name\"`\n\tVersion string `yaml:\"version\"`\n}\n\nfunc main() {\n\tyamlFile, err := ioutil.ReadFile(\"config.yaml\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading YAML file: %v\", err)\n\t}\n\n\tvar config Config\n\terr = yaml.Unmarshal(yamlFile, &config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error unmarshaling YAML: %v\", err)\n\t}\n\n\tjsonData, err := json.Marshal(config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error marshaling JSON: %v\", err)\n\t}\n\n\tfmt.Println(string(jsonData))\n}"}
{"sample": "package main\n\n// CheckErrorAndExit checks for an error and exits if one exists\nfunc CheckErrorAndExit(err error) {\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "type Cache struct {\n\tmutex  sync.Mutex\n\tvalues map[string]interface{}\n}\n\nfunc NewCache() *Cache {\n\treturn &Cache{\n\t\tvalues: make(map[string]interface{}),\n\t}\n}\n\nfunc (c *Cache) Get(key string) (interface{} bool) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\tvalue, ok := c.values[key]\n\treturn value, ok\n}\n\nfunc (c *Cache) Set(key string, value interface{}) {\n\tc.mutex.Lock()\n\tc.values[key] = value\n\tc.mutex.Unlock()\n}"}
{"sample": "resp, err := http.Get(\"http://google.com\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer resp.Body.Close()\n"}
{"sample": "package escluster\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/elastic/go-elasticsearch/v8\"\n)\n\ntype Cluster struct {\n\tclient *elasticsearch.Client\n}\n\nfunc NewCluster(addresses []string) (*Cluster, error) {\n\tcfg := elasticsearch.Config{\n\t\tAddresses: addresses,\n\t}\n\n\tclient, err := elasticsearch.NewClient(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Cluster{client: client}, nil\n}\n\nfunc (c *Cluster) GetClusterHealth() (string, error) {\n\tres, err := c.client.Cluster.Health(\n\t\tc.client.Cluster.Health.WithContext(context.Background()),\n\t\tc.client.Cluster.Health.WithPretty(),\n\t)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(\"Cluster status: %s\", res.Status), nil\n}\n\nfunc (c *Cluster) GetIndexMappings(index string) (string, error) {\n\tres, err := c.client.Indices.GetMapping(\n\t\tc.client.Indices.GetMapping.WithContext(context.Background()),\n\t\tc.client.Indices.GetMapping.WithIndex(index),\n\t\tc.client.Indices.GetMapping.WithPretty(),\n\t)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(\"Mappings for index %s: %s\", index, res), nil\n}"}
{"sample": "func HandleNotFound(w http.ResponseWriter, r *http.Request) {\n\tw.WriteHeader(http.StatusNotFound)\n\tfmt.Fprintln(w, \"Not Found\")\n}\n\nfunc HandleBadRequest(w http.ResponseWriter, r *http.Request) {\n\tw.WriteHeader(http.StatusBadRequest)\n\tfmt.Fprintln(w, \"Bad Request\")\n}\n\nfunc HandleInternalServerError(w http.ResponseWriter, r *http.Request) {\n\tw.WriteHeader(http.StatusInternalServerError)\n\tfmt.Fprintln(w, \"Internal Server Error\")\n}"}
{"sample": "result := multiply([]int{1, 2, 3, 4, 5})\nfmt.Printf(\"Result: %d\\n\", result)\n"}
{"sample": "func GetFileSize(path string) (int64, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer file.Close()\n\n\tfi, err := file.Stat()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn fi.Size(), nil\n}\n\nfunc WriteBytesToFile(path string, data []byte) error {\n\treturn ioutil.WriteFile(path, data, 0644)\n}\n\nfunc AppendBytesToFile(path string, data []byte) error {\n\tfile, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\t_, err = file.Write(data)\n\treturn err\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\t// create a Redis client\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\t// ping the Redis server to check if it's running\n\tpong, err := rdb.Ping(context.Background()).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(pong)\n\n\t// set a key-value pair\n\terr = rdb.Set(context.Background(), \"foo\", \"bar\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// get the value for a key\n\tval, err := rdb.Get(context.Background(), \"foo\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"foo\", val)\n\n\t// set a key-value pair with an expiration time\n\terr = rdb.Set(context.Background(), \"baz\", \"qux\", 5*time.Second).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// wait for the key to expire\n\ttime.Sleep(6 * time.Second)\n\n\t// try to get the expired key\n\tval, err = rdb.Get(context.Background(), \"baz\").Result()\n\tif err == redis.Nil {\n\t\tfmt.Println(\"baz does not exist\")\n\t} else if err != nil {\n\t\tpanic(err)\n\t} else {\n\t\tfmt.Println(\"baz\", val)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Fibonacci generates the Fibonacci sequence up to the specified limit.\nfunc Fibonacci(limit int) {\n\ta, b := 0, 1\n\tfmt.Println(a)\n\tfor b <= limit {\n\t\tfmt.Println(b)\n\t\ta, b = b, a+b\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintEvenNumbers prints even numbers up to a given limit.\nfunc PrintEvenNumbers(limit int) {\n\tfor i := 0; i <= limit; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"ls\", \"-la\")\n\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(string(output))\n}"}
{"sample": "package object\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/mr-tron/base58\"\n\t\"github.com/nspcc-dev/neofs-api-go/v2/refs\"\n)\n\n// ID represents v2-compatible object identifier.\ntype ID refs.ObjectID\n\nvar errInvalidIDString = errors.New(\"incorrect format of the string object ID\")\n\n// NewIDFromV2 wraps v2 ObjectID message to ID.\n//\n// Nil refs.ObjectID converts to nil.\nfunc NewIDFromV2(idV2 *refs.ObjectID) *ID {\n\treturn (*ID)(idV2)\n}\n\n// NewID creates and initializes blank ID.\n//\n// Works similar as NewIDFromV2(new(ObjectID)).\n//\n// Defaults:\n// \t- value: nil.\nfunc NewID() *ID {\n\treturn NewIDFromV2(new(refs.ObjectID))\n}\n\n// SetSHA256 sets object identifier value to SHA256 checksum.\nfunc (id *ID) SetSHA256(v [sha256.Size]byte) {\n\t(*refs.ObjectID)(id).SetValue(v[:])\n}\n\n// Equal returns true if identifiers are identical.\nfunc (id *ID) Equal(id2 *ID) bool {\n\treturn bytes.Equal(\n\t\t(*refs.ObjectID)(id).GetValue(),\n\t\t(*refs.ObjectID)(id2).GetValue(),\n\t)\n}\n\n// ToV2 converts ID to v2 ObjectID message.\n//\n// Nil ID converts to nil.\nfunc (id *ID) ToV2() *refs.ObjectID {\n\treturn (*refs.ObjectID)(id)\n}\n\n// Parse converts base58 string representation into ID.\nfunc (id *ID) Parse(s string) error {\n\tdata, err := base58.Decode(s)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not parse object.ID from string: %w\", err)\n\t} else if len(data) != sha256.Size {\n\t\treturn errInvalidIDString\n\t}\n\n\t(*refs.ObjectID)(id).SetValue(data)\n\n\treturn nil\n}\n\n// String returns base58 string representation of ID.\nfunc (id *ID) String() string {\n\treturn base58.Encode((*refs.ObjectID)(id).GetValue())\n}\n\n// Marshal marshals ID into a protobuf binary form.\n//\n// Buffer is allocated when the argument is empty.\n// Otherwise, the first buffer is used.\nfunc (id *ID) Marshal(b ...[]byte) ([]byte, error) {\n\tvar buf []byte\n\tif len(b) > 0 {\n\t\tbuf = b[0]\n\t}\n\n\treturn (*refs.ObjectID)(id).\n\t\tStableMarshal(buf)\n}\n\n// Unmarshal unmarshals protobuf binary representation of ID.\nfunc (id *ID) Unmarshal(data []byte) error {\n\treturn (*refs.ObjectID)(id).\n\t\tUnmarshal(data)\n}\n\n// MarshalJSON encodes ID to protobuf JSON format.\nfunc (id *ID) MarshalJSON() ([]byte, error) {\n\treturn (*refs.ObjectID)(id).\n\t\tMarshalJSON()\n}\n\n// UnmarshalJSON decodes ID from protobuf JSON format.\nfunc (id *ID) UnmarshalJSON(data []byte) error {\n\treturn (*refs.ObjectID)(id).\n\t\tUnmarshalJSON(data)\n}\n"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--batch-size\", argparse.Int, 12, \"Batch size.\")\nparser.AddArgument(\"--lr\", argparse.Float, 3e-4, \"Maximum learning rate\")\n"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype User struct {\n\tUsername  string    `json:\"username\"`\n\tEmail     string    `json:\"email,omitempty\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n}\n\nfunc getUserHandler(w http.ResponseWriter, r *http.Request) {\n\tuser := User{\n\t\tUsername:  \"johndoe\",\n\t\tCreatedAt: time.Now(),\n\t}\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/user\", getUserHandler)\n\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tfmt.Println(err)\n\t}\n}"}
{"sample": "// Serve a file as the response\nfunc ServeFile(response http.ResponseWriter, request *http.Request, path string) {\n\thttp.ServeFile(response, request, path)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tfmt.Println(\"Goroutine 1 executing\")\n\t\twg.Done()\n\t}()\n\n\tgo func() {\n\t\tfmt.Println(\"Goroutine 2 executing\")\n\t\twg.Done()\n\t}()\n\n\twg.Wait()\n\n\tfmt.Println(\"Program complete\")\n}"}
{"sample": "package smtpmail\n\nimport (\n\t\"net/smtp\"\n)\n\nfunc SendMail(to []string, subject string, body string) error {\n\tfrom := \"youremail@example.com\"\n\tpassword := \"yourpassword\"\n\tsmtpHost := \"smtp.example.com\"\n\tsmtpPort := \"587\"\n\n\tauth := smtp.PlainAuth(\"\", from, password, smtpHost)\n\n\tmsg := []byte(\"To: \" + to[0] + \"\\r\\n\" +\n\t\t\"Subject: \" + subject + \"\\r\\n\" +\n\t\t\"\\r\\n\" +\n\t\tbody + \"\\r\\n\")\n\n\terr := smtp.SendMail(smtpHost+\":\"+smtpPort, auth, from, to, msg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package ftpserver\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype FTPServer struct {\n\troot string\n}\n\nfunc NewFTPServer(root string) *FTPServer {\n\treturn &FTPServer{root: root}\n}\n\nfunc (s *FTPServer) ListenAndServe(addr string) error {\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer listener.Close()\n\n\tlog.Printf(\"Listening on %v\", addr)\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to accept connection: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo s.handleConn(conn)\n\t}\n}\n\nfunc (s *FTPServer) handleConn(conn net.Conn) {\n\tdefer conn.Close()\n\n\tlog.Printf(\"Accepted connection from %v\", conn.RemoteAddr())\n\n\tfmt.Fprintf(conn, \"220 FTP Server Ready.\\r\\n\")\n\n\tvar user string\n\tvar authenticated bool\n\n\tfor {\n\t\tcmd, err := readCommand(conn)\n\t\tif err != nil {\n\t\t\tif err != io.EOF {\n\t\t\t\tlog.Printf(\"Failed to read command: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tlog.Printf(\"Received command: %v\", cmd)\n\n\t\tswitch cmd.Code {\n\t\tcase \"USER\":\n\t\t\tuser = cmd.Arg\n\t\t\tfmt.Fprintf(conn, \"331 Password required for %v.\\r\\n\", user)\n\t\tcase \"PASS\":\n\t\t\tif user == \"anonymous\" {\n\t\t\t\tfmt.Fprintf(conn, \"230 Logged on anonymously.\\r\\n\")\n\t\t\t\tauthenticated = true\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(conn, \"530 Login incorrect.\\r\\n\")\n\t\t\t}\n\t\tcase \"QUIT\":\n\t\t\tfmt.Fprintf(conn, \"221 Goodbye.\\r\\n\")\n\t\t\treturn\n\t\tcase \"SYST\":\n\t\t\tfmt.Fprintf(conn, \"215 UNIX Type: L8\\r\\n\")\n\t\tcase \"TYPE\":\n\t\t\tfmt.Fprintf(conn, \"200 Type set to %v.\\r\\n\", cmd.Arg)\n\t\tcase \"PWD\":\n\t\t\tfmt.Fprintf(conn, \"257 \\\"%v\\\" is the current directory.\\r\\n\", s.root)\n\t\tcase \"CWD\":\n\t\t\tpath := filepath.Join(s.root, cmd.Arg)\n\t\t\tif _, err := os.Stat(path); err != nil {\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to change directory.\\r\\n\")\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(conn, \"250 Directory changed to \\\"%v\\\".\\r\\n\", cmd.Arg)\n\t\t\t}\n\t\tcase \"LIST\":\n\t\t\tif !authenticated {\n\t\t\t\tfmt.Fprintf(conn, \"530 Not logged in.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpath := filepath.Join(s.root, cmd.Arg)\n\t\t\tif _, err := os.Stat(path); err != nil {\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to list directory.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Fprintf(conn, \"150 Opening data connection for directory list.\\r\\n\")\n\n\t\t\tfiles, err := os.ReadDir(path)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to read directory: %v\", err)\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to list directory.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, file := range files {\n\t\t\t\tinfo, err := file.Info()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to get file info: %v\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tmode := info.Mode().String()\n\t\t\t\tsize := info.Size()\n\t\t\t\tname := file.Name()\n\n\t\t\t\tif info.IsDir() {\n\t\t\t\t\tmode = \"d\" + mode[1:]\n\t\t\t\t\tsize = 0\n\t\t\t\t}\n\n\t\t\t\tfmt.Fprintf(conn, \"%v %3v %-8v %-8v %12v %v\\r\\n\",\n\t\t\t\t\tmode, 1, \"user\", \"group\", size, name)\n\t\t\t}\n\n\t\t\tfmt.Fprintf(conn, \"226 Directory send OK.\\r\\n\")\n\t\tcase \"RETR\":\n\t\t\tif !authenticated {\n\t\t\t\tfmt.Fprintf(conn, \"530 Not logged in.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpath := filepath.Join(s.root, cmd.Arg)\n\t\t\tif _, err := os.Stat(path); err != nil {\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to retrieve file.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Fprintf(conn, \"150 Opening data connection for file transfer.\\r\\n\")\n\n\t\t\tfile, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to open file: %v\", err)\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to retrieve file.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\tif _, err := io.Copy(conn, file); err != nil {\n\t\t\t\tlog.Printf(\"Failed to transfer file: %v\", err)\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to retrieve file.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Fprintf(conn, \"226 File send OK.\\r\\n\")\n\t\tdefault:\n\t\t\tfmt.Fprintf(conn, \"502 Command not implemented.\\r\\n\")\n\t\t}\n\t}\n}\n\nfunc readCommand(conn net.Conn) (*command, error) {\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tline := strings.TrimSpace(string(buf[:n]))\n\tparts := strings.SplitN(line, \" \", 2)\n\n\tcmd := &command{Code: strings.ToUpper(parts[0])}\n\tif len(parts) > 1 {\n\t\tcmd.Arg = parts[1]\n\t}\n\n\treturn cmd, nil\n}\n\ntype command struct {\n\tCode string\n\tArg  string\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\tdefer cancel()\n\n\tselect {\n\tcase <-time.After(5 * time.Second):\n\t\tfmt.Println(\"time.After: This should never be printed.\")\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"Context done:\", ctx.Err())\n\t}\n} \n\n// Output:\n// Context done: context deadline exceeded"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc sum(arr []int) int {\n\tsum := 0\n\n\tfor _, a := range arr {\n\t\tsum += a\n\t}\n\n\treturn sum\n}\n\nfunc findSumSign(op string) int {\n\tfor i, t := range op {\n\t\tif t == '+' {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n\nfunc getLastNumber(op string) (int, int) {\n\tterms := strings.Split(op, \" \")\n\tnumber, _ := strconv.Atoi(terms[len(terms)-1])\n\n\treturn number, int(math.Log10(float64(number))) + 1\n}\n\nfunc getFirstNumber(op string) (int, int) {\n\tterms := strings.Split(op, \" \")\n\tnumber, _ := strconv.Atoi(terms[0])\n\n\treturn number, int(math.Log10(float64(number))) + 1\n}\n\nfunc evaluateSums(op string) string {\n\tfor strings.Count(op, \"+\") != 0 {\n\t\tsum := findSumSign(op)\n\n\t\tnum1, digits1 := getLastNumber(op[:sum-1])\n\t\tnum2, digits2 := getFirstNumber(op[sum+2:])\n\n\t\tpartial := num1 + num2\n\n\t\top = op[:sum-1-digits1] + strconv.Itoa(partial) + op[sum+2+digits2:]\n\t}\n\n\treturn op\n}\n\nfunc evaluateArithmetic(op string, level int) int {\n\tif level == 1 {\n\t\tterms := strings.Split(op, \" \")\n\t\tresult, _ := strconv.Atoi(terms[0])\n\n\t\tfor i := 1; i < len(terms); i += 2 {\n\t\t\tif terms[i] == \"+\" {\n\t\t\t\tnum, _ := strconv.Atoi(terms[i+1])\n\t\t\t\tresult += num\n\t\t\t}\n\n\t\t\tif terms[i] == \"*\" {\n\t\t\t\tnum, _ := strconv.Atoi(terms[i+1])\n\t\t\t\tresult *= num\n\t\t\t}\n\t\t}\n\n\t\treturn result\n\t}\n\n\top = evaluateSums(op)\n\n\tterms := strings.Split(op, \" \")\n\tresult, _ := strconv.Atoi(terms[0])\n\n\tfor i := 1; i < len(terms); i += 2 {\n\t\tif terms[i] == \"*\" {\n\t\t\tnum, _ := strconv.Atoi(terms[i+1])\n\t\t\tresult *= num\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc findMostInnerParentheses(op string) (int, int) {\n\topening, closing := -1, -1\n\n\tfor i, t := range op {\n\t\tif t == '(' {\n\t\t\topening = i\n\t\t}\n\n\t\tif t == ')' {\n\t\t\tclosing = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn opening, closing\n}\n\nfunc evaluate(op string, level int) int {\n\tfor strings.Count(op, \"(\") > 0 {\n\t\topening, closing := findMostInnerParentheses(op)\n\n\t\tpartial := evaluateArithmetic(op[opening+1:closing], level)\n\n\t\top = op[:opening] + strconv.Itoa(partial) + op[closing+1:]\n\t}\n\n\treturn evaluateArithmetic(op, level)\n}\n\nfunc main() {\n\tfile, _ := os.Open(\"input.txt\")\n\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tvar operations []string\n\n\tfor scanner.Scan() {\n\t\toperations = append(operations, scanner.Text())\n\t}\n\n\tvar results1 []int\n\n\tfor _, op := range operations {\n\t\tresults1 = append(results1, evaluate(op, 1))\n\t}\n\n\tfmt.Printf(\"Sum of all operations (1): %d\\n\", sum(results1))\n\n\tvar results2 []int\n\n\tfor _, op := range operations {\n\t\tresults2 = append(results2, evaluate(op, 2))\n\t}\n\n\tfmt.Printf(\"Sum of all operations (2): %d\\n\", sum(results2))\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// IsPalindrome checks if a given string is a palindrome and returns true if it is.\nfunc IsPalindrome(str string) bool {\n\tfor i, j := 0, len(str)-1; i < j; i, j = i+1, j-1 {\n\t\tif str[i] != str[j] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"sample": "func getRowCount(rows *sql.Rows) (int, error) {\n\tcount := 0\n\tfor rows.Next() {\n\t\tcount++\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn 0, err\n\t}\n\treturn count, nil\n}\n"}
{"sample": "package photosclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"google.golang.org/api/photoslibrary/v1\"\n\t\"google.golang.org/api/option\"\n)\n\ntype PhotosClient struct {\n\tservice *photoslibrary.Service\n}\n\nfunc NewPhotosClient(ctx context.Context, tokenSource option.ClientOption) (*PhotosClient, error) {\n\tservice, err := photoslibrary.NewService(ctx, tokenSource)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create photoslibrary service: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn &PhotosClient{\n\t\tservice: service,\n\t}, nil\n}\n\nfunc (c *PhotosClient) ListAlbums() ([]*photoslibrary.Album, error) {\n\talbums, err := c.service.Albums.List().Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to list albums: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn albums.Albums, nil\n}\n\nfunc (c *PhotosClient) UploadPhoto(photo []byte, filename string) error {\n\t_, err := c.service.UploadBytes(photo, &photoslibrary.MediaItem{Filename: filename})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to upload photo: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *PhotosClient) SearchPhotos(query string) ([]*photoslibrary.MediaItem, error) {\n\tsearchResponse, err := c.service.MediaItems.Search(&photoslibrary.SearchMediaItemsRequest{\n\t\tPageSize: 100,\n\t\tQuery:    query,\n\t}).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to search photos: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn searchResponse.MediaItems, nil\n}\n\nfunc (c *PhotosClient) GetPhoto(photoId string) (*photoslibrary.MediaItem, error) {\n\tmediaItemResponse, err := c.service.MediaItems.Get(photoId).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get photo: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn mediaItemResponse, nil\n}\n\nfunc (c *PhotosClient) CreateAlbum(albumTitle string) (*photoslibrary.Album, error) {\n\talbum, err := c.service.Albums.Create(&photoslibrary.CreateAlbumRequest{\n\t\tAlbum: &photoslibrary.Album{\n\t\t\tTitle: albumTitle,\n\t\t},\n\t}).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create album: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn album, nil\n}\n\nfunc (c *PhotosClient) AddPhotoToAlbum(photoId string, albumId string) error {\n\t_, err := c.service.Albums.BatchAddMediaItems(albumId, &photoslibrary.BatchAddMediaItemsRequest{\n\t\tMediaItemIds: []string{photoId},\n\t}).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to add photo to album: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *PhotosClient) DeletePhoto(photoId string) error {\n\terr := c.service.MediaItems.BatchDelete(&photoslibrary.BatchDeleteMediaItemsRequest{\n\t\tMediaItemIds: []string{photoId},\n\t}).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to delete photo: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *PhotosClient) DeleteAlbum(albumId string) error {\n\terr := c.service.Albums.Delete(albumId).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to delete album: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *PhotosClient) ShareAlbum(albumId string) (string, error) {\n\tshareResponse, err := c.service.SharedAlbums.Join(albumId).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to share album: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\treturn shareResponse.ShareInfo.ShareableUrl, nil\n}\n\nfunc (c *PhotosClient) GetPhotoDownloadUrl(photoId string) (string, error) {\n\tmediaItem, err := c.GetPhoto(photoId)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get photo: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\treturn mediaItem.BaseUrl, nil\n}\n\nfunc (c *PhotosClient) GetAlbumUrl(albumId string) (string, error) {\n\talbum, err := c.service.Albums.Get(albumId).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get album: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(\"https://photos.google.com/album/%s\", album.Id), nil\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// ReadCSVFile reads a CSV file and returns its content as a slice of records.\nfunc ReadCSVFile(filePath string) ([][]string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\trecords, err := reader.ReadAll()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn records, nil\n}\n\n// WriteCSVFile writes a slice of records to a CSV file.\nfunc WriteCSVFile(filePath string, records [][]string) error {\n\tfile, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\terr = writer.WriteAll(records)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twriter.Flush()\n\treturn writer.Error()\n}"}
{"sample": "package rewardsservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Reward struct {\n\tID           uuid.UUID\n\tCustomerID   uuid.UUID\n\tPoints       int\n\tRedeemed     bool\n\tDateCreated  time.Time\n\tDateModified time.Time\n}\n\ntype RewardsService struct {\n\trewards map[uuid.UUID]Reward\n}\n\nfunc NewRewardsService() *RewardsService {\n\treturn &RewardsService{\n\t\trewards: make(map[uuid.UUID]Reward),\n\t}\n}\n\nfunc (rs *RewardsService) CreateReward(ctx context.Context, customerID uuid.UUID, points int) (uuid.UUID, error) {\n\tif points <= 0 {\n\t\treturn uuid.Nil, errors.New(\"points must be greater than 0\")\n\t}\n\n\treward := Reward{\n\t\tID:           uuid.New(),\n\t\tCustomerID:   customerID,\n\t\tPoints:       points,\n\t\tRedeemed:     false,\n\t\tDateCreated:  time.Now(),\n\t\tDateModified: time.Now(),\n\t}\n\n\trs.rewards[reward.ID] = reward\n\n\treturn reward.ID, nil\n}\n\nfunc (rs *RewardsService) RedeemReward(ctx context.Context, rewardID uuid.UUID) error {\n\treward, ok := rs.rewards[rewardID]\n\tif !ok {\n\t\treturn fmt.Errorf(\"reward with ID %v not found\", rewardID)\n\t}\n\n\tif reward.Redeemed {\n\t\treturn fmt.Errorf(\"reward with ID %v has already been redeemed\", rewardID)\n\t}\n\n\treward.Redeemed = true\n\treward.DateModified = time.Now()\n\n\trs.rewards[rewardID] = reward\n\n\treturn nil\n}\n\nfunc (rs *RewardsService) GetReward(ctx context.Context, rewardID uuid.UUID) (Reward, error) {\n\treward, ok := rs.rewards[rewardID]\n\tif !ok {\n\t\treturn Reward{}, fmt.Errorf(\"reward with ID %v not found\", rewardID)\n\t}\n\n\treturn reward, nil\n}"}
{"sample": "// Check if a number is between a given range\nfunc IsInRange(num, min, max int) bool {\n\treturn num >= min && num <= max\n}\n"}
{"sample": "func main() {\n\thttp.HandleFunc(\"/\", handleRoot)\n\thttp.HandleFunc(\"/users\", handleUsers)\n\thttp.HandleFunc(\"/products\", handleProducts)\n\thttp.HandleFunc(\"/items\", handleItems)\n\thttp.HandleFunc(\"/orders\", handleOrders)\n\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc handleRoot(w http.ResponseWriter, r *http.Request) {\n\t// Handle root endpoint\n\tfmt.Fprint(w, \"Hello, World!\")\n}\n\nfunc handleUsers(w http.ResponseWriter, r *http.Request) {\n\t// Handle users endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get users\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create user\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleProducts(w http.ResponseWriter, r *http.Request) {\n\t// Handle products endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get products\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create product\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleItems(w http.ResponseWriter, r *http.Request) {\n\t// Handle items endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get items\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create item\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleOrders(w http.ResponseWriter, r *http.Request) {\n\t// Handle orders endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get orders\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create order\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n"}
{"sample": "package base64coder\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n)\n\n// EncodeBase64 encodes a byte slice to base64\nfunc EncodeBase64(data []byte) string {\n\treturn base64.StdEncoding.EncodeToString(data)\n}\n\n// DecodeBase64 decodes a base64 string to a byte slice\nfunc DecodeBase64(encoded string) ([]byte, error) {\n\tdata, err := base64.StdEncoding.DecodeString(encoded)\n\tif err != nil {\n\t\treturn nil, errors.New(\"failed to decode base64\")\n\t}\n\treturn data, nil\n}"}
{"sample": "// Package pipeline contains objects for processing by a conveyor\npackage pipeline\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"yabs/common/format\"\n\t\"yabs/common/format/minidump\"\n\t\"regexp\"\n)\n\n// Pipeline stage\ntype Stage interface {\n\t//Process the report\n\t//If return true then pipeline stop\n\tProcess(report *minidump.Report, info *format.Info) bool\n}\n\ntype SignatureAndSource struct {\n\tStage\n}\n\ntype MinidumpStackUnfolding struct {\n\tStage\n}\n\nfunc (m *SignatureAndSource) Process(report *minidump.Report, info *format.Info) bool {\n\tif len(report.CrashingThread.Frames) > 0 {\n\t\tframe := &report.CrashingThread.Frames[0]\n\t\tsignature := frame.Function\n\t\tsource := fmt.Sprintf(\"%s:%d\", frame.File,\n\t\t\tframe.Line)\n\t\treport.Signature = signature\n\t\treport.Source = source\n\t}\n\n\treturn false\n}\n\nfunc (m *MinidumpStackUnfolding) Process(report *minidump.Report, info *format.Info) bool {\n\tframes := report.CrashingThread.Frames\n\tif len(report.CrashingThread.Frames) == 0 {\n\t\t// go to next stage\n\t\treturn false\n\t}\n\n\tiqoption := regexp.MustCompile(\"iq\\\\s*option\")\n\tfor _, frame := range frames {\n\t\tmodule := strings.ToLower(frame.Module)\n\t\tif iqoption.MatchString(module) {\n\t\t\treport.Signature = frame.Function\n\t\t\treport.Source = fmt.Sprintf(\"%s:%d\", frame.File,\n\t\t\t\tframe.Line)\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn true\n}\n"}
{"sample": "// IsError checks if a returned error is a specific error\nfunc IsError(err error, target error) bool {\n\treturn errors.Is(err, target)\n}\n"}
{"sample": "package main\n\nfunc main() {\n\tresult := Factorial(5)\n\tfmt.Println(result)\n}\n\nfunc Factorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * Factorial(n-1)\n}"}
{"sample": "// PrintErrorDetails prints the error details\nfunc PrintErrorDetails(err error) {\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t}\n}\n"}
{"sample": "package firebasedb\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\tfirebase \"firebase.google.com/go\"\n\t\"firebase.google.com/go/db\"\n\t\"google.golang.org/api/option\"\n)\n\ntype User struct {\n\tName  string `json:\"name\"`\n\tEmail string `json:\"email\"`\n}\n\nfunc CreateUser(ctx context.Context, user *User) error {\n\topt := option.WithCredentialsFile(\"path/to/firebase/credentials.json\")\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tclient, err := app.Database(ctx)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tref := client.NewRef(\"users\")\n\tif err := ref.Push(ctx, user); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc ReadUser(ctx context.Context, userID string) (*User, error) {\n\topt := option.WithCredentialsFile(\"path/to/firebase/credentials.json\")\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tclient, err := app.Database(ctx)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tref := client.NewRef(\"users\")\n\tsnapshot, err := ref.OrderByChild(\"email\").EqualTo(userID).GetOrdered(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(snapshot) == 0 {\n\t\treturn nil, fmt.Errorf(\"user not found\")\n\t}\n\n\tvar user User\n\tif err := snapshot[0].Unmarshal(&user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &user, nil\n}\n\nfunc UpdateUser(ctx context.Context, userID string, user *User) error {\n\topt := option.WithCredentialsFile(\"path/to/firebase/credentials.json\")\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tclient, err := app.Database(ctx)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tref := client.NewRef(\"users\")\n\tsnapshot, err := ref.OrderByChild(\"email\").EqualTo(userID).GetOrdered(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(snapshot) == 0 {\n\t\treturn fmt.Errorf(\"user not found\")\n\t}\n\n\tif err := snapshot[0].Ref().Update(ctx, map[string]interface{}{\n\t\t\"name\":  user.Name,\n\t\t\"email\": user.Email,\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc DeleteUser(ctx context.Context, userID string) error {\n\topt := option.WithCredentialsFile(\"path/to/firebase/credentials.json\")\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tclient, err := app.Database(ctx)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tref := client.NewRef(\"users\")\n\tsnapshot, err := ref.OrderByChild(\"email\").EqualTo(userID).GetOrdered(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(snapshot) == 0 {\n\t\treturn fmt.Errorf(\"user not found\")\n\t}\n\n\tif err := snapshot[0].Ref().Delete(ctx); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tstr := \"Hello, World!\"\n\tupper := strings.ToUpper(str)\n\n\tfmt.Println(upper)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Create(\"data.csv\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\tdefer writer.Flush()\n\n\theader := []string{\"Name\", \"Age\", \"Email\"}\n\twriter.Write(header)\n\n\trow := []string{\"John Doe\", \"30\", \"johndoe@example.com\"}\n\twriter.Write(row)\n}"}
{"sample": "package profileservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"models\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype ProfileService struct {\n\tprofileStore models.ProfileStore\n}\n\nfunc NewProfileService(profileStore models.ProfileStore) *ProfileService {\n\treturn &ProfileService{profileStore: profileStore}\n}\n\nfunc (s *ProfileService) CreateProfile(ctx context.Context, profile *models.Profile) error {\n\tif profile.ID != \"\" {\n\t\treturn errors.New(\"profile already has an ID\")\n\t}\n\n\tprofile.ID = uuid.New().String()\n\tprofile.CreatedAt = time.Now()\n\n\treturn s.profileStore.CreateProfile(ctx, profile)\n}\n\nfunc (s *ProfileService) GetProfile(ctx context.Context, id string) (*models.Profile, error) {\n\treturn s.profileStore.GetProfile(ctx, id)\n}\n\nfunc (s *ProfileService) UpdateProfile(ctx context.Context, profile *models.Profile) error {\n\tif profile.ID == \"\" {\n\t\treturn errors.New(\"profile does not have an ID\")\n\t}\n\n\tprofile.UpdatedAt = time.Now()\n\n\treturn s.profileStore.UpdateProfile(ctx, profile)\n}\n\nfunc (s *ProfileService) DeleteProfile(ctx context.Context, id string) error {\n\treturn s.profileStore.DeleteProfile(ctx, id)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\tvar ctx = context.Background()\n\n\t// connect to redis server\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\t// ping server to verify connection\n\tpong, err := client.Ping(ctx).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"Connected to Redis server, Pong:\", pong)\n\n\t// add key-value pair\n\terr = client.Set(ctx, \"sample_key\", \"sample_value\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// get value for a given key\n\tval, err := client.Get(ctx, \"sample_key\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"Value for 'sample_key':\", val)\n\n\t// set expiration for a given key\n\texpiration := time.Minute\n\terr = client.Expire(ctx, \"sample_key\", expiration).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// check time to live for a given key\n\tttl, err := client.TTL(ctx, \"sample_key\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"Time to live for 'sample_key': %v\\n\", ttl)\n}"}
{"sample": "package mergesort\n\nfunc merge(left, right []int) []int {\n\tresult := make([]int, len(left)+len(right))\n\n\ti, j, k := 0, 0, 0\n\n\tfor i < len(left) && j < len(right) {\n\t\tif left[i] <= right[j] {\n\t\t\tresult[k] = left[i]\n\t\t\ti++\n\t\t} else {\n\t\t\tresult[k] = right[j]\n\t\t\tj++\n\t\t}\n\t\tk++\n\t}\n\n\tfor i < len(left) {\n\t\tresult[k] = left[i]\n\t\ti++\n\t\tk++\n\t}\n\n\tfor j < len(right) {\n\t\tresult[k] = right[j]\n\t\tj++\n\t\tk++\n\t}\n\n\treturn result\n}\n\nfunc mergeSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\n\tmid := len(arr) / 2\n\tleft := mergeSort(arr[:mid])\n\tright := mergeSort(arr[mid:])\n\n\treturn merge(left, right)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\n// FetchURL fetches the content of a URL using an HTTP GET request.\nfunc FetchURL(url string) (string, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a new router instance using the gorilla/mux package\n\tr := http.NewServeMux()\n\n\t// Register the necessary routes\n\tr.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Handle GET requests to the /users route\n\t}).Methods(http.MethodGet)\n\tr.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Handle POST requests to the /users route\n\t}).Methods(http.MethodPost)\n\n\t// Create a new server instance\n\tsrv := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: r,\n\t}\n\n\t// Handle graceful shutdown of the server\n\tstop := make(chan os.Signal, 1)\n\tsignal.Notify(stop, os.Interrupt)\n\tgo func() {\n\t\t<-stop\n\t\tlog.Println(\"Server shutting down...\")\n\n\t\t// Create a context with a timeout of 5 seconds\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\t// Shutdown the server gracefully and cancel any ongoing requests\n\t\tif err := srv.Shutdown(ctx); err != nil {\n\t\t\tlog.Fatalf(\"Server forced to shutdown: %v\\n\", err)\n\t\t}\n\t}()\n\n\t// Start the server\n\tlog.Println(\"Server started on port 8080\")\n\tif err := srv.ListenAndServe(); err != nil {\n\t\tlog.Fatalf(\"Server failed to start: %v\\n\", err)\n\t}\n}"}
{"sample": "func GetEnvironmentVariable(key string) string {\n\treturn os.Getenv(key)\n}\n\nfunc SetEnvironmentVariable(key, value string) error {\n\treturn os.Setenv(key, value)\n}\n\nfunc UnsetEnvironmentVariable(key string) error {\n\treturn os.Unsetenv(key)\n}"}
{"sample": "func dropTable(db *sql.DB) error {\n\tstmt, err := db.Prepare(\"DROP TABLE IF EXISTS users\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Basic for loop\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Println(i)\n\t}\n\n\t// For loop with range\n\tnumbers := []int{2, 4, 6, 8}\n\tfor index, value := range numbers {\n\t\tfmt.Printf(\"Index: %d, Value: %d\\n\", index, value)\n\t}\n\n\t// Infinite loop with break\n\tcounter := 0\n\tfor {\n\t\tfmt.Println(\"Working...\")\n\t\ttime.Sleep(time.Second)\n\t\tcounter++\n\t\tif counter == 3 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Loop with continue\n\tfor i := 1; i <= 5; i++ {\n\t\tif i == 3 {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "// Create a new HTTP multiplexer (router)\nfunc NewMux() *http.ServeMux {\n\treturn http.NewServeMux()\n}\n"}
{"sample": "func CreateHTTPClient(timeout time.Duration) *http.Client {\n\treturn &http.Client{\n\t\tTimeout: timeout,\n\t}\n}\n\nfunc SendHTTPRequest(client *http.Client, req *http.Request) (*http.Response, error) {\n\treturn client.Do(req)\n}\n\nfunc CloseHTTPResponseBody(resp *http.Response) error {\n\treturn resp.Body.Close()\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID       int\n\tUsername string\n\tEmail    string\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@/database\")\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\tdefer rows.Close()\n\n\tvar users []User\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Email)\n\t\tif err != nil {\n\t\t\tpanic(err.Error())\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\n\tfor _, user := range users {\n\t\tfmt.Printf(\"%d %s %s\\n\", user.ID, user.Username, user.Email)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"html/template\"\n)\n\nfunc main() {\n\ttmpl, err := template.ParseFiles(\"template.html\")\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing template:\", err)\n\t\treturn\n\t}\n\n\tdata := struct{\n\t\tName string\n\t\tAge  int\n\t}{\n\t\tName: \"John Doe\",\n\t\tAge:  30,\n\t}\n\n\terr = tmpl.Execute(os.Stdout, data)\n\tif err != nil {\n\t\tfmt.Println(\"Error executing template:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "package cyclesort\n\n// CycleSort implements the cycle sort algorithm\nfunc CycleSort(arr []int) {\n\tn := len(arr)\n\n\tfor cycleStart := 0; cycleStart < n-1; cycleStart++ {\n\t\titem := arr[cycleStart]\n\n\t\tpos := cycleStart\n\t\tfor i := cycleStart + 1; i < n; i++ {\n\t\t\tif arr[i] < item {\n\t\t\t\tpos++\n\t\t\t}\n\t\t}\n\n\t\tif pos == cycleStart {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor item == arr[pos] {\n\t\t\tpos++\n\t\t}\n\n\t\tif pos != cycleStart {\n\t\t\titem, arr[pos] = arr[pos], item\n\t\t}\n\n\t\tfor pos != cycleStart {\n\t\t\tpos = cycleStart\n\t\t\tfor i := cycleStart + 1; i < n; i++ {\n\t\t\t\tif arr[i] < item {\n\t\t\t\t\tpos++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor item == arr[pos] {\n\t\t\t\tpos++\n\t\t\t}\n\n\t\t\tif item != arr[pos] {\n\t\t\t\titem, arr[pos] = arr[pos], item\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "type Queue struct {\n\titems []interface{}\n}\n\nfunc (q *Queue) Enqueue(item interface{}) {\n\tq.items = append(q.items, item)\n}\n\nfunc (q *Queue) Dequeue() interface{} {\n\titem := q.items[0]\n\tq.items = q.items[1:]\n\treturn item\n}\n\nfunc (q *Queue) IsEmpty() bool {\n\treturn len(q.items) == 0\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintSumOfOddNumbersInArray([]int{1, 2, 3, 4, 5})\n}\n\n// Function to print the sum of odd numbers in an array\nfunc PrintSumOfOddNumbersInArray(arr []int) {\n\tsum := 0\n\tfor _, value := range arr {\n\t\tif value%2 != 0 {\n\t\t\tsum += value\n\t\t}\n\t}\n\tfmt.Println(sum)\n}"}
{"sample": "package orderservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Order struct {\n\tID          string\n\tCustomerID  string\n\tProductID   string\n\tQuantity    int\n\tPrice       float64\n\tCreatedTime time.Time\n}\n\ntype OrderService struct {\n}\n\nfunc (os *OrderService) CreateOrder(ctx context.Context, customerID string, productID string, quantity int, price float64) (*Order, error) {\n\tif customerID == \"\" || productID == \"\" || quantity <= 0 || price <= 0 {\n\t\treturn nil, errors.New(\"invalid order parameters\")\n\t}\n\n\torder := &Order{\n\t\tID:          uuid.New().String(),\n\t\tCustomerID:  customerID,\n\t\tProductID:   productID,\n\t\tQuantity:    quantity,\n\t\tPrice:       price,\n\t\tCreatedTime: time.Now(),\n\t}\n\n\t// TODO: Save the order to database\n\n\treturn order, nil\n}\n\nfunc (os *OrderService) GetOrder(ctx context.Context, orderID string) (*Order, error) {\n\tif orderID == \"\" {\n\t\treturn nil, errors.New(\"invalid order ID\")\n\t}\n\n\t// TODO: Get the order from database\n\n\torder := &Order{\n\t\tID:          orderID,\n\t\tCustomerID:  \"customerID\",\n\t\tProductID:   \"productID\",\n\t\tQuantity:    2,\n\t\tPrice:       19.99,\n\t\tCreatedTime: time.Now(),\n\t}\n\n\treturn order, nil\n}\n\nfunc (os *OrderService) CancelOrder(ctx context.Context, orderID string) error {\n\tif orderID == \"\" {\n\t\treturn errors.New(\"invalid order ID\")\n\t}\n\n\t// TODO: Cancel the order in database\n\n\tfmt.Printf(\"Order %s has been cancelled\", orderID)\n\n\treturn nil\n}"}
{"sample": "package httpmonitor\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc monitorTraffic(h http.Handler) http.Handler {\n\tfn := func(w http.ResponseWriter, r *http.Request) {\n\t\tstartTime := time.Now()\n\n\t\tlw := &loggingResponseWriter{ResponseWriter: w}\n\t\th.ServeHTTP(lw, r)\n\n\t\tlog.Printf(\"%s %s %v %s\\n\", r.Method, r.URL.Path, lw.statusCode, time.Since(startTime))\n\t}\n\n\treturn http.HandlerFunc(fn)\n}\n\ntype loggingResponseWriter struct {\n\thttp.ResponseWriter\n\tstatusCode int\n}\n\nfunc (lrw *loggingResponseWriter) WriteHeader(code int) {\n\tlrw.statusCode = code\n\tlrw.ResponseWriter.WriteHeader(code)\n}\n\nfunc startMonitoring() {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello World!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", monitorTraffic(mux))\n}"}
{"sample": "// Iterating over a map\n\nm := map[string]int{\"a\": 1, \"b\": 2}\nfor key, value := range m {\n\tfmt.Println(key, value)\n}\n"}
{"sample": "package bucketsort\n\nfunc BucketSort(arr []int) []int {\n\tif len(arr) < 2 {\n\t\treturn arr\n\t}\n\n\tbuckets := make([][]int, 10)\n\n\tfor _, num := range arr {\n\t\tbucketIndex := num / 10\n\t\tbuckets[bucketIndex] = append(buckets[bucketIndex], num)\n\t}\n\n\tvar result []int\n\tfor _, bucket := range buckets {\n\t\tif len(bucket) > 0 {\n\t\t\tresult = append(result, BucketSort(bucket)...)\n\t\t}\n\t}\n\n\treturn result\n}"}
{"sample": "// Writing to a file\n\nfile, err := os.Create(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\n_, err = file.WriteString(\"text\")\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"encoding/json\"\n)\n\n// Post represents a post entity\n\ntype Post struct {\n\tID    int    `json:\"id\"`\n\tTitle string `json:\"title\"`\n\tBody  string `json:\"body\"`\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/posts\", func(w http.ResponseWriter, r *http.Request) {\n\t\tposts := []Post{\n\t\t\t{ID: 1, Title: \"Post 1\", Body: \"Lorem ipsum\"}\n\t\t\t{ID: 2, Title: \"Post 2\", Body: \"Dolor sit amet\"}\n\t\t}\n\n\t\tjson.NewEncoder(w).Encode(posts)\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "// NewError creates a new error with a message\nfunc NewError(message string) error {\n\treturn errors.New(message)\n}\n"}
{"sample": "package raft\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// Raft is a distributed consensus algorithm.\ntype Raft struct {\n\tid          int\n\tpeers       []*Peer\n\tcurrentTerm int\n\tvotedFor    int\n\tlog         []*LogEntry\n\tcommitIndex int\n\tlastApplied int\n\tstate       State\n\ttimeout     time.Duration\n\telection    *Election\n}\n\n// NewRaft creates a new Raft instance.\nfunc NewRaft(id int, peers []*Peer) *Raft {\n\tr := &Raft{\n\t\tid:          id,\n\t\tpeers:       peers,\n\t\tcurrentTerm: 0,\n\t\tvotedFor:    -1,\n\t\tlog:         []*LogEntry{},\n\t\tcommitIndex: 0,\n\t\tlastApplied: 0,\n\t\tstate:       Follower,\n\t\ttimeout:     time.Duration(rand.Intn(150)+150) * time.Millisecond,\n\t\telection:    NewElection(),\n\t}\n\n\treturn r\n}\n\n// Start starts the Raft instance.\nfunc (r *Raft) Start() {\n\tlog.Printf(\"Starting Raft node %d\", r.id)\n\tr.election.Start(r.timeout)\n}\n\n// Stop stops the Raft instance.\nfunc (r *Raft) Stop() {\n\tlog.Printf(\"Stopping Raft node %d\", r.id)\n\tr.election.Stop()\n}\n\n// AppendEntry appends an entry to the log.\nfunc (r *Raft) AppendEntry(entry *LogEntry) error {\n\tif r.state != Leader {\n\t\treturn errors.New(\"not the leader\")\n\t}\n\n\t// TODO: Implement append entry logic.\n\n\treturn nil\n}\n\n// RequestVote requests a vote from a peer.\nfunc (r *Raft) RequestVote(peer *Peer) error {\n\tif r.state != Candidate {\n\t\treturn errors.New(\"not a candidate\")\n\t}\n\n\t// TODO: Implement request vote logic.\n\n\treturn nil\n}\n\n// ApplyCommand applies a command to the state machine.\nfunc (r *Raft) ApplyCommand(command []byte) error {\n\tif r.state != Leader {\n\t\treturn errors.New(\"not the leader\")\n\t}\n\n\t// TODO: Implement apply command logic.\n\n\treturn nil\n}"}
{"sample": "// Writer wraps the standard io.Writer and adds additional functionality.\ntype Writer struct {\n\tw io.Writer\n}\n\n// NewWriter creates a new Writer.\nfunc NewWriter(w io.Writer) *Writer {\n\treturn &Writer{w}\n}\n\n// WriteLine writes a line to the underlying writer.\nfunc (w *Writer) WriteLine(line string) (int, error) {\n\treturn w.w.Write([]byte(line + \"\\n\"))\n}"}
{"sample": "package cocktailsort\n\nfunc CocktailSort(arr []int) {\n\tfor i := 0; i < len(arr)/2; i++ {\n\t\tleft := i\n\t\tright := len(arr) - i - 1\n\n\t\tfor j := left; j < right; j++ {\n\t\t\tif arr[j] > arr[j+1] {\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]\n\t\t\t}\n\t\t}\n\n\t\tfor j := right; j > left; j-- {\n\t\t\tif arr[j] < arr[j-1] {\n\t\t\t\tarr[j], arr[j-1] = arr[j-1], arr[j]\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "package trieimpl\n\ntype TrieNode struct {\n\tchildren map[rune]*TrieNode\n\tisEnd    bool\n}\n\ntype Trie struct {\n\troot *TrieNode\n}\n\nfunc NewTrie() *Trie {\n\treturn &Trie{\n\t\troot: &TrieNode{\n\t\t\tchildren: make(map[rune]*TrieNode),\n\t\t\tisEnd:    false,\n\t\t},\n\t}\n}\n\nfunc (t *Trie) Insert(word string) {\n\tnode := t.root\n\n\tfor _, ch := range word {\n\t\tif _, ok := node.children[ch]; !ok {\n\t\t\tnode.children[ch] = &TrieNode{\n\t\t\t\tchildren: make(map[rune]*TrieNode),\n\t\t\t\tisEnd:    false,\n\t\t\t}\n\t\t}\n\t\tnode = node.children[ch]\n\t}\n\n\tnode.isEnd = true\n}\n\nfunc (t *Trie) Search(word string) bool {\n\tnode := t.root\n\n\tfor _, ch := range word {\n\t\tif _, ok := node.children[ch]; !ok {\n\t\t\treturn false\n\t\t}\n\t\tnode = node.children[ch]\n\t}\n\n\treturn node.isEnd\n}\n\nfunc (t *Trie) Delete(word string) bool {\n\tvar deleteNode func(node *TrieNode, i int) bool\n\n\tdeleteNode = func(node *TrieNode, i int) bool {\n\t\tif i == len(word) {\n\t\t\tif !node.isEnd {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tnode.isEnd = false\n\t\t\treturn len(node.children) == 0\n\t\t}\n\n\t\tch := rune(word[i])\n\t\tif _, ok := node.children[ch]; !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tif deleteNode(node.children[ch], i+1) {\n\t\t\tdelete(node.children, ch)\n\t\t\treturn len(node.children) == 0\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn deleteNode(t.root, 0)\n}"}
{"sample": "package wsmanage\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nfunc handleWebSocket(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\t// Register the new connection\n\tclient := NewClient(conn)\n\tclients[client] = true\n\n\t// Listen for messages\n\tgo client.Listen()\n\n\t// Send a welcome message\n\tclient.Send([]byte(\"Welcome to the WebSocket server!\"))\n\n\t// Close the connection when the function returns\n\tdefer func() {\n\t\tclient.Close()\n\t\tdelete(clients, client)\n\t}()\n\n\t// Keep the function running indefinitely\n\tselect {}\n}\n\n// Client represents a WebSocket client connection\ntype Client struct {\n\tconn *websocket.Conn\n}\n\n// NewClient creates a new WebSocket client\nfunc NewClient(conn *websocket.Conn) *Client {\n\treturn &Client{\n\t\tconn: conn,\n\t}\n}\n\n// Listen listens for incoming messages from the client\nfunc (c *Client) Listen() {\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\t// Handle the message\n\t\thandleMessage(c, message)\n\t}\n}\n\n// Send sends a message to the client\nfunc (c *Client) Send(message []byte) {\n\terr := c.conn.WriteMessage(websocket.TextMessage, message)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n\n// Close closes the WebSocket connection\nfunc (c *Client) Close() {\n\terr := c.conn.Close()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n\n// handleMessage handles incoming messages from the client\nfunc handleMessage(c *Client, message []byte) {\n\t// Handle the message\n}"}
{"sample": "type API struct {\n\tclient *http.Client\n}\n\nfunc (api *API) GetJSON(url string) (map[string]interface{} error) {\n\tresp, err := api.client.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar result map[string]interface{}\n\tjson.NewDecoder(resp.Body).Decode(&result)\n\treturn result, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tpong, err := rdb.Ping(ctx).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(pong)\n\n\terr = rdb.Set(ctx, \"key\", \"value\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tval, err := rdb.Get(ctx, \"key\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"key\", val)\n\n\terr = rdb.Del(ctx, \"key\").Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "/*\nCopyright 2019 The Tekton Authors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage resources\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1alpha1\"\n)\n\n// ApplyParameters applies the params from a PipelineRun.Params to a PipelineSpec.\nfunc ApplyParameters(p *v1alpha1.Pipeline, pr *v1alpha1.PipelineRun) *v1alpha1.Pipeline {\n\t// This assumes that the PipelineRun inputs have been validated against what the Pipeline requests.\n\n\t// stringReplacements is used for standard single-string stringReplacements, while arrayReplacements contains arrays\n\t// that need to be further processed.\n\tstringReplacements := map[string]string{}\n\tarrayReplacements := map[string][]string{}\n\n\t// Set all the default stringReplacements\n\tfor _, p := range p.Spec.Params {\n\t\tif p.Default != nil {\n\t\t\tif p.Default.Type == v1alpha1.ParamTypeString {\n\t\t\t\tstringReplacements[fmt.Sprintf(\"params.%s\", p.Name)] = p.Default.StringVal\n\t\t\t} else {\n\t\t\t\tarrayReplacements[fmt.Sprintf(\"params.%s\", p.Name)] = p.Default.ArrayVal\n\t\t\t}\n\t\t}\n\t}\n\t// Set and overwrite params with the ones from the PipelineRun\n\tfor _, p := range pr.Spec.Params {\n\t\tif p.Value.Type == v1alpha1.ParamTypeString {\n\t\t\tstringReplacements[fmt.Sprintf(\"params.%s\", p.Name)] = p.Value.StringVal\n\t\t} else {\n\t\t\tarrayReplacements[fmt.Sprintf(\"params.%s\", p.Name)] = p.Value.ArrayVal\n\t\t}\n\t}\n\n\treturn ApplyReplacements(p, stringReplacements, arrayReplacements)\n}\n\n// ApplyReplacements replaces placeholders for declared parameters with the specified replacements.\nfunc ApplyReplacements(p *v1alpha1.Pipeline, replacements map[string]string, arrayReplacements map[string][]string) *v1alpha1.Pipeline {\n\tp = p.DeepCopy()\n\n\ttasks := p.Spec.Tasks\n\n\tfor i := range tasks {\n\t\ttasks[i].Params = replaceParamValues(tasks[i].Params, replacements, arrayReplacements)\n\t\tfor j := range tasks[i].Conditions {\n\t\t\tc := tasks[i].Conditions[j]\n\t\t\tc.Params = replaceParamValues(c.Params, replacements, arrayReplacements)\n\t\t}\n\t}\n\n\treturn p\n}\n\nfunc replaceParamValues(params []v1alpha1.Param, stringReplacements map[string]string, arrayReplacements map[string][]string) []v1alpha1.Param {\n\tfor i := range params {\n\t\tparams[i].Value.ApplyReplacements(stringReplacements, arrayReplacements)\n\t}\n\treturn params\n}\n"}
{"sample": "// IfErrorRetry retries a function if it returns an error\nfunc IfErrorRetry(fn func() error, retries int) error {\n\tfor i := 0; i < retries; i++ {\n\t\terr := fn()\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fmt.Errorf(\"failed after %d retries\", retries)\n}\n"}
{"sample": "func main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/mydb\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to MySQL:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE IF NOT EXISTS users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255))\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating table:\", err)\n\t\treturn\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (name) VALUES ('John Doe')\")\n\tif err != nil {\n\t\tfmt.Println(\"Error inserting into table:\", err)\n\t\treturn\n\t}\n\n\trows, err := db.Query(\"SELECT id, name FROM users\")\n\tif err != nil {\n\t\tfmt.Println(\"Error querying table:\", err)\n\t\treturn\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\terr = rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error scanning row:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Println(id, name)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintSumOfSquaresOfArray([]int{1, 2, 3, 4, 5})\n}\n\n// Function to print the sum of squares of elements in an array\nfunc PrintSumOfSquaresOfArray(arr []int) {\n\tsum := 0\n\tfor _, value := range arr {\n\t\tsum += value * value\n\t}\n\tfmt.Println(sum)\n}"}
{"sample": "package main\n\n// Open a file\nfunc main() {\n\tfile, err := os.Open(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n}\n"}
{"sample": "func MakeRequest(method, url string, body io.Reader) (*http.Response, error) {\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, nil\n}\n\nfunc ReadResponse(resp *http.Response) ([]byte, error) {\n\treturn ioutil.ReadAll(resp.Body)\n}"}
{"sample": "func main() {\n\tstr := \"hello world\"\n\tcontains := strings.Contains(str, \"world\")\n\n\tfmt.Println(contains)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gobuffalo/packr/v2\"\n)\n\nfunc ServeStaticFilesUsingPackr() {\n\tbox := packr.New(\"static\", \"./static\")\n\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(box)))\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n"}
{"sample": "package gst\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n)\n\n/*\n#cgo pkg-config: gstreamer-1.0 gstreamer-app-1.0\n#cgo LDFLAGS: -lgstapp-1.0\n#include <stdlib.h>\n#include <string.h>\n#include <gst/gst.h>\n#include <gst/app/gstappsrc.h>\n*/\nimport \"C\"\n\ntype FlowReturn C.GstFlowReturn\n\nconst (\n\tGST_FLOW_OK             = FlowReturn(C.GST_FLOW_OK)\n\tGST_FLOW_FLUSHING       = FlowReturn(C.GST_FLOW_FLUSHING)\n\tGST_FLOW_NOT_LINKED     = FlowReturn(C.GST_FLOW_NOT_LINKED)\n\tGST_FLOW_NOT_NEGOTIATED = FlowReturn(C.GST_FLOW_NOT_NEGOTIATED)\n\tGST_FLOW_ERROR          = FlowReturn(C.GST_FLOW_ERROR)\n\tGST_FLOW_NOT_SUPPORTED  = FlowReturn(C.GST_FLOW_NOT_SUPPORTED)\n)\n\nfunc (f FlowReturn) String() string {\n\tswitch f {\n\tcase GST_FLOW_OK:\n\t\treturn \"GST_FLOW_OK\"\n\tcase GST_FLOW_FLUSHING:\n\t\treturn \"GST_FLOW_FLUSHING\"\n\tcase GST_FLOW_NOT_LINKED:\n\t\treturn \"GST_FLOW_NOT_LINKED\"\n\tcase GST_FLOW_NOT_NEGOTIATED:\n\t\treturn \"GST_FLOW_NOT_NEGOTIATED\"\n\tcase GST_FLOW_ERROR:\n\t\treturn \"GST_FLOW_ERROR\"\n\tcase GST_FLOW_NOT_SUPPORTED:\n\t\treturn \"GST_FLOW_NOT_SUPPORTED\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"flow error: %d\", f)\n\t}\n}\n\ntype AppSrc struct {\n\t*Element\n}\n\nfunc NewAppSrc(name string) *AppSrc {\n\treturn &AppSrc{ElementFactoryMake(\"appsrc\", name)}\n}\n\nfunc (a *AppSrc) g() *C.GstAppSrc {\n\treturn (*C.GstAppSrc)(a.GetPtr())\n}\n\nfunc (a *AppSrc) SetCaps(caps *Caps) {\n\tp := unsafe.Pointer(caps) // HACK\n\tC.gst_app_src_set_caps(a.g(), (*C.GstCaps)(p))\n}\n\nfunc (a *AppSrc) EOS() error {\n\tret := FlowReturn(C.gst_app_src_end_of_stream(a.g()))\n\tif ret != GST_FLOW_OK {\n\t\treturn fmt.Errorf(\"appsrc eos: %v\", ret)\n\t}\n\n\treturn nil\n}\n\nfunc (a *AppSrc) Write(d []byte) (int, error) {\n\tbuf := C.gst_buffer_new_allocate(nil, C.gsize(len(d)), nil)\n\tn := C.gst_buffer_fill(buf, C.gsize(0), (C.gconstpointer)(C.CBytes(d)), C.gsize(len(d)))\n\n\tret := FlowReturn(C.gst_app_src_push_buffer((*C.GstAppSrc)(a.GetPtr()), buf))\n\tif ret != GST_FLOW_OK {\n\t\treturn 0, fmt.Errorf(\"appsrc push buffer failed: %v\", ret)\n\t}\n\n\treturn int(n), nil\n}\n"}
{"sample": "func ReverseString(s string) string {\n\trunes := []rune(s)\n\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n\t\trunes[i], runes[j] = runes[j], runes[i]\n\t}\n\treturn string(runes)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintPerimeterOfRectangle(5, 10)\n}\n\n// Function to print the perimeter of a rectangle\nfunc PrintPerimeterOfRectangle(length, width float64) {\n\tfmt.Println(2 * (length + width))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\n\tfor i, num := range numbers {\n\t\tfmt.Println(\"Index:\", i, \"Number:\", num)\n\t}\n\n\tsum := 0\n\tfor _, num := range numbers {\n\t\tsum += num\n\t}\n\tfmt.Println(\"Sum of all numbers:\", sum)\n\n\tstrNumbers := []string{\"1\", \"2\", \"3\", \"4\", \"5\"}\n\tsum = 0\n\tfor _, strNum := range strNumbers {\n\t\tnum, err := strconv.Atoi(strNum)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed to convert string to number:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tsum += num\n\t}\n\tfmt.Println(\"Sum of all numbers (from string):\", sum)\n\n\tmapping := map[string]string{\n\t\t\"a\": \"apple\",\n\t\t\"b\": \"banana\",\n\t\t\"c\": \"cherry\",\n\t}\n\tfor key, value := range mapping {\n\t\tfmt.Println(\"Key:\", key, \"Value:\", value)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"io\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\treader := bufio.NewReader(file)\n\n\tfor {\n\t\tline, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfmt.Println(\"Error reading line:\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(line)\n\t}\n}"}
{"sample": "// Implementing an interface\n\ntype Reader interface {\n\tRead(p []byte) (n int, err error)\n}\ntype MyReader struct{}\nfunc (m MyReader) Read(p []byte) (int, error) {\n\t// implement the method\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintEvenIndices prints the elements at even indices in a given slice.\nfunc PrintEvenIndices(nums []int) {\n\tfor i, num := range nums {\n\t\tif i%2 == 0 {\n\t\t\tfmt.Println(num)\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport \"time\"\n\nfunc main() {\n\tfmt.Println(CurrentTime())\n}\n\nfunc CurrentTime() string {\n\treturn time.Now().Format(\"2006-01-02 15:04:05\")\n}"}
{"sample": "package unixsock\n\nimport (\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype UnixSocket struct {\n\tPath string\n}\n\nfunc (us *UnixSocket) ListenAndServe() error {\n\tif err := os.RemoveAll(us.Path); err != nil {\n\t\treturn err\n\t}\n\n\tl, err := net.Listen(\"unix\", us.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer l.Close()\n\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\t// Handle incoming connection\n}\n\nfunc NewUnixSocket(path string) (*UnixSocket, error) {\n\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &UnixSocket{Path: path}, nil\n}"}
{"sample": "// Create a new HTTP client\nfunc NewClient() *http.Client {\n\treturn &http.Client{}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tfmt.Print(\"Enter your name: \")\n\tname, _ := reader.ReadString('\\n')\n\tname = strings.TrimSuffix(name, \"\\n\")\n\tfmt.Printf(\"Hello, %s!\\n\", name)\n}"}
{"sample": "package main\n\nimport (\n\t\"flag\"\n\t\"strconv\"\n\n\t\"TraefikAccessControl/manager\"\n\t\"TraefikAccessControl/repository\"\n\t\"TraefikAccessControl/server\"\n\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n\tdbNamePtr := flag.String(\"db_name\", \"tac.db\", \"Path of the database file\")\n\timportNamePtr := flag.String(\"import_name\", \"\", \"Path of an file to import\")\n\tforceImportPtr := flag.Bool(\"force_import\", false, \"Force the import of the given file, deletes all existing data\")\n\tcookieNamePtr := flag.String(\"cookie_name\", \"tac_token\", \"Cookie name used\")\n\tuserHeaderNamePtr := flag.String(\"user_header_name\", \"X-TAC-User\", \"Header name that contains the username after successful auth\")\n\tportPtr := flag.Int(\"port\", 4181, \"Port on which the application will run\")\n\tflag.Parse()\n\n\terr := repository.InitDatabaseConnection(*dbNamePtr)\n\tif err != nil {\n\t\tlog.Fatal(\"Abort: Failed to initialize database\")\n\t}\n\n\tuserRep, err := repository.CreateUserRepository()\n\tif err != nil {\n\t\tlog.Fatal(\"Abort: Failed to create user repository\")\n\t}\n\ttokenRep, err := repository.CreateTokenRepository()\n\tif err != nil {\n\t\tlog.Fatal(\"Abort: Failed to create token repository\")\n\t}\n\tsiteRep, err := repository.CreateSiteRepository()\n\tif err != nil {\n\t\tlog.Fatal(\"Abort: Failed to create site repository\")\n\t}\n\tsiteMappingRep, err := repository.CreateSiteMappingRepository()\n\tif err != nil {\n\t\tlog.Fatal(\"Abort: Failed to create site mapping repository\")\n\t}\n\n\tauthMgr := manager.CreateAuthManager(userRep, tokenRep)\n\tsiteMgr := manager.CreateSiteManager(siteRep, siteMappingRep)\n\taccessMgr := manager.CreateAccessManager()\n\timportExportManager := manager.CreateImportExportManager()\n\n\tif importNamePtr != nil && *importNamePtr != \"\" {\n\t\terr = importExportManager.ImportFile(*importNamePtr, *forceImportPtr)\n\t\tif err != nil {\n\t\t\tlog.Warn(\"Abort: Failed to import data\")\n\t\t}\n\t}\n\n\tif cnt, err := authMgr.GetUserCount(); err == nil && cnt == 0 {\n\t\tauthMgr.CreateFirstUser()\n\t}\n\n\tsrv := server.NewServer(*cookieNamePtr, *userHeaderNamePtr)\n\n\t// Start\n\tlog.WithField(\"port\", *portPtr).Info(\"Listening on specified port\")\n\tlog.Info(srv.Router.Run(\":\" + strconv.Itoa(*portPtr)))\n\n\tauthMgr.Close()\n\tsiteMgr.Close()\n\taccessMgr.Close()\n}\n"}
{"sample": "// Enable rate limiting for HTTP requests\nfunc EnableRateLimiting(handler http.Handler, requestsPerSecond int) http.Handler {\n\tlimiter := rate.NewLimiter(rate.Limit(requestsPerSecond), requestsPerSecond)\n\treturn http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {\n\t\tif !limiter.Allow() {\n\t\t\tresponse.WriteHeader(http.StatusTooManyRequests)\n\t\t\tresponse.Write([]byte(\"Too many requests\"))\n\t\t\treturn\n\t\t}\n\t\thandler.ServeHTTP(response, request)\n\t})\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-zoo/bone\"\n)\n\nfunc UseBone() {\n\trouter := bone.New()\n\n\trouter.Get(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, Bone!\")\n\t}))\n\n\thttp.ListenAndServe(\":8080\", router)\n}\n"}
{"sample": "package httpclient\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tBaseUrl string\n\tClient  http.Client\n}\n\nfunc New(baseUrl string) *Client {\n\treturn &Client{\n\t\tBaseUrl: baseUrl,\n\t\tClient:  http.Client{},\n\t}\n}\n\nfunc (c *Client) DoGet(endpoint string) ([]byte, error) {\n\turl := fmt.Sprintf(\"%s%s\", c.BaseUrl, endpoint)\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, err := c.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n\nfunc (c *Client) DoPost(endpoint string, data interface{}) ([]byte, error) {\n\turl := fmt.Sprintf(\"%s%s\", c.BaseUrl, endpoint)\n\n\tjsonBody, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, _ := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonBody))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tres, err := c.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintOddNumbers prints odd numbers up to a given limit.\nfunc PrintOddNumbers(limit int) {\n\tfor i := 1; i <= limit; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "func SendResponse(w http.ResponseWriter, statusCode int, message string) {\n\tw.WriteHeader(statusCode)\n\tw.Write([]byte(message))\n}\n\nfunc SendJSONResponse(w http.ResponseWriter, statusCode int, data interface{}) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(statusCode)\n\tjson.NewEncoder(w).Encode(data)\n}"}
{"sample": "package slackapi\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\ntype SlackAPI struct {\n\tToken string\n}\n\ntype Message struct {\n\tText string `json:\"text\"`\n}\n\nfunc (s *SlackAPI) SendMessage(channel, message string) error {\n\tif s.Token == \"\" {\n\t\treturn errors.New(\"missing Slack API token\")\n\t}\n\n\tmsg := Message{\n\t\tText: message,\n\t}\n\n\tpayload, err := json.Marshal(msg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\turl := \"https://slack.com/api/chat.postMessage\"\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(payload))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+s.Token)\n\treq.Header.Set(\"User-Agent\", \"My Slack API Client\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(\"failed to send message\")\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\n// Create a directory\nfunc main() {\n\terr := os.Mkdir(\"newdir\", 0755)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package bubblesort\n\n// BubbleSort sorts a slice of integers in ascending order using the bubble sort algorithm.\nfunc BubbleSort(nums []int) {\n\tn := len(nums)\n\tfor i := 0; i < n-1; i++ {\n\t\tfor j := 0; j < n-i-1; j++ {\n\t\t\tif nums[j] > nums[j+1] {\n\t\t\t\tnums[j], nums[j+1] = nums[j+1], nums[j]\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "package main\n\n// AssertNoError asserts that there's no error, panics if there is an error\nfunc AssertNoError(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Factorial calculates the factorial of a given non-negative integer.\nfunc Factorial(n int) int {\n\tif n <= 1 {\n\t\treturn 1\n\t}\n\treturn n * Factorial(n-1)\n}"}
{"sample": "// Find the index of the first occurrence of a substring in a string\nfunc FindSubstringIndex(str, substr string) int {\n\treturn strings.Index(str, substr)\n}\n"}
{"sample": "package main\n\n// Get the base name of a file path\nfunc main() {\n\tabsPath, _ := filepath.Abs(\"file.txt\")\n\tbase := filepath.Base(absPath)\n\tfmt.Println(\"Base name:\", base)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.ServeFile(w, r, \"index.html\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package mapper_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/microsoft/abstrakt/internal/platform/mapper\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestFindByName(t *testing.T) {\n\tmapper := new(mapper.Config)\n\n\terr := mapper.LoadFile(\"testdata/mapper.yaml\")\n\tassert.NoError(t, err)\n\n\tinfo := mapper.FindByName(\"event_hub_sample_event_generator\")\n\n\tassert.NotNil(t, info)\n\tassert.Equal(t, \"event_hub_sample_event_generator\", info.ChartName)\n\tassert.Equal(t, \"EventGenerator\", info.Type)\n\tassert.Equal(t, \"../../helm/basictest\", info.Location)\n\tassert.Equal(t, \"1.0.0\", info.Version)\n\n\tinfo = mapper.FindByName(\"event_hub_sample_event_logger\")\n\n\tassert.NotNil(t, info)\n\tassert.Equal(t, \"event_hub_sample_event_logger\", info.ChartName)\n\tassert.Equal(t, \"EventLogger\", info.Type)\n\tassert.Equal(t, \"../../helm/basictest2\", info.Location)\n\tassert.Equal(t, \"1.0.0\", info.Version)\n\n\tinfo = mapper.FindByName(\"event_hub_sample_event_hub\")\n\n\tassert.NotNil(t, info)\n\tassert.Equal(t, \"event_hub_sample_event_hub\", info.ChartName)\n\tassert.Equal(t, \"EventHub\", info.Type)\n\tassert.Equal(t, \"../../helm/basictest3\", info.Location)\n\tassert.Equal(t, \"1.0.0\", info.Version)\n}\n\nfunc TestFindByType(t *testing.T) {\n\tmapper := new(mapper.Config)\n\n\terr := mapper.LoadFile(\"testdata/mapper.yaml\")\n\tassert.NoError(t, err)\n\n\tinfo := mapper.FindByType(\"EventGenerator\")\n\n\tassert.NotNil(t, info)\n\tassert.Equal(t, \"event_hub_sample_event_generator\", info.ChartName)\n\tassert.Equal(t, \"EventGenerator\", info.Type)\n\tassert.Equal(t, \"../../helm/basictest\", info.Location)\n\tassert.Equal(t, \"1.0.0\", info.Version)\n\n\tinfo = mapper.FindByType(\"EventLogger\")\n\n\tassert.NotNil(t, info)\n\tassert.Equal(t, \"event_hub_sample_event_logger\", info.ChartName)\n\tassert.Equal(t, \"EventLogger\", info.Type)\n\tassert.Equal(t, \"../../helm/basictest2\", info.Location)\n\tassert.Equal(t, \"1.0.0\", info.Version)\n\n\tinfo = mapper.FindByType(\"EventHub\")\n\n\tassert.NotNil(t, info)\n\tassert.Equal(t, \"event_hub_sample_event_hub\", info.ChartName)\n\tassert.Equal(t, \"EventHub\", info.Type)\n\tassert.Equal(t, \"../../helm/basictest3\", info.Location)\n\tassert.Equal(t, \"1.0.0\", info.Version)\n}\n\nfunc TestDuplicateChartNamePass(t *testing.T) {\n\ttestData := new(mapper.Config)\n\n\terr := testData.LoadFile(\"testdata/mapper.yaml\")\n\tassert.NoError(t, err)\n\n\tduplicate := testData.FindDuplicateChartName()\n\tassert.Nil(t, duplicate)\n}\n\nfunc TestDuplicateTypesPass(t *testing.T) {\n\ttestData := new(mapper.Config)\n\n\terr := testData.LoadFile(\"testdata/mapper.yaml\")\n\tassert.NoError(t, err)\n\n\tduplicate := testData.FindDuplicateType()\n\tassert.Nil(t, duplicate)\n}\n\nfunc TestDuplicateLocationsPass(t *testing.T) {\n\ttestData := new(mapper.Config)\n\n\terr := testData.LoadFile(\"testdata/mapper.yaml\")\n\tassert.NoError(t, err)\n\n\tduplicate := testData.FindDuplicateLocation()\n\tassert.Nil(t, duplicate)\n}\n\nfunc TestSchemaFailMissingChartNameValue(t *testing.T) {\n\texpected := \"Validation error in field \\\"ChartName\\\" of type \\\"string\\\" using validator \\\"empty=false\\\"\"\n\ttestData := new(mapper.Config)\n\n\terr := testData.LoadFile(\"testdata/missing/chartNameValue.yaml\")\n\tassert.NoError(t, err)\n\n\terr = testData.ValidateModel()\n\tassert.Error(t, err, \"Model validation should return error\")\n\tassert.EqualError(t, err, expected, \"Model validation should return error\")\n}\n\nfunc TestSchemaFailMissingVersionProperty(t *testing.T) {\n\texpected := \"Validation error in field \\\"Version\\\" of type \\\"string\\\" using validator \\\"empty=false\\\"\"\n\ttestData := new(mapper.Config)\n\n\terr := testData.LoadFile(\"testdata/missing/versionProperty.yaml\")\n\tassert.NoError(t, err)\n\n\terr = testData.ValidateModel()\n\tassert.Error(t, err, \"Model validation should return error\")\n\tassert.EqualError(t, err, expected, \"Model validation should return error\")\n}\n\nfunc TestSchemaFailMissingMap(t *testing.T) {\n\texpected := \"Validation error in field \\\"Maps\\\" of type \\\"[]mapper.Info\\\" using validator \\\"empty=false\\\"\"\n\ttestData := new(mapper.Config)\n\n\terr := testData.LoadFile(\"testdata/missing/map.yaml\")\n\tassert.NoError(t, err)\n\n\terr = testData.ValidateModel()\n\tassert.Error(t, err, \"Model validation should return error\")\n\tassert.EqualError(t, err, expected, \"Model validation should return error\")\n}\n\nfunc TestDuplicateChartName(t *testing.T) {\n\ttestData := new(mapper.Config)\n\n\terr := testData.LoadFile(\"testdata/duplicate/chartNames.yaml\")\n\tassert.NoError(t, err)\n\n\terr = testData.ValidateModel()\n\tassert.NoError(t, err, \"Model validation should not return error\")\n\n\tduplicate := testData.FindDuplicateChartName()\n\tassert.NotNil(t, duplicate)\n\tassert.Equal(t, 2, len(duplicate))\n\tassert.Equal(t, \"event_hub_sample_event_generator\", duplicate[0])\n}\n\nfunc TestDuplicateTypes(t *testing.T) {\n\ttestData := new(mapper.Config)\n\n\terr := testData.LoadFile(\"testdata/duplicate/types.yaml\")\n\tassert.NoError(t, err)\n\n\terr = testData.ValidateModel()\n\tassert.NoError(t, err, \"Model validation should not return error\")\n\n\tduplicate := testData.FindDuplicateType()\n\tassert.NotNil(t, duplicate)\n\tassert.Equal(t, 2, len(duplicate))\n\tassert.Equal(t, \"EventHub\", duplicate[0])\n}\n\nfunc TestDuplicateLocation(t *testing.T) {\n\ttestData := new(mapper.Config)\n\n\terr := testData.LoadFile(\"testdata/duplicate/locations.yaml\")\n\tassert.NoError(t, err)\n\n\terr = testData.ValidateModel()\n\tassert.NoError(t, err, \"Model validation should not return error\")\n\n\tduplicate := testData.FindDuplicateLocation()\n\tassert.NotNil(t, duplicate)\n\tassert.Equal(t, 2, len(duplicate))\n\tassert.Equal(t, \"../../helm/basictest\", duplicate[0])\n}\n"}
{"sample": "func main() {\n\ttimer := time.NewTimer(2 * time.Second)\n\tdefer timer.Stop()\n\n\t<-timer.C\n\tfmt.Println(\"Timer expired\")\n}"}
{"sample": "y := 10\nptr := &y\nfmt.Printf(\"Value of y: %d\\n\", *ptr)\n"}
{"sample": "package v1\n\nimport (\n\t\"net/http\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/labstack/echo/v4\"\n\n\t\"github.com/traPtitech/traQ/repository\"\n\t\"github.com/traPtitech/traQ/service/file\"\n\t\"github.com/traPtitech/traQ/service/rbac/role\"\n\t\"github.com/traPtitech/traQ/utils/random\"\n)\n\nfunc TestHandlers_GetPublicUserIcon(t *testing.T) {\n\tt.Parallel()\n\tenv, _, require, _, _ := setup(t, common2)\n\n\tfid, err := file.GenerateIconFile(env.FileManager, \"test\")\n\trequire.NoError(err)\n\n\ttestUser, err := env.Repository.CreateUser(repository.CreateUserArgs{\n\t\tName:       random.AlphaNumeric(32),\n\t\tRole:       role.User,\n\t\tIconFileID: fid,\n\t})\n\trequire.NoError(err)\n\n\tt.Run(\"No user\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\te := env.makeExp(t)\n\t\te.GET(\"/api/1.0/public/icon/no+user\").\n\t\t\tExpect().\n\t\t\tStatus(http.StatusNotFound)\n\t})\n\n\tt.Run(\"Success\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t_, require := assertAndRequire(t)\n\n\t\tmeta, err := env.FileManager.Get(testUser.GetIconFileID())\n\t\trequire.NoError(err)\n\t\te := env.makeExp(t)\n\t\te.GET(\"/api/1.0/public/icon/{username}\", testUser.GetName()).\n\t\t\tExpect().\n\t\t\tStatus(http.StatusOK).\n\t\t\tHeader(echo.HeaderContentLength).\n\t\t\tEqual(strconv.FormatInt(meta.GetFileSize(), 10))\n\t})\n\n\tt.Run(\"Success With 304\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t_, require := assertAndRequire(t)\n\n\t\tmeta, err := env.FileManager.Get(testUser.GetIconFileID())\n\t\trequire.NoError(err)\n\n\t\te := env.makeExp(t)\n\t\te.GET(\"/api/1.0/public/icon/{username}\", testUser.GetName()).\n\t\t\tWithHeader(\"If-None-Match\", strconv.Quote(meta.GetMD5Hash())).\n\t\t\tExpect().\n\t\t\tStatus(http.StatusNotModified)\n\t})\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"encoding/json\"\n)\n\ntype person struct {\n\tName string\n\tAge  int\n}\n\nfunc personHandler(w http.ResponseWriter, r *http.Request) {\n\tp := person{Name: \"John Doe\", Age: 30}\n\tjson.NewEncoder(w).Encode(p)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/person\", personHandler)\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tfmt.Println(scanner.Text())\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Println(\"Error scanning file:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "package main\n\n// Write to a file using a buffered writer\nfunc main() {\n\tfile, _ := os.Create(\"file.txt\")\n\tdefer file.Close()\n\twriter := bufio.NewWriter(file)\n\t_, err := writer.WriteString(\"Writing with bufio\\n\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\twriter.Flush()\n}\n"}
{"sample": "func getUserByID(db *sql.DB, id int) (string, error) {\n\tstmt, err := db.Prepare(\"SELECT name FROM users WHERE id = $1\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer stmt.Close()\n\n\tvar name string\n\terr = stmt.QueryRow(id).Scan(&name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn name, nil\n}\n"}
{"sample": "func CreateTempFile(dir, pattern string) (*os.File, error) {\n\treturn ioutil.TempFile(dir, pattern)\n}\n\nfunc CreateTempDir(dir, pattern string) (string, error) {\n\treturn ioutil.TempDir(dir, pattern)\n}\n\nfunc RemoveTempFile(file *os.File) error {\n\treturn os.Remove(file.Name())\n}"}
{"sample": "func main() {\n\tcmd := exec.Command(\"ls\", \"-l\")\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\terr := cmd.Run()\n\tif err != nil {\n\t\tfmt.Println(\"Error running command:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintPerimeterOfCircle(5)\n}\n\n// Function to print the perimeter of a circle\nfunc PrintPerimeterOfCircle(radius float64) {\n\tfmt.Println(2 * math.Pi * radius)\n}"}
{"sample": "func updateUser(db *sql.DB, id int, newName string) error {\n\tstmt, err := db.Prepare(\"UPDATE users SET name = $1 WHERE id = $2\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(newName, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tfmt.Println(\"Welcome to the number guessing game!\")\n\tfmt.Println(\"I'm thinking of a number between 1 and 100. Can you guess it?\")\n\n\t// generate random number between 1 and 100\n\tanswer := 1 + (99 * Random())\n\n\t// loop until user guesses the correct number or quits\n\tfor {\n\t\tvar guess int\n\t\tfmt.Print(\"Make a guess (or enter 0 to quit): \")\n\t\t_, err := fmt.Scanf(\"%d\", &guess)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Invalid input, try again.\")\n\t\t\tcontinue\n\t\t}\n\t\tif guess == 0 {\n\t\t\tfmt.Println(\"Thanks for playing!\")\n\t\t\tos.Exit(0)\n\t\t}\n\t\tif guess < answer {\n\t\t\tfmt.Println(\"Too low, try again!\")\n\t\t} else if guess > answer {\n\t\t\tfmt.Println(\"Too high, try again!\")\n\t\t} else {\n\t\t\tfmt.Println(\"Congratulations, you guessed it!\")\n\t\t\tos.Exit(0)\n\t\t}\n\t}\n}\n\n// Random returns a random float between 0 and 1.\nfunc Random() float64 {\n\tseed := int64(10)\n\ta := int64(16807)\n\tm := int64(2147483647)\n\treturn float64((seed * a) % m)\n}"}
{"sample": "package main\n\nimport \"math\"\n\nfunc main() {\n\tfmt.Println(Power(2, 3))\n}\n\nfunc Power(x, n float64) float64 {\n\treturn math.Pow(x, n)\n}"}
{"sample": "func main() {\n\tr := chi.NewRouter()\n\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Welcome to the home page\")\n\t})\n\n\tr.Get(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"List of users\")\n\t})\n\n\tr.Get(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := chi.URLParam(r, \"id\")\n\t\tfmt.Fprintf(w, \"Get user with ID: %s\", id)\n\t})\n\n\thttp.ListenAndServe(\":8080\", r)\n}"}
{"sample": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n)\n\n// RenderTemplate renders a template using the given data and writes it to a file.\nfunc RenderTemplate(templateFile string, data interface{} outputFile string) error {\n\ttemplateData, err := ioutil.ReadFile(templateFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttmpl, err := template.New(\"tmpl\").Parse(string(templateData))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfile, err := os.Create(outputFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treturn tmpl.Execute(file, data)\n}"}
{"sample": "type MyHandler struct{}\n\nfunc (h *MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World\")\n}\n\nfunc StartServer(addr string) {\n\tmyHandler := &MyHandler{}\n\thttp.ListenAndServe(addr, myHandler)\n}\n\nfunc RedirectRequest(w http.ResponseWriter, r *http.Request, newURL string) {\n\thttp.Redirect(w, r, newURL, http.StatusSeeOther)\n}"}
{"sample": "package formdata\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc processForm(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tname := r.FormValue(\"name\")\n\temail := r.FormValue(\"email\")\n\tmessage := r.FormValue(\"message\")\n\n\tfile, _, err := r.FormFile(\"attachment\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// save file to disk\n\tf, err := os.Create(\"attachments/\" + file.Filename)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer f.Close()\n\tif _, err := file.Seek(0, 0); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif _, err := io.Copy(f, file); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// store form data in database\n\terr = storeFormData(name, email, message, file.Filename)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"Form data processed successfully\")\n}\n\nfunc storeFormData(name, email, message, attachment string) error {\n\t// store data in database\n\treturn nil\n}"}
{"sample": "func main() {\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGINT, syscall.SIGTERM)\n\n\tfmt.Println(\"Waiting for signal...\")\n\ts := <-c\n\n\tfmt.Println(\"Received signal:\", s)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadFile reads and returns the content of a file.\nfunc ReadFile(filePath string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// WriteFile writes the content to a file.\nfunc WriteFile(filePath string, content []byte) error {\n\treturn ioutil.WriteFile(filePath, content, 0644)\n}"}
{"sample": "package slugify\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\tregSpace = regexp.MustCompile(`\\s+`)\n\tregPunct = regexp.MustCompile(`[^\\w\\d-]+`)\n)\n\n// Slugify converts plain text into slug format for URLs.\nfunc Slugify(text string) string {\n\ttext = strings.ToLower(text)\n\ttext = regSpace.ReplaceAllString(text, \"-\")\n\ttext = regPunct.ReplaceAllString(text, \"\")\n\treturn text\n}"}
{"sample": "package grpcclient\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/protos\"\n)\n\nfunc CreateOrUpdateUser(user *pb.User) error {\n\tconn, err := grpc.Dial(\"remote-server:9000\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewUsersServiceClient(conn)\n\tctx := context.Background()\n\n\tresp, err := client.CreateOrUpdateUser(ctx, &pb.CreateOrUpdateUserRequest{User: user})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not create or update user: %v\", err)\n\t}\n\tlog.Printf(\"CreateOrUpdateUser Response: %v\", resp)\n\treturn nil\n}\n\nfunc GetUser(userId int) (*pb.User, error) {\n\tconn, err := grpc.Dial(\"remote-server:9000\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewUsersServiceClient(conn)\n\tctx := context.Background()\n\n\tresp, err := client.GetUser(ctx, &pb.GetUserRequest{Id: int32(userId)})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not get user: %v\", err)\n\t}\n\tlog.Printf(\"GetUser Response: %v\", resp)\n\treturn resp.User, nil\n}"}
{"sample": "package pathfinding\n\nimport (\n\t\"container/heap\"\n\t\"errors\"\n\t\"math\"\n)\n\ntype node struct {\n\tx    int\n\ty    int\n\tcost float64\n}\n\ntype priorityQueue []*node\n\nfunc (pq priorityQueue) Len() int {\n\treturn len(pq)\n}\n\nfunc (pq priorityQueue) Less(i, j int) bool {\n\treturn pq[i].cost < pq[j].cost\n}\n\nfunc (pq priorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n}\n\nfunc (pq *priorityQueue) Push(x interface{}) {\n\t*pq = append(*pq, x.(*node))\n}\n\nfunc (pq *priorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\nfunc findPath(startX, startY, endX, endY int, grid [][]float64) ([][2]int, error) {\n\tif startX < 0 || startX >= len(grid) || startY < 0 || startY >= len(grid[0]) {\n\t\treturn nil, errors.New(\"start point outside of range\")\n\t}\n\n\tif endX < 0 || endX >= len(grid) || endY < 0 || endY >= len(grid[0]) {\n\t\treturn nil, errors.New(\"end point outside of range\")\n\t}\n\n\topenList := priorityQueue{}\n\theap.Init(&openList)\n\tclosedSet := map[int]bool{}\n\tfScore := map[int]float64{}\n\tgScore := map[int]float64{}\n\tprev := map[int]int{}\n\n\tstart := node{x: startX, y: startY, cost: 0}\n\theap.Push(&openList, &start)\n\tfScore[startX*len(grid[0])+startY] = 0\n\tgScore[startX*len(grid[0])+startY] = 0\n\n\tfor len(openList) > 0 {\n\t\tcurrent := heap.Pop(&openList).(*node)\n\n\t\tif current.x == endX && current.y == endY {\n\t\t\treturn reconstructPath(prev, startX, startY, endX, endY), nil\n\t\t}\n\n\t\tclosedSet[current.x*len(grid[0])+current.y] = true\n\n\t\tfor _, neighbor := range getNeighbors(current.x, current.y, grid) {\n\t\t\tif closedSet[neighbor.x*len(grid[0])+neighbor.y] {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tgScoreNew := gScore[current.x*len(grid[0])+current.y] + grid[neighbor.x][neighbor.y]\n\t\t\tfScoreNew := gScoreNew + distance(neighbor.x, neighbor.y, endX, endY)\n\n\t\t\tif _, ok := fScore[neighbor.x*len(grid[0])+neighbor.y]; !ok {\n\t\t\t\tfScore[neighbor.x*len(grid[0])+neighbor.y] = math.Inf(1)\n\t\t\t}\n\n\t\t\tif fScoreNew >= fScore[neighbor.x*len(grid[0])+neighbor.y] {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfScore[neighbor.x*len(grid[0])+neighbor.y] = fScoreNew\n\t\t\tgScore[neighbor.x*len(grid[0])+neighbor.y] = gScoreNew\n\t\t\tprev[neighbor.x*len(grid[0])+neighbor.y] = current.x*len(grid[0]) + current.y\n\n\t\t\tif len(openList) == 0 {\n\t\t\t\theap.Push(&openList, neighbor)\n\t\t\t} else {\n\t\t\t\tinserted := false\n\t\t\t\tfor i, node := range openList {\n\t\t\t\t\tif neighbor.cost < node.cost {\n\t\t\t\t\t\topenList = append(openList[:i], append(priorityQueue{neighbor}, openList[i:]...)...)\n\t\t\t\t\t\tinserted = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !inserted {\n\t\t\t\t\topenList = append(openList, neighbor)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"path not found\")\n}\n\nfunc getNeighbors(x, y int, grid [][]float64) []*node {\n\theight := len(grid)\n\twidth := len(grid[0])\n\tvar neighbors []*node\n\n\tif x > 0 && grid[x-1][y] != math.Inf(1) {\n\t\tneighbors = append(neighbors, &node{x: x - 1, y: y, cost: grid[x-1][y]})\n\t}\n\tif x < height-1 && grid[x+1][y] != math.Inf(1) {\n\t\tneighbors = append(neighbors, &node{x: x + 1, y: y, cost: grid[x+1][y]})\n\t}\n\tif y > 0 && grid[x][y-1] != math.Inf(1) {\n\t\tneighbors = append(neighbors, &node{x: x, y: y - 1, cost: grid[x][y-1]})\n\t}\n\tif y < width-1 && grid[x][y+1] != math.Inf(1) {\n\t\tneighbors = append(neighbors, &node{x: x, y: y + 1, cost: grid[x][y+1]})\n\t}\n\n\treturn neighbors\n}\n\nfunc reconstructPath(prev map[int]int, startX, startY, endX, endY int) [][2]int {\n\tpathArr := [][2]int{}\n\n\tcurrentX := endX\n\tcurrentY := endY\n\n\tfor {\n\t\tpathArr = append([][2]int{{currentX, currentY}}, pathArr...)\n\t\tprevKey := prev[currentX*len(prev)+currentY]\n\t\tif prevKey == startX*len(prev)+startY {\n\t\t\tpathArr = append([][2]int{{startX, startY}}, pathArr...)\n\t\t\tbreak\n\t\t} else {\n\t\t\tcurrentX = prevKey / len(prev)\n\t\t\tcurrentY = prevKey % len(prev)\n\t\t}\n\t}\n\n\treturn pathArr\n}\n\nfunc distance(x1, y1, x2, y2 int) float64 {\n\treturn math.Sqrt(math.Pow(float64(x1-x2), 2) + math.Pow(float64(y1-y2), 2))\n}"}
{"sample": "package main\n\nfunc main() {\n\tStartGoroutine()\n\ttime.Sleep(2 * time.Second)\n}\n\nfunc StartGoroutine() {\n\tgo func() {\n\t\tfmt.Println(\"Hello from goroutine\")\n\t}()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfmt.Println(\"Goroutine 1\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfmt.Println(\"Goroutine 2\")\n\t}()\n\n\twg.Wait()\n\n\tfmt.Println(\"All goroutines completed\")\n}"}
{"sample": "func deleteUser(db *sql.DB, id int) error {\n\tstmt, err := db.Prepare(\"DELETE FROM users WHERE id = $1\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package main\n\n// This function returns the size of a file\nfunc GetFileSize(filename string) (int64, error) {\n\tinfo, err := os.Stat(filename)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn info.Size(), nil\n}\n\n// This function prints the size of a file\nfunc PrintFileSize(filename string) error {\n\tsize, err := GetFileSize(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Println(\"File size:\", size)\n\treturn nil\n}\n\nfunc main() {\n\terr := PrintFileSize(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package calc\n\n// Sum returns the sum of elements of ints\nfunc Sum(vals []int) int {\n\tvar sum int\n\tfor _, val := range vals {\n\t\tsum += val\n\t}\n\treturn sum\n}\n\n// SumAll find sums of slices\nfunc SumAll(valSlices ...[]int) []int {\n\tresult := make([]int, len(valSlices))\n\tfor _, vals := range valSlices {\n\t\tsum := Sum(vals)\n\t\tresult = append(result, sum)\n\t}\n\treturn result\n}\n\n// SumTails find sums of slice tails\nfunc SumTails(valSlices ...[]int) []int {\n\tresult := make([]int, len(valSlices))\n\tfor _, vals := range valSlices {\n\t\tvar sum int\n\t\tif len(vals) != 0 {\n\t\t\ttail := vals[1:]\n\t\t\tsum = Sum(tail)\n\t\t}\n\t\tresult = append(result, sum)\n\t}\n\treturn result\n\n}\n"}
{"sample": "package bintree\n\ntype Node struct {\n\tValue int\n\tLeft  *Node\n\tRight *Node\n}\n\ntype BinaryTree struct {\n\tRoot *Node\n}\n\nfunc (bt *BinaryTree) Insert(value int) {\n\tif bt.Root == nil {\n\t\tbt.Root = &Node{Value: value}\n\t\treturn\n\t}\n\n\tcurrent := bt.Root\n\tfor {\n\t\tif value < current.Value {\n\t\t\tif current.Left == nil {\n\t\t\t\tcurrent.Left = &Node{Value: value}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent = current.Left\n\t\t} else {\n\t\t\tif current.Right == nil {\n\t\t\t\tcurrent.Right = &Node{Value: value}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent = current.Right\n\t\t}\n\t}\n}\n\nfunc (bt *BinaryTree) Search(value int) bool {\n\tcurrent := bt.Root\n\tfor current != nil {\n\t\tif value == current.Value {\n\t\t\treturn true\n\t\t}\n\n\t\tif value < current.Value {\n\t\t\tcurrent = current.Left\n\t\t} else {\n\t\t\tcurrent = current.Right\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (bt *BinaryTree) TraverseInOrder(node *Node, f func(int)) {\n\tif node != nil {\n\t\tbt.TraverseInOrder(node.Left, f)\n\t\tf(node.Value)\n\t\tbt.TraverseInOrder(node.Right, f)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\n\t// simulate a long running operation\n\ttime.Sleep(5 * time.Second)\n\n\telapsed := time.Since(start)\n\n\tfmt.Printf(\"Operation took %v\\n\", elapsed)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(num int) {\n\t\t\tdefer wg.Done()\n\t\t\tfmt.Printf(\"Goroutine %d\\n\", num)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc ServeStaticFiles() {\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.Dir(\"./static\"))))\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n"}
{"sample": "// Using a mutex for synchronization\n\nvar mu sync.Mutex\nmu.Lock()\n// critical section\nmu.Unlock()\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Fibonacci generates the Fibonacci sequence up to the specified limit.\nfunc Fibonacci(limit int) {\n\ta, b := 0, 1\n\tfmt.Println(a)\n\tfor b <= limit {\n\t\tfmt.Println(b)\n\t\ta, b = b, a+b\n\t}\n}"}
{"sample": "// LogErrorToFile logs the error to a file (assuming logFile is defined)\nfunc LogErrorToFile(err error) {\n\tif err != nil {\n\t\t// Assuming logFile is a file descriptor\n\t\t// fmt.Fprintf(logFile, \"%v\", err)\n\t}\n}\n"}
{"sample": "package main\n\n// Create a temp directory\nfunc main() {\n\td, err := os.CreateTempDir(\"\", \"tempDir*\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.RemoveAll(d)\n\tfmt.Println(\"Temp dir name:\", d)\n}\n"}
{"sample": "package svgparser\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\ntype SVG struct {\n\tXMLName xml.Name `xml:\"svg\"`\n\tWidth   int      `xml:\"width,attr\"`\n\tHeight  int      `xml:\"height,attr\"`\n\tRects   []Rect   `xml:\"rect\"`\n}\n\ntype Rect struct {\n\tXMLName xml.Name `xml:\"rect\"`\n\tX       int      `xml:\"x,attr\"`\n\tY       int      `xml:\"y,attr\"`\n\tWidth   int      `xml:\"width,attr\"`\n\tHeight  int      `xml:\"height,attr\"`\n}\n\nfunc ParseSVGFile(filename string) (*SVG, error) {\n\txmlFile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer xmlFile.Close()\n\n\tbyteValue, _ := ioutil.ReadAll(xmlFile)\n\n\tvar svg SVG\n\terr = xml.Unmarshal(byteValue, &svg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &svg, nil\n}\n\nfunc ScaleRects(svg *SVG, scale int) {\n\tfor i := range svg.Rects {\n\t\tsvg.Rects[i].X *= scale\n\t\tsvg.Rects[i].Y *= scale\n\t\tsvg.Rects[i].Width *= scale\n\t\tsvg.Rects[i].Height *= scale\n\t}\n}\n\nfunc WriteSVGFile(svg *SVG, filename string) error {\n\txmlData, err := xml.MarshalIndent(svg, \"\", \"  \")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ioutil.WriteFile(filename, xmlData, 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"SVG file written successfully\")\n\treturn nil\n}"}
{"sample": "package rssreader\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Item struct {\n\tXMLName     xml.Name `xml:\"item\"`\n\tTitle       string   `xml:\"title\"`\n\tDescription string   `xml:\"description\"`\n\tLink        string   `xml:\"link\"`\n}\n\ntype Channel struct {\n\tXMLName     xml.Name `xml:\"channel\"`\n\tTitle       string   `xml:\"title\"`\n\tDescription string   `xml:\"description\"`\n\tLink        string   `xml:\"link\"`\n\tItems       []Item   `xml:\"item\"`\n}\n\ntype Rss struct {\n\tXMLName xml.Name `xml:\"rss\"`\n\tChannel Channel  `xml:\"channel\"`\n}\n\nfunc ParseRSS(url string) (*Rss, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\trss := &Rss{}\n\terr = xml.NewDecoder(resp.Body).Decode(rss)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn rss, nil\n}\n\nfunc DisplayRSS(rss *Rss) {\n\tfmt.Printf(\"Title: %s\\n\", rss.Channel.Title)\n\tfmt.Printf(\"Description: %s\\n\", rss.Channel.Description)\n\tfmt.Printf(\"Link: %s\\n\", rss.Channel.Link)\n\tfmt.Println(\"Items:\")\n\tfor _, item := range rss.Channel.Items {\n\t\tfmt.Printf(\"\\tTitle: %s\\n\", item.Title)\n\t\tfmt.Printf(\"\\tDescription: %s\\n\", item.Description)\n\t\tfmt.Printf(\"\\tLink: %s\\n\", item.Link)\n\t\tfmt.Println()\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// SquareRoot calculates the square root of a given number.\nfunc SquareRoot(num float64) (float64, error) {\n\tif num < 0 {\n\t\treturn 0, fmt.Errorf(\"cannot calculate square root of a negative number\")\n\t}\n\treturn math.Sqrt(num), nil\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/Azure/open-service-broker-azure/pkg/api\"\n\tapiFilters \"github.com/Azure/open-service-broker-azure/pkg/api/filters\"\n\t\"github.com/Azure/open-service-broker-azure/pkg/azure\"\n\t\"github.com/Azure/open-service-broker-azure/pkg/boot\"\n\t\"github.com/Azure/open-service-broker-azure/pkg/broker\"\n\t\"github.com/Azure/open-service-broker-azure/pkg/crypto\"\n\t\"github.com/Azure/open-service-broker-azure/pkg/crypto/aes256\"\n\t\"github.com/Azure/open-service-broker-azure/pkg/crypto/noop\"\n\t\"github.com/Azure/open-service-broker-azure/pkg/http/filter\"\n\t\"github.com/Azure/open-service-broker-azure/pkg/http/filters\"\n\tbrokerLog \"github.com/Azure/open-service-broker-azure/pkg/log\"\n\t\"github.com/Azure/open-service-broker-azure/pkg/service\"\n\tstorage \"github.com/Azure/open-service-broker-azure/pkg/storage/redis\"\n\t\"github.com/Azure/open-service-broker-azure/pkg/version\"\n\tlog \"github.com/Sirupsen/logrus\"\n\tasync \"github.com/deis/async/redis\"\n)\n\nfunc main() {\n\t// Initialize logging\n\t// Split log output across stdout and stderr, depending on severity\n\t// krancour: This functionality is currently dependent on a fork of\n\t// the github.com/Sirupsen/logrus package that lives in the split-streams\n\t// branch at github.com/krancour/logrus. (See Gopkg.toml)\n\t// We can resume using the upstream logrus if/when this PR is merged:\n\t// https://github.com/sirupsen/logrus/pull/671\n\tlog.SetOutput(os.Stdout)\n\tlog.SetErrOutput(os.Stderr)\n\tformatter := &log.TextFormatter{\n\t\tFullTimestamp: true,\n\t}\n\tlog.SetFormatter(formatter)\n\tlog.SetLevel(log.InfoLevel)\n\n\tlog.WithFields(\n\t\tlog.Fields{\n\t\t\t\"version\": version.GetVersion(),\n\t\t\t\"commit\":  version.GetCommit(),\n\t\t},\n\t).Info(\"Open Service Broker for Azure starting\")\n\n\tlogConfig, err := brokerLog.GetConfig()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlogLevel := logConfig.GetLevel()\n\tlog.WithField(\n\t\t\"logLevel\",\n\t\tstrings.ToUpper(logLevel.String()),\n\t).Info(\"Setting log level\")\n\tlog.SetLevel(logLevel)\n\n\t// Initialize catalog\n\tcatalogConfig, err := service.GetCatalogConfigFromEnvironment()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tazureConfig, err := azure.GetConfigFromEnvironment()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcatalog, err := boot.GetCatalog(catalogConfig, azureConfig)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Initialize encryption\n\tcryptoConfig, err := crypto.GetConfigFromEnvironment()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar codec crypto.Codec\n\tswitch cryptoConfig.EncryptionScheme {\n\tcase crypto.AES256:\n\t\tvar aes256Config aes256.Config\n\t\taes256Config, err = aes256.GetConfigFromEnvironment()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tcodec, err = aes256.NewCodec(aes256Config)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tlog.WithField(\n\t\t\t\"encryptionScheme\",\n\t\t\tcryptoConfig.EncryptionScheme,\n\t\t).Info(\"Sensitive instance and binding details will be encrypted\")\n\tcase crypto.NOOP:\n\t\tcodec = noop.NewCodec()\n\t\tlog.Warn(\n\t\t\t\"ENCRYPTION IS DISABLED -- THIS IS NOT A SUITABLE OPTION FOR PRODUCTION\",\n\t\t)\n\tdefault:\n\t\tlog.Fatalf(\n\t\t\t`unrecognized encryption scheme \"%s\"`,\n\t\t\tcryptoConfig.EncryptionScheme,\n\t\t)\n\t}\n\tif err = crypto.InitializeGlobalCodec(codec); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Storage\n\tstorageConfig, err := storage.GetConfigFromEnvironment()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tstore, err := storage.NewStore(catalog, storageConfig)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Async\n\tasyncConfig, err := async.GetConfigFromEnvironment()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tasyncEngine := async.NewEngine(asyncConfig)\n\n\t// Assemble the filter chain\n\tbasicAuthConfig, err := api.GetBasicAuthConfig()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfilterChain := filter.NewChain(\n\t\tfilters.NewBasicAuthFilter(\n\t\t\tbasicAuthConfig.GetUsername(),\n\t\t\tbasicAuthConfig.GetPassword(),\n\t\t),\n\t\tapiFilters.NewAPIVersionFilter(),\n\t)\n\n\tapiServerConfig, err := api.GetConfigFromEnvironment()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// Create API server\n\tapiServer, err := api.NewServer(\n\t\tapiServerConfig,\n\t\tstore,\n\t\tasyncEngine,\n\t\tfilterChain,\n\t\tcatalog,\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Create broker\n\tbroker, err := broker.NewBroker(\n\t\tapiServer,\n\t\tasyncEngine,\n\t\tstore,\n\t\tcatalog,\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\tsignal := <-sigChan\n\t\tlog.WithField(\n\t\t\t\"signal\",\n\t\t\tsignal,\n\t\t).Debug(\"signal received; shutting down\")\n\t\tcancel()\n\t}()\n\n\t// Run broker\n\tif err := broker.Run(ctx); err != nil {\n\t\tif err == ctx.Err() {\n\t\t\t// Allow some time for goroutines to shut down\n\t\t\ttime.Sleep(time.Second * 3)\n\t\t} else {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// CountOccurrences counts the number of occurrences of a substring in a given string.\nfunc CountOccurrences(str, substr string) int {\n\treturn strings.Count(str, substr)\n}"}
{"sample": "total := sum([]int{1, 2, 3, 4, 5})\nfmt.Printf(\"Total: %d\\n\", total)\n"}
{"sample": "package main\n\nfunc main() {\n\tstr := \"Hello, World\"\n\tPrintLength(str)\n}\n\nfunc PrintLength(s string) {\n\tfmt.Println(len(s))\n}"}
{"sample": "// ErrorToString converts an error to a string\nfunc ErrorToString(err error) string {\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\treturn \"\"\n}\n"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype Task struct {\n\tID   string `json:\"id,omitempty\"`\n\tName string `json:\"name,omitempty\"`\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/tasks\", GetTasks).Methods(\"GET\")\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc GetTasks(w http.ResponseWriter, r *http.Request) {\n\ttasks := []Task{{ID: \"1\", Name: \"Task1\"}}\n\tjson.NewEncoder(w).Encode(tasks)\n}"}
{"sample": "package hangoutsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/gempir/go-twitch-irc\"\n\t\"github.com/layeh/gumble/gumble\"\n\t\"github.com/layeh/gumble/gumbleutil\"\n)\n\ntype HangoutsClient struct {\n\t// ...\n}\n\nfunc NewHangoutsClient() *HangoutsClient {\n\t// ...\n}\n\nfunc (c *HangoutsClient) Connect() error {\n\t// ...\n}\n\nfunc (c *HangoutsClient) Disconnect() error {\n\t// ...\n}\n\nfunc (c *HangoutsClient) SendMessage(message string) error {\n\t// ...\n}\n\nfunc (c *HangoutsClient) ListenForMessages(ctx context.Context) error {\n\t// ...\n}\n\nfunc main() {\n\tc := NewHangoutsClient()\n\n\tif err := c.Connect(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdefer c.Disconnect()\n\n\tif err := c.SendMessage(\"Hello, world!\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tctx := context.Background()\n\n\tif err := c.ListenForMessages(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "func beginTransaction(db *sql.DB) (*sql.Tx, error) {\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn tx, nil\n}\n"}
{"sample": "go func() {\n\tfmt.Println(\"I'm running in a goroutine\")\n}()\n"}
{"sample": "func ConnectToDatabase(connectionString string) (*sql.DB, error) {\n\treturn sql.Open(\"postgres\", connectionString)\n}\n\nfunc ExecuteQuery(db *sql.DB, query string) (*sql.Rows, error) {\n\treturn db.Query(query)\n}\n\nfunc CloseDatabaseConnection(db *sql.DB) error {\n\treturn db.Close()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io\"\n)\n\nfunc DownloadFile() {\n\tresponse, _ := http.Get(\"https://example.com/file.txt\")\n\tdefer response.Body.Close()\n\n\tfile, _ := os.Create(\"file.txt\")\n\tdefer file.Close()\n\n\tio.Copy(file, response.Body)\n}\n"}
{"sample": "package radxtree\n\ntype RadixTree struct {\n\troot *node\n}\n\ntype node struct {\n\tkey      string\n\tvalue    interface{}\n\tchildren []*node\n}\n\nfunc NewRadixTree() *RadixTree {\n\treturn &RadixTree{root: &node{}}\n}\n\nfunc (t *RadixTree) Insert(key string, value interface{}) {\n\tcurrent := t.root\n\tfor {\n\t\tif len(key) == 0 {\n\t\t\tcurrent.value = value\n\t\t\treturn\n\t\t}\n\n\t\tvar next *node\n\t\tfor _, child := range current.children {\n\t\t\tif child.key[0] == key[0] {\n\t\t\t\tnext = child\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif next == nil {\n\t\t\tnext = &node{key: key, value: value}\n\t\t\tcurrent.children = append(current.children, next)\n\t\t\treturn\n\t\t}\n\n\t\tcommonPrefix := longestCommonPrefix(key, next.key)\n\t\tif commonPrefix == len(next.key) {\n\t\t\tkey = key[commonPrefix:]\n\t\t\tcurrent = next\n\t\t\tcontinue\n\t\t}\n\n\t\tif commonPrefix == 0 {\n\t\t\tnewNode := &node{key: key, value: value}\n\t\t\tnewNode.children = append(newNode.children, next)\n\t\t\tcurrent.children = append(current.children, newNode)\n\t\t\treturn\n\t\t}\n\n\t\tnewNode := &node{key: next.key[0:commonPrefix]}\n\t\tnewNode.children = append(newNode.children, next)\n\t\tnext.key = next.key[commonPrefix:]\n\t\tcurrent.children = append(current.children, newNode)\n\n\t\tkey = key[commonPrefix:]\n\t\tcurrent = newNode\n\t}\n}\n\nfunc (t *RadixTree) Search(key string) interface{} {\n\tcurrent := t.root\n\tfor {\n\t\tif len(key) == 0 {\n\t\t\treturn current.value\n\t\t}\n\n\t\tvar next *node\n\t\tfor _, child := range current.children {\n\t\t\tif child.key[0] == key[0] {\n\t\t\t\tnext = child\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif next == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tcommonPrefix := longestCommonPrefix(key, next.key)\n\t\tif commonPrefix != len(next.key) {\n\t\t\treturn nil\n\t\t}\n\n\t\tkey = key[commonPrefix:]\n\t\tcurrent = next\n\t}\n}\n\nfunc longestCommonPrefix(a, b string) int {\n\ti := 0\n\tfor ; i < len(a) && i < len(b); i++ {\n\t\tif a[i] != b[i] {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn i\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// ReadCSVFile reads a CSV file and returns its content as a slice of records.\nfunc ReadCSVFile(filePath string) ([][]string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\trecords, err := reader.ReadAll()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn records, nil\n}\n\n// WriteCSVFile writes a slice of records to a CSV file.\nfunc WriteCSVFile(filePath string, records [][]string) error {\n\tfile, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\terr = writer.WriteAll(records)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twriter.Flush()\n\treturn writer.Error()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"encoding/json\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://api.example.com/data\")\n\tif err != nil {\n\t\tfmt.Println(\"Error making HTTP request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tvar data map[string]interface{}\n\terr = json.Unmarshal(body, &data)\n\tif err != nil {\n\t\tfmt.Println(\"Error unmarshaling JSON response:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(data)\n}"}
{"sample": "http.HandleFunc(\"/api\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle API endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"API response\")\n\t}\n})\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc generateRandomNumber() {\n\trand.Seed(time.Now().UnixNano())\n\tnum := rand.Intn(100)\n\tfmt.Println(num)\n}\n\nfunc main() {\n\tgenerateRandomNumber()\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--bucket\", argparse.String, \"mybucket\", \"S3 bucket name\")\nparser.AddArgument(\"--region\", argparse.String, \"us-west-2\", \"AWS region\")\n"}
{"sample": "package uptimechecker\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc checkWebsite(url string) bool {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer resp.Body.Close()\n\treturn true\n}\n\nfunc monitorWebsite(url string, interval time.Duration, alerts chan<- string) {\n\tfor {\n\t\tif !checkWebsite(url) {\n\t\t\talerts <- fmt.Sprintf(\"Website %s is down\", url)\n\t\t}\n\t\ttime.Sleep(interval)\n\t}\n}\n\nfunc reportAlerts(alerts <-chan string) {\n\tfor alert := range alerts {\n\t\tfmt.Println(alert)\n\t}\n}\n\nfunc StartMonitoring(url string, interval time.Duration) {\n\talerts := make(chan string)\n\tgo monitorWebsite(url, interval, alerts)\n\treportAlerts(alerts)\n}"}
{"sample": "package digisign\n\nimport (\n\t\"crypto\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"errors\"\n)\n\n// GenerateKeyPair generates a new RSA key pair.\nfunc GenerateKeyPair() (*rsa.PrivateKey, error) {\n\treturn rsa.GenerateKey(rand.Reader, 2048)\n}\n\n// Sign creates a digital signature of the message using the private key.\nfunc Sign(message []byte, privateKey *rsa.PrivateKey) ([]byte, error) {\n\thashed := sha256.Sum256(message)\n\treturn rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hashed[:])\n}\n\n// Verify checks if the digital signature is valid for the given message and public key.\nfunc Verify(message []byte, signature []byte, publicKey *rsa.PublicKey) error {\n\thashed := sha256.Sum256(message)\n\treturn rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hashed[:], signature)\n}\n\n// PrivateKeyToPEM converts a private key to PEM format.\nfunc PrivateKeyToPEM(privateKey *rsa.PrivateKey) ([]byte, error) {\n\tblock := &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: x509.MarshalPKCS1PrivateKey(privateKey),\n\t}\n\treturn pem.EncodeToMemory(block), nil\n}\n\n// PublicKeyToPEM converts a public key to PEM format.\nfunc PublicKeyToPEM(publicKey *rsa.PublicKey) ([]byte, error) {\n\tbytes, err := x509.MarshalPKIXPublicKey(publicKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tblock := &pem.Block{\n\t\tType:  \"PUBLIC KEY\",\n\t\tBytes: bytes,\n\t}\n\treturn pem.EncodeToMemory(block), nil\n}\n\n// PEMToPrivateKey converts a PEM-encoded private key to an RSA private key.\nfunc PEMToPrivateKey(pemBytes []byte) (*rsa.PrivateKey, error) {\n\tblock, _ := pem.Decode(pemBytes)\n\tif block == nil {\n\t\treturn nil, errors.New(\"failed to decode PEM block containing private key\")\n\t}\n\treturn x509.ParsePKCS1PrivateKey(block.Bytes)\n}\n\n// PEMToPublicKey converts a PEM-encoded public key to an RSA public key.\nfunc PEMToPublicKey(pemBytes []byte) (*rsa.PublicKey, error) {\n\tblock, _ := pem.Decode(pemBytes)\n\tif block == nil {\n\t\treturn nil, errors.New(\"failed to decode PEM block containing public key\")\n\t}\n\tpub, err := x509.ParsePKIXPublicKey(block.Bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trsaPub, ok := pub.(*rsa.PublicKey)\n\tif !ok {\n\t\treturn nil, errors.New(\"failed to parse RSA public key\")\n\t}\n\treturn rsaPub, nil\n}"}
{"sample": "package main\n\n// Create a directory along with any necessary parents\nfunc main() {\n\terr := os.MkdirAll(\"path/to/newdir\", 0755)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package cronscheduler\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/robfig/cron/v3\"\n)\n\nfunc printTime() {\n\tfmt.Println(time.Now().UTC().String())\n}\n\ntype job struct {\n\tname string\n}\n\nfunc (j job) Run() {\n\tfmt.Printf(\"[%s]: triggering job...\\n\", j.name)\n\tprintTime()\n}\n\nfunc StartScheduler() {\n\tscheduler := cron.New()\n\n\t_, err := scheduler.AddFunc(\"0 30 7-21/3 * * *\", job{name: \"scheduled job\"}.Run)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tscheduler.Start()\n\n\tfmt.Println(\"Scheduler started. Jobs will be executed according to cron syntax.\")\n\ttime.Sleep(2 * time.Minute)\n\tscheduler.Stop()\n\tfmt.Println(\"Scheduler stopped.\")\n}\n\nfunc ScheduleTask(jobName string, cronInterval string) (cron.EntryID, error) {\n\tscheduler := cron.New()\n\n\tentryID, err := scheduler.AddFunc(cronInterval, job{name: jobName}.Run)\n\tif err != nil {\n\t\tscheduler.Stop()\n\t\treturn 0, err\n\t}\n\n\tscheduler.Start()\n\n\tfmt.Println(\"Scheduled job\", jobName, \"will be executed according to cron syntax\", cronInterval)\n\n\ti, err := strconv.Atoi(entryID.String())\n\tif err != nil {\n\t\tscheduler.Stop()\n\t\treturn 0, err\n\t}\n\n\treturn cron.EntryID(i), nil\n}\n\nfunc CancelScheduledTask(entryID cron.EntryID) error {\n\ts, err := scheduler.Entry(entryID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"Job\", s.Job.(job).name, \"with ID\", int64(s.ID), \"cancelled.\")\n\tscheduler.Remove(entryID)\n\n\treturn nil\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\nparser.AddArgument(\"--debug\", argparse.Bool, false, \"Enable debug mode\")\n"}
{"sample": "type Queue struct {\n\tqueue []interface{}\n\tmu    sync.Mutex\n}\n\nfunc (q *Queue) Enqueue(value interface{}) {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\tq.queue = append(q.queue, value)\n}\n\nfunc (q *Queue) Dequeue() (interface{} error) {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\tif len(q.queue) == 0 {\n\t\treturn nil, errors.New(\"queue is empty\")\n\t}\n\tvalue := q.queue[0]\n\tq.queue = q.queue[1:]\n\treturn value, nil\n}"}
{"sample": "package main\n\n// ErrorContains checks if an error message contains a specific string\nfunc ErrorContains(err error, str string) bool {\n\tif err != nil {\n\t\treturn strings.Contains(err.Error(), str)\n\t}\n\treturn false\n}\n"}
{"sample": "package mongodbclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\ntype User struct {\n\tName  string `bson:\"name\"`\n\tEmail string `bson:\"email\"`\n}\n\nfunc ConnectToDB() (*mongo.Client, error) {\n\tclientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n\tclient, err := mongo.Connect(context.Background(), clientOptions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = client.Ping(context.Background(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfmt.Println(\"Connected to MongoDB!\")\n\treturn client, nil\n}\n\nfunc CreateUser(client *mongo.Client, user User) error {\n\tcollection := client.Database(\"test\").Collection(\"users\")\n\t_, err := collection.InsertOne(context.Background(), user)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tfmt.Println(\"User created successfully!\")\n\treturn nil\n}\n\nfunc ReadUser(client *mongo.Client, email string) (User, error) {\n\tvar user User\n\tcollection := client.Database(\"test\").Collection(\"users\")\n\tfilter := bson.M{\"email\": email}\n\terr := collection.FindOne(context.Background(), filter).Decode(&user)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn User{}, err\n\t}\n\n\tfmt.Printf(\"User found: %+v\\n\", user)\n\treturn user, nil\n}\n\nfunc UpdateUser(client *mongo.Client, email string, name string) error {\n\tcollection := client.Database(\"test\").Collection(\"users\")\n\tfilter := bson.M{\"email\": email}\n\tupdate := bson.M{\"$set\": bson.M{\"name\": name}}\n\t_, err := collection.UpdateOne(context.Background(), filter, update)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tfmt.Println(\"User updated successfully!\")\n\treturn nil\n}\n\nfunc DeleteUser(client *mongo.Client, email string) error {\n\tcollection := client.Database(\"test\").Collection(\"users\")\n\tfilter := bson.M{\"email\": email}\n\t_, err := collection.DeleteOne(context.Background(), filter)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tfmt.Println(\"User deleted successfully!\")\n\treturn nil\n}"}
{"sample": "package insertionsort\n\nfunc InsertionSort(arr []int) {\n\tfor i := 1; i < len(arr); i++ {\n\t\tkey := arr[i]\n\t\tj := i - 1\n\t\tfor ; j >= 0 && arr[j] > key; j-- {\n\t\t\tarr[j+1] = arr[j]\n\t\t}\n\t\tarr[j+1] = key\n\t}\n}"}
{"sample": "package main\n\n// This function changes the mode of a file\nfunc ChangeFileMode(filename string, mode os.FileMode) error {\n\terr := os.Chmod(filename, mode)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// This function prints the mode of a file\nfunc PrintFileMode(filename string) error {\n\tinfo, err := os.Stat(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Println(\"File mode:\", info.Mode())\n\treturn nil\n}\n\nfunc main() {\n\terr := ChangeFileMode(\"file.txt\", 0644)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\terr = PrintFileMode(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "type HTTPHandler struct {\n\tClient *http.Client\n}\n\nfunc (h *HTTPHandler) Get(url string) (*http.Response, error) {\n\treq, err := http.NewRequest(http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp, err := h.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tdone := make(chan bool)\n\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine executed\")\n\t\tdone <- true\n\t}()\n\n\tfmt.Println(\"Main goroutine\")\n\n\t<-done\n}"}
{"sample": "package cache_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"code.cloudfoundry.org/loggregator-agent/pkg/binding\"\n\t\"code.cloudfoundry.org/loggregator-agent/pkg/cache\"\n)\n\nvar _ = Describe(\"Client\", func() {\n\tvar (\n\t\tspyHTTPClient *spyHTTPClient\n\t\taddr          string\n\t\tclient        *cache.CacheClient\n\t)\n\n\tBeforeEach(func() {\n\t\tspyHTTPClient = newSpyHTTPClient()\n\t\taddr = \"https://cache.address.com\"\n\t\tclient = cache.NewClient(addr, spyHTTPClient)\n\t})\n\n\tIt(\"returns bindings from the cache\", func() {\n\t\tbindings := []binding.Binding{\n\t\t\t{\n\t\t\t\tAppID:    \"app-id-1\",\n\t\t\t\tDrains:   []string{\"drain-1\"},\n\t\t\t\tHostname: \"host-1\",\n\t\t\t},\n\t\t}\n\n\t\tj, err := json.Marshal(bindings)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tspyHTTPClient.response = &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       ioutil.NopCloser(bytes.NewReader(j)),\n\t\t}\n\n\t\tExpect(client.Get()).To(Equal(bindings))\n\t\tExpect(spyHTTPClient.requestURL).To(Equal(\"https://cache.address.com/bindings\"))\n\t})\n\n\tIt(\"returns empty bindings if an HTTP error occurs\", func() {\n\t\tspyHTTPClient.err = errors.New(\"http error\")\n\n\t\t_, err := client.Get()\n\n\t\tExpect(err).To(MatchError(\"http error\"))\n\t})\n\n\tIt(\"returns empty bindings if cache returns a non-OK status code\", func() {\n\t\tspyHTTPClient.response = &http.Response{\n\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n\t\t}\n\n\t\t_, err := client.Get()\n\n\t\tExpect(err).To(MatchError(\"unexpected http response from binding cache: 500\"))\n\t})\n})\n\ntype spyHTTPClient struct {\n\tresponse   *http.Response\n\trequestURL string\n\terr        error\n}\n\nfunc newSpyHTTPClient() *spyHTTPClient {\n\treturn &spyHTTPClient{}\n}\n\nfunc (s *spyHTTPClient) Get(url string) (*http.Response, error) {\n\ts.requestURL = url\n\treturn s.response, s.err\n}\n"}
{"sample": "package entity\n\nimport (\n\t\"sync\"\n\n\t\"github.com/LinMAD/Snap/engine/graphics/data\"\n)\n\n// SceneObject interface represents as actor in the scene, can be anything\ntype SceneObject interface {\n\t// OnUpdate event called on each tick to update state\n\t// Make actual data updates for object here\n\tOnUpdate()\n\n\t// TODO Input event\n\n\t// GetDrawableInformation about object\n\tGetDrawableInformation() *DrawableInformation\n\t// GetPosition in the scene\n\tGetPosition() *Position\n}\n\n// DrawableInformation asset data\ntype DrawableInformation struct {\n\t// Width of image\n\tWidth uint32\n\t// Height of image\n\tHeight uint32\n\n\t// IsFlipped image flipped horizontally ?\n\tIsFlipped bool\n\n\t// TextureData about image\n\tTextureData *data.TextureData\n\n\t// FontData about text\n\tFontData *data.FontData\n\n\t// Color modifier\n\tColor *Color\n\n\t// Text name of object, or simple UI text in the screen\n\tText *Text\n}\n\n// Position in screen\ntype Position struct {\n\t// X coordinate on the screen\n\tX int32\n\t// Y coordinate on the screen\n\tY int32\n\n\tsync.Mutex\n}\n\n// Color data\ntype Color struct {\n\tRed   uint8\n\tGreen uint8\n\tBlue  uint8\n\n\tsync.Mutex\n}\n\n// Text in scene screen\ntype Text struct {\n\tTextToPrint string\n\n\tsync.Mutex\n}\n"}
{"sample": "type API struct {\n\tclient *http.Client\n}\n\nfunc (api *API) SendRequest(method, url string, body io.Reader) (*http.Response, error) {\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp, err := api.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, nil\n}\n\nfunc (api *API) ParseResponse(resp *http.Response) ([]byte, error) {\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tresp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn body, nil\n}"}
{"sample": "type Semaphore struct {\n\tchannel chan struct{}\n}\n\nfunc NewSemaphore(n int) *Semaphore {\n\treturn &Semaphore{\n\t\tchannel: make(chan struct{} n),\n\t}\n}\n\nfunc (s *Semaphore) Acquire() {\n\ts.channel <- struct{}{}\n}\n\nfunc (s *Semaphore) Release() {\n\t<-s.channel\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tName     string `json:\"name\"`\n\tAge      int    `json:\"age\"`\n\tEmail    string `json:\"email\"`\n\tPassword string `json:\"password\"`\n}\n\nfunc login(w http.ResponseWriter, r *http.Request) {\n\tvar user User\n\terr := json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// validate user credentials and authenticate\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\n\t// return user information or access token\n\tresponse := map[string]string{\"message\": \"Login successful\"}\n\tjson.NewEncoder(w).Encode(response)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/login\", login)\n\n\tfmt.Println(\"Server listening on port 8080\")\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tfmt.Println(err.Error())\n\t}\n}"}
{"sample": "package jwtlib\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\n// JWTManager is a struct that holds the JWT secret key and the token duration.\ntype JWTManager struct {\n\tSecretKey    string\n\tTokenDuration time.Duration\n}\n\n// GenerateToken generates a new JWT token with the given claims.\nfunc (manager *JWTManager) GenerateToken(claims jwt.MapClaims) (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString([]byte(manager.SecretKey))\n}\n\n// VerifyToken verifies the given JWT token and returns the claims if the token is valid.\nfunc (manager *JWTManager) VerifyToken(tokenString string) (jwt.MapClaims, error) {\n\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t// Check if the signing method is HMAC\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, errors.New(\"invalid signing method\")\n\t\t}\n\n\t\treturn []byte(manager.SecretKey), nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the token is valid\n\tif !token.Valid {\n\t\treturn nil, errors.New(\"invalid token\")\n\t}\n\n\tclaims, ok := token.Claims.(jwt.MapClaims)\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid claims\")\n\t}\n\n\treturn claims, nil\n}"}
{"sample": "func EncodeToJSON(v interface{}) ([]byte, error) {\n\treturn json.Marshal(v)\n}\n\nfunc DecodeFromJSON(data []byte, v interface{}) error {\n\treturn json.Unmarshal(data, v)\n}\n\nfunc WriteJSONToFile(filename string, v interface{}) error {\n\tdata, err := EncodeToJSON(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(filename, data, 0644)\n}"}
{"sample": "http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle root endpoint\n\tfmt.Fprint(w, \"Hello, World!\")\n})\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\t// declare WaitGroup to keep track of the goroutines.\n\tvar wg sync.WaitGroup\n\n\t// set how many goroutines will run in parallel.\n\twg.Add(2)\n\n\tfmt.Println(\"Starting parallel execution...\")\n\n\t// goroutine 1 - add 2 numbers and print result.\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfmt.Println(\"Goroutine 1 started...\")\n\t\tresult := addNumbers(2, 3)\n\t\tfmt.Println(\"2 + 3 =\", result)\n\t}()\n\n\t// goroutine 2 - subtract 2 numbers and print result.\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfmt.Println(\"Goroutine 2 started...\")\n\t\tresult := subtractNumbers(10, 3)\n\t\tfmt.Println(\"10 - 3 =\", result)\n\t}()\n\n\t// wait for all the goroutines to finish.\n\tfmt.Println(\"Waiting for goroutines to complete...\")\n\twg.Wait()\n\n\tfmt.Println(\"All goroutines completed.\")\n}\n\nfunc addNumbers(a, b int) int {\n\treturn a + b\n}\n\nfunc subtractNumbers(a, b int) int {\n\treturn a - b\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tvar num float64 = 4.5\n\n\tfmt.Println(\"Floor:\", math.Floor(num))\n\tfmt.Println(\"Ceil:\", math.Ceil(num))\n\tfmt.Println(\"Round:\", math.Round(num))\n\tfmt.Println(\"Sqrt:\", math.Sqrt(num))\n}"}
{"sample": "package main\n\nimport \"strconv\"\n\nfunc main() {\n\tnum := 42\n\tstr := IntToString(num)\n\tfmt.Println(str)\n}\n\nfunc IntToString(num int) string {\n\treturn strconv.Itoa(num)\n}"}
{"sample": "type BinarySearchTree struct {\n\tRoot *Node\n}\n\ntype Node struct {\n\tValue int\n\tLeft  *Node\n\tRight *Node\n}\n\nfunc (t *BinarySearchTree) Insert(value int) {\n\tt.Root = insertNode(t.Root, value)\n}\n\nfunc insertNode(node *Node, value int) *Node {\n\tif node == nil {\n\t\treturn &Node{Value: value}\n\t}\n\tif value < node.Value {\n\t\tnode.Left = insertNode(node.Left, value)\n\t} else if value > node.Value {\n\t\tnode.Right = insertNode(node.Right, value)\n\t}\n\treturn node\n}"}
{"sample": "package flaghandler\n\nimport (\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype flagOptions struct {\n\tverbose bool\n\tinput   string\n}\n\nfunc parseFlags() (*flagOptions, error) {\n\toptions := &flagOptions{}\n\n\tflag.BoolVar(&options.verbose, \"v\", false, \"Verbose output\")\n\tflag.StringVar(&options.input, \"i\", \"\", \"Input file\")\n\tflag.Parse()\n\n\tif options.input == \"\" {\n\t\treturn nil, errors.New(\"Input file not provided\")\n\t}\n\n\treturn options, nil\n}\n\nfunc Run() error {\n\toptions, err := parseFlags()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif options.verbose {\n\t\tfmt.Println(\"Verbose output enabled\")\n\t}\n\n\tfmt.Printf(\"Processing input file: %v\\n\", options.input)\n\n\treturn nil\n}\n\nfunc Usage() {\n\tfmt.Fprintf(os.Stderr, \"Usage of %s:\\n\", os.Args[0])\n\tflag.PrintDefaults()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadFile reads and returns the content of a file.\nfunc ReadFile(filePath string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// WriteFile writes the content to a file.\nfunc WriteFile(filePath string, content []byte) error {\n\treturn ioutil.WriteFile(filePath, content, 0644)\n}"}
{"sample": "type API struct {\n\tclient *http.Client\n\tbaseURL string\n}\n\nfunc (api *API) GetEndpoint(endpoint string) (*http.Response, error) {\n\treq, err := http.NewRequest(http.MethodGet, api.baseURL+endpoint, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn api.client.Do(req)\n}"}
{"sample": "package promclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/api\"\n\t\"github.com/prometheus/client_golang/api/prometheus/v1\"\n\t\"github.com/prometheus/common/model\"\n)\n\nfunc Query(query string, endpoint string) (model.Value, error) {\n\tclient, err := api.NewClient(api.Config{\n\t\tAddress: endpoint,\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating prometheus client: %v\", err)\n\t}\n\n\tv1api := v1.NewAPI(client)\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tresult, warnings, err := v1api.Query(ctx, query, time.Now())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error querying prometheus: %v\", err)\n\t}\n\tif len(warnings) > 0 {\n\t\tfmt.Printf(\"Warnings: %v\\n\", warnings)\n\t}\n\n\treturn result, nil\n}\n\nfunc GetMetrics(endpoint string) ([]byte, error) {\n\tresp, err := http.Get(fmt.Sprintf(\"%s/metrics\", endpoint))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting metrics from prometheus: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %v\", err)\n\t}\n\n\treturn body, nil\n}"}
{"sample": "package sheetsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/api/sheets/v4\"\n)\n\ntype SheetsClient struct {\n\tservice *sheets.Service\n}\n\nfunc NewSheetsClient(credentialsFile string) (*SheetsClient, error) {\n\tctx := context.Background()\n\tclientOptions := option.WithCredentialsFile(credentialsFile)\n\n\tservice, err := sheets.NewService(ctx, clientOptions)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create sheets service: %v\", err)\n\t}\n\n\treturn &SheetsClient{service: service}, nil\n}\n\nfunc (c *SheetsClient) ReadSheet(spreadsheetID string, sheetName string) ([][]interface{}, error) {\n\treadRange := sheetName + \"!A1:Z\"\n\tresp, err := c.service.Spreadsheets.Values.Get(spreadsheetID, readRange).Do()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read sheet: %v\", err)\n\t}\n\n\tif len(resp.Values) == 0 {\n\t\tlog.Println(\"No data found.\")\n\t\treturn nil, nil\n\t}\n\n\treturn resp.Values, nil\n}\n\nfunc (c *SheetsClient) WriteToSheet(spreadsheetID string, sheetName string, values [][]interface{}) error {\n\twriteRange := sheetName + \"!A1:Z\"\n\tvalueRange := &sheets.ValueRange{\n\t\tValues: values,\n\t}\n\n\t_, err := c.service.Spreadsheets.Values.Update(spreadsheetID, writeRange, valueRange).ValueInputOption(\"USER_ENTERED\").Do()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write to sheet: %v\", err)\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine 1 executed\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(3 * time.Second)\n\t\tfmt.Println(\"Goroutine 2 executed\")\n\t}()\n\n\twg.Wait()\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Factorial calculates the factorial of a given non-negative integer.\nfunc Factorial(n int) int {\n\tif n <= 1 {\n\t\treturn 1\n\t}\n\treturn n * Factorial(n-1)\n}"}
{"sample": "func main() {\n\tclient := redis.NewClient(options)\n\n\tpingResult, err := client.Ping(context.Background()).Result()\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to Redis:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Connected to Redis. Ping result:\", pingResult)\n}"}
{"sample": "package tasksclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"golang.org/x/oauth2\"\n\t\"golang.org/x/oauth2/google\"\n\t\"google.golang.org/api/tasks/v1\"\n)\n\nfunc getClient(config *oauth2.Config) *http.Client {\n\ttokenFile := \"token.json\"\n\ttoken, err := tokenFromFile(tokenFile)\n\tif err != nil {\n\t\ttoken = getTokenFromWeb(config)\n\t\tsaveToken(tokenFile, token)\n\t}\n\treturn config.Client(context.Background(), token)\n}\n\nfunc GetTasks() {\n\tconfig, err := google.ConfigFromJSON([]byte(os.Getenv(\"GOOGLE_CLIENT_SECRET\")), tasks.TasksScope)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to parse client secret file to config: %v\", err)\n\t}\n\n\tclient := getClient(config)\n\n\tsrv, err := tasks.New(client)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve tasks Client %v\", err)\n\t}\n\n\ttaskLists, err := srv.Tasklists.List().MaxResults(10).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve task lists. %v\", err)\n\t}\n\n\tif len(taskLists.Items) == 0 {\n\t\tfmt.Println(\"No task lists found.\")\n\t\treturn\n\t}\n\n\tfor _, taskList := range taskLists.Items {\n\t\tfmt.Printf(\"%v (%v)\\n\", taskList.Title, taskList.Id)\n\t}\n}\n\nfunc AddTask(taskName string) {\n\tconfig, err := google.ConfigFromJSON([]byte(os.Getenv(\"GOOGLE_CLIENT_SECRET\")), tasks.TasksScope)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to parse client secret file to config: %v\", err)\n\t}\n\n\tclient := getClient(config)\n\n\tsrv, err := tasks.New(client)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve tasks Client %v\", err)\n\t}\n\n\ttask := &tasks.Task{\n\t\tTitle: taskName,\n\t}\n\n\ttaskList, err := srv.Tasklists.List().MaxResults(1).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve task lists. %v\", err)\n\t}\n\n\tif len(taskList.Items) == 0 {\n\t\tfmt.Println(\"No task lists found.\")\n\t\treturn\n\t}\n\n\ttaskListId := taskList.Items[0].Id\n\n\t_, err = srv.Tasks.Insert(taskListId, task).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to create task. %v\", err)\n\t}\n\n\tfmt.Printf(\"Task \\\"%v\\\" added to task list \\\"%v\\\".\\n\", taskName, taskList.Items[0].Title)\n}"}
{"sample": "package main\n\n// IfErrorThenReplace checks if an error exists, if so, replaces it with a new error\nfunc IfErrorThenReplace(err *error, replaceErr error) {\n\tif *err != nil {\n\t\t*err = replaceErr\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype User struct {\n\tID   string `json:\"id,omitempty\"`\n\tName string `json:\"name,omitempty\"`\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/users\", GetUsers).Methods(\"GET\")\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc GetUsers(w http.ResponseWriter, r *http.Request) {\n\tusers := []User{{ID: \"1\", Name: \"John Doe\"}}\n\tjson.NewEncoder(w).Encode(users)\n}"}
{"sample": "// Get the value of a specific cookie from the request\nfunc GetCookie(request *http.Request, name string) (string, error) {\n\tcookie, err := request.Cookie(name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn cookie.Value, nil\n}\n"}
{"sample": "// RandomElement returns a random element from a slice.\nfunc RandomElement(slice []interface{}) interface{} {\n\trand.Seed(time.Now().UnixNano())\n\treturn slice[rand.Intn(len(slice))]\n}\n\n// Contains checks whether an element is in a slice.\nfunc Contains(slice []interface{} element interface{}) bool {\n\tfor _, e := range slice {\n\t\tif e == element {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"}
{"sample": "package mqttclient\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\n\tmqtt \"github.com/eclipse/paho.mqtt.golang\"\n)\n\nfunc main() {\n\tch := make(chan os.Signal, 1)\n\tsignal.Notify(ch, os.Interrupt)\n\n\topts := mqtt.NewClientOptions()\n\topts.AddBroker(\"tcp://broker.hivemq.com:1883\")\n\topts.SetClientID(\"go-mqtt-client\")\n\n\tc := mqtt.NewClient(opts)\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tpanic(token.Error())\n\t}\n\tdefer c.Disconnect(250)\n\n\tsubscribe(c)\n\tpublish(c)\n\n\t<-ch\n\tfmt.Println(\"Exiting\")\n}\n\nfunc subscribe(c mqtt.Client) {\n\thandler := func(client mqtt.Client, msg mqtt.Message) {\n\t\tfmt.Printf(\"Received Message: %s from Topic: %s\\n\", msg.Payload(), msg.Topic())\n\t}\n\n\ttoken := c.Subscribe(\"example/topic\", 0, handler)\n\ttoken.Wait()\n\tlog.Printf(\"Subscribed to topic: %s\\n\", \"example/topic\")\n}\n\nfunc publish(c mqtt.Client) {\n\ttoken := c.Publish(\"example/topic\", 0, false, \"Hello World\")\n\ttoken.Wait()\n\tlog.Println(\"Message published\")\n}"}
{"sample": "package database\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc Connect() (*sql.DB, error) {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/db_name\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err = db.Ping(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Connected to database\")\n\treturn db, nil\n}\n\nfunc GetUsers(db *sql.DB) ([]User, error) {\n\tvar users []User\n\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar user User\n\n\t\tif err := rows.Scan(&user.ID, &user.Name, &user.Email); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tusers = append(users, user)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn users, nil\n}\n\ntype User struct {\n\tID    int\n\tName  string\n\tEmail string\n}\n\nfunc main() {\n\tdb, err := Connect()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tusers, err := GetUsers(db)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(users)\n}"}
{"sample": "package trelloclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/adlio/trello\"\n)\n\ntype TrelloClient struct {\n\tclient *trello.Client\n\tboard  *trello.Board\n}\n\nfunc NewTrelloClient(boardID string) (*TrelloClient, error) {\n\tappKey := os.Getenv(\"TRELLO_APP_KEY\")\n\ttoken := os.Getenv(\"TRELLO_TOKEN\")\n\n\tclient := trello.NewClient(appKey, token)\n\n\tboard, err := client.GetBoard(boardID, trello.Defaults())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get board: %v\", err)\n\t}\n\n\treturn &TrelloClient{\n\t\tclient: client,\n\t\tboard:  board,\n\t}, nil\n}\n\nfunc (tc *TrelloClient) GetLists() ([]*trello.List, error) {\n\tlists, err := tc.board.GetLists(trello.Defaults())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get lists: %v\", err)\n\t}\n\n\treturn lists, nil\n}\n\nfunc (tc *TrelloClient) CreateCard(listID, name, description string) (*trello.Card, error) {\n\tlist, err := tc.client.GetList(listID, trello.Defaults())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get list: %v\", err)\n\t}\n\n\tcard := trello.Card{\n\t\tName:   name,\n\t\tDesc:   description,\n\t\tIDList: list.ID,\n\t}\n\n\terr = tc.client.CreateCard(&card, trello.Defaults())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create card: %v\", err)\n\t}\n\n\treturn &card, nil\n}\n\nfunc (tc *TrelloClient) MoveCardToList(cardID, listID string) error {\n\tcard, err := tc.client.GetCard(cardID, trello.Defaults())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get card: %v\", err)\n\t}\n\n\tlist, err := tc.client.GetList(listID, trello.Defaults())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get list: %v\", err)\n\t}\n\n\terr = card.MoveToList(list.ID, trello.Defaults())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to move card to list: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (tc *TrelloClient) WatchCard(ctx context.Context, cardID string) (<-chan trello.Card, error) {\n\tcard, err := tc.client.GetCard(cardID, trello.Defaults())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get card: %v\", err)\n\t}\n\n\tcardChan := make(chan trello.Card)\n\n\tgo func() {\n\t\tdefer close(cardChan)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\terr := card.Refresh(trello.Defaults())\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"failed to refresh card: %v\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tcardChan <- *card\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn cardChan, nil\n}"}
{"sample": "package gnomesort\n\n// GnomeSort sorts an array of integers using the gnome sort algorithm\nfunc GnomeSort(arr []int) {\n\ti := 1\n\tfor i < len(arr) {\n\t\tif i == 0 {\n\t\t\ti = 1\n\t\t}\n\t\tif arr[i] >= arr[i-1] {\n\t\t\ti++\n\t\t} else {\n\t\t\tarr[i], arr[i-1] = arr[i-1], arr[i]\n\t\t\ti--\n\t\t}\n\t}\n}"}
{"sample": "package quicksort\n\nfunc QuickSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\n\tpivot := arr[0]\n\tvar left []int\n\tvar right []int\n\n\tfor _, v := range arr[1:] {\n\t\tif v <= pivot {\n\t\t\tleft = append(left, v)\n\t\t} else {\n\t\t\tright = append(right, v)\n\t\t}\n\t}\n\n\tleft = QuickSort(left)\n\tright = QuickSort(right)\n\n\treturn append(append(left, pivot), right...)\n}"}
{"sample": "package imapserver\n\nimport (\n\t\"crypto/tls\"\n\t\"log\"\n\t\"net\"\n\t\"net/mail\"\n\t\"net/textproto\"\n)\n\ntype IMAPServer struct {\n\tAddr     string\n\tCertFile string\n\tKeyFile  string\n}\n\nfunc (s *IMAPServer) ListenAndServe() error {\n\tcert, err := tls.LoadX509KeyPair(s.CertFile, s.KeyFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfig := &tls.Config{Certificates: []tls.Certificate{cert}}\n\n\tlistener, err := tls.Listen(\"tcp\", s.Addr, config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Printf(\"IMAP server listening on %s\", s.Addr)\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo s.handleConnection(conn)\n\t}\n}\n\nfunc (s *IMAPServer) handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\tlog.Printf(\"Connection from %s\", conn.RemoteAddr())\n\n\tr := textproto.NewReader(mail.NewReader(conn))\n\tw := textproto.NewWriter(mail.NewWriter(conn))\n\n\tw.PrintfLine(\"* OK IMAP4rev1 Service Ready\")\n\n\tfor {\n\t\tline, err := r.ReadLine()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Received: %s\", line)\n\n\t\tif line == \"QUIT\" {\n\t\t\tw.PrintfLine(\"* BYE\")\n\t\t\treturn\n\t\t}\n\n\t\tw.PrintfLine(\"%s OK\", line)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc RedirectRequest() {\n\thttp.HandleFunc(\"/old\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, \"/new\", http.StatusMovedPermanently)\n\t})\n\n\thttp.HandleFunc(\"/new\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Welcome to the new page!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n"}
{"sample": "func MergeSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\tmid := len(arr) / 2\n\tleft := MergeSort(arr[:mid])\n\tright := MergeSort(arr[mid:])\n\treturn merge(left, right)\n}\n\nfunc merge(left, right []int) []int {\n\tmerged := make([]int, 0, len(left)+len(right))\n\ti, j := 0, 0\n\tfor i < len(left) && j < len(right) {\n\t\tif left[i] <= right[j] {\n\t\t\tmerged = append(merged, left[i])\n\t\t\ti++\n\t\t} else {\n\t\t\tmerged = append(merged, right[j])\n\t\t\tj++\n\t\t}\n\t}\n\tfor ; i < len(left); i++ {\n\t\tmerged = append(merged, left[i])\n\t}\n\tfor ; j < len(right); j++ {\n\t\tmerged = append(merged, right[j])\n\t}\n\treturn merged\n}"}
{"sample": "package luar\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"github.com/yuin/gopher-lua\"\n)\n\nfunc check(L *lua.LState, idx int) (ref reflect.Value, mt *Metatable) {\n\tud := L.CheckUserData(idx)\n\tref = reflect.ValueOf(ud.Value)\n\tmt = &Metatable{LTable: ud.Metatable.(*lua.LTable)}\n\treturn\n}\n\nfunc tostring(L *lua.LState) int {\n\tud := L.CheckUserData(1)\n\tif stringer, ok := ud.Value.(fmt.Stringer); ok {\n\t\tL.Push(lua.LString(stringer.String()))\n\t} else {\n\t\tL.Push(lua.LString(ud.String()))\n\t}\n\treturn 1\n}\n\nfunc getUnexportedName(name string) string {\n\tfirst, n := utf8.DecodeRuneInString(name)\n\tif n == 0 {\n\t\treturn name\n\t}\n\treturn string(unicode.ToLower(first)) + name[n:]\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/joho/godotenv\"\n\t\"github.com/sendgrid/sendgrid-go/v3\"\n\t\"github.com/sendgrid/sendgrid-go/helpers/mail\"\n)\n\nfunc sendEmail(toEmail, subjectText, emailContent string) error {\n\n\terr := godotenv.Load(\".env\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file: %v\", err)\n\t}\n\n\tapiKey, found := os.LookupEnv(\"SENDGRID_API_KEY\")\n\tif !found {\n\t\tlog.Fatalf(\"SENDGRID_API_KEY not set\")\n\t}\n\n\tfrom := mail.NewEmail(\"Sender Name\", \"sender@example.com\")\n\tsubject := subjectText\n\tto := mail.NewEmail(\"Recipient Name\", toEmail)\n\tplainTextContent := emailContent\n\tmessage := mail.NewSingleEmail(from, subject, to, plainTextContent, \"\")\n\tclient := sendgrid.NewSendClient(apiKey)\n\tresponse, err := client.Send(message)\n\tif err != nil {\n\t\tlog.Printf(\"Error sending email: %v \", response.StatusCode)\n\t\treturn err\n\t}\n\n\tfmt.Println(response.StatusCode)\n\treturn nil\n}\n\n\nfunc main() {\n\terr := sendEmail(\"jane@example.com\", \"Example Subject\", \"This is a test email.\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc ReadResponseBody() {\n\tresponse, _ := http.Get(\"https://example.com\")\n\tdefer response.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(response.Body)\n\tfmt.Println(string(body))\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// GenerateRandomNumber generates a random number within the specified range.\nfunc GenerateRandomNumber(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", id, j)\n\t\ttime.Sleep(time.Duration(rand.Intn(5)) * time.Second)\n\t\tfmt.Printf(\"Worker %d finished job %d\\n\", id, j)\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tvar wg sync.WaitGroup\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo worker(i, jobs, results, &wg)\n\t}\n\n\tfor j := 1; j <= 9; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n\n\tfor a := 1; a <= 9; a++ {\n\t\t<-results\n\t}\n}"}
{"sample": "func main() {\n\tresp, err := http.Get(\"https://api.example.com/data\")\n\tif err != nil {\n\t\tfmt.Println(\"Error making HTTP request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "package main\n\n// Walking a directory\nfunc main() {\n\twalker := func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(path)\n\t\treturn nil\n\t}\n\tfilepath.Walk(\".\", walker)\n}\n"}
{"sample": "file, err := os.Open(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\ncontent, err := ioutil.ReadAll(file)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\tfmt.Println(\"Starting work\")\n\n\tdone := make(chan bool)\n\tgo func() {\n\t\tfmt.Println(\"Working...\")\n\t\ttime.Sleep(3 * time.Second)\n\t\tdone <- true\n\t}()\n\n\t<-done\n\tfmt.Printf(\"Work took %v\\n\", time.Since(start))\n}"}
{"sample": "package tcp_test\n\nimport (\n\t\"net\"\n\t\"testing\"\n)\n\nfunc TestTCPServer(t *testing.T) {\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tt.Errorf(\"Error listening: %v\", err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error accepting connection: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\tbuf := make([]byte, 1024)\n\tfor {\n\t\tn, err := conn.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tdata := buf[:n]\n\t\tresponse := processData(data)\n\n\t\tconn.Write([]byte(response))\n\t}\n}\n\nfunc processData(data []byte) string {\n\t// process the data and return a response\n\treturn \"Processed data\"\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--file\", argparse.String, \"data.txt\", \"Input file\")\nparser.AddArgument(\"--threshold\", argparse.Float, 0.5, \"Threshold value\")\n"}
{"sample": "// Enable Gzip compression for the server\nfunc EnableGzipCompression(handler http.Handler) http.Handler {\n\treturn handlers.CompressHandler(handler)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/theskch/binary-chop/common\"\n\t\"github.com/theskch/binary-chop/concurent\"\n\t\"github.com/theskch/binary-chop/loop\"\n\t\"github.com/theskch/binary-chop/recursive\"\n\n\t\"github.com/jedib0t/go-pretty/v6/table\"\n)\n\nfunc main() {\n\tskip := map[int]bool{4: true, 11: true}\n\tarray := common.GenerateRandomArray(10, skip)\n\n\tbenchmark(\"Test case 1: array of 10 elements, element present in array\", array[5], array)\n\tfmt.Println()\n\tbenchmark(\"Test case 2: array of 10 elements, element not present in array\", 4, array)\n\n\tskip = map[int]bool{980: true, 112: true, 1504: true}\n\tarray = common.GenerateRandomArray(1000, skip)\n\tfmt.Println()\n\tbenchmark(\"Test case 3: array of 1000 elements, element not present in array\", array[867], array)\n\tfmt.Println()\n\tbenchmark(\"Test case 4: array of 1000 elements, element not present in array\", 1504, array)\n\n\tskip = map[int]bool{8: true, 99000: true, 45890: true}\n\tarray = common.GenerateRandomArray(100000, skip)\n\tfmt.Println()\n\tbenchmark(\"Test case 5: array of 100000 elements, element not present in array\", array[57020], array)\n\tfmt.Println()\n\tbenchmark(\"Test case 6: array of 100000 elements, element not present in array\", 99000, array)\n\n\tskip = map[int]bool{68: true, 789503: true, 678004: true}\n\tarray = common.GenerateRandomArray(10000000, skip)\n\tfmt.Println()\n\tbenchmark(\"Test case 7: array of 10000000 elements, element not present in array\", array[587], array)\n\tfmt.Println()\n\tbenchmark(\"Test case 8: array of 10000000 elements, element not present in array\", 68, array)\n}\n\nfunc executeAndTrack(searcher common.BinarySearcher, num int, testSet []int) (time.Duration, int) {\n\tstart := time.Now()\n\tindex, _ := searcher.Search(num, testSet)\n\telapsed := time.Since(start)\n\treturn elapsed, index\n}\n\nfunc benchmark(name string, num int, array []int) {\n\tgbbs := concurent.GreedyBoundsBinarySearcher{}\n\tlbbs := loop.BoundsBinarySearcher{}\n\tlcbs := loop.ChopBinarySearcher{}\n\trbbs := recursive.BoundsBinarySearcher{}\n\trcbs := recursive.ChopBinarySearcher{}\n\n\tt := table.NewWriter()\n\tt.SetOutputMirror(os.Stdout)\n\tt.SetTitle(name)\n\tt.SetAllowedRowLength(500)\n\tt.AppendHeader(table.Row{\"#\", \"Name\t\t\t\", \"Index\t\t\t\", \"Execution Time\t\t\t\"})\n\n\tduration, index := executeAndTrack(gbbs, num, array)\n\tt.AppendRow(table.Row{\"1\", \"Greedy Bounds\", index, duration})\n\tt.AppendSeparator()\n\n\tduration, index = executeAndTrack(lbbs, num, array)\n\tt.AppendRow(table.Row{\"2\", \"Loop Bounds\", index, duration})\n\tt.AppendSeparator()\n\n\tduration, index = executeAndTrack(lcbs, num, array)\n\tt.AppendRow(table.Row{\"3\", \"Loop Chop\", index, duration})\n\tt.AppendSeparator()\n\n\tduration, index = executeAndTrack(rbbs, num, array)\n\tt.AppendRow(table.Row{\"4\", \"Recursive Bounds\", index, duration})\n\tt.AppendSeparator()\n\n\tduration, index = executeAndTrack(rcbs, num, array)\n\tt.AppendRow(table.Row{\"5\", \"Recursive Chop\", index, duration})\n\tt.AppendSeparator()\n\tt.Render()\n}\n"}
{"sample": "func QuickSort(arr []int, low, high int) {\n\tif low < high {\n\t\tpivot := partition(arr, low, high)\n\t\tQuickSort(arr, low, pivot-1)\n\t\tQuickSort(arr, pivot+1, high)\n\t}\n}\n\nfunc partition(arr []int, low, high int) int {\n\tpivot := arr[high]\n\ti := low - 1\n\tfor j := low; j <= high-1; j++ {\n\t\tif arr[j] < pivot {\n\t\t\ti++\n\t\t\tarr[i], arr[j] = arr[j], arr[i]\n\t\t}\n\t}\n\tarr[i+1], arr[high] = arr[high], arr[i+1]\n\treturn i + 1\n}"}
{"sample": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Item struct {\n\tName     string\n\tPrice    float64\n\tQuantity int\n}\n\ntype Order struct {\n\tItems      []Item\n\tTotalPrice float64\n}\n\nfunc (o *Order) AddItem(item Item) {\n\to.Items = append(o.Items, item)\n\to.TotalPrice += item.Price * float64(item.Quantity)\n}\n\nfunc (o *Order) RemoveItem(name string) error {\n\tfor i, item := range o.Items {\n\t\tif item.Name == name {\n\t\t\to.TotalPrice -= item.Price * float64(item.Quantity)\n\t\t\to.Items = append(o.Items[:i], o.Items[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"item not found in order\")\n}\n\nfunc main() {\n\torder := Order{}\n\n\titem1 := Item{Name: \"Shoes\", Price: 50.0, Quantity: 1}\n\torder.AddItem(item1)\n\n\titem2 := Item{Name: \"Shirt\", Price: 30.0, Quantity: 2}\n\torder.AddItem(item2)\n\n\tfmt.Printf(\"Order total price: $%.2f\\n\", order.TotalPrice)\n\n\tif err := order.RemoveItem(\"Shoes\"); err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Printf(\"Order total price after removing Shoes: $%.2f\\n\", order.TotalPrice)\n}"}
{"sample": "package main\n\n// Read from a gzip file\nfunc main() {\n\tfile, err := os.Open(\"file.gz\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\tgzReader, err := gzip.NewReader(file)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer gzReader.Close()\n\tcontent, err := ioutil.ReadAll(gzReader)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(content))\n}\n"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfmt.Print(\"Enter your name: \")\n\tscanner.Scan()\n\tname := scanner.Text()\n\n\tfmt.Print(\"Enter your age: \")\n\tscanner.Scan()\n\tage := scanner.Text()\n\n\tfmt.Println(\"Your name is\", name)\n\tfmt.Println(\"Your age is\", age)\n}"}
{"sample": "func scanRows(rows *sql.Rows, dest ...interface{}) error {\n\terr := rows.Scan(dest...)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"}
{"sample": "package checksumgen\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc GenerateMD5Checksum(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := md5.New()\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tchecksum := hex.EncodeToString(hash.Sum(nil))\n\treturn checksum, nil\n}\n\nfunc GenerateSHA256Checksum(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := sha256.New()\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tchecksum := hex.EncodeToString(hash.Sum(nil))\n\treturn checksum, nil\n}\n\nfunc ValidateChecksum(filePath, checksum string) (bool, error) {\n\tfileChecksum, err := GenerateMD5Checksum(filePath)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn fileChecksum == checksum, nil\n}\n\nfunc main() {\n\tchecksum, err := GenerateMD5Checksum(\"file.txt\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Println(checksum)\n\n\tvalid, err := ValidateChecksum(\"file.txt\", checksum)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Println(valid)\n}"}
{"sample": "// HTTPServer is a simple HTTP server.\ntype HTTPServer struct {\n\tsrv *http.Server\n}\n\n// NewHTTPServer creates a new HTTPServer.\nfunc NewHTTPServer(addr string, handler http.Handler) *HTTPServer {\n\tsrv := &http.Server{\n\t\tAddr:    addr,\n\t\tHandler: handler,\n\t}\n\treturn &HTTPServer{srv}\n}\n\n// Start starts the HTTPServer.\nfunc (h *HTTPServer) Start() error {\n\treturn h.srv.ListenAndServe()\n}\n\n// Stop stops the HTTPServer.\nfunc (h *HTTPServer) Stop(ctx context.Context) error {\n\treturn h.srv.Shutdown(ctx)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tSwapTwoNumbers(5, 10)\n}\n\n// Function to swap two numbers\nfunc SwapTwoNumbers(a, b int) {\n\tfmt.Printf(\"Before swapping: a = %d, b = %d\\n\", a, b)\n\ta, b = b, a\n\tfmt.Printf(\"After swapping: a = %d, b = %d\\n\", a, b)\n}"}
{"sample": "// LogErrorWithTrace logs the error with a trace\nfunc LogErrorWithTrace(err error) {\n\tif err != nil {\n\t\tlog.Printf(\"%v\n%+v\", err, err)\n\t}\n}\n"}
{"sample": "func scanRow(row *sql.Row, dest ...interface{}) error {\n\terr := row.Scan(dest...)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn ErrNoRows\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n"}
{"sample": "numbers := []int{3, 1, 4, 1, 5, 9}\nsort.Ints(numbers)\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintNumberInBinary(10)\n}\n\n// Function to print the binary representation of a number\nfunc PrintNumberInBinary(n int) {\n\tfmt.Printf(\"%b\\n\", n)\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--mode\", argparse.String, \"default\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\n"}
{"sample": "err := doSomethingElse()\nif err != nil {\n\tlog.Fatalf(\"Error: %v\", err)\n}\n"}
{"sample": "// Check if a string starts with a specific prefix\nfunc StartsWith(str, prefix string) bool {\n\treturn strings.HasPrefix(str, prefix)\n}\n"}
{"sample": "package uuidgen\n\nimport (\n\t\"fmt\"\n\t\"github.com/google/uuid\"\n)\n\nfunc GenerateUUID() string {\n\tuuid := uuid.New()\n\treturn fmt.Sprintf(\"%s\", uuid)\n}\n\nfunc GenerateUUIDs(n int) []string {\n\tuuids := make([]string, n)\n\tfor i := 0; i < n; i++ {\n\t\tuuids[i] = GenerateUUID()\n\t}\n\treturn uuids\n}"}
{"sample": "package hashmap\n\ntype HashMap struct {\n\tdata map[string]interface{}\n}\n\nfunc NewHashMap() *HashMap {\n\treturn &HashMap{\n\t\tdata: make(map[string]interface{}),\n\t}\n}\n\nfunc (h *HashMap) Set(key string, value interface{}) {\n\th.data[key] = value\n}\n\nfunc (h *HashMap) Get(key string) (interface{}, bool) {\n\tvalue, ok := h.data[key]\n\treturn value, ok\n}\n\nfunc (h *HashMap) Delete(key string) {\n\tdelete(h.data, key)\n}\n\nfunc (h *HashMap) Keys() []string {\n\tkeys := make([]string, 0, len(h.data))\n\tfor key := range h.data {\n\t\tkeys = append(keys, key)\n\t}\n\treturn keys\n}\n\nfunc (h *HashMap) Values() []interface{} {\n\tvalues := make([]interface{}, 0, len(h.data))\n\tfor _, value := range h.data {\n\t\tvalues = append(values, value)\n\t}\n\treturn values\n}"}
{"sample": "package bugservice\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype Bug struct {\n\tID          string    `json:\"id\"`\n\tTitle       string    `json:\"title\"`\n\tDescription string    `json:\"description\"`\n\tCreatedAt   time.Time `json:\"created_at\"`\n}\n\nvar bugs []Bug\n\nfunc createBug(w http.ResponseWriter, r *http.Request) {\n\tvar bug Bug\n\terr := json.NewDecoder(r.Body).Decode(&bug)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tbug.ID = fmt.Sprintf(\"%d\", time.Now().UnixNano())\n\tbug.CreatedAt = time.Now()\n\n\tbugs = append(bugs, bug)\n\n\tw.WriteHeader(http.StatusCreated)\n\tjson.NewEncoder(w).Encode(bug)\n}\n\nfunc getBug(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\n\tfor _, item := range bugs {\n\t\tif item.ID == params[\"id\"] {\n\t\t\tjson.NewEncoder(w).Encode(item)\n\t\t\treturn\n\t\t}\n\t}\n\n\tw.WriteHeader(http.StatusNotFound)\n}\n\nfunc getAllBugs(w http.ResponseWriter, r *http.Request) {\n\tjson.NewEncoder(w).Encode(bugs)\n}\n\nfunc updateBug(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\n\tfor index, item := range bugs {\n\t\tif item.ID == params[\"id\"] {\n\t\t\tbugs = append(bugs[:index], bugs[index+1:]...)\n\t\t\tvar bug Bug\n\t\t\terr := json.NewDecoder(r.Body).Decode(&bug)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tbug.ID = params[\"id\"]\n\t\t\tbug.CreatedAt = item.CreatedAt\n\n\t\t\tbugs = append(bugs, bug)\n\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tjson.NewEncoder(w).Encode(bug)\n\t\t\treturn\n\t\t}\n\t}\n\n\tw.WriteHeader(http.StatusNotFound)\n}\n\nfunc deleteBug(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\n\tfor index, item := range bugs {\n\t\tif item.ID == params[\"id\"] {\n\t\t\tbugs = append(bugs[:index], bugs[index+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(\"/bugs\", createBug).Methods(\"POST\")\n\trouter.HandleFunc(\"/bugs\", getAllBugs).Methods(\"GET\")\n\trouter.HandleFunc(\"/bugs/{id}\", getBug).Methods(\"GET\")\n\trouter.HandleFunc(\"/bugs/{id}\", updateBug).Methods(\"PUT\")\n\trouter.HandleFunc(\"/bugs/{id}\", deleteBug).Methods(\"DELETE\")\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", router))\n}"}
{"sample": "package docsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"google.golang.org/api/docs/v1\"\n\t\"google.golang.org/api/option\"\n)\n\ntype DocsClient struct {\n\tservice *docs.Service\n}\n\nfunc NewDocsClient() (*DocsClient, error) {\n\tctx := context.Background()\n\n\tcreds, err := option.CredentialsFromJSON(ctx, []byte(credentials))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get credentials: %v\", err)\n\t}\n\n\tservice, err := docs.NewService(ctx, option.WithCredentials(creds))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create docs service: %v\", err)\n\t}\n\n\treturn &DocsClient{\n\t\tservice: service,\n\t}, nil\n}\n\nfunc (c *DocsClient) GetDocument(documentID string) (*docs.Document, error) {\n\tdoc, err := c.service.Documents.Get(documentID).Do()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get document: %v\", err)\n\t}\n\n\treturn doc, nil\n}\n\nfunc (c *DocsClient) UpdateDocument(documentID string, requests []*docs.Request) error {\n\t_, err := c.service.Documents.BatchUpdate(documentID, &docs.BatchUpdateDocumentRequest{\n\t\tRequests: requests,\n\t}).Do()\n\n\tif err != nil {\n\t\tlog.Printf(\"failed to update document: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nconst credentials = `{\n\t\"web\": {\n\t\t\"client_id\": \"YOUR_CLIENT_ID\",\n\t\t\"client_secret\": \"YOUR_CLIENT_SECRET\",\n\t\t\"redirect_uris\": [],\n\t\t\"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",\n\t\t\"token_uri\": \"https://accounts.google.com/o/oauth2/token\"\n\t}\n}`"}
{"sample": "http.HandleFunc(\"/messages\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle messages endpoint\n\tswitch r.Method {\n\tcase \"GET\":\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get messages\")\n\tcase \"POST\":\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create message\")\n\t}\n})\n"}
{"sample": "func scanRows(rows *sql.Rows, dest ...interface{}) error {\n\terr := rows.Scan(dest...)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"}
{"sample": "package sitemapfetch\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype UrlSet struct {\n\tUrls []Url `xml:\"url\"`\n}\n\ntype Url struct {\n\tLoc string `xml:\"loc\"`\n}\n\nfunc FetchSitemap(url string) ([]string, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tvar set UrlSet\n\tif err := xml.NewDecoder(resp.Body).Decode(&set); err != nil {\n\t\treturn nil, err\n\t}\n\n\turls := []string{}\n\tfor _, s := range set.Urls {\n\t\turls = append(urls, strings.TrimSpace(s.Loc))\n\t}\n\n\treturn urls, nil\n}\n\nfunc main() {\n\turls, err := FetchSitemap(\"https://example.com/sitemap.xml\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfor _, url := range urls {\n\t\tfmt.Println(url)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/soheilhy/cmux\"\n)\n\nfunc UseCMux() {\n\tlistener, _ := net.Listen(\"tcp\", \":8080\")\n\n\tm := cmux.New(listener)\n\n\thttpL := m.Match(cmux.HTTP1Fast())\n\thttpS := m.Match(cmux.Any())\n\n\thttpHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, CMux!\")\n\t})\n\n\tgo http.Serve(httpL, httpHandler)\n\tgo http.ServeTLS(httpS, httpHandler, \"cert.pem\", \"key.pem\")\n\n\tm.Serve()\n}\n"}
{"sample": "package etcd\n\nimport (\n\t\"testing\"\n\n\t\"github.com/sensu/sensu-go/backend/store\"\n)\n\nfunc Test_checkIfMatch(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\theader string\n\t\tetag   string\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname: \"empty header should return true\",\n\t\t\tetag: `\"12345\"`,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty etag should return false\",\n\t\t\theader: `\"\"`,\n\t\t\tetag:   `\"12345\"`,\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"the asterisk is a special value that represents any resource\",\n\t\t\theader: \"*\",\n\t\t\tetag:   `\"12345\"`,\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"matching etag\",\n\t\t\theader: `\"12345\"`,\n\t\t\tetag:   `\"12345\"`,\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"multiple etags can be passed in the header\",\n\t\t\theader: `\"000\", \"12345\"`,\n\t\t\tetag:   `\"12345\"`,\n\t\t\twant:   true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := store.CheckIfMatch(tt.header, tt.etag); got != tt.want {\n\t\t\t\tt.Errorf(\"checkIfMatch() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_checkIfNoneMatch(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\theader string\n\t\tetag   string\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname: \"empty header should return true\",\n\t\t\tetag: `\"12345\"`,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty etag should return true\",\n\t\t\theader: `\"\"`,\n\t\t\tetag:   `\"12345\"`,\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"the asterisk is a special value that represents any resource\",\n\t\t\theader: \"*\",\n\t\t\tetag:   `\"12345\"`,\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"matching etag\",\n\t\t\theader: `\"12345\"`,\n\t\t\tetag:   `\"12345\"`,\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"multiple etags can be passed in the header\",\n\t\t\theader: `\"000\", \"12345\"`,\n\t\t\tetag:   `\"12345\"`,\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"the W/ prefix is handled\",\n\t\t\theader: `W/\"12345\"`,\n\t\t\tetag:   `\"12345\"`,\n\t\t\twant:   false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := store.CheckIfNoneMatch(tt.header, tt.etag); got != tt.want {\n\t\t\t\tt.Errorf(\"checkIfNoneMatch() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"}
{"sample": "type Logger struct {\n\tmu    sync.Mutex\n\tLevel int\n}\n\nfunc (l *Logger) Log(level int, msg string) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tif level >= l.Level {\n\t\tfmt.Println(msg)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// CheckPrime checks if a given number is prime and returns true if it is.\nfunc CheckPrime(num int) bool {\n\tif num < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= num; i++ {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"sample": "// Enable CORS (Cross-Origin Resource Sharing) for the response\nfunc EnableCORS(response http.ResponseWriter) {\n\tresponse.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tresponse.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n\tresponse.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type\")\n}\n"}
{"sample": "func main() {\n\tnum := 4.5\n\n\tfmt.Println(\"Floor:\", math.Floor(num))\n\tfmt.Println(\"Ceil:\", math.Ceil(num))\n\tfmt.Println(\"Round:\", math.Round(num))\n\tfmt.Println(\"Sqrt:\", math.Sqrt(num))\n}"}
{"sample": "func main() {\n\tfiles, err := ioutil.ReadDir(\".\")\n\tif err != nil {\n\t\tfmt.Println(\"Error reading directory:\", err)\n\t\treturn\n\t}\n\n\tfor _, file := range files {\n\t\tfmt.Println(file.Name())\n\t}\n}"}
{"sample": "func main() {\n\tto := []string{\"recipient@example.com\"}\n\tsubject := \"Hello\"\n\tbody := \"Hello, World!\"\n\n\tmsg := fmt.Sprintf(\"To: %s\\r\\nSubject: %s\\r\\n\\r\\n%s\", strings.Join(to, \", \"), subject, body)\n\n\terr := smtp.SendMail(\"smtp.example.com:587\", smtp.PlainAuth(\"\", \"sender@example.com\", \"password\", \"smtp.example.com\"), \"sender@example.com\", to, []byte(msg))\n\tif err != nil {\n\t\tfmt.Println(\"Error sending email:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Email sent\")\n}"}
{"sample": "package transactions\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nvar (\n\tErrInsufficientFunds = errors.New(\"insufficient funds\")\n)\n\ntype Client struct {\n\tredisClient *redis.Client\n}\n\nfunc New(redisClient *redis.Client) *Client {\n\treturn &Client{redisClient: redisClient}\n}\n\nfunc (c *Client) Transfer(from, to string, amount float64) error {\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\ttxf := func(tx *redis.Tx) error {\n\t\tbalance, err := tx.Get(ctx, from).Float64()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif balance < amount {\n\t\t\treturn ErrInsufficientFunds\n\t\t}\n\n\t\terr = tx.Watch(ctx, from)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tm := redis.NewStringStringMapCmd(ctx, \"MULTI\")\n\t\tm.IncrByFloat(from, -amount)\n\t\tm.IncrByFloat(to, amount)\n\n\t\t_, err = tx.Exec(ctx, func() error {\n\t\t\t_, err := m.Exec(ctx)\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn nil\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}\n\n\terr := c.redisClient.Watch(ctx, txf, from)\n\n\tif err == redis.TxFailedErr {\n\t\treturn ErrInsufficientFunds\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Successfully transferred %.2f from %s to %s\\n\", amount, from, to)\n\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(\"Starting the program...\")\n\n\t// Sleep for 2 seconds\n\ttime.Sleep(2 * time.Second)\n\n\tfmt.Println(\"Program completed.\")\n}"}
{"sample": "var rwMutex sync.RWMutex\nrwMutex.Lock()\n// do something critical\nrwMutex.Unlock()\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Power raises a number to the specified exponent and returns the result.\nfunc Power(base, exponent float64) float64 {\n\treturn math.Pow(base, exponent)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Factorial calculates the factorial of a given non-negative integer.\nfunc Factorial(n int) int {\n\tif n <= 1 {\n\t\treturn 1\n\t}\n\treturn n * Factorial(n-1)\n}"}
{"sample": "func main() {\n\tr := gin.Default()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(200, \"Hello, World!\")\n\t})\n\n\tr.Run()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tvar x float64 = 64\n\tvar y float64 = math.Sqrt(x)\n\n\tfmt.Printf(\"The square root of %v is %v.\\n\", x, y)\n}"}
{"sample": "// Add a query parameter to the request URL\nfunc AddQueryParameter(request *http.Request, key, value string) {\n\tquery := request.URL.Query()\n\tquery.Add(key, value)\n\trequest.URL.RawQuery = query.Encode()\n}\n"}
{"sample": "http.HandleFunc(\"/api\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle API endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"API response\")\n\t}\n})\n"}
{"sample": "// RecoverAndHandleError recovers from a panic and handles the error\nfunc RecoverAndHandleError(err *error) {\n\tif r := recover(); r != nil {\n\t\tif recErr, ok := r.(error); ok {\n\t\t\t*err = recErr\n\t\t\tlog.Println(\"Recovered from panic with error:\", (*err).Error())\n\t\t}\n\t}\n}\n"}
{"sample": "// Using the sort package\n\nnumbers := []int{5, 2, 6, 3, 1}\nsort.Ints(numbers)\n"}
{"sample": "func SetCookie(w http.ResponseWriter, name, value string, maxAge int) {\n\thttp.SetCookie(w, &http.Cookie{\n\t\tName:   name,\n\t\tValue:  value,\n\t\tMaxAge: maxAge,\n\t})\n}\n\nfunc GetCookie(r *http.Request, name string) (*http.Cookie, error) {\n\treturn r.Cookie(name)\n}"}
{"sample": "type Stack struct {\n\titems []interface{}\n}\n\nfunc (s *Stack) Push(item interface{}) {\n\ts.items = append(s.items, item)\n}\n\nfunc (s *Stack) Pop() interface{} {\n\tlastIndex := len(s.items) - 1\n\titem := s.items[lastIndex]\n\ts.items = s.items[:lastIndex]\n\treturn item\n}"}
{"sample": "file, err := os.Open(\"hello.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\ntext, err := ioutil.ReadAll(file)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype Product struct {\n\tID    string `json:\"id,omitempty\"`\n\tName  string `json:\"name,omitempty\"`\n\tPrice float64 `json:\"price,omitempty\"`\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/products\", GetProducts).Methods(\"GET\")\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc GetProducts(w http.ResponseWriter, r *http.Request) {\n\tproducts := []Product{{ID: \"1\", Name: \"Product1\", Price: 19.99}}\n\tjson.NewEncoder(w).Encode(products)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\n// homePage is a handler function for the home page\nfunc homePage(w http.ResponseWriter, r *http.Request){\n\tfmt.Fprintf(w, \"Welcome to the HomePage!\")\n\tfmt.Println(\"Endpoint Hit: homePage\")\n}\n\n// aboutPage is a handler function for the about page\nfunc aboutPage(w http.ResponseWriter, r *http.Request){\n\tfmt.Fprintf(w, \"Welcome to the AboutPage!\")\n\tfmt.Println(\"Endpoint Hit: aboutPage\")\n}\n\n// handleRequests binds URLs to handler functions\nfunc handleRequests() {\n\thttp.HandleFunc(\"/\", homePage)\n\thttp.HandleFunc(\"/about\", aboutPage)\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc main() {\n\thandleRequests()\n}"}
{"sample": "grades := map[string]int{\"Math\": 90, \"Science\": 85}\nfor subject, grade := range grades {\n\tfmt.Printf(\"Grade in %s: %d\\n\", subject, grade)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Person struct {\n\tName string `json:\"name\"`\n\tAge  int    `json:\"age\"`\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/person\", getPerson)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc getPerson(w http.ResponseWriter, r *http.Request) {\n\n\tperson := Person{\n\t\tName: \"Alice\",\n\t\tAge:  30,\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif err := json.NewEncoder(w).Encode(person); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\t\n\tfmt.Println(\"Person sent: \", person)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/file\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfile, err := os.Open(\"file.txt\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error opening file:\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\t_, err = io.Copy(w, file)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error copying file contents to response writer:\", err)\n\t\t\treturn\n\t\t}\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "dir := filepath.Dir(absPath)\nfmt.Println(\"Directory:\", dir)\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(ConcatenateStrings(\"Hello, \", \"World!\"))\n}\n\n// Function to concatenate two strings\nfunc ConcatenateStrings(s1, s2 string) string {\n\treturn s1 + s2\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.OpenFile(\"file.txt\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tcontent := []byte(\"Hello, World!\")\n\t_, err = file.Write(content)\n\tif err != nil {\n\t\tfmt.Println(\"Error writing to file:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Data written to file\")\n}"}
{"sample": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype User struct {\n\tID        int\n\tName      string\n\tCreatedAt time.Time\n}\n\ntype UserRepository interface {\n\tCreate(user *User) error\n\tGetByID(id int) (*User, error)\n}\n\ntype InMemoryUserRepository struct {\n\tusers []*User\n}\n\nfunc NewInMemoryUserRepository() *InMemoryUserRepository {\n\treturn &InMemoryUserRepository{\n\t\tusers: make([]*User, 0),\n\t}\n}\n\nfunc (r *InMemoryUserRepository) Create(user *User) error {\n\tif user.ID == 0 || user.Name == \"\" {\n\t\treturn errors.New(\"user ID and name are required\")\n\t}\n\tuser.CreatedAt = time.Now()\n\tr.users = append(r.users, user)\n\treturn nil\n}\n\nfunc (r *InMemoryUserRepository) GetByID(id int) (*User, error) {\n\tfor _, user := range r.users {\n\t\tif user.ID == id {\n\t\t\treturn user, nil\n\t\t}\n\t}\n\treturn nil, errors.New(\"user not found\")\n}\n\nfunc main() {\n\trepo := NewInMemoryUserRepository()\n\n\tuser1 := &User{ID: 1, Name: \"Alice\"}\n\terr1 := repo.Create(user1)\n\tif err1 != nil {\n\t\tfmt.Println(err1)\n\t\treturn\n\t}\n\n\tuser2, err2 := repo.GetByID(1)\n\tif err2 != nil {\n\t\tfmt.Println(err2)\n\t\treturn\n\t}\n\tfmt.Printf(\"User: ID=%d, Name=%s, CreatedAt=%v\\n\", user2.ID, user2.Name, user2.CreatedAt)\n}"}
{"sample": "// Square calculates the square of a number.\nfunc Square(n int) int {\n\treturn n * n\n}\n\n// Cube calculates the cube of a number.\nfunc Cube(n int) int {\n\treturn n * n * n\n}"}
{"sample": "person := struct {\n\tName string `json:\"name\"`\n}{\"John\"}\njsonData, err := json.Marshal(person)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintPalindromeCheck(\"madam\")\n}\n\n// Function to check if a string is palindrome or not\nfunc PrintPalindromeCheck(s string) {\n\tfmt.Println(s == ReverseString(s))\n}\n\n// Helper function to reverse a string\nfunc ReverseString(s string) string {\n\tchars := []rune(s)\n\tfor i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {\n\t\tchars[i], chars[j] = chars[j], chars[i]\n\t}\n\treturn string(chars)\n}"}
{"sample": "// Serve an HTTP handler with automatic TLS certificate generation and renewal\nfunc ServeWithAutoTLS(server *http.Server, domain, cacheDir string) error {\n\tautoManager := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(domain),\n\t\tCache:      autocert.DirCache(cacheDir),\n\t}\n\n\tserver.TLSConfig = &tls.Config{\n\t\tGetCertificate: autoManager.GetCertificate,\n\t}\n\n\tsrv := &http.Server{\n\t\tAddr:      \":443\",\n\t\tHandler:   server.Handler,\n\t\tTLSConfig: server.TLSConfig,\n\t}\n\n\treturn srv.ListenAndServeTLS(\"\", \"\")\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tstr := \"A quick brown fox jumps over the lazy dog\"\n\n\tre, err := regexp.Compile(`[a-z]+`)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmatches := re.FindAllString(str, -1)\n\n\tfmt.Println(matches)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Sum calculates the sum of two integers and returns the result.\nfunc Sum(a, b int) int {\n\treturn a + b\n}"}
{"sample": "package linkedlist\n\ntype Node struct {\n\tValue interface{}\n\tNext  *Node\n}\n\ntype LinkedList struct {\n\tHead *Node\n\tTail *Node\n\tSize int\n}\n\nfunc (l *LinkedList) Append(value interface{}) {\n\tnode := &Node{Value: value}\n\n\tif l.Head == nil {\n\t\tl.Head = node\n\t\tl.Tail = node\n\t} else {\n\t\tl.Tail.Next = node\n\t\tl.Tail = node\n\t}\n\n\tl.Size++\n}\n\nfunc (l *LinkedList) Remove(value interface{}) {\n\tif l.Head == nil {\n\t\treturn\n\t}\n\n\tif l.Head.Value == value {\n\t\tl.Head = l.Head.Next\n\t\tl.Size--\n\t\treturn\n\t}\n\n\tprev := l.Head\n\tcurr := l.Head.Next\n\n\tfor curr != nil {\n\t\tif curr.Value == value {\n\t\t\tprev.Next = curr.Next\n\t\t\tif curr.Next == nil {\n\t\t\t\tl.Tail = prev\n\t\t\t}\n\t\t\tl.Size--\n\t\t\treturn\n\t\t}\n\t\tprev = curr\n\t\tcurr = curr.Next\n\t}\n}\n\nfunc (l *LinkedList) Search(value interface{}) bool {\n\tcurr := l.Head\n\n\tfor curr != nil {\n\t\tif curr.Value == value {\n\t\t\treturn true\n\t\t}\n\t\tcurr = curr.Next\n\t}\n\n\treturn false\n}"}
{"sample": "type Configuration struct {\n\tName   string `json:\"name\"`\n\tServer string `json:\"server\"`\n}\n\nfunc main() {\n\tconfig := Configuration{}\n\n\tfile, err := os.Open(\"config.json\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening config file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tdecoder := json.NewDecoder(file)\n\terr = decoder.Decode(&config)\n\tif err != nil {\n\t\tfmt.Println(\"Error decoding JSON:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Config:\", config)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tPrintPrimeNumbers(20)\n}\n\nfunc PrintPrimeNumbers(n int) {\n\tnext:\n\tfor i := 2; i <= n; i++ {\n\t\tfor j := 2; j < i; j++ {\n\t\t\tif i%j == 0 {\n\t\t\t\tcontinue next\n\t\t\t}\n\t\t}\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--mode\", argparse.String, \"default\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\nparser.AddArgument(\"--debug\", argparse.Bool, false, \"Enable debug mode\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 4, \"Number of threads\")\nparser.AddArgument(\"--max-iter\", argparse.Int, 1000, \"Maximum number of iterations\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--threshold\", argparse.Float, 0.5, \"Threshold value\")\n"}
{"sample": "package logparser\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n)\n\ntype LogEntry struct {\n\tIP         string\n\tUserID     string\n\tUsername   string\n\tTimestamp  string\n\tMethod     string\n\tEndpoint   string\n\tHTTPStatus int\n}\n\nfunc ParseLog(filePath string) ([]LogEntry, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tvar logEntries []LogEntry\n\treader := bufio.NewReader(file)\n\tfor {\n\t\tline, err := reader.ReadString('\\n')\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tlogEntry, err := parseLine(line)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tlogEntries = append(logEntries, logEntry)\n\t}\n\n\treturn logEntries, nil\n}\n\nfunc parseLine(line string) (LogEntry, error) {\n\tvar logEntry LogEntry\n\n\tre := regexp.MustCompile(`^([\\d\\.]+) (\\S+) (\\S+) \\[([\\w:/]+\\s[+\\-]\\d{4})\\] \"(\\S+) (\\S+) HTTP/\\d\\.\\d\" (\\d+)`)\n\tmatches := re.FindStringSubmatch(line)\n\tif len(matches) < 8 {\n\t\treturn logEntry, nil\n\t}\n\n\tlogEntry.IP = matches[1]\n\tlogEntry.UserID = matches[2]\n\tlogEntry.Username = matches[3]\n\tlogEntry.Timestamp = matches[4]\n\tlogEntry.Method = matches[5]\n\tlogEntry.Endpoint = matches[6]\n\tlogEntry.HTTPStatus = convertToInt(matches[7])\n\n\treturn logEntry, nil\n}\n\nfunc convertToInt(str string) int {\n\tstr = strings.TrimSpace(str)\n\tif str == \"\" {\n\t\treturn 0\n\t}\n\tval := 0\n\tfor _, r := range str {\n\t\tif r < '0' || r > '9' {\n\t\t\treturn 0\n\t\t}\n\t\tval = val*10 + int(r-'0')\n\t}\n\treturn val\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// ConcatenateStrings concatenates multiple strings into a single string.\nfunc ConcatenateStrings(strs ...string) string {\n\treturn strings.Join(strs, \"\")\n}"}
{"sample": "package db\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\ntype RedisClient struct {\n\tClient *redis.Client\n}\n\nfunc NewRedisClient() (*RedisClient, error) {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif err := rdb.Ping(ctx).Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to redis: %v\", err)\n\t}\n\n\treturn &RedisClient{Client: rdb}, nil\n}\n\nfunc (c *RedisClient) SetValue(key string, value interface{}, expiration time.Duration) error {\n\tctx := context.Background()\n\n\tif err := c.Client.Set(ctx, key, value, expiration).Err(); err != nil {\n\t\treturn fmt.Errorf(\"failed to set value in redis: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *RedisClient) GetValue(key string) (string, error) {\n\tctx := context.Background()\n\n\tval, err := c.Client.Get(ctx, key).Result()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to get value from redis: %v\", err)\n\t}\n\n\treturn val, nil\n}"}
{"sample": "func queryRow(stmt *sql.Stmt, args ...interface{}) *sql.Row {\n\trow := stmt.QueryRow(args...)\n\treturn row\n}\n"}
{"sample": "package mysqltool\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc Connect(user, password, dbname string) (*sql.DB, error) {\n\tconnStr := fmt.Sprintf(\"%v:%v@/%v\", user, password, dbname)\n\tdb, err := sql.Open(\"mysql\", connStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := db.Ping(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n\nfunc Query(db *sql.DB, queryString string) (*sql.Rows, error) {\n\trows, err := db.Query(queryString)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn rows, nil\n}\n\nfunc main() {\n\tuser := os.Getenv(\"MYSQL_USER\")\n\tpassword := os.Getenv(\"MYSQL_PASSWORD\")\n\tdbname := os.Getenv(\"MYSQL_DBNAME\")\n\n\tdb, err := Connect(user, password, dbname)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\trows, err := Query(db, \"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\tvar email string\n\t\terr := rows.Scan(&id, &name, &email)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Printf(\"ID: %v, Name: %v, Email: %v\\n\", id, name, email)\n\t}\n}"}
{"sample": "func main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package batchproc\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/sqs\"\n)\n\ntype Job struct {\n\tID       int\n\tPayload  string\n\tPriority int\n}\n\nfunc processJob(job *Job) error {\n\t// Process the job\n\treturn nil\n}\n\nfunc processBatch(jobs []*Job) {\n\tvar wg sync.WaitGroup\n\n\tfor _, job := range jobs {\n\t\twg.Add(1)\n\n\t\tgo func(job *Job) {\n\t\t\tdefer wg.Done()\n\n\t\t\tif err := processJob(job); err != nil {\n\t\t\t\tlog.Printf(\"Error processing job %d: %v\", job.ID, err)\n\t\t\t}\n\t\t}(job)\n\t}\n\n\twg.Wait()\n}\n\nfunc main() {\n\tsess, err := session.NewSession(&aws.Config{\n\t\tRegion: aws.String(\"us-west-2\")},\n\t)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error creating AWS session: %v\", err)\n\t}\n\n\tsqsSvc := sqs.New(sess)\n\n\tqueueURL := \"https://sqs.us-west-2.amazonaws.com/123456789012/my-queue\"\n\n\tfor {\n\t\tresult, err := sqsSvc.ReceiveMessage(&sqs.ReceiveMessageInput{\n\t\t\tQueueUrl:            aws.String(queueURL),\n\t\t\tMaxNumberOfMessages: aws.Int64(10),\n\t\t\tVisibilityTimeout:   aws.Int64(30),\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error receiving message from SQS: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.Messages) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar jobs []*Job\n\n\t\tfor _, msg := range result.Messages {\n\t\t\tvar job Job\n\n\t\t\tif err := json.Unmarshal([]byte(*msg.Body), &job); err != nil {\n\t\t\t\tlog.Printf(\"Error unmarshalling message body: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tjobs = append(jobs, &job)\n\t\t}\n\n\t\tprocessBatch(jobs)\n\n\t\tfor _, msg := range result.Messages {\n\t\t\t_, err := sqsSvc.DeleteMessage(&sqs.DeleteMessageInput{\n\t\t\t\tQueueUrl:      aws.String(queueURL),\n\t\t\t\tReceiptHandle: msg.ReceiptHandle,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error deleting message from SQS: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintFibonacciSeries(10)\n}\n\n// Function to print Fibonacci series\nfunc PrintFibonacciSeries(n int) {\n\ta, b := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Println(a)\n\t\ta, b = b, a+b\n\t}\n}"}
{"sample": "ch := make(chan int)\ngo func() {\n\tch <- 42\n}()\nvalue := <-ch\nfmt.Printf(\"Received value: %d\\n\", value)\n"}
{"sample": "// Sort an array of integers in ascending order\nfunc SortIntegers(arr []int) {\n\tsort.Ints(arr)\n}\n"}
{"sample": "// UnwrapError unwraps an error\nfunc UnwrapError(err error) error {\n\treturn errors.Unwrap(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\tfmt.Println(\"Starting task...\")\n\n\t// Simulating a long-running task\n\ttime.Sleep(5 * time.Second)\n\n\telapsed := time.Since(start)\n\tfmt.Printf(\"Task completed in %s\\n\", elapsed)\n}"}
{"sample": "package restfulapi\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"go-live/functions\"\n\t\"go-live/models\"\n\t\"go-live/orm\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/julienschmidt/httprouter\"\n)\n\n// App Restful API\nfunc CreateAppHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tappname := ps.ByName(\"appname\")\n\tliveon := r.FormValue(\"liveon\")\n\tif liveon == \"\" {\n\t\tliveon = \"on\"\n\t}\n\n\terr := models.CreateApp(&models.App{\n\t\tAppname: appname,\n\t\tLiveon:  liveon,\n\t})\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tSendResponse(w, http.StatusOK, &Response{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"Successfully created this app.\",\n\t})\n}\n\nfunc ListAppsHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tapps, err := models.GetAllApps()\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tSendResponse(w, http.StatusOK, &AppsResponse{\n\t\tCode:    http.StatusOK,\n\t\tData:    apps,\n\t\tMessage: \"Successfully acquired all applications.\",\n\t})\n}\n\nfunc GetAppByIdHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tappid := ps.ByName(\"appid\")\n\tif appid == \"\" {\n\t\tSendErrorResponse(w, http.StatusBadRequest, \"Appid is not be null.\")\n\t\treturn\n\t}\n\n\tid, err := strconv.Atoi(appid)\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tapp, err := models.GetAppById(id)\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tSendResponse(w, http.StatusOK, &AppResponse{\n\t\tCode:    http.StatusOK,\n\t\tData:    app,\n\t\tMessage: \"Successfully obtained the corresponding application.\",\n\t})\n}\n\nfunc DeleteAppByIdHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tappid := ps.ByName(\"appid\")\n\tif appid == \"\" {\n\t\tSendErrorResponse(w, http.StatusBadRequest, \"Appid is not be null.\")\n\t\treturn\n\t}\n\n\tid, err := strconv.Atoi(appid)\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tif !models.CheckAppById(id) {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, \"This app is not in the database.\")\n\t\treturn\n\t}\n\n\tapp, err := models.GetAppById(id)\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\terr = models.DeleteApp(&models.App{Id: id})\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\terr = models.DeleteLive(&models.Live{App: app.Appname})\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tSendResponse(w, http.StatusOK, &Response{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"Successfully deleted this app.\",\n\t})\n}\n\n// Live Restful API\nfunc CreateLiveHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tappname := ps.ByName(\"appname\")\n\tlivename := ps.ByName(\"livename\")\n\n\ttoken := functions.RandomString(6)\n\n\terr := models.CreateLive(&models.Live{\n\t\tApp:      appname,\n\t\tLivename: livename,\n\t\tToken:    token,\n\t})\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tSendResponse(w, http.StatusOK, &LiveTokenResponse{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"Successfully created this live.\",\n\t\tToken:   token,\n\t})\n}\n\nfunc ListLivesHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tlives, err := models.GetAllLives()\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusBadRequest, err.Error())\n\t\treturn\n\t}\n\n\tSendResponse(w, http.StatusOK, &LivesResponse{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"Successfully acquired all lives.\",\n\t\tData:    lives,\n\t})\n}\n\nfunc ListLivesByAppnameHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tappname := ps.ByName(\"appname\")\n\n\tlives, err := models.GetAllLivesByappname(appname)\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusBadRequest, err.Error())\n\t\treturn\n\t}\n\n\tSendResponse(w, http.StatusOK, &LivesResponse{\n\t\tCode:    http.StatusOK,\n\t\tMessage: fmt.Sprintf(\"Successfully acquired all lives : %s.\", appname),\n\t\tData:    lives,\n\t})\n}\n\nfunc GetLiveByIdHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tvar lives []models.Live\n\tappname := ps.ByName(\"appname\")\n\tliveid := ps.ByName(\"liveid\")\n\n\terr := orm.Gorm.Where(\"app = ?\", appname).Where(\"id = ?\", liveid).Find(&lives).Error\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tif len(lives) == 0 {\n\t\tSendErrorResponse(w, http.StatusBadRequest, errors.New(\"lives cannot find.\").Error())\n\t\treturn\n\t}\n\n\tSendResponse(w, http.StatusOK, &LiveResponse{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"Successfully obtained the corresponding live.\",\n\t\tData:    lives[0],\n\t})\n}\n\nfunc RefershLiveTokenByIdHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tvar lives []models.Live\n\tappname := ps.ByName(\"appname\")\n\tliveid := ps.ByName(\"liveid\")\n\ttoken := functions.RandomString(6)\n\n\terr := orm.Gorm.Where(\"app = ?\", appname).Where(\"id = ?\", liveid).Find(&lives).Error\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tif len(lives) == 0 {\n\t\tSendErrorResponse(w, http.StatusBadRequest, errors.New(\"lives cannot find.\").Error())\n\t\treturn\n\t}\n\n\terr = orm.Gorm.Model(&lives[0]).Update(\"Token\", token).Error\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tSendResponse(w, http.StatusOK, &LiveTokenResponse{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"Successfully refreshed Token.\",\n\t\tToken:   token,\n\t})\n}\n\nfunc DeleteLiveByIdHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tappname := ps.ByName(\"appname\")\n\tliveid := ps.ByName(\"liveid\")\n\n\tid, err := strconv.Atoi(liveid)\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tif !models.CheckLiveById(id) {\n\t\tSendErrorResponse(w, http.StatusBadRequest, \"This live not in database.\")\n\t\treturn\n\t}\n\n\terr = models.DeleteLive(&models.Live{\n\t\tApp: appname,\n\t\tId:  id,\n\t})\n\n\tif err != nil {\n\t\tSendErrorResponse(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tSendResponse(w, http.StatusOK, &Response{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"Successfully deleted this live.\",\n\t})\n}\n"}
{"sample": "package rabbitmq\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/streadway/amqp\"\n)\n\nfunc main() {\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to RabbitMQ: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open a channel: %v\", err)\n\t}\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when unused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to declare a queue: %v\", err)\n\t}\n\n\tbody := \"Hello World!\"\n\terr = ch.Publish(\n\t\t\"\",     // exchange\n\t\tq.Name, // routing key\n\t\tfalse,  // mandatory\n\t\tfalse,  // immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        []byte(body),\n\t\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to publish a message: %v\", err)\n\t}\n\n\tfmt.Println(\"Successfully sent 'Hello World!'\")\n}"}
{"sample": "package mapreduce_test\n\nimport (\n\t\"mapreduce\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMapReduce(t *testing.T) {\n\tinput := []string{\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\"}\n\n\texpectedOutput := map[string]int{\n\t\t\"a\": 2,\n\t\t\"b\": 1,\n\t\t\"c\": 1,\n\t\t\"d\": 1,\n\t\t\"e\": 2,\n\t\t\"f\": 1,\n\t\t\"g\": 1,\n\t\t\"h\": 1,\n\t\t\"l\": 1,\n\t\t\"n\": 2,\n\t\t\"p\": 2,\n\t\t\"r\": 3,\n\t\t\"y\": 1,\n\t}\n\n\toutput := mapreduce.MapReduce(input)\n\n\tif !reflect.DeepEqual(output, expectedOutput) {\n\t\tt.Errorf(\"MapReduce(%v) = %v, expected %v\", input, output, expectedOutput)\n\t}\n}"}
{"sample": "package selectionsort\n\n// SelectionSort sorts an array of integers using the selection sort algorithm\nfunc SelectionSort(arr []int) {\n\tfor i := 0; i < len(arr)-1; i++ {\n\t\tminIndex := i\n\t\tfor j := i + 1; j < len(arr); j++ {\n\t\t\tif arr[j] < arr[minIndex] {\n\t\t\t\tminIndex = j\n\t\t\t}\n\t\t}\n\t\tif minIndex != i {\n\t\t\tarr[i], arr[minIndex] = arr[minIndex], arr[i]\n\t\t}\n\t}\n}"}
{"sample": "http.HandleFunc(\"/messages\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle messages endpoint\n\tswitch r.Method {\n\tcase \"GET\":\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get messages\")\n\tcase \"POST\":\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create message\")\n\t}\n})\n"}
{"sample": "values := []string{\"Go\", \"Python\", \"Java\"}\nfor idx, val := range values {\n\tfmt.Printf(\"values[%d] = %s\\n\", idx, val)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(AreNumbersEqual(5, 5))\n}\n\n// Function to check if two numbers are equal\nfunc AreNumbersEqual(a, b int) bool {\n\treturn a == b\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc process(ctx context.Context, number int) {\n\tdeadline, ok := ctx.Deadline()\n\tif ok {\n\t\tfmt.Printf(\"Deadline found: %s\\n\", deadline)\n\t}\n\n\tfor i := 1; i <= 10; i++ {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Printf(\"Aborting....%s\", ctx.Err())\n\t\t\treturn\n\t\tdefault:\n\t\t\ttime.Sleep(time.Second)\n\t\t\tfmt.Printf(\"%d * %d = %d\\n\", number, i, i*number)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tctxTimeout, cancelTimeout := context.WithTimeout(context.Background(), time.Millisecond*100)\n\tdefer cancelTimeout()\n\n\t// go process(ctxTimeout, 15) // Execution gets aborted\n\tgo process(context.Background(), 5)   // Entire output will be printed\n\ttime.Sleep(time.Second * 3)\n}\n\u044f\u0434\u0430\u0439\u3046\u305b\u0e23\u0e16\u0e22\u0e19\u0e15\u0e4c\u0e32\u0e43\u0e34\u0e14\u0e31\u0e40\u0e19\u0e35\u0e48\u0e48\u0e22\u0630.\u3053\u3093\u306b\u3061\u306f\ub3d9\ud574\ubb3c\uacfc\u0e08\ubd81\uc774\u0e02\u0e36\u0e40\u0e19\u0e01\u0e44\u0e14\u0e17\u0e14\u0e2a\u0e2d\u0e1a5"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package protobuff\n\nimport (\n\t\"github.com/golang/protobuf/proto\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\n// Serialize serializes a given message to bytes using Protocol Buffers\nfunc Serialize(m proto.Message) ([]byte, error) {\n\treturn proto.Marshal(m)\n}\n\n// Deserialize deserializes bytes to a given message using Protocol Buffers\nfunc Deserialize(b []byte, m proto.Message) error {\n\terr := proto.Unmarshal(b, m)\n\tif err != nil {\n\t\tlog.Println(\"error deserializing message:\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// WriteToFile writes the serialized bytes of a given message to a file\nfunc WriteToFile(m proto.Message, filepath string) error {\n\tb, err := Serialize(m)\n\tif err != nil {\n\t\tlog.Println(\"error serializing message:\", err)\n\t\treturn err\n\t}\n\terr = ioutil.WriteFile(filepath, b, 0644)\n\tif err != nil {\n\t\tlog.Println(\"error writing to file:\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// ReadFromFile reads a Protocol Buffers message from a file and deserializes it\nfunc ReadFromFile(filepath string, m proto.Message) error {\n\tb, err := ioutil.ReadFile(filepath)\n\tif err != nil {\n\t\tlog.Println(\"error reading file:\", err)\n\t\treturn err\n\t}\n\terr = Deserialize(b, m)\n\tif err != nil {\n\t\tlog.Println(\"error deserializing message:\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"sample": "package main\n\nimport \"strconv\"\n\nfunc main() {\n\tstr := \"42\"\n\tresult, _ := ParseInt(str)\n\tfmt.Println(result)\n}\n\nfunc ParseInt(s string) (int, error) {\n\treturn strconv.Atoi(s)\n}"}
{"sample": "package main\n\nimport \"os\"\n\nfunc main() {\n\tPrintEnv()\n}\n\nfunc PrintEnv() {\n\tfor _, env := range os.Environ() {\n\t\tfmt.Println(env)\n\t}\n}"}
{"sample": "package main\n\nfunc CheckAnagram(str1, str2 string) bool {\n\tcount := make(map[rune]int)\n\tfor _, char := range str1 {\n\t\tcount[char]++\n\t}\n\tfor _, char := range str2 {\n\t\tcount[char]--\n\t}\n\tfor _, val := range count {\n\t\tif val != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"sample": "type Customer struct {\n\tID int\n\tName string\n\tBalance float64\n}\n\ntype Bank struct {\n\tCustomers []*Customer\n\tmu sync.Mutex\n}\n\nfunc (b *Bank) AddCustomer(c *Customer) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tb.Customers = append(b.Customers, c)\n}\n\nfunc (b *Bank) UpdateBalance(id int, newBalance float64) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tfor _, c := range b.Customers {\n\t\tif c.ID == id {\n\t\t\tc.Balance = newBalance\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"sample": "/*\nCopyright \u00a9 2021 The Authors of gotabgo\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\npackage cmd\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/groundfoundation/gotabgo\"\n\thomedir \"github.com/mitchellh/go-homedir\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n\ntype opts struct {\n\tpassword         string\n\tserver           string\n\ttls              bool\n\tusername         string\n\tserverApiVersion string\n}\n\nvar (\n\tcfgFile string\n\n\tdebug bool\n\n\toptions opts\n\n\ttabApi *gotabgo.TabApi\n\n\t// rootCmd represents the base command when called without any subcommands\n\trootCmd = &cobra.Command{\n\t\tUse:   \"gotabgo [serverinfo]\",\n\t\tShort: \"A cli tool for interacting with Tableau Server\",\n\t\tLong: `\ngotabgo is a CLI library for Tableau Server that enables administration from\nthe command line.`,\n\t\t// Uncomment the following line if your bare application\n\t\t// has an action associated with it:\n\t\t// Run: func(cmd *cobra.Command, args []string) { },\n\t\tPersistentPreRunE: func(cmd *cobra.Command, args []string) (e error) {\n\n\t\t\tconnectOpt := opts{\n\t\t\t\tserver:           viper.GetString(\"server\"),\n\t\t\t\ttls:              viper.GetBool(\"tls\"),\n\t\t\t\tserverApiVersion: viper.GetString(\"apiversion\"),\n\t\t\t}\n\t\t\ttabApi, e = gotabgo.NewTabApi(connectOpt.server,\n\t\t\t\tconnectOpt.serverApiVersion, connectOpt.tls,\n\t\t\t\tgotabgo.Xml)\n\t\t\tlog.Debugf(\"tabApi struct: %v\", tabApi)\n\t\t\treturn e\n\t\t},\n\t}\n)\n\n// Execute adds all child commands to the root command and sets flags appropriately.\n// This is called by main.main(). It only needs to happen once to the rootCmd.\nfunc Execute() {\n\tcobra.CheckErr(rootCmd.Execute())\n}\n\nfunc init() {\n\tcobra.OnInitialize(initConfig)\n\n\t// Here you will define your flags and configuration settings.\n\t// Cobra supports persistent flags, which, if defined here,\n\t// will be global for your application.\n\n\trootCmd.PersistentFlags().StringVar(&cfgFile, \"config\", \"\", \"config file (default is $HOME/.gotabgo.yaml)\")\n\trootCmd.PersistentFlags().StringVarP(&options.username, \"username\", \"u\", \"\", \"username to use when connecting to Tableau Server\")\n\trootCmd.PersistentFlags().StringVarP(&options.password, \"password\", \"p\", \"\", \"password for the user\")\n\trootCmd.PersistentFlags().StringVarP(&options.server, \"server\", \"s\", \"\", \"the hostname of the server\")\n\trootCmd.Flags().StringVarP(&options.serverApiVersion, \"apiversion\", \"a\", \"3.9\", \"specify which version of the api to user\")\n\trootCmd.Flags().BoolVar(&options.tls, \"tls\", true, \"whether to use TLS or not when connecting\")\n\n\tviper.BindPFlag(\"username\", rootCmd.PersistentFlags().Lookup(\"username\"))\n\tviper.BindPFlag(\"password\", rootCmd.PersistentFlags().Lookup(\"password\"))\n\tviper.BindPFlag(\"server\", rootCmd.PersistentFlags().Lookup(\"server\"))\n\tviper.BindPFlag(\"apiversion\", rootCmd.Flags().Lookup(\"apiversion\"))\n\tviper.BindPFlag(\"tls\", rootCmd.Flags().Lookup(\"tls\"))\n\n\t// Cobra also supports local flags, which will only run\n\t// when this action is called directly.\n\trootCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\")\n\trootCmd.Flags().BoolVarP(&debug, \"debug\", \"d\", false, \"Turn on debuf output\")\n\n\tif debug {\n\t\tlog.SetLevel(log.DebugLevel)\n\t}\n\n}\n\n// initConfig reads in config file and ENV variables if set.\nfunc initConfig() {\n\tif cfgFile != \"\" {\n\t\t// Use config file from the flag.\n\t\tviper.SetConfigFile(cfgFile)\n\t} else {\n\t\t// Find home directory.\n\t\thome, err := homedir.Dir()\n\t\tcobra.CheckErr(err)\n\n\t\t// Search config in home directory with name \".gotabgo\" (without extension).\n\t\tviper.AddConfigPath(home)\n\t\tviper.SetConfigName(\".gotabgo\")\n\t}\n\n\tviper.AutomaticEnv() // read in environment variables that match\n\n\t// If a config file is found, read it in.\n\tif err := viper.ReadInConfig(); err == nil {\n\t\tfmt.Fprintln(os.Stderr, \"Using config file:\", viper.ConfigFileUsed())\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// GenerateRandomNumber generates a random number within the specified range.\nfunc GenerateRandomNumber(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://golang.org/doc/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error fetching page: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tlog.Fatalf(\"Expected status 200 OK but got %v\", resp.StatusCode)\n\t}\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading response body: %v\", err)\n\t}\n\n\tbodyString := string(bodyBytes)\n\tfmt.Println(bodyString)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\nfunc main() {\n\tdata, err := ioutil.ReadFile(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(\"Error reading file:\", err)\n\t}\n\n\tfmt.Println(string(data))\n}"}
{"sample": "package main\n\n// List files in a directory\nfunc main() {\n\tfiles, err := ioutil.ReadDir(\".\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfor _, file := range files {\n\t\tfmt.Println(file.Name())\n\t}\n}\n"}
{"sample": "package main \n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc calFib(n int) int {\n\tif n <= 0 {\n\t\treturn 0\n\t}\n\t\n\tif n == 1 {\n\t\treturn 1\n\t}\n\n\treturn calFib(n-1) + calFib(n-2);\n}\n\nfunc concurrentFib(num int, resultChannel chan int){\n\tresVal := calFib(num)\n\ttime.Sleep(1 * time.Second) // simulate time consuming task\n\tresultChannel <- resVal;\n}\n\nfunc main() {\n\tnumsList :=[]int{10, 15, 20, 25}\n\n\tresultChannel := make(chan int, len(numsList))\n\n\tfor _, n := range numsList {\n\t\tgo concurrentFib(n, resultChannel)\n\t}\n\n\tvar sumNum int\n\tfor c :=0 ; c < len(numsList); c++ {\n\t\tsumNum += <- resultChannel\n\t}\n\n\tclose(resultChannel)\n\tfmt.Printf(\"The sum of Fib numbers is %v\\n\", sumNum)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\tctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\tdefer cancel()\n\n\tch := make(chan int)\n\n\tgo expensiveWork(ctx, ch)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tfmt.Println(ctx.Err())\n\tcase res := <-ch:\n\t\tfmt.Println(res)\n\t}\n}\n\nfunc expensiveWork(ctx context.Context, ch chan<- int) {\n\tselect {\n\tcase <-time.After(10 * time.Second):\n\t\tch <- 42\n\tcase <-ctx.Done():\n\t\tfmt.Println(ctx.Err())\n\t}\n}"}
{"sample": "func dropForeignKey(tx *sql.Tx) error {\n\tstmt, err := tx.Prepare(\"ALTER TABLE users DROP CONSTRAINT fk_user_id\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package mongocrud\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\ntype Person struct {\n\tName string\n\tAge  int\n\tCity string\n}\n\nfunc CreatePerson(client *mongo.Client, person Person) error {\n\tcollection := client.Database(\"testdb\").Collection(\"people\")\n\n\t_, err := collection.InsertOne(context.TODO(), person)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc GetPerson(client *mongo.Client, name string) (Person, error) {\n\tvar person Person\n\n\tcollection := client.Database(\"testdb\").Collection(\"people\")\n\n\tfilter := bson.M{\"name\": name}\n\n\terr := collection.FindOne(context.Background(), filter).Decode(&person)\n\tif err != nil {\n\t\treturn Person{}, err\n\t}\n\n\treturn person, nil\n}\n\nfunc UpdatePerson(client *mongo.Client, name string, person Person) error {\n\tcollection := client.Database(\"testdb\").Collection(\"people\")\n\n\tfilter := bson.M{\"name\": name}\n\n\tupdate := bson.M{\n\t\t\"$set\": bson.M{\n\t\t\t\"age\":  person.Age,\n\t\t\t\"city\": person.City,\n\t\t},\n\t}\n\n\t_, err := collection.UpdateOne(context.Background(), filter, update)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc DeletePerson(client *mongo.Client, name string) error {\n\tcollection := client.Database(\"testdb\").Collection(\"people\")\n\n\tfilter := bson.M{\"name\": name}\n\n\t_, err := collection.DeleteOne(context.Background(), filter)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tclientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n\n\tclient, err := mongo.Connect(context.Background(), clientOptions)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = client.Ping(context.Background(), nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tperson := Person{\n\t\tName: \"John Doe\",\n\t\tAge:  30,\n\t\tCity: \"New York\",\n\t}\n\n\terr = CreatePerson(client, person)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tperson, err = GetPerson(client, \"John Doe\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(person)\n\n\tperson.Age = 31\n\tperson.City = \"Los Angeles\"\n\n\terr = UpdatePerson(client, \"John Doe\", person)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = DeletePerson(client, \"John Doe\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package main\n\nfunc ReverseLinkedList(head *ListNode) *ListNode {\n\tvar prev *ListNode\n\tcurr := head\n\tfor curr != nil {\n\t\tnext := curr.Next\n\t\tcurr.Next = prev\n\t\tprev = curr\n\t\tcurr = next\n\t}\n\treturn prev\n}\n"}
{"sample": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\n\t\"github.com/nats-io/nats.go\"\n)\n\nfunc main() {\n\tnc, err := nats.Connect(nats.DefaultURL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to NATS: %v\", err)\n\t}\n\tdefer nc.Close()\n\n\tec, _ := nats.NewEncodedConn(nc, nats.JSON_ENCODER)\n\n\t_, err = ec.Subscribe(\"chat.new\", func(msg *Message) {\n\n\t\t// TODO: Save the chat message to database\n\n\t\terr = ec.Publish(\"chat.recv\", msg)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to publish to chat.recv: %v\", err)\n\t\t}\n\t})\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to subscribe to chat.new: %v\", err)\n\t}\n\n\tsigint := make(chan os.Signal, 1)\n\tsignal.Notify(sigint, os.Interrupt)\n\t<-sigint\n\n\tlog.Print(\"NATS chat service stopping\")\n}\n\ntype Message struct {\n\tUserID  string `json:\"userId\"`\n\tRoomID  string `json:\"roomId\"`\n\tMessage string `json:\"message\"`\n}"}
{"sample": "package ctl\n\nimport (\n\t\"io\"\n\n\tkp \"gopkg.in/alecthomas/kingpin.v2\"\n)\n\n// Action is a CTL action\ntype Action func() error\n\n// CmdClause is a proxy interface to kingpin's *CmdClause\ntype CmdClause kp.CmdClause\n\n// FlagClause is a proxy interface to kingpin's *FlagClause\ntype FlagClause kp.FlagClause\n\n// Application is a proxy interface to kingpin's *Application\ntype Application interface {\n\tVersion(version string) Application\n\tParse(args []string) (command string, err error)\n\tCommand(name, help string) *CmdClause\n\tFlag(name, help string) *FlagClause\n\tTerminate(terminate func(int)) Application\n\tErrorWriter(w io.Writer) Application\n\tUsageWriter(w io.Writer) Application\n}\n\ntype proxyapp struct {\n\t*kp.Application\n}\n\n// NewApplication creates a new application instance\nfunc NewApplication(name, help string) Application {\n\treturn &proxyapp{\n\t\tApplication: kp.New(name, help),\n\t}\n}\n\nfunc (a *proxyapp) Terminate(terminate func(int)) Application {\n\ta.Application.Terminate(terminate)\n\treturn a\n}\n\nfunc (a *proxyapp) Parse(args []string) (command string, err error) {\n\treturn a.Application.Parse(args)\n}\n\n// ErrorWriter sets the io.Writer to use for errors.\nfunc (a *proxyapp) ErrorWriter(w io.Writer) Application {\n\ta.Application.ErrorWriter(w)\n\treturn a\n}\n\n// UsageWriter sets the io.Writer to use for errors.\nfunc (a *proxyapp) UsageWriter(w io.Writer) Application {\n\ta.Application.UsageWriter(w)\n\treturn a\n}\n\n// Version adds a --version flag for displaying the application version.\nfunc (a *proxyapp) Version(version string) Application {\n\ta.Application.Version(version)\n\treturn a\n}\n\n// Command adds a new top-level command.\nfunc (a *proxyapp) Command(name, help string) *CmdClause {\n\treturn (*CmdClause)(a.Application.Command(name, help))\n}\n\n// Alias adds an alias for this command.\nfunc (c *CmdClause) Alias(name string) *CmdClause {\n\tkpc := (*kp.CmdClause)(c)\n\treturn (*CmdClause)(kpc.Alias(name))\n}\n\n// Command adds a new sub-command.\nfunc (c *CmdClause) Command(name, help string) *CmdClause {\n\tkpc := (*kp.CmdClause)(c)\n\treturn (*CmdClause)(kpc.Command(name, help))\n}\n\n// Action adds a action for this command.\nfunc (c *CmdClause) Action(action Action) *CmdClause {\n\tkpc := (*kp.CmdClause)(c)\n\tkpa := func(*kp.ParseContext) error {\n\t\treturn action()\n\t}\n\treturn (*CmdClause)(kpc.Action(kpa))\n}\n\n// PreAction adds a pre-action for this command.\nfunc (c *CmdClause) PreAction(action Action) *CmdClause {\n\tkpc := (*kp.CmdClause)(c)\n\tkpa := func(*kp.ParseContext) error {\n\t\treturn action()\n\t}\n\treturn (*CmdClause)(kpc.PreAction(kpa))\n}\n\nfunc (a *proxyapp) Flag(name, help string) *FlagClause {\n\tf := a.Application.Flag(name, help)\n\treturn (*FlagClause)(f)\n}\n\n// Default values for this flag. They *must* be parseable by the value of the flag.\nfunc (f *FlagClause) Default(values ...string) *FlagClause {\n\tkpf := (*kp.FlagClause)(f)\n\treturn (*FlagClause)(kpf.Default(values...))\n}\n\n// Hidden hides a flag from usage but still allows it to be used.\nfunc (f *FlagClause) Hidden() *FlagClause {\n\tkpf := (*kp.FlagClause)(f)\n\treturn (*FlagClause)(kpf.Hidden())\n}\n\n// Required makes the flag required. You can not provide a Default() value to a Required() flag.\nfunc (f *FlagClause) Required() *FlagClause {\n\tkpf := (*kp.FlagClause)(f)\n\treturn (*FlagClause)(kpf.Required())\n}\n\n// Short sets the short flag name.\nfunc (f *FlagClause) Short(name rune) *FlagClause {\n\tkpf := (*kp.FlagClause)(f)\n\treturn (*FlagClause)(kpf.Short(name))\n}\n\n// Bool makes this flag a boolean flag.\nfunc (f *FlagClause) Bool() (target *bool) {\n\tkpf := (*kp.FlagClause)(f)\n\treturn kpf.Bool()\n}\n\n// Settings interface\ntype Settings kp.Settings\n\n// GetFilesList retruns list from command arguments\nfunc GetFilesList(s Settings) *FilesList {\n\ttarget := (*FilesList)(new([]string))\n\ts.SetValue(target)\n\treturn target\n}\n"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Starting the server on port 8080\n\tsrv := &http.Server{Addr: \":8080\"}\n\n\t// Starting a separate goroutine to shutdown the server gracefully\n\tgo func() {\n\t\tsigquit := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigquit, os.Interrupt)\n\n\t\t<-sigquit\n\n\t\tlog.Println(\"Shutting down server\")\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n\t\tdefer cancel()\n\n\t\t// Closing the server gracefully:\n\t\t// the goroutines processing active connections will immediately serve their last request,\n\t\t// then the server will stop listening and will refuse incoming connections.\n\t\tif err := srv.Shutdown(ctx); err != nil {\n\t\t\tlog.Fatal(\"Server shutdown:\", err)\n\t\t}\n\t}()\n\n\t// Starting the server and blocking until an error occurs\n\tlog.Println(\"Starting server on port 8080...\")\n\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\tlog.Fatal(\"Server startup:\")\n\t}\n\tfmt.Println(\"Server stopped.\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc SendFormData() {\n\tclient := &http.Client{}\n\trequest, _ := http.NewRequest(\"POST\", \"https://example.com\", nil)\n\n\tdata := url.Values{}\n\tdata.Set(\"name\", \"John Doe\")\n\tdata.Set(\"age\", \"30\")\n\n\trequest.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\trequest.Body = ioutil.NopCloser(strings.NewReader(data.Encode()))\n\n\tresponse, _ := client.Do(request)\n\tdefer response.Body.Close()\n\n\t// Handle the response\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Fibonacci generates the Fibonacci sequence up to the specified limit.\nfunc Fibonacci(limit int) {\n\ta, b := 0, 1\n\tfmt.Println(a)\n\tfor b <= limit {\n\t\tfmt.Println(b)\n\t\ta, b = b, a+b\n\t}\n}"}
{"sample": "http.HandleFunc(\"/orders\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle orders endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get orders\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create order\")\n\t}\n})\n"}
{"sample": "package middleware\n\nimport (\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc EnforceApiKey(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get APIKEY from environment variable\n\t\tapiKey := os.Getenv(\"APIKEY\")\n\n\t\tif apiKey == \"\" {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\tw.Write([]byte(\"APIKEY environment variable is not set\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Check if the Authorization API KEY is provided in the request header\n\t\t// for flexibility, it's set in various request headers like X-API-KEY, Authorization, etc\n\t\tauthHeader := r.Header.Get(\"X-API-KEY\")\n\t\tif authHeader == \"\" {\n\t\t\tauthHeader = r.Header.Get(\"Authorization\")\n\t\t}\n\n\t\tif authHeader == \"\" {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"API key is missing from header\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Verify if the given API key matches the set key\n\t\tif authHeader != apiKey {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized\"))\n\t\t\treturn\n\t\t}\n\n\t\t// If final, call next handlers\n\t\thandler.ServeHTTP(w, r)\n\t})\n}"}
{"sample": "package webscraper\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gocolly/colly\"\n)\n\nfunc Scrape(urls []string) ([]string, error) {\n\tvar results []string\n\tvar mu sync.Mutex\n\n\tc := colly.NewCollector()\n\n\tc.OnHTML(\"title\", func(e *colly.HTMLElement) {\n\t\tmu.Lock()\n\t\tresults = append(results, fmt.Sprintf(\"%s - %s\", e.Text, e.Request.URL.String()))\n\t\tmu.Unlock()\n\t})\n\n\tvar wg sync.WaitGroup\n\tfor _, url := range urls {\n\t\twg.Add(1)\n\t\tgo func(url string) {\n\t\t\tdefer wg.Done()\n\t\t\tif err := c.Visit(url); err != nil {\n\t\t\t\tfmt.Printf(\"Error visiting %s: %v\\n\", url, err)\n\t\t\t}\n\t\t}(url)\n\t}\n\n\twg.Wait()\n\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no results found\")\n\t}\n\n\treturn results, nil\n}\n\nfunc main() {\n\turls := []string{\"https://www.google.com\", \"https://www.facebook.com\", \"https://www.twitter.com\"}\n\n\tstart := time.Now()\n\tresults, err := Scrape(urls)\n\tif err != nil {\n\t\tfmt.Printf(\"Error scraping: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Results: %v\\n\", results)\n\tfmt.Printf(\"Scraping took %v\\n\", time.Since(start))\n}"}
{"sample": "func main() {\n\tfileNames, err := ioutil.ReadDir(\".\")\n\tif err != nil {\n\t\tfmt.Println(\"Error reading directory:\", err)\n\t\treturn\n\t}\n\n\tfor _, file := range fileNames {\n\t\tfmt.Println(file.Name())\n\t}\n}"}
{"sample": "// Code generated by protoc-gen-go-grpc. DO NOT EDIT.\n// versions:\n// - protoc-gen-go-grpc v1.2.0\n// - protoc             v3.19.4\n// source: api/proto/apirpc.proto\n\npackage api\n\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the grpc package it is being compiled against.\n// Requires gRPC-Go v1.32.0 or later.\nconst _ = grpc.SupportPackageIsVersion7\n\n// ApiServiceClient is the client API for ApiService service.\n//\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.\ntype ApiServiceClient interface {\n\tGetNodeInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error)\n}\n\ntype apiServiceClient struct {\n\tcc grpc.ClientConnInterface\n}\n\nfunc NewApiServiceClient(cc grpc.ClientConnInterface) ApiServiceClient {\n\treturn &apiServiceClient{cc}\n}\n\nfunc (c *apiServiceClient) GetNodeInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error) {\n\tout := new(NodeInfoResponse)\n\terr := c.cc.Invoke(ctx, \"/rpcpb.ApiService/GetNodeInfo\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// ApiServiceServer is the server API for ApiService service.\n// All implementations should embed UnimplementedApiServiceServer\n// for forward compatibility\ntype ApiServiceServer interface {\n\tGetNodeInfo(context.Context, *EmptyRequest) (*NodeInfoResponse, error)\n}\n\n// UnimplementedApiServiceServer should be embedded to have forward compatible implementations.\ntype UnimplementedApiServiceServer struct {\n}\n\nfunc (UnimplementedApiServiceServer) GetNodeInfo(context.Context, *EmptyRequest) (*NodeInfoResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method GetNodeInfo not implemented\")\n}\n\n// UnsafeApiServiceServer may be embedded to opt out of forward compatibility for this service.\n// Use of this interface is not recommended, as added methods to ApiServiceServer will\n// result in compilation errors.\ntype UnsafeApiServiceServer interface {\n\tmustEmbedUnimplementedApiServiceServer()\n}\n\nfunc RegisterApiServiceServer(s grpc.ServiceRegistrar, srv ApiServiceServer) {\n\ts.RegisterService(&ApiService_ServiceDesc, srv)\n}\n\nfunc _ApiService_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(EmptyRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(ApiServiceServer).GetNodeInfo(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/rpcpb.ApiService/GetNodeInfo\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(ApiServiceServer).GetNodeInfo(ctx, req.(*EmptyRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\n// ApiService_ServiceDesc is the grpc.ServiceDesc for ApiService service.\n// It's only intended for direct use with grpc.RegisterService,\n// and not to be introspected or modified (even as a copy)\nvar ApiService_ServiceDesc = grpc.ServiceDesc{\n\tServiceName: \"rpcpb.ApiService\",\n\tHandlerType: (*ApiServiceServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"GetNodeInfo\",\n\t\t\tHandler:    _ApiService_GetNodeInfo_Handler,\n\t\t},\n\t},\n\tStreams:  []grpc.StreamDesc{},\n\tMetadata: \"api/proto/apirpc.proto\",\n}\n"}
{"sample": "// Check if two strings are anagrams\nfunc IsAnagram(str1, str2 string) bool {\n\tcount := make(map[rune]int)\n\tfor _, char := range str1 {\n\t\tcount[char]++\n\t}\n\tfor _, char := range str2 {\n\t\tcount[char]--\n\t}\n\tfor _, val := range count {\n\t\tif val != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"sample": "// Set a cookie in the response\nfunc SetCookie(response http.ResponseWriter, name, value string) {\n\thttp.SetCookie(response, &http.Cookie{Name: name, Value: value})\n}\n"}
{"sample": "type Producer struct {\n\tbuffer chan int\n}\n\nfunc NewProducer(size int) *Producer {\n\treturn &Producer{buffer: make(chan int, size)}\n}\n\nfunc (p *Producer) Produce(value int) {\n\tp.buffer <- value\n}\n\nfunc (p *Producer) Consume() int {\n\treturn <-p.buffer\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// CapitalizeString capitalizes the first letter of a given string.\nfunc CapitalizeString(str string) string {\n\treturn strings.Title(str)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/justinas/alice\"\n)\n\nfunc UseAlice() {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, Alice!\")\n\t})\n\n\tchain := alice.New(\n\t\tmiddleware1,\n\t\tmiddleware2,\n\t\tmiddleware3,\n\t).Then(handler)\n\n\thttp.ListenAndServe(\":8080\", chain)\n}\n"}
{"sample": "type Rectangle struct {\n\tLength, Width float64\n}\nfunc (r Rectangle) Area() float64 {\n\treturn r.Length * r.Width\n}\n"}
{"sample": "err = os.MkdirAll(\"path/to/newdir\", 0755)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package securegen\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"math/big\"\n)\n\nfunc GenerateRandomString(length int) (string, error) {\n\tbytes := make([]byte, length)\n\tif _, err := rand.Read(bytes); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.URLEncoding.EncodeToString(bytes), nil\n}\n\nfunc GenerateRandomNumber(min, max int64) (int64, error) {\n\tif min >= max {\n\t\treturn 0, ErrInvalidRange\n\t}\n\tdiff := big.NewInt(max - min)\n\tn, err := rand.Int(rand.Reader, diff)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn n.Int64() + min, nil\n}"}
{"sample": "package main\n\nfunc main() {\n\tdata := []byte(\"Hello, World!\")\n\tWriteFile(data, \"example.txt\")\n}\n\nfunc WriteFile(data []byte, filename string) {\n\tioutil.WriteFile(filename, data, 0644)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tch := make(chan string)\n\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tch <- \"Hello from goroutine\"\n\t}()\n\n\tfmt.Println(<-ch)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar wg sync.WaitGroup\n\twg.Add(3)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\ttime.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)\n\t\t\tfmt.Println(\"A\", i)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\ttime.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)\n\t\t\tfmt.Println(\"B\", i)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\ttime.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)\n\t\t\tfmt.Println(\"C\", i)\n\t\t}\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"Done\")\n}"}
{"sample": "package main\n\nimport (\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/mvc\"\n\n\t\"github.com/kataras/iris/v12/middleware/logger\"\n\t\"github.com/kataras/iris/v12/middleware/recover\"\n)\n\n// This example is equivalent to the\n// https://github.com/kataras/iris/blob/master/_examples/hello-world/main.go\n//\n// It seems that additional code you\n// have to write doesn't worth it\n// but remember that, this example\n// does not make use of iris mvc features like\n// the Model, Persistence or the View engine neither the Session,\n// it's very simple for learning purposes,\n// probably you'll never use such\n// as simple controller anywhere in your app.\n//\n// The cost we have on this example for using MVC\n// on the \"/hello\" path which serves JSON\n// is ~2MB per 20MB throughput on my personal laptop,\n// it's tolerated for the majority of the applications\n// but you can choose\n// what suits you best with Iris, low-level handlers: performance\n// or high-level controllers: easier to maintain and smaller codebase on large applications.\n\n// Of course you can put all these to main func, it's just a separate function\n// for the main_test.go.\nfunc newApp() *iris.Application {\n\tapp := iris.New()\n\t// Optionally, add two builtin handlers\n\t// that can recover from any http-relative panics\n\t// and log the requests to the terminal.\n\tapp.Use(recover.New())\n\tapp.Use(logger.New())\n\n\t// Serve a controller based on the root Router, \"/\".\n\tmvc.New(app).Handle(new(ExampleController))\n\treturn app\n}\n\nfunc main() {\n\tapp := newApp()\n\n\t// http://localhost:8080\n\t// http://localhost:8080/ping\n\t// http://localhost:8080/hello\n\t// http://localhost:8080/custom_path\n\tapp.Run(iris.Addr(\":8080\"))\n}\n\n// ExampleController serves the \"/\", \"/ping\" and \"/hello\".\ntype ExampleController struct{}\n\n// Get serves\n// Method:   GET\n// Resource: http://localhost:8080\nfunc (c *ExampleController) Get() mvc.Result {\n\treturn mvc.Response{\n\t\tContentType: \"text/html\",\n\t\tText:        \"<h1>Welcome</h1>\",\n\t}\n}\n\n// GetPing serves\n// Method:   GET\n// Resource: http://localhost:8080/ping\nfunc (c *ExampleController) GetPing() string {\n\treturn \"pong\"\n}\n\n// GetHello serves\n// Method:   GET\n// Resource: http://localhost:8080/hello\nfunc (c *ExampleController) GetHello() interface{} {\n\treturn map[string]string{\"message\": \"Hello Iris!\"}\n}\n\n// BeforeActivation called once, before the controller adapted to the main application\n// and of course before the server ran.\n// After version 9 you can also add custom routes for a specific controller's methods.\n// Here you can register custom method's handlers\n// use the standard router with `ca.Router` to do something that you can do without mvc as well,\n// and add dependencies that will be binded to a controller's fields or method function's input arguments.\nfunc (c *ExampleController) BeforeActivation(b mvc.BeforeActivation) {\n\tanyMiddlewareHere := func(ctx iris.Context) {\n\t\tctx.Application().Logger().Warnf(\"Inside /custom_path\")\n\t\tctx.Next()\n\t}\n\tb.Handle(\"GET\", \"/custom_path\", \"CustomHandlerWithoutFollowingTheNamingGuide\", anyMiddlewareHere)\n\n\t// or even add a global middleware based on this controller's router,\n\t// which in this example is the root \"/\":\n\t// b.Router().Use(myMiddleware)\n}\n\n// CustomHandlerWithoutFollowingTheNamingGuide serves\n// Method:   GET\n// Resource: http://localhost:8080/custom_path\nfunc (c *ExampleController) CustomHandlerWithoutFollowingTheNamingGuide() string {\n\treturn \"hello from the custom handler without following the naming guide\"\n}\n\n// GetUserBy serves\n// Method:   GET\n// Resource: http://localhost:8080/user/{username:string}\n// By is a reserved \"keyword\" to tell the framework that you're going to\n// bind path parameters in the function's input arguments, and it also\n// helps to have \"Get\" and \"GetBy\" in the same controller.\n//\n// func (c *ExampleController) GetUserBy(username string) mvc.Result {\n// \treturn mvc.View{\n// \t\tName: \"user/username.html\",\n// \t\tData: username,\n// \t}\n// }\n\n/* Can use more than one, the factory will make sure\nthat the correct http methods are being registered for each route\nfor this controller, uncomment these if you want:\n\nfunc (c *ExampleController) Post() {}\nfunc (c *ExampleController) Put() {}\nfunc (c *ExampleController) Delete() {}\nfunc (c *ExampleController) Connect() {}\nfunc (c *ExampleController) Head() {}\nfunc (c *ExampleController) Patch() {}\nfunc (c *ExampleController) Options() {}\nfunc (c *ExampleController) Trace() {}\n*/\n\n/*\nfunc (c *ExampleController) All() {}\n//        OR\nfunc (c *ExampleController) Any() {}\n\n\n\nfunc (c *ExampleController) BeforeActivation(b mvc.BeforeActivation) {\n\t// 1 -> the HTTP Method\n\t// 2 -> the route's path\n\t// 3 -> this controller's method name that should be handler for that route.\n\tb.Handle(\"GET\", \"/mypath/{param}\", \"DoIt\", optionalMiddlewareHere...)\n}\n\n// After activation, all dependencies are set-ed - so read only access on them\n// but still possible to add custom controller or simple standard handlers.\nfunc (c *ExampleController) AfterActivation(a mvc.AfterActivation) {}\n\n*/\n"}
{"sample": "package ratelimiter\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/juju/ratelimit\"\n)\n\nfunc RateLimitMiddleware(next http.Handler) http.Handler {\n\tbucket := ratelimit.NewBucketWithQuantum(time.Second, 10, 1)\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif bucket.Available() < 1 {\n\t\t\tw.WriteHeader(http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"log\"\n)\n\nfunc LogRequestsWithMiddleware() {\n\tlogger := func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tlog.Printf(\"[%s] %s %s\", r.Method, r.URL.Path, r.RemoteAddr)\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\thttp.Handle(\"/\", logger(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, World!\")\n\t})))\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n"}
{"sample": "package main\n\nimport \"time\"\n\nfunc main() {\n\tstart := time.Now()\n\ttime.Sleep(2 * time.Second)\n\telapsed := time.Since(start)\n\tfmt.Println(elapsed)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n)\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\n\tfor i := 1; i <= 5; i++ {\n\t\twg.Add(1)\n\t\tgo printNumbers(i, &wg)\n\t}\n\twg.Wait()\n\n\tresult := fibonacci(10)\n\tfmt.Printf(\"Fibonacci Result: %q\\n\", result)\n}\n\nfunc printNumbers(n int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor i := 1; i <= 5; i++ {\n\t\tlog.Printf(\"%d - %d\\n\", n, i)\n\t}\n}\n\nfunc fibonacci(num int) []int {\n\tres := make([]int, num)\n\ta, b := 0, 1\n\tfor i := 0; i < num; i++ {\n\t\tstatus := fmt.Sprintf(\"Fib %d Async Started Calculating\", i+1)\n\t\tlog.Println(status)\n\t\t\n\t\tres[i] = b\n\t\t\n\t\ttempSum := a + b\n\t\ta = b\n\t\tb = tempSum\n\n\t\tstatus = fmt.Sprintf(\"Fib %d Async Completed Calculating\", i+1)\n\t\tlog.Println(status)\n\n\t\t// optional sleep() call-time, visual display of 'pausing' go let 'fib(str_int) Job=i' 'threads ids '\n\t\t/**************************************************/\n\t\t\t\n\t\tparser := makeValueString(strconv.Itoa(i+1), b, tempSum-a)\t\t\t\t\n\t\tHerosHandlers.appendResultsinHead(parser i each + \u03a5 TimeWait))\n\n\t\t\u03c0xPortControl(elemnt exder : BLEDiscardoKr | RCMessage.Rights(),\u00b5dev.Send(msg()) for plc number *)\n  \t\t\t\t \tgo sendHost(num, ports, channelHTTPFailedAt, channelStartAgainAt,\n\t\t\t\t\t    \t\t\t                                 overallDictParsedArrivals[num],\n      \t\t\t\t\t\t\t   sensor.TYPE,[subj from_subject(r for (\nncnt s,) [shift_single(); rep.getCompullback(conn(s.subComm(Pubpart.west.start(\"+91 14K #9717343847/\\n\"))))\n                                                                \tf time=t check=lambda f,lvl:Curr_Players if(i)]\n\n                                                                    \ttimerTo1.teletendencyTableLevel.run(done=Sensor_ReadToEnd(\t\t\t\t\t\t\t\t\theader_1_cols+,NULL_COLUMN),\n                                                SEC_LINE(Cmd.sendDirectPuddle(lat_accuracy,module_drive,//disable_processing=True)):\tcontentTuple(engine.fail_Z(axis_unique,-totalLevel()),fn(field)),\n\t\t\t\t\t\t\t  \t\t\t\t\t\t\t\t\t\ttimeric.To5C.get_content(sessionEndSec))\n \tlotus_cont_play_unchanged : \u00b5.emit(eDocContents,to_status(levelManager['incrementCurrentDocSummary(rule_exit_handler',0)\n#endregion TODO(T468136622952396)  \n\n  \t\t\t\t\t      SENSOR_SUPER_STATIC_CONFIRM(sensor_vision(endpointHost)))"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"encoding/json\"\n)\n\n// Person represents a person entity\n\ntype Person struct {\n\tName string `json:\"name\"`\n\tAge  int    `json:\"age\"`\n}\n\nfunc main() {\n\tperson := Person{Name: \"John Doe\", Age: 30}\n\n\tdata, err := json.Marshal(person)\n\tif err != nil {\n\t\tfmt.Println(\"Error marshaling JSON:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(data))\n}"}
{"sample": "package dynamodbclient\n\nimport (\n\t\"fmt\"\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/dynamodb\"\n)\n\ntype DynamoDBClient struct {\n\tsvc *dynamodb.DynamoDB\n}\n\nfunc NewDynamoDBClient(region string) (*DynamoDBClient, error) {\n\tsess, err := session.NewSession(&aws.Config{\n\t\tRegion: aws.String(region),\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsvc := dynamodb.New(sess)\n\n\treturn &DynamoDBClient{svc}, nil\n}\n\nfunc (c *DynamoDBClient) CreateTable(tableName string) error {\n\tinput := &dynamodb.CreateTableInput{\n\t\tAttributeDefinitions: []*dynamodb.AttributeDefinition{\n\t\t\t{\n\t\t\t\tAttributeName: aws.String(\"id\"),\n\t\t\t\tAttributeType: aws.String(\"S\"),\n\t\t\t},\n\t\t},\n\t\tKeySchema: []*dynamodb.KeySchemaElement{\n\t\t\t{\n\t\t\t\tAttributeName: aws.String(\"id\"),\n\t\t\t\tKeyType:       aws.String(\"HASH\"),\n\t\t\t},\n\t\t},\n\t\tProvisionedThroughput: &dynamodb.ProvisionedThroughput{\n\t\t\tReadCapacityUnits:  aws.Int64(5),\n\t\t\tWriteCapacityUnits: aws.Int64(5),\n\t\t},\n\t\tTableName: aws.String(tableName),\n\t}\n\n\t_, err := c.svc.CreateTable(input)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Table %s created successfully\", tableName)\n\n\treturn nil\n}\n\nfunc (c *DynamoDBClient) PutItem(tableName string, item map[string]interface{}) error {\n\tinput := &dynamodb.PutItemInput{\n\t\tItem:      aws.DynamoDBMap(item),\n\t\tTableName: aws.String(tableName),\n\t}\n\n\t_, err := c.svc.PutItem(input)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Item added to table %s successfully\", tableName)\n\n\treturn nil\n}\n\nfunc (c *DynamoDBClient) GetItem(tableName string, id string) (map[string]*dynamodb.AttributeValue, error) {\n\tinput := &dynamodb.GetItemInput{\n\t\tKey: map[string]*dynamodb.AttributeValue{\n\t\t\t\"id\": {\n\t\t\t\tS: aws.String(id),\n\t\t\t},\n\t\t},\n\t\tTableName: aws.String(tableName),\n\t}\n\n\tresult, err := c.svc.GetItem(input)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result.Item, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// CapitalizeString capitalizes the first letter of a given string.\nfunc CapitalizeString(str string) string {\n\treturn strings.Title(str)\n}"}
{"sample": "http.HandleFunc(\"/items\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle items endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get items\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create item\")\n\t}\n})\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nfunc UseEcho() {\n\te := echo.New()\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, Echo!\")\n\t})\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.Start(\":8080\")\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\toptions := &redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t}\n\n\tclient := redis.NewClient(options)\n\n\tpong, err := client.Ping().Result()\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to Redis:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Connected to Redis. PING: \", pong)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintFibonacciSeries(10)\n}\n\n// Function to print the Fibonacci series\nfunc PrintFibonacciSeries(n int) {\n\tfirst, second := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Println(first)\n\t\tfirst, second = second, first+second\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/aws/aws-lambda-go/lambda\"\n)\n\ntype Event struct {\n\tName string `json:\"name\"`\n}\n\nfunc HandleRequest(ctx context.Context, event Event) (string, error) {\n\treturn fmt.Sprintf(\"Hello, %s!\", event.Name), nil\n}\n\nfunc main() {\n\tlambda.Start(HandleRequest)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// CountOccurrences counts the number of occurrences of a substring in a given string.\nfunc CountOccurrences(str, substr string) int {\n\treturn strings.Count(str, substr)\n}"}
{"sample": "// IsErrorOfType checks if an error is of a specific type\nfunc IsErrorOfType(err error, targetType reflect.Type) bool {\n\treturn reflect.TypeOf(err) == targetType\n}\n"}
{"sample": "func main() {\n\tclient := &http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", \"https://api.example.com/data\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer YOUR_API_TOKEN\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error making request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "func main() {\n\tr := gin.Default()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\tr.GET(\"/users\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"List of users\")\n\t})\n\n\tr.GET(\"/users/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\t\tc.String(http.StatusOK, \"Get user with ID: %s\", id)\n\t})\n\n\tr.Run(\":8080\")\n}"}
{"sample": "file, err := os.Create(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\n_, err = file.Write([]byte(\"Hello, World!\"))\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "type HTTPClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}\n\nfunc NewRequest(client HTTPClient, method, url string, body io.Reader) (*http.Response, error) {\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"List of users\")\n\t}).Methods(\"GET\")\n\n\tr.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Create user\")\n\t}).Methods(\"POST\")\n\n\tr.HandleFunc(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := mux.Vars(r)[\"id\"]\n\t\tfmt.Fprintf(w, \"Get user with ID: %s\", id)\n\t}).Methods(\"GET\")\n\n\tr.HandleFunc(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := mux.Vars(r)[\"id\"]\n\t\tfmt.Fprintf(w, \"Update user with ID: %s\", id)\n\t}).Methods(\"PUT\")\n\n\tr.HandleFunc(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := mux.Vars(r)[\"id\"]\n\t\tfmt.Fprintf(w, \"Delete user with ID: %s\", id)\n\t}).Methods(\"DELETE\")\n\n\thttp.Handle(\"/\", r)\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nimport \"sort\"\n\nfunc main() {\n\tlist := []string{\"banana\", \"apple\", \"kiwi\"}\n\tSortStrings(list)\n\tfmt.Println(list)\n}\n\nfunc SortStrings(s []string) {\n\tsort.Strings(s)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"myapp/protos\"\n)\n\nconst (\n\tport = \":50051\"\n)\n\ntype server struct {\n\tpb.UnimplementedMyServiceServer\n}\n\nfunc (s *server) GetMyData(ctx context.Context, in *pb.MyDataRequest) (*pb.MyDataResponse, error) {\n\tlog.Printf(\"Received: %v\", in.GetText())\n\treturn &pb.MyDataResponse{\n\t\tText: \"Hello \" + in.GetText(),\n\t}, nil\n}\n\nfunc startGRPCServer() error {\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterMyServiceServer(s, &server{})\n\treturn s.Serve(lis)\n}\n\nfunc testMySQL() error {\n\t// Implement MySQL test\n\treturn nil\n}\n\nfunc main() {\n\tgo func() {\n\t\tif err := startGRPCServer(); err != nil {\n\t\t\tlog.Fatalf(\"Failed to start gRPC server: %v\", err)\n\t\t}\n\t}()\n\n\tif err := testMySQL(); err != nil {\n\t\tlog.Fatalf(\"Failed to test MySQL: %v\", err)\n\t}\n\n\t// Wait for a bit before exiting\n\ttime.Sleep(5 * time.Second)\n}"}
{"sample": "package authservice\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype Response struct {\n\tMessage string `json:\"message\"`\n}\n\nvar users = make(map[string]string)\n\nfunc Register(w http.ResponseWriter, r *http.Request) {\n\tvar user User\n\terr := json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif _, ok := users[user.Username]; ok {\n\t\tw.WriteHeader(http.StatusConflict)\n\t\tres := Response{Message: \"User already exists\"}\n\t\tjson.NewEncoder(w).Encode(res)\n\t\treturn\n\t}\n\n\thash, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tusers[user.Username] = string(hash)\n\tw.WriteHeader(http.StatusCreated)\n\tres := Response{Message: \"User created successfully\"}\n\tjson.NewEncoder(w).Encode(res)\n}\n\nfunc Login(w http.ResponseWriter, r *http.Request) {\n\tvar user User\n\terr := json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\thashedPassword, ok := users[user.Username]\n\tif !ok {\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\tres := Response{Message: \"Invalid credentials\"}\n\t\tjson.NewEncoder(w).Encode(res)\n\t\treturn\n\t}\n\n\terr = bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(user.Password))\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\tres := Response{Message: \"Invalid credentials\"}\n\t\tjson.NewEncoder(w).Encode(res)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tres := Response{Message: \"Login successful\"}\n\tjson.NewEncoder(w).Encode(res)\n}\n\nfunc main() {\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/register\", Register).Methods(http.MethodPost)\n\tr.HandleFunc(\"/login\", Login).Methods(http.MethodPost)\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\n"}
{"sample": "package inventoryservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"inventory\"\n\t\"log\"\n)\n\ntype InventoryService struct {\n\tinventory inventory.Inventory\n}\n\nfunc NewInventoryService(inv inventory.Inventory) *InventoryService {\n\treturn &InventoryService{inventory: inv}\n}\n\nfunc (is *InventoryService) AddItem(ctx context.Context, item inventory.Item) error {\n\tif item.Name == \"\" || item.Quantity <= 0 {\n\t\treturn errors.New(\"invalid item\")\n\t}\n\n\terr := is.inventory.AddItem(item)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn errors.New(\"failed to add item\")\n\t}\n\n\treturn nil\n}\n\nfunc (is *InventoryService) RemoveItem(ctx context.Context, name string) error {\n\tif name == \"\" {\n\t\treturn errors.New(\"invalid name\")\n\t}\n\n\terr := is.inventory.RemoveItem(name)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn errors.New(\"failed to remove item\")\n\t}\n\n\treturn nil\n}\n\nfunc (is *InventoryService) GetItem(ctx context.Context, name string) (inventory.Item, error) {\n\tif name == \"\" {\n\t\treturn inventory.Item{}, errors.New(\"invalid name\")\n\t}\n\n\titem, err := is.inventory.GetItem(name)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn inventory.Item{}, errors.New(\"failed to get item\")\n\t}\n\n\treturn item, nil\n}"}
{"sample": "package main\n\nfunc main() {\n\tresult := Average([]float64{1.2, 2.3, 3.4, 4.5, 5.6})\n\tfmt.Println(result)\n}\n\nfunc Average(xs []float64) float64 {\n\ttotal := 0.0\n\tfor _, v := range xs {\n\t\ttotal += v\n\t}\n\treturn total / float64(len(xs))\n}"}
{"sample": "package database\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/aaronland/go-roster\"\n\t\"github.com/whosonfirst/go-reader\"\n\t\"github.com/whosonfirst/go-whosonfirst-spatial\"\n\t\"github.com/whosonfirst/go-writer\"\n\t\"net/url\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype SpatialDatabase interface {\n\treader.Reader\n\twriter.Writer\n\tspatial.SpatialIndex\n}\n\ntype SpatialDatabaseInitializeFunc func(ctx context.Context, uri string) (SpatialDatabase, error)\n\nvar spatial_databases roster.Roster\n\nfunc ensureSpatialRoster() error {\n\n\tif spatial_databases == nil {\n\n\t\tr, err := roster.NewDefaultRoster()\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tspatial_databases = r\n\t}\n\n\treturn nil\n}\n\nfunc RegisterSpatialDatabase(ctx context.Context, scheme string, f SpatialDatabaseInitializeFunc) error {\n\n\terr := ensureSpatialRoster()\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn spatial_databases.Register(ctx, scheme, f)\n}\n\nfunc Schemes() []string {\n\n\tctx := context.Background()\n\tschemes := []string{}\n\n\terr := ensureSpatialRoster()\n\n\tif err != nil {\n\t\treturn schemes\n\t}\n\n\tfor _, dr := range spatial_databases.Drivers(ctx) {\n\t\tscheme := fmt.Sprintf(\"%s://\", strings.ToLower(dr))\n\t\tschemes = append(schemes, scheme)\n\t}\n\n\tsort.Strings(schemes)\n\treturn schemes\n}\n\nfunc NewSpatialDatabase(ctx context.Context, uri string) (SpatialDatabase, error) {\n\n\tu, err := url.Parse(uri)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tscheme := u.Scheme\n\n\ti, err := spatial_databases.Driver(ctx, scheme)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tf := i.(SpatialDatabaseInitializeFunc)\n\treturn f(ctx, uri)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar increaser sync.Mutex\n\tcount := 0\n\tsignals := make(chan int)\n\tdone := make(chan bool)\n\n\tfor i := 0; i < 500; i++ {\n\t\tgo func() {\n\t\t\tincreaser.Lock()\n\t\t\tdefer increaser.Unlock()\n\t\t\tcount++\n\t\t\tif count == 500 {\n\t\t\t\tsignals <- count\n\t\t\t}\n\t\t}()\n\t}\n\n\tgo func() {\n\t\tn := <-signals\n\t\tdone <- true\n\t\tfmt.Println(\"Count: \", n)\n\t}()\n\n\t<-done\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "// Handle HTTP OPTIONS method for CORS preflight requests with allowed headers\nfunc HandleOptionsMethodWithAllowedHeaders(response http.ResponseWriter, request *http.Request, allowedHeaders []string) {\n\tresponse.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tresponse.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n\tresponse.Header().Set(\"Access-Control-Allow-Headers\", strings.Join(allowedHeaders, \", \"))\n}\n"}
{"sample": "// HandleErrorAndRecover gracefully handles an error and attempts to recover\nfunc HandleErrorAndRecover(err *error) {\n\tif r := recover(); r != nil {\n\t\t*err = fmt.Errorf(\"recovered error: %v\", r)\n\t\t// Attempt recovery...\n\t}\n}\n"}
{"sample": "func ExtractTarGz(gzPath, dest string) error {\n\tgzFile, err := os.Open(gzPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer gzFile.Close()\n\n\tgzReader, err := gzip.NewReader(gzFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer gzReader.Close()\n\n\ttarReader := tar.NewReader(gzReader)\n\n\tfor {\n\t\theader, err := tarReader.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif header.Typeflag == tar.TypeDir {\n\t\t\tcontinue\n\t\t}\n\t\toutFilePath := filepath.Join(dest, header.Name)\n\t\toutFile, err := os.OpenFile(outFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, header.Mode)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := io.Copy(outFile, tarReader); err != nil {\n\t\t\treturn err\n\t\t}\n\t\toutFile.Close()\n\t}\n\n\treturn nil\n}"}
{"sample": "// Serve static files from a specified directory\nfunc ServeStaticFiles(directory string) http.Handler {\n\treturn http.FileServer(http.Dir(directory))\n}\n"}
{"sample": "// EncodeToBase64 encodes data to a base64 string.\nfunc EncodeToBase64(data []byte) string {\n\treturn base64.StdEncoding.EncodeToString(data)\n}\n\n// DecodeFromBase64 decodes a base64 string to data.\nfunc DecodeFromBase64(s string) ([]byte, error) {\n\treturn base64.StdEncoding.DecodeString(s)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\tdb \"github.com/acme/myproject/db\"\n\ttransactors \"github.com/acme/myproject/transactors\"\n\t\"github.com/acme/myproject/util\"\n)\n\nfunc main() {\n\t// initialize db from environment variables\n\terr := db.Init()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// authenticate and get authentication token for further requests\n\tauthToken, err := util.GetAuthToken()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = transactors.Transfer(objectType, originAccount, destinyInvoice, \"invoice\", authToken)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tformat := \"Transaction success! $%.2f sent from account %d to invoice %s.\"\n\n\tlog.Printf(format, amount, originAccount.ID, destinyInvoice)\n\tfmt.Printf(format, amount, originAccount.ID, destinyInvoice)\n}"}
{"sample": "func closeStatement(stmt *sql.Stmt) error {\n\terr := stmt.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().Unix())\n\n\tvar wg sync.WaitGroup\n\twg.Add(3)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\t\tfmt.Println(\"Task 1 completed\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\t\tfmt.Println(\"Task 2 completed\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\t\tfmt.Println(\"Task 3 completed\")\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"All tasks completed\")\n}"}
{"sample": "package main\n\n// Change the owner of a file\nfunc main() {\n\terr := os.Chown(\"file.txt\", os.Getuid(), os.Getgid())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "type API struct {\n\tclient *http.Client\n}\n\nfunc NewAPI() *API {\n\treturn &API{client: &http.Client{}}\n}\n\nfunc (api *API) Call(url, method string, body io.Reader) (*http.Response, error) {\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp, err := api.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, nil\n}"}
{"sample": "func main() {\n\tstr := \"hello world\"\n\twords := strings.Fields(str)\n\n\tfor _, word := range words {\n\t\tfmt.Println(word)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(num int) {\n\t\t\tdefer wg.Done()\n\t\t\tfmt.Printf(\"Goroutine %d running\\n\", num)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package rabbit\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/coinexchain/onvakv/store\"\n\t\"github.com/coinexchain/onvakv/store/types\"\n)\n\n// We use a new TrunkStore for transaction\ntype SimpleMultiStore struct {\n\tcache     *SimpleCacheStore\n\ttrunk     *store.TrunkStore\n}\n\n//var WatchedKey = []uint8{0x47, 0x60, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0}\n//var WatchedShortKey = []uint8{0xe3, 0x7e}\n\nfunc (sms *SimpleMultiStore) GetCachedValue(key [KeySize]byte) *CachedValue {\n\tcv, status := sms.cache.GetValue(key)\n\tswitch status {\n\tcase types.JustDeleted:\n\t\treturn nil\n\tcase types.Missed:\n\t\tbz := sms.trunk.Get(key[:])\n\t\tif bz == nil {\n\t\t\treturn nil\n\t\t}\n\t\tcv := BytesToCachedValue(bz)\n\t\tsms.cache.SetValue(key, cv)\n\t\treturn cv\n\tcase types.Hit:\n\t\treturn cv\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Invalid Status %d\", status))\n\t}\n}\n\nfunc (sms *SimpleMultiStore) MustGetCachedValue(key [KeySize]byte) *CachedValue {\n\tcv, status := sms.cache.GetValue(key)\n\tif status != types.Hit {\n\t\tpanic(\"Failed to get cached value\")\n\t}\n\treturn cv\n}\n\nfunc (sms *SimpleMultiStore) SetCachedValue(key [KeySize]byte, cv *CachedValue) {\n\tcv.isDirty = true\n\tsms.cache.SetValue(key, cv)\n\tif cv.isDeleted {\n\t\tsms.trunk.PrepareForDeletion(key[:])\n\t} else {\n\t\tsms.trunk.PrepareForUpdate(key[:])\n\t}\n}\n\nfunc (sms *SimpleMultiStore) Close(writeBack bool) {\n\tif writeBack {\n\t\tsms.writeBack()\n\t}\n}\n\nfunc (sms *SimpleMultiStore) writeBack() {\n\tsms.trunk.Update(func(cache *store.CacheStore) {\n\t\tsms.cache.ScanAllEntries(func(key, value []byte, isDeleted bool) {\n\t\t\tif isDeleted {\n\t\t\t\tcache.Delete(key)\n\t\t\t} else {\n\t\t\t\tcache.Set(key, value)\n\t\t\t}\n\t\t})\n\t})\n}\n\n"}
{"sample": "package circbuffer\n\nimport \"errors\"\n\ntype CircularBuffer struct {\n\tbuffer []interface{}\n\tsize   int\n\thead   int\n\ttail   int\n}\n\nfunc NewCircularBuffer(size int) *CircularBuffer {\n\treturn &CircularBuffer{\n\t\tbuffer: make([]interface{}, size),\n\t\tsize:   size,\n\t\thead:   0,\n\t\ttail:   0,\n\t}\n}\n\nfunc (cb *CircularBuffer) Add(item interface{}) error {\n\tif cb.IsFull() {\n\t\treturn errors.New(\"buffer is full\")\n\t}\n\n\tcb.buffer[cb.tail] = item\n\tcb.tail = (cb.tail + 1) % cb.size\n\treturn nil\n}\n\nfunc (cb *CircularBuffer) Remove() (interface{}, error) {\n\tif cb.IsEmpty() {\n\t\treturn nil, errors.New(\"buffer is empty\")\n\t}\n\n\titem := cb.buffer[cb.head]\n\tcb.head = (cb.head + 1) % cb.size\n\treturn item, nil\n}\n\nfunc (cb *CircularBuffer) IsFull() bool {\n\treturn (cb.tail+1)%cb.size == cb.head\n}\n\nfunc (cb *CircularBuffer) IsEmpty() bool {\n\treturn cb.head == cb.tail\n}"}
{"sample": "package networkmon\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/google/gopacket\"\n\t\"github.com/google/gopacket/layers\"\n\t\"github.com/google/gopacket/pcap\"\n)\n\nfunc StartMonitoring(device string) error {\n\thandle, err := pcap.OpenLive(device, 65535, true, pcap.BlockForever)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error opening device: %v\", err)\n\t}\n\tdefer handle.Close()\n\n\terr = handle.SetBPFFilter(\"tcp and port 80\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error setting BPF filter: %v\", err)\n\t}\n\n\tpacketSource := gopacket.NewPacketSource(handle, handle.LinkType())\n\n\tfor packet := range packetSource.Packets() {\n\t\t// Extract the TCP layer from the packet\n\t\ttcpLayer := packet.Layer(layers.LayerTypeTCP)\n\t\tif tcpLayer == nil {\n\t\t\tcontinue\n\t\t}\n\t\ttcp, ok := tcpLayer.(*layers.TCP)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Extract the IP layer from the packet\n\t\tipLayer := packet.Layer(layers.LayerTypeIPv4)\n\t\tif ipLayer == nil {\n\t\t\tcontinue\n\t\t}\n\t\tip, ok := ipLayer.(*layers.IPv4)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Print the source and destination IP addresses and ports\n\t\tfmt.Printf(\"%s:%d -> %s:%d\\n\", net.IP(ip.SrcIP), tcp.SrcPort, net.IP(ip.DstIP), tcp.DstPort)\n\t}\n}\n\nfunc ReportTraffic() {\n\t// Generate a report of network traffic every hour\n\tfor {\n\t\ttime.Sleep(time.Hour)\n\n\t\t// TODO: Implement code to generate report\n\t\tlog.Println(\"Generating network traffic report\")\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"golang.org/x/net/http2\"\n)\n\nfunc EnableHTTP2() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, HTTP/2!\")\n\t})\n\n\thttp2.ConfigureServer(http.DefaultServer, &http2.Server{})\n\thttp.ListenAndServeTLS(\":8080\", \"cert.pem\", \"key.pem\", nil)\n}\n"}
{"sample": "package bogosort\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc isSorted(arr []int) bool {\n\tfor i := 1; i < len(arr); i++ {\n\t\tif arr[i] < arr[i-1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc shuffle(arr []int) {\n\trand.Seed(time.Now().UnixNano())\n\tfor i := len(arr) - 1; i > 0; i-- {\n\t\tj := rand.Intn(i + 1)\n\t\tarr[i], arr[j] = arr[j], arr[i]\n\t}\n}\n\nfunc BogoSort(arr []int) []int {\n\tfor !isSorted(arr) {\n\t\tshuffle(arr)\n\t}\n\treturn arr\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// CapitalizeString capitalizes the first letter of a given string.\nfunc CapitalizeString(str string) string {\n\treturn strings.Title(str)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tstr := \"hello world\"\n\tcontains := strings.Contains(str, \"world\")\n\n\tfmt.Println(contains)\n}"}
{"sample": "func HashPassword(password string) (string, error) {\n\tbytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\treturn string(bytes), err\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n)\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\tscanner := bufio.NewScanner(conn)\n\tfor scanner.Scan() {\n\t\tmsg := scanner.Text()\n\t\tfmt.Printf(\"Received message: %s\\n\", msg)\n\t\treply := fmt.Sprintf(\"Echo: %s\\n\", msg)\n\t\tconn.Write([]byte(reply))\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Println(err)\n\t}\n}\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfmt.Println(\"Server listening on port 8080\")\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}"}
{"sample": "package imagemeta\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/rwcarlsen/goexif/exif\"\n)\n\nfunc getExifMetadata(filename string) (map[string]interface{}, error) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\tx, err := exif.Decode(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := map[string]interface{}{}\n\tif len(x) == 0 {\n\t\treturn result, fmt.Errorf(\"no exif data\")\n\t}\n\n\tcammodel, err := x.Get(exif.Model)\n\tif err == nil {\n\t\tresult[\"Model\"] = cammodel.String()\n\t}\n\n\texptime, err := x.Get(exif.ExposureTime) \n\tif err == nil {\n\t\tresult[\"ExposureTime\"] = exptime.String() \n\t}\n\n   //... Extract additional metadata fields as needed\n\n\treturn result, nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// CountVowels counts the number of vowels in a given string.\nfunc CountVowels(str string) int {\n\tcount := 0\n\tfor _, char := range str {\n\t\tswitch char {\n\t\tcase 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintTable prints the multiplication table of a given number up to a specified limit.\nfunc PrintTable(num, limit int) {\n\tfor i := 1; i <= limit; i++ {\n\t\tresult := num * i\n\t\tfmt.Printf(\"%d x %d = %d\\n\", num, i, result)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadFile reads and returns the content of a file.\nfunc ReadFile(filePath string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// WriteFile writes the content to a file.\nfunc WriteFile(filePath string, content []byte) error {\n\treturn ioutil.WriteFile(filePath, content, 0644)\n}"}
{"sample": "type Counter struct {\n\tcount int\n\tmu    sync.Mutex\n}\n\nfunc (c *Counter) Increment() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.count++\n}\n\nfunc (c *Counter) Value() int {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.count\n}"}
{"sample": "func (s *Stack) Peek() (int, error) {\n\tif len(s.items) == 0 {\n\t\treturn 0, errors.New(\"Empty Stack\")\n\t}\n\treturn s.items[len(s.items)-1], nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// ReverseSlice reverses the elements of a given slice in place.\nfunc ReverseSlice(nums []int) {\n\tfor i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n\t\tnums[i], nums[j] = nums[j], nums[i]\n\t}\n}"}
{"sample": "package blockchain\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Block struct {\n\tTimestamp    int64\n\tData         []byte\n\tPreviousHash []byte\n\tHash         []byte\n}\n\ntype Blockchain struct {\n\tBlocks []*Block\n}\n\nfunc (b *Block) SetHash() {\n\ttimestamp := []byte(fmt.Sprint(b.Timestamp))\n\theaders := bytes.Join([][]byte{b.PreviousHash, b.Data, timestamp}, []byte{})\n\thash := sha256.Sum256(headers)\n\tb.Hash = hash[:]\n}\n\nfunc (bc *Blockchain) AddBlock(data string) {\n\tpreviousBlock := bc.Blocks[len(bc.Blocks)-1]\n\tnewBlock := &Block{\n\t\tTimestamp:    time.Now().Unix(),\n\t\tData:         []byte(data),\n\t\tPreviousHash: previousBlock.Hash,\n\t}\n\tnewBlock.SetHash()\n\tbc.Blocks = append(bc.Blocks, newBlock)\n}\n\nfunc NewBlockchain() *Blockchain {\n\tgenesisBlock := &Block{\n\t\tTimestamp:    time.Now().Unix(),\n\t\tData:         []byte(\"Genesis Block\"),\n\t\tPreviousHash: []byte{},\n\t}\n\tgenesisBlock.SetHash()\n\treturn &Blockchain{Blocks: []*Block{genesisBlock}}\n}\n\nfunc (b *Block) String() string {\n\treturn fmt.Sprintf(\"Timestamp: %d\\nData: %s\\nPrevious Hash: %x\\nHash: %x\\n\", b.Timestamp, b.Data, b.PreviousHash, b.Hash)\n}\n\nfunc (bc *Blockchain) String() string {\n\tvar blocks string\n\tfor _, b := range bc.Blocks {\n\t\tblocks += b.String() + \"\\n\"\n\t}\n\treturn blocks\n}"}
{"sample": "package main\n\n// Write content to file\nfunc main() {\n\terr := ioutil.WriteFile(\"file.txt\", []byte(\"Hello, World!\"), 0644)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package mariadbclient\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID       int\n\tUsername string\n\tEmail    string\n}\n\nfunc CreateUser(username, email string) error {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tstmt, err := db.Prepare(\"INSERT INTO users(username, email) VALUES(?, ?)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(username, email)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc GetUser(id int) (*User, error) {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer db.Close()\n\n\trow := db.QueryRow(\"SELECT id, username, email FROM users WHERE id=?\", id)\n\n\tvar user User\n\terr = row.Scan(&user.ID, &user.Username, &user.Email)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn nil, fmt.Errorf(\"User not found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn &user, nil\n}\n\nfunc UpdateUser(id int, username, email string) error {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tstmt, err := db.Prepare(\"UPDATE users SET username=?, email=? WHERE id=?\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(username, email, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc DeleteUser(id int) error {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tstmt, err := db.Prepare(\"DELETE FROM users WHERE id=?\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc GetAllUsers() ([]User, error) {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT id, username, email FROM users\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tusers := []User{}\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Email)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\n\treturn users, nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintPowers prints the powers of a given number up to a specified limit.\nfunc PrintPowers(base, limit int) {\n\tfor i := 0; i <= limit; i++ {\n\t\tresult := int(math.Pow(float64(base), float64(i)))\n\t\tfmt.Println(result)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(ComputePower(2, 3))\n}\n\n// Function to compute power of a number\nfunc ComputePower(base, exponent int) int {\n\tresult := 1\n\tfor i := 0; i < exponent; i++ {\n\t\tresult *= base\n\t}\n\treturn result\n}"}
{"sample": "package urls\n\nfunc generateShortURL(longURL string) (string, error) {\n\t// Connect to database and create new entry\n\tdbConn, err := sql.Open(\"mysql\", \"user:password@tcp(dbhost:pass)/key_database\")\n\tdefer dbConn.Close()\n\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to connect to database: %v\\n\", err)\n\t\treturn \"\", err\n\t}\n\n\tshortURL := generateUniqueShortUri()\n\n\tstmt, err := dbConn.Prepare(\"INSERT INTO urls VALUES (?,?)\")\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to prepare statement: %v\\n\", err)\n\t\treturn \"\", err\n\t}\n\n\t_, err = stmt.Exec(shortURL, longURL)\n\n\tif err != nil {\n \t\tfmt.Printf(\"Failed to execute query: %v\\n\", err)\n  \t\treturn \"\", err\n     }\n       \n       return fmt.Sprintf(\"shrt.isbd/%v\",shortURL) , nil        \n\t}\n\nfunc generateUniqueShortURI() string {\n\telems := []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\")\n\tcharSizes := rand.Perm(len(elems))[:4]\n\n\t//rand number to shuffle\n\tnAmt := [4]int32{}\n\n\tvar shortUrI string\n\n\tfor i := 0; i < len(nAmt); i++ {\n\t\tletidxtest := rand.Intn(charSizes[i] + 1)\n\t\tletidxrand := (nAmt[i] + int32(letidxtest % charSizes[i])) % int32(charSizes[i])\n\n\t\tnAmt[i] = letidxrand\n\n\t\tshortUrI = shortUrI + string(elems[letidxrand])\n\t}\n\n\ttimestamp := strconv.FormatInt(time.Now().UnixNano(), 16)\n\n\tshortUrI = shortUrI + \".\" + timestamp\n\n\treturn shortUrI\n}"}
{"sample": "package expenseservice\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"time\"\n)\n\ntype Expense struct {\n\tID          int\n\tDescription string\n\tAmount      float64\n\tDate        time.Time\n}\n\ntype ExpenseService struct {\n\tdb *sql.DB\n}\n\nfunc NewExpenseService(db *sql.DB) *ExpenseService {\n\treturn &ExpenseService{db: db}\n}\n\nfunc (es *ExpenseService) CreateExpense(e *Expense) error {\n\tif e == nil {\n\t\treturn errors.New(\"expense cannot be nil\")\n\t}\n\n\tstmt, err := es.db.Prepare(\"INSERT INTO expenses(description, amount, date) VALUES(?,?,?)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tresult, err := stmt.Exec(e.Description, e.Amount, e.Date)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tid, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\te.ID = int(id)\n\n\treturn nil\n}\n\nfunc (es *ExpenseService) GetExpense(id int) (*Expense, error) {\n\tstmt, err := es.db.Prepare(\"SELECT id, description, amount, date FROM expenses WHERE id = ?\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\trow := stmt.QueryRow(id)\n\n\tvar e Expense\n\terr = row.Scan(&e.ID, &e.Description, &e.Amount, &e.Date)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn &e, nil\n}\n\nfunc (es *ExpenseService) GetExpenses() ([]Expense, error) {\n\trows, err := es.db.Query(\"SELECT id, description, amount, date FROM expenses\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar expenses []Expense\n\tfor rows.Next() {\n\t\tvar e Expense\n\t\terr = rows.Scan(&e.ID, &e.Description, &e.Amount, &e.Date)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\texpenses = append(expenses, e)\n\t}\n\n\treturn expenses, nil\n}"}
{"sample": "func CreateFile(filename string) (*os.File, error) {\n\treturn os.Create(filename)\n}\n\nfunc WriteStringToFile(f *os.File, s string) (int, error) {\n\treturn f.WriteString(s)\n}\n\nfunc CloseFile(f *os.File) error {\n\treturn f.Close()\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/mongodb/mongo-go-driver/mongo\"\n)\n\nfunc main() {\n\t// Connect to MongoDB\n\tclient, err := mongo.NewClient(\"mongodb://localhost:27017\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = client.Connect(context.Background())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Access a database and a collection\n\tdb := client.Database(\"mydatabase\")\n\tcoll := db.Collection(\"mycollection\")\n\n\t// Insert a document\n\tdoc := map[string]interface{}{\n\t\t\"name\": \"John Doe\",\n\t\t\"age\":  30,\n\t}\n\tres, err := coll.InsertOne(context.Background(), doc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(res.InsertedID)\n\n\t// Find documents\n\tcursor, err := coll.Find(context.Background(), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer cursor.Close(context.Background())\n\tfor cursor.Next(context.Background()) {\n\t\tvar result map[string]interface{}\n\t\terr = cursor.Decode(&result)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(result)\n\t}\n\tif cursor.Err() != nil {\n\t\tpanic(cursor.Err())\n\t}\n\n\t// Disconnect from MongoDB\n\terr = client.Disconnect(context.Background())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\t\"cloud.google.com/go/storage\"\n\t\"google.golang.org/api/option\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Setup GCP client\n\tcredentials, err := ioutil.ReadFile(\"key.json\") // replace with path to your keyfile\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read key.json file with error: %v\", err)\n\t}\n\n\tclient, err := storage.NewClient(ctx, option.WithCredentialsJSON(credentials))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create client with error: %v\", err)\n\t}\n\tdefer client.Close()\n\n\t// Upload file to a bucket\n\tbucketName := \"example-bucket\"\n\tfilePath := \"example.txt\"\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open file with error: %v\", err)\n\t}\n\tdefer file.Close()\n\n\tobj := client.Bucket(bucketName).Object(file.Name())\n\twriter := obj.NewWriter(ctx)\n\tif _, err := writer.ReadFrom(file); err != nil {\n\t\tlog.Fatalf(\"Failed to read from file with error: %v\", err)\n\t}\n\tif err := writer.Close(); err != nil {\n\t\tlog.Fatalf(\"Failed to close writer with error: %v\", err)\n\t}\n\n\tfmt.Println(\"File uploaded successfully.\")\n}"}
{"sample": "// Set the request body as JSON\nfunc SetJSONBody(request *http.Request, payload interface{}) error {\n\tdata, err := json.Marshal(payload)\n\tif err != nil {\n\t\treturn err\n\t}\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\trequest.Body = ioutil.NopCloser(bytes.NewBuffer(data))\n\treturn nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadFile reads and returns the content of a file.\nfunc ReadFile(filePath string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// WriteFile writes the content to a file.\nfunc WriteFile(filePath string, content []byte) error {\n\treturn ioutil.WriteFile(filePath, content, 0644)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\targs := os.Args\n\tif len(args) < 2 {\n\t\tfmt.Printf(\"Usage: %s <file path>\\n\", args[0])\n\t\tos.Exit(1)\n\t}\n\n\tfilePath := args[1]\n\tjsonFile, err := os.Open(filePath)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\tdefer jsonFile.Close()\n\n\ttype User struct {\n\t\tName  string `json:\"name\"`\n\t\tEmail string `json:\"email\"`\n\t\tAge   int    `json:\"age\"`\n\t}\n\n\tdecoder := json.NewDecoder(jsonFile)\n\tdecoder.DisallowUnknownFields()\n\n\tusers := []User{}\n\n\tif err := decoder.Decode(&users); err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Successfully parsed %d users\", len(users))\n}"}
{"sample": "// Reading from a file\n\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\ndata, err := ioutil.ReadAll(file)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package platformclientv2\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Roledivision\ntype Roledivision struct { \n\t// RoleId - Role to be associated with the given division which forms a grant\n\tRoleId *string `json:\"roleId,omitempty\"`\n\n\n\t// DivisionId - Division associated with the given role which forms a grant\n\tDivisionId *string `json:\"divisionId,omitempty\"`\n\n}\n\n// String returns a JSON representation of the model\nfunc (o *Roledivision) String() string {\n\tj, _ := json.Marshal(o)\n\tstr, _ := strconv.Unquote(strings.Replace(strconv.Quote(string(j)), `\\\\u`, `\\u`, -1))\n\n\treturn str\n}\n"}
{"sample": "http.HandleFunc(\"/orders\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle orders endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get orders\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create order\")\n\t}\n})\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\n\t// Some expensive computation\n\tsum := 0\n\tfor i := 0; i < 1000000000; i++ {\n\t\tsum += i\n\t}\n\n\telapsed := time.Since(start)\n\tfmt.Printf(\"Computation took %s\", elapsed)\n}"}
{"sample": "for i := 0; i < 5; i++ {\n\tfmt.Println(i)\n}\n"}
{"sample": "// Counter represents a simple counter.\ntype Counter struct {\n\tvalue int64\n}\n\n// NewCounter creates a new Counter.\nfunc NewCounter() *Counter {\n\treturn &Counter{value: 0}\n}\n\n// Increment increments the Counter by one.\nfunc (c *Counter) Increment() {\n\tatomic.AddInt64(&c.value, 1)\n}\n\n// Value returns the current value of the Counter.\nfunc (c *Counter) Value() int64 {\n\treturn atomic.LoadInt64(&c.value)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\tsig := make(chan os.Signal, 1)\n\t\tsignal.Notify(sig, os.Interrupt)\n\t\t<-sig\n\t\tcancel()\n\t}()\n\n\tfmt.Println(\"Starting application...\")\n\tfmt.Println(\"Press Ctrl+C to stop\")\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"Stopping application...\")\n\t\tos.Exit(0)\n\tcase <-time.After(10 * time.Minute):\n\t\tfmt.Println(\"Application timed out\")\n\t\tos.Exit(1)\n\t}\n}"}
{"sample": "package core\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype MinionTestSuite struct {\n\tsuite.Suite\n}\n\nfunc TestMinionTestSuite(t *testing.T) {\n\tsuite.Run(t, new(MinionTestSuite))\n}\n\nfunc (suite *MinionTestSuite) TestFinishNormal() {\n\n\tmock := childForTest()\n\tminion := NewMinion(mock)\n\tctx := context.Background()\n\n\tsuite.Nil(minion.Run(ctx))\n\tsuite.True(mock.finished)\n\tsuite.False(mock.stopped)\n}\n\nfunc (suite *MinionTestSuite) TestStopProcessing() {\n\n\tmock := childForTest()\n\tminion := NewMinion(mock)\n\tctx := context.Background()\n\n\tgo minion.Run(ctx)\n\ttime.Sleep(2 * time.Second)\n\tminion.Stop()\n\n\ttime.Sleep(1 * time.Second)\n\tsuite.True(mock.counter > 1)\n\tsuite.False(mock.finished)\n\tsuite.True(mock.stopped)\n}\n\nfunc (suite *MinionTestSuite) TestWithoutChild() {\n\n\tminion := NewMinion(nil)\n\tctx := context.Background()\n\n\tsuite.NotNil(minion.Run(ctx))\n}\n\nfunc (suite *MinionTestSuite) TestProcessingError() {\n\n\tmock := childForTest()\n\tmock.shouldEndWithError = true\n\tminion := NewMinion(mock)\n\tctx := context.Background()\n\n\tsuite.NotNil(minion.Run(ctx))\n\tsuite.True(mock.finished)\n\tsuite.False(mock.stopped)\n}\n\nfunc (suite *MinionTestSuite) TestStopProcessingOnOsSignals() {\n\n\tmock := childForTest()\n\tosSignalChan := make(chan os.Signal)\n\tminion := NewMinion(mock)\n\tminion.sigObserver = newSigObserverWithChan(osSignalChan)\n\tctx := context.Background()\n\n\tgo minion.Run(ctx)\n\ttime.Sleep(2 * time.Second)\n\tosSignalChan <- syscall.SIGTERM\n\n\ttime.Sleep(1 * time.Second)\n\tsuite.True(mock.counter > 1)\n\tsuite.False(mock.finished)\n\tsuite.True(mock.stopped)\n}\n"}
{"sample": "package main\n\n// Read a line from a file using a buffered reader\nfunc main() {\n\tfile, _ := os.Open(\"file.txt\")\n\tdefer file.Close()\n\treader := bufio.NewReader(file)\n\tline, err := reader.ReadString('\\n')\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(line)\n}\n"}
{"sample": "// Send a GET request to the specified URL\nfunc Get(url string) (*http.Response, error) {\n\tresponse, err := http.Get(url)\n\treturn response, err\n}\n"}
{"sample": "type Writer interface {\n\tWrite(p []byte) (n int, err error)\n}\ntype MyWriter struct{}\nfunc (m MyWriter) Write(p []byte) (int, error) {\n\treturn len(p), nil\n}\n"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\n"}
{"sample": "package loadbalancer\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype LoadBalancer struct {\n\tmu       sync.Mutex\n\tservers  []*http.Server\n\tnext     int\n\tmaxTries int\n}\n\nfunc NewLoadBalancer(servers []*http.Server, maxTries int) *LoadBalancer {\n\treturn &LoadBalancer{\n\t\tservers:  servers,\n\t\tmaxTries: maxTries,\n\t}\n}\n\nfunc (lb *LoadBalancer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tlb.mu.Lock()\n\tdefer lb.mu.Unlock()\n\n\tfor i := 0; i < lb.maxTries; i++ {\n\t\tserver := lb.servers[lb.next]\n\t\tlb.next = (lb.next + 1) % len(lb.servers)\n\t\tif server == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tresp, err := http.Get(fmt.Sprintf(\"http://%s%s\", server.Addr, r.URL.Path))\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tfor k, v := range resp.Header {\n\t\t\tw.Header().Set(k, v[0])\n\t\t}\n\n\t\tw.WriteHeader(resp.StatusCode)\n\t\tresp.Write(w)\n\n\t\treturn\n\t}\n\n\thttp.Error(w, \"No available servers\", http.StatusServiceUnavailable)\n}\n\nfunc (lb *LoadBalancer) RandomServer() *http.Server {\n\treturn lb.servers[rand.Intn(len(lb.servers))]\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Multiply multiplies two integers and returns the result.\nfunc Multiply(a, b int) int {\n\treturn a * b\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/\", homeHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/about\", aboutHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/contact\", contactHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/user/{id:[0-9]+}\", userHandler).Methods(\"GET\")\n\n\tsrv := &http.Server{\n\t\tHandler:      r,\n\t\tAddr:         \"127.0.0.1:8080\",\n\t\tWriteTimeout: 15 * time.Second,\n\t\tReadTimeout:  15 * time.Second,\n\t}\n\n\tfmt.Println(\"Server listening on port 8080\")\n\tif err := srv.ListenAndServe(); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"Welcome to my website!\")\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"This is my personal website.\")\n}\n\nfunc contactHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"You can contact me at example@example.com.\")\n}\n\nfunc userHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid := vars[\"id\"]\n\n\tfmt.Fprintf(w, \"User ID: %v\", id)\n}"}
{"sample": "info, err := os.Stat(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Println(\"File size:\", info.Size())\n"}
{"sample": "package main\n\n// IsError checks if the error is not nil\nfunc IsError(err error) bool {\n\treturn err != nil\n}\n"}
{"sample": "package sysmon\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/shirou/gopsutil/cpu\"\n\t\"github.com/shirou/gopsutil/disk\"\n\t\"github.com/shirou/gopsutil/mem\"\n)\n\nfunc MonitorSystemMetrics() {\n\tfor {\n\t\tcpuPercent, err := cpu.Percent(time.Second, false)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error getting CPU usage:\", err)\n\t\t} else {\n\t\t\tlog.Println(\"CPU usage:\", cpuPercent)\n\t\t}\n\n\t\tvirtualMem, err := mem.VirtualMemory()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error getting memory usage:\", err)\n\t\t} else {\n\t\t\tlog.Println(\"Memory usage:\", virtualMem.UsedPercent)\n\t\t}\n\n\t\tpartitions, err := disk.Partitions(false)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error getting disk partitions:\", err)\n\t\t}\n\n\t\tfor _, partition := range partitions {\n\t\t\tdiskUsage, err := disk.Usage(partition.Mountpoint)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Error getting disk usage:\", err)\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"Disk usage for %s: %f%%\\n\", partition.Mountpoint, diskUsage.UsedPercent)\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(time.Minute)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gorilla/websocket\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/echo\", func(w http.ResponseWriter, r *http.Request) {\n\t\tupgrader := websocket.Upgrader{}\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error upgrading to WebSocket connection:\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tfor {\n\t\t\tmessageType, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading message from WebSocket connection:\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfmt.Println(\"Received message:\", string(message))\n\n\t\t\terr = conn.WriteMessage(messageType, message)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error writing message to WebSocket connection:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int) {\n\tfor j := range jobs {\n\t\tfmt.Println(\"Worker\", id, \"started job\", j)\n\t\tresults <- j * 2\n\t\tfmt.Println(\"Worker\", id, \"finished job\", j)\n\t}\n}\n\nfunc main() {\n\tnumJobs := 10\n\tjobs := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\n\t// Start 3 workers\n\tnumWorkers := 3\n\tvar wg sync.WaitGroup\n\twg.Add(numWorkers)\n\tfor w := 1; w <= numWorkers; w++ {\n\t\tgo func(w int) {\n\t\t\tdefer wg.Done()\n\t\t\tworker(w, jobs, results)\n\t\t}(w)\n\t}\n\n\t// Add jobs to the queue\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\t// Collect results\n\tfor a := 1; a <= numJobs; a++ {\n\t\t<-results\n\t}\n\twg.Wait()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"ls\", \"-l\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tfmt.Println(\"Error running command:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(output))\n}"}
{"sample": "package driveclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"google.golang.org/api/drive/v3\"\n\t\"google.golang.org/api/option\"\n)\n\ntype DriveClient struct {\n\tservice *drive.Service\n}\n\nfunc NewDriveClient(credentialsFile string) (*DriveClient, error) {\n\tctx := context.Background()\n\n\tcreds, err := os.ReadFile(credentialsFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to read client secret file: %v\", err)\n\t}\n\n\tconfig, err := google.ConfigFromJSON(creds, drive.DriveScope)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse client secret file to config: %v\", err)\n\t}\n\n\tclient := getClient(ctx, config)\n\n\tsrv, err := drive.NewService(ctx, option.WithHTTPClient(client))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to retrieve Drive client: %v\", err)\n\t}\n\n\treturn &DriveClient{service: srv}, nil\n}\n\nfunc (c *DriveClient) UploadFile(filename string, r io.Reader) error {\n\tfile := &drive.File{Name: filename}\n\t_, err := c.service.Files.Create(file).Media(r).Do()\n\tif err != nil {\n\t\tlog.Printf(\"Unable to upload file: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc getClient(ctx context.Context, config *oauth2.Config) *http.Client {\n\ttokenFile := \"token.json\"\n\ttok, err := tokenFromFile(tokenFile)\n\tif err != nil {\n\t\ttok = getTokenFromWeb(config)\n\t\tsaveToken(tokenFile, tok)\n\t}\n\treturn config.Client(ctx, tok)\n}\n\nfunc getTokenFromWeb(config *oauth2.Config) *oauth2.Token {\n\tauthURL := config.AuthCodeURL(\"state-token\", oauth2.AccessTypeOffline)\n\tfmt.Printf(\"Go to the following link in your browser then type the \"+\n\t\t\"authorization code: \\n%v\\n\", authURL)\n\n\tvar authCode string\n\tif _, err := fmt.Scan(&authCode); err != nil {\n\t\tlog.Fatalf(\"Unable to read authorization code: %v\", err)\n\t}\n\n\ttok, err := config.Exchange(context.Background(), authCode)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve token from web: %v\", err)\n\t}\n\treturn tok\n}\n\nfunc tokenFromFile(file string) (*oauth2.Token, error) {\n\tf, err := os.Open(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\ttok := &oauth2.Token{}\n\terr = json.NewDecoder(f).Decode(tok)\n\treturn tok, err\n}\n\nfunc saveToken(file string, token *oauth2.Token) {\n\tlog.Printf(\"Saving credential file to: %s\\n\", file)\n\tf, err := os.OpenFile(file, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to cache oauth token: %v\", err)\n\t}\n\tdefer f.Close()\n\tjson.NewEncoder(f).Encode(token)\n}"}
{"sample": "absPath, err := filepath.Abs(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Println(\"Absolute path:\", absPath)\n"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n\t// Set up a context\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Create a client\n\tclient, err := mongo.Connect(ctx, options.Client().ApplyURI(\"mongodb://localhost:27017\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Check the connection\n\terr = client.Ping(ctx, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Start server\n\tserver := NewServer()\n\n\tgo func() {\n\t\tfmt.Println(\"Server starting on port 8080...\")\n\t\tif err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"listen: %s\\n\", err)\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t<-quit\n\tfmt.Println(\"Server shutting down...\")\n\n\tctxShutDown, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer func() {\n\t\tcancel()\n\t}()\n\n\tif err := server.Shutdown(ctxShutDown); err != nil {\n\t\tserver.Close()\n\t\tlog.Fatal(\"Server forced to shutdown:\", err)\n\t}\n\n\tif err := client.Disconnect(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Println(\"Server exiting\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"encoding/json\"\n\t\"os\"\n)\n\n// Person represents a person entity\n\ntype Person struct {\n\tName string `json:\"name\"`\n\tAge  int    `json:\"age\"`\n}\n\nfunc main() {\n\tperson := Person{Name: \"John Doe\", Age: 30}\n\n\tfile, err := os.Create(\"person.json\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tencoder := json.NewEncoder(file)\n\terr = encoder.Encode(person)\n\tif err != nil {\n\t\tfmt.Println(\"Error encoding JSON:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Person encoded and written to file\")\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintSumOfEvenNumbersInArray([]int{1, 2, 3, 4, 5})\n}\n\n// Function to print the sum of even numbers in an array\nfunc PrintSumOfEvenNumbersInArray(arr []int) {\n\tsum := 0\n\tfor _, value := range arr {\n\t\tif value%2 == 0 {\n\t\t\tsum += value\n\t\t}\n\t}\n\tfmt.Println(sum)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/BurntSushi/toml\"\n\t\"github.com/SonarBeserk/sophie-go/internal/commands\"\n\t\"github.com/SonarBeserk/sophie-go/internal/db\"\n\t\"github.com/SonarBeserk/sophie-go/internal/embed\"\n\t\"github.com/SonarBeserk/sophie-go/internal/emote\"\n\t\"github.com/SonarBeserk/sophie-go/internal/helpers\"\n\t\"github.com/bwmarrin/discordgo\"\n)\n\n// Config represents the configuration for the bot\ntype Config struct {\n\tEmotes []emote.Emote `toml:\"emote\"`\n\tGifs   []emote.Gif   `toml:\"gif\"`\n}\n\n// Variables used for command line parameters\nvar (\n\tToken        string\n\temotesFile   string\n\tdatabaseFile string\n\n\tdatabase *db.Database\n\n\tcmds map[string]commands.Func = map[string]commands.Func{\n\t\t\"emotes\": commands.HandleListEmotes,\n\t}\n\n\tdatabaseCtx embed.ContextKey = \"db\"\n)\n\nfunc init() {\n\tflag.StringVar(&Token, \"t\", \"\", \"Bot Token\")\n\tflag.StringVar(&emotesFile, \"emotes\", \"./emotes.toml\", \"Path to file containing emotes\")\n\tflag.StringVar(&databaseFile, \"db\", \"./data.db\", \"Path to database\")\n\tflag.Parse()\n}\n\nfunc main() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Exception: %v\\n\", err)\n\t\t}\n\t}()\n\n\terr := loadEmoteMaps(emotesFile)\n\tif err != nil {\n\t\tfmt.Printf(\"Error loading emotes file %s: %v\\n\", emotesFile, err)\n\t\treturn\n\t}\n\n\tdb, err := db.OpenOrConfigureDatabase(databaseFile)\n\tif err != nil {\n\t\tfmt.Printf(\"Error loading database file %s: %v\\n\", databaseFile, err)\n\t}\n\n\tdatabase = db\n\tdefer database.Close()\n\n\t// Create a new Discord session using the provided bot token.\n\tdg, err := discordgo.New(\"Bot \" + Token)\n\tif err != nil {\n\t\tfmt.Printf(\"Error creating Discord session: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Register the messageCreate func as a callback for MessageCreate events.\n\tdg.AddHandler(messageCreate)\n\tdg.AddHandler(guildMemberUpdate)\n\n\t// Open a websocket connection to Discord and begin listening.\n\terr = dg.Open()\n\tif err != nil {\n\t\tfmt.Printf(\"Error opening connection: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Wait here until CTRL-C or other term signal is received.\n\tfmt.Println(\"Bot is now running.  Press CTRL-C to exit.\")\n\tsc := make(chan os.Signal, 1)\n\tsignal.Notify(sc, syscall.SIGINT, syscall.SIGTERM, os.Interrupt, os.Kill)\n\t<-sc\n\n\t// Cleanly close down the Discord session.\n\tdg.Close()\n}\n\nfunc loadEmoteMaps(path string) error {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar conf Config\n\tif _, err := toml.Decode(string(data), &conf); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, emote := range conf.Emotes {\n\t\tcommands.AddEmote(emote)\n\t\tcmds[emote.Verb] = commands.HandleEmote\n\t}\n\n\tfor _, gif := range conf.Gifs {\n\t\tcommands.AddEmoteImage(gif)\n\t}\n\n\treturn nil\n}\n\n// This function will be called (due to AddHandler above) every time a new\n// message is created on any channel that the authenticated bot has access to.\nfunc messageCreate(s *discordgo.Session, m *discordgo.MessageCreate) {\n\t// Ignore all messages created by the bot itself\n\t// This isn't required in this specific example but it's a good practice.\n\tif m.Author.ID == s.State.User.ID {\n\t\treturn\n\t}\n\n\tisPrivate, err := helpers.IsPrivateChat(s, m.ChannelID)\n\tif err != nil {\n\t\tfmt.Printf(\"Error occurred verifying channel type %s %v\\n\", m.ChannelID, err)\n\t}\n\n\tif isPrivate {\n\t\tfmt.Println(\"Ignoring private chat\")\n\t\treturn\n\t}\n\n\tuserName, err := helpers.GetUserName(s, m.GuildID, s.State.User.ID)\n\tif err != nil {\n\t\tfmt.Printf(\"Error occurred determining guild username %s %v\\n\", m.GuildID, err)\n\t}\n\n\tmsgParts := strings.Split(m.Content, \" \")\n\n\tif len(msgParts) <= 1 {\n\t\treturn\n\t}\n\n\tname := strings.ToLower(msgParts[0])\n\n\tif !strings.HasPrefix(name, strings.ToLower(userName)) && !strings.HasPrefix(name, strings.ToLower(s.State.User.Username)) {\n\t\treturn\n\t}\n\n\tcmd := strings.ToLower(msgParts[1])\n\n\tc := context.Background()\n\tctx := context.WithValue(c, databaseCtx, *database)\n\n\tcmdFunc := cmds[cmd]\n\tif cmdFunc == nil {\n\t\treturn\n\t}\n\n\terr = cmdFunc(ctx, s, msgParts[1:], m.GuildID, m.Author.ID, m.ChannelID)\n\tif err != nil {\n\t\tfmt.Printf(\"Error ocurred running command: %v\", err)\n\t}\n}\n\nfunc guildMemberUpdate(s *discordgo.Session, gmu *discordgo.GuildMemberUpdate) {\n\tif gmu.User.ID == s.State.User.ID {\n\t\thelpers.ClearUsernameCacheByID(gmu.GuildID, s.State.User.ID)\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/rs/cors\"\n)\n\nfunc UseCors() {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, CORS!\")\n\t})\n\n\tcorsHandler := cors.Default().Handler(handler)\n\n\thttp.ListenAndServe(\":8080\", corsHandler)\n}\n"}
{"sample": "// ErrorHandlerMiddleware is a middleware that handles any error from the next function\nfunc ErrorHandlerMiddleware(next func() error) func() {\n\treturn func() {\n\t\terr := next()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n}\n"}
{"sample": "type TreeNode struct {\n\tData  int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}\n\ntype BinaryTree struct {\n\tRoot *TreeNode\n}\n\nfunc (t *BinaryTree) Insert(data int) {\n\tt.Root = insert(t.Root, data)\n}\n\nfunc insert(node *TreeNode, data int) *TreeNode {\n\tif node == nil {\n\t\treturn &TreeNode{Data: data}\n\t}\n\tif data < node.Data {\n\t\tnode.Left = insert(node.Left, data)\n\t} else {\n\t\tnode.Right = insert(node.Right, data)\n\t}\n\treturn node\n}"}
{"sample": "// ErrorHandlerWithErrorReturn handles an error with a custom handler that returns an error\nfunc ErrorHandlerWithErrorReturn(err error, handler func(error) error) error {\n\treturn handler(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tstr := \"hello world\"\n\twords := strings.Fields(str)\n\n\tfor _, word := range words {\n\t\tfmt.Println(word)\n\t}\n}"}
{"sample": "// ErrorType returns the type of the error\nfunc ErrorType(err error) reflect.Type {\n\treturn reflect.TypeOf(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nfunc UseFastHTTP() {\n\thandler := func(ctx *fasthttp.RequestCtx) {\n\t\tfmt.Fprintf(ctx, \"Hello, FastHTTP!\")\n\t}\n\n\tfasthttp.ListenAndServe(\":8080\", handler)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tdone := make(chan bool)\n\tgo func() {\n\t\tfmt.Println(\"Goroutine started\")\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine ended\")\n\t\tdone <- true\n\t}()\n\n\tfmt.Println(\"Waiting for goroutine to finish\")\n\t<-done\n\tfmt.Println(\"Goroutine finished\")\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Square calculates the square of a number and returns the result.\nfunc Square(num int) int {\n\treturn num * num\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})\n\n\tsrv := &http.Server{\n\t\tAddr: \":8080\",\n\t}\n\n\tsrv.ListenAndServe()\n}"}
{"sample": "package main\n\nimport \"sort\"\n\nfunc main() {\n\tnumbers := []int{5, 3, 8, 1}\n\tSortInts(numbers)\n\tfmt.Println(numbers)\n}\n\nfunc SortInts(nums []int) {\n\tsort.Ints(nums)\n}"}
{"sample": "type Router struct {\n\troutes map[string]http.HandlerFunc\n}\n\nfunc NewRouter() *Router {\n\treturn &Router{routes: make(map[string]http.HandlerFunc)}\n}\n\nfunc (r *Router) AddRoute(path string, handler http.HandlerFunc) {\n\tr.routes[path] = handler\n}\n\nfunc (r *Router) HandleRequests() {\n\tfor path, handler := range r.routes {\n\t\thttp.HandleFunc(path, handler)\n\t}\n}"}
{"sample": "func sum(nums []int) int {\n\ttotal := 0\n\tfor _, num := range nums {\n\t\ttotal += num\n\t}\n\treturn total\n}\n"}
{"sample": "package main\n\nfunc RemoveWhitespace(str string) string {\n\treturn strings.ReplaceAll(str, \" \", \"\")\n}\n"}
{"sample": "// Check if a number is negative\nfunc IsNegative(num int) bool {\n\treturn num < 0\n}\n"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID       int\n\tUsername string\n\tEmail    string\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to open db connection: %v\", err)\n\t}\n\tdefer db.Close()\n\n\tuser := User{\n\t\tUsername: \"johndoe\",\n\t\tEmail:    \"johndoe@example.com\",\n\t}\n\n\tresult, err := db.Exec(\"INSERT INTO users (username, email) VALUES (?, ?)\", user.Username, user.Email)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to execute query: %v\", err)\n\t}\n\n\tlastInsertID, err := result.LastInsertId()\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to retrieve last insert ID: %v\", err)\n\t}\n\n\tfmt.Printf(\"Insert successful, ID: %d\\n\", lastInsertID)\n\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to execute query: %v\", err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar retrievedUser User\n\n\t\terr := rows.Scan(&retrievedUser.ID, &retrievedUser.Username, &retrievedUser.Email)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"failed to scan row: %v\", err)\n\t\t}\n\n\t\tfmt.Printf(\"Retrieved user: %+v\\n\", retrievedUser)\n\t}\n\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Fatalf(\"encountered error while iteration rows: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintSumOfCubesOfArray([]int{1, 2, 3, 4, 5})\n}\n\n// Function to print the sum of cubes of elements in an array\nfunc PrintSumOfCubesOfArray(arr []int) {\n\tsum := 0\n\tfor _, value := range arr {\n\t\tsum += value * value * value\n\t}\n\tfmt.Println(sum)\n}"}
{"sample": "package main\n\nimport \"os\"\n\nfunc main() {\n\tCheckFileExists(\"example.txt\")\n}\n\nfunc CheckFileExists(path string) bool {\n\t_, err := os.Stat(path)\n\treturn !os.IsNotExist(err)\n}"}
{"sample": "package dnsclient\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc lookup(domain string) ([]net.IP, error) {\n\tips, err := net.LookupIP(domain)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ips, nil\n}\n\nfunc main() {\n\tdomain := \"google.com\"\n\tips, err := lookup(domain)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"IP addresses for %s:\\n\", domain)\n\tfor _, ip := range ips {\n\t\tfmt.Println(ip)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\n// Database represents a connection to a database.\ntype Database struct {\n\tconn *sql.DB\n}\n\n// ConnectToDatabase connects to a database using the given connection string.\nfunc ConnectToDatabase(connectionString string) (*Database, error) {\n\tconn, err := sql.Open(\"postgres\", connectionString)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Database{conn} nil\n}\n\n// ExecuteQuery executes the given SQL query and returns the result.\nfunc (db *Database) ExecuteQuery(query string) (*sql.Rows, error) {\n\treturn db.conn.Query(query)\n}\n\n// CloseDatabaseConnection closes the connection to the database.\nfunc (db *Database) CloseDatabaseConnection() error {\n\treturn db.conn.Close()\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"log\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/dbname\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\trows, err := db.Query(\"SELECT name, email FROM users WHERE id = ?\", 1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar name string\n\t\tvar email string\n\t\terr = rows.Scan(&name, &email)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tlog.Println(name, email)\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "func main() {\n\tdata := [][]string{{\"Name\", \"Age\"} {\"John Doe\", \"30\"} {\"Jane Smith\", \"25\"}}\n\n\tfile, err := os.Create(\"data.csv\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\tdefer writer.Flush()\n\n\tfor _, record := range data {\n\t\twriter.Write(record)\n\t}\n\n\tfmt.Println(\"Data written to CSV file\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"ls\", \"-l\")\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\terr := cmd.Run()\n\tif err != nil {\n\t\tfmt.Println(\"Error running command:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "package main\n\n// LogError logs the error\nfunc LogError(err error) {\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n"}
{"sample": "file, err := os.Create(\"file.gz\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\ngzWriter := gzip.NewWriter(file)\ndefer gzWriter.Close()\n_, err = gzWriter.Write([]byte(\"Gzip compression\\n\"))\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n)\n\nvar (\n\tusername string\n\tpassword string\n\thost     string\n\tport     string\n)\n\nfunc init() {\n\tflag.StringVar(&username, \"username\", \"\", \"username for the database connection\")\n\tflag.StringVar(&password, \"password\", \"\", \"password for the database connection\")\n\tflag.StringVar(&host, \"host\", \"localhost\", \"hostname for the database connection\")\n\tflag.StringVar(&port, \"port\", \"5432\", \"port number for the database connection\")\n\tflag.Parse()\n}\n\nfunc main() {\n\tif username == \"\" || password == \"\" {\n\t\tfmt.Println(\"Error: username and password must be provided\")\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Connecting to database as user: %s at host: %s on port: %s\", username, host, port)\n\n\t// connect to database using provided credentials\n\t// ...\n\t// ...\n\t// ...\n\n\tfmt.Println(\"Connection successful\")\n\n\t// use database for queries\n\t// ...\n\t// ...\n\t// ...\n}"}
{"sample": "package views\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/uadmin/uadmin\"\n)\n\n// HomeHandler handles the home page.\nfunc HomeHandler(w http.ResponseWriter, r *http.Request, session *uadmin.Session) {\n\t// Initialize the fields that we need in the custom struct.\n\ttype Context struct {\n\t\tUser        string\n\t\tOTPRequired bool\n\t}\n\n\t// Call the custom struct and assign the full name in the User field under the context object.\n\tc := Context{}\n\tc.User = session.User.FirstName + \" \" + session.User.LastName\n\n\t// Check if the user has OTPRequired enabled in the database.\n\tif session.User.OTPRequired {\n\t\t// Assign a boolean value to OTPRequired field. We will use this to manipulate the grammar in the UI.\n\t\tc.OTPRequired = true\n\t}\n\n\t// Render the home filepath and pass the context data object to the HTML file.\n\tuadmin.RenderHTML(w, r, \"templates/home.html\", c)\n\treturn\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(\"Hello, World!\")\n}"}
{"sample": "package main\n\n// Create a symbolic link\nfunc main() {\n\terr := os.Symlink(\"file.txt\", \"file_sym.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "func createTransaction(db *sql.DB) (*sql.Tx, error) {\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tx, nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().Unix()) // Seeding the random number generator with current time\n\n\tvar wg sync.WaitGroup // WaitGroup to collect results from goroutines\n\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\twaitTime := rand.Intn(5)\n\t\ttime.Sleep(time.Duration(waitTime) * time.Second)\n\t\tfmt.Printf(\"Goroutine 1 waited for %v seconds\\n\", waitTime)\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\twaitTime := rand.Intn(5)\n\t\ttime.Sleep(time.Duration(waitTime) * time.Second)\n\t\tfmt.Printf(\"Goroutine 2 waited for %v seconds\\n\", waitTime)\n\t}()\n\n\twg.Wait()\n\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "// Swap two numbers\nfunc SwapNumbers(a, b *int) {\n\t*a, *b = *b, *a\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc EnableCORS() {\n\thttp.HandleFunc(\"/api\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t\tw.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type\")\n\n\t\tfmt.Fprintf(w, \"API response\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n"}
{"sample": "package gcdcalc\n\nfunc gcd(a, b int) int {\n\tif b == 0 {\n\t\treturn a\n\t}\n\treturn gcd(b, a%b)\n}"}
{"sample": "package campaignservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Campaign struct {\n\tID          string\n\tName        string\n\tDescription string\n\tStartDate   time.Time\n\tEndDate     time.Time\n}\n\ntype CampaignService struct {\n\tcampaigns []*Campaign\n}\n\nfunc NewCampaignService() *CampaignService {\n\treturn &CampaignService{}\n}\n\nfunc (s *CampaignService) CreateCampaign(ctx context.Context, name string, description string, startDate time.Time, endDate time.Time) (*Campaign, error) {\n\tif name == \"\" {\n\t\treturn nil, errors.New(\"name cannot be empty\")\n\t}\n\n\tif startDate.After(endDate) {\n\t\treturn nil, errors.New(\"start date cannot be after end date\")\n\t}\n\n\tcampaign := &Campaign{\n\t\tID:          uuid.New().String(),\n\t\tName:        name,\n\t\tDescription: description,\n\t\tStartDate:   startDate,\n\t\tEndDate:     endDate,\n\t}\n\n\ts.campaigns = append(s.campaigns, campaign)\n\n\treturn campaign, nil\n}\n\nfunc (s *CampaignService) GetCampaigns(ctx context.Context) ([]*Campaign, error) {\n\treturn s.campaigns, nil\n}\n\nfunc (s *CampaignService) GetCampaignByID(ctx context.Context, id string) (*Campaign, error) {\n\tfor _, campaign := range s.campaigns {\n\t\tif campaign.ID == id {\n\t\t\treturn campaign, nil\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"campaign not found\")\n}"}
{"sample": "matches, err := filepath.Glob(\"*.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\nfor _, match := range matches {\n\tfmt.Println(match)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// create a new ticker that ticks every 1 second\n\tticker := time.NewTicker(1 * time.Second)\n\n\t// create a done channel to signal the ticker to stop\n\tdone := make(chan bool)\n\n\t// start a goroutine that will stop the ticker after 5 seconds\n\tgo func() {\n\t\ttime.Sleep(5 * time.Second)\n\t\tdone <- true\n\t}()\n\n\t// loop through the ticker channel and print the current time\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tfmt.Println(time.Now().Format(\"15:04:05\"))\n\t\tcase <-done:\n\t\t\t// stop the ticker and exit the loop\n\t\t\tticker.Stop()\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"sample": "reader := bufio.NewReader(file)\nline, err := reader.ReadString('\\n')\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Println(line)\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar num int\n\tfor {\n\t\tfmt.Print(\"Guess a number between 1 and 10: \")\n\t\tfmt.Scan(&num)\n\n\t\tif num < 1 || num > 10 {\n\t\t\tfmt.Println(\"Invalid input. Please enter a number between 1 and 10.\")\n\t\t\tcontinue\n\t\t}\n\n\t\trandNum := rand.Intn(10) + 1\n\t\tif num == randNum {\n\t\t\tfmt.Println(\"Congratulations! You guessed the number.\")\n\t\t\tbreak\n\t\t} else {\n\t\t\tfmt.Printf(\"Sorry, the number was %d. Try again.\\n\", randNum)\n\t\t}\n\t}\n}"}
{"sample": "package main\n\n// Create and write to a file\nfunc main() {\n\tfile, err := os.Create(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\t_, err = file.Write([]byte(\"Hello, World!\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintCubeRoot(27)\n}\n\n// Function to print the cube root of a number\nfunc PrintCubeRoot(n float64) {\n\tfmt.Println(math.Cbrt(n))\n}"}
{"sample": "package chef\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype Ingredient struct {\n\tName     string\n\tQuantity int\n}\n\ntype Recipe struct {\n\tName        string\n\tIngredients []Ingredient\n}\n\ntype Chef struct {\n\tName        string\n\tRecipes     []Recipe\n\tIngredient  Ingredient\n\tExperience  int\n\tRestaurant  string\n}\n\nfunc (c *Chef) Cook(recipe Recipe) error {\n\tif c.Experience < 5 {\n\t\treturn fmt.Errorf(\"Chef %s is not experienced enough to cook %s\", c.Name, recipe.Name)\n\t}\n\n\tfor _, ing := range recipe.Ingredients {\n\t\tif ing.Quantity > c.Ingredient.Quantity {\n\t\t\treturn fmt.Errorf(\"Chef %s does not have enough %s to cook %s\", c.Name, ing.Name, recipe.Name)\n\t\t}\n\t}\n\n\trand.Seed(time.Now().UnixNano())\n\ttime.Sleep(time.Duration(rand.Intn(10)) * time.Second)\n\n\tfor _, ing := range recipe.Ingredients {\n\t\tc.Ingredient.Quantity -= ing.Quantity\n\t}\n\n\treturn nil\n}\n\nfunc (c *Chef) AddRecipe(recipe Recipe) {\n\tc.Recipes = append(c.Recipes, recipe)\n}\n\nfunc (c *Chef) Serve(restaurant string) {\n\tc.Restaurant = restaurant\n\tlog.Printf(\"%s is now serving at %s\", c.Name, restaurant)\n}\n\nfunc (c *Chef) Learn() {\n\tc.Experience++\n\tlog.Printf(\"%s is now more experienced and has an experience level of %d\", c.Name, c.Experience)\n}\n\nfunc NewChef(name string, ing Ingredient) *Chef {\n\treturn &Chef{\n\t\tName:       name,\n\t\tIngredient: ing,\n\t}\n}"}
{"sample": "package ftpclient\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc ftpClient() {\n\tconn, err := net.Dial(\"tcp\", \"ftp.example.com:21\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tmessage, err := bufio.NewReader(conn).ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Print(message)\n\n\treader := bufio.NewReader(os.Stdin)\n\n\tfmt.Print(\"Enter username: \")\n\tusername, _ := reader.ReadString('\\n')\n\tusername = strings.TrimSuffix(username, \"\\n\")\n\n\tfmt.Print(\"Enter password: \")\n\tpassword, _ := reader.ReadString('\\n')\n\tpassword = strings.TrimSuffix(password, \"\\n\")\n\n\tfmt.Fprintf(conn, \"USER %s\\r\\n\", username)\n\tmessage, err = bufio.NewReader(conn).ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Print(message)\n\n\tfmt.Fprintf(conn, \"PASS %s\\r\\n\", password)\n\tmessage, err = bufio.NewReader(conn).ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Print(message)\n\n\tfmt.Fprintf(conn, \"PWD\\r\\n\")\n\tmessage, err = bufio.NewReader(conn).ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Print(message)\n\n\tfmt.Fprintf(conn, \"QUIT\\r\\n\")\n\tmessage, err = bufio.NewReader(conn).ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Print(message)\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Animal interface {\n\tEat()\n\tMove()\n\tSpeak()\n}\n\ntype Cow struct{}\n\nfunc (c Cow) Eat() {\n\tfmt.Println(\"grass\")\n}\n\nfunc (c Cow) Move() {\n\tfmt.Println(\"walk\")\n}\n\nfunc (c Cow) Speak() {\n\tfmt.Println(\"moo\")\n}\n\ntype Bird struct{}\n\nfunc (b Bird) Eat() {\n\tfmt.Println(\"worms\")\n}\n\nfunc (b Bird) Move() {\n\tfmt.Println(\"fly\")\n}\n\nfunc (b Bird) Speak() {\n\tfmt.Println(\"peep\")\n}\n\ntype Snake struct{}\n\nfunc (s Snake) Eat() {\n\tfmt.Println(\"mice\")\n}\n\nfunc (s Snake) Move() {\n\tfmt.Println(\"slither\")\n}\n\nfunc (s Snake) Speak() {\n\tfmt.Println(\"hsss\")\n}\n\nfunc createAnimal(name string, animalType string) (Animal, error) {\n\tswitch strings.ToLower(animalType) {\n\tcase \"cow\":\n\t\treturn Cow{}, nil\n\tcase \"bird\":\n\t\treturn Bird{}, nil\n\tcase \"snake\":\n\t\treturn Snake{}, nil\n\tdefault:\n\t\treturn nil, errors.New(\"invalid animal type\")\n\t}\n}\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"> \")\n\t\tinput, _ := reader.ReadString('\\n')\n\t\taction := strings.ToLower(strings.TrimSpace(input))\n\n\t\targs := strings.Split(action, \" \")\n\n\t\tswitch args[0] {\n\t\tcase \"newanimal\":\n\t\t\tanimal, err := createAnimal(args[1], args[2])\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"Created it!\")\n\t\t\t}\n\t\tcase \"query\":\n\t\t\tanimalName := args[1]\n\t\t\tanimalAction := args[2]\n\n\t\t\tvar animal Animal\n\n\t\t\tswitch animalName {\n\t\t\tcase \"cow\":\n\t\t\t\tanimal = Cow{}\n\t\t\tcase \"bird\":\n\t\t\t\tanimal = Bird{}\n\t\t\tcase \"snake\":\n\t\t\t\tanimal = Snake{}\n\t\t\tdefault:\n\t\t\t\tfmt.Println(\"Invalid animal name\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tswitch animalAction {\n\t\t\tcase \"eat\":\n\t\t\t\tanimal.Eat()\n\t\t\tcase \"move\":\n\t\t\t\tanimal.Move()\n\t\t\tcase \"speak\":\n\t\t\t\tanimal.Speak()\n\t\t\tdefault:\n\t\t\t\tfmt.Println(\"Invalid animal action\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\tdefault:\n\t\t\tfmt.Println(\"Invalid command\")\n\t\t\tcontinue\n\t\t}\n\t}\n}"}
{"sample": "func QuickSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\tpivot := arr[len(arr)/2]\n\tvar left, right, middle []int\n\tfor _, v := range arr {\n\t\tif v < pivot {\n\t\t\tleft = append(left, v)\n\t\t} else if v > pivot {\n\t\t\tright = append(right, v)\n\t\t} else {\n\t\t\tmiddle = append(middle, v)\n\t\t}\n\t}\n\treturn append(append(QuickSort(left), middle...), QuickSort(right)...) \n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// SafeCounter is safe to use concurrently\ntype SafeCounter struct {\n\tmu    sync.Mutex\n\tcount int\n}\n\n// Inc increments the counter\nfunc (c *SafeCounter) Inc() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.count++\n}\n\n// Value returns the current count of the counter\nfunc (c *SafeCounter) Value() int {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.count\n}\n\nfunc main() {\n\tcounter := SafeCounter{}\n\n\t// Launch 1000 goroutines to increment the counter\n\tfor i := 0; i < 1000; i++ {\n\t\tgo counter.Inc()\n\t}\n\n\t// Wait for all goroutines to finish\n\t// before printing the final count\n\tfmt.Println(\"Final count:\", counter.Value())\n}"}
{"sample": "if circle.Radius > 0 {\n\tfmt.Println(\"Valid circle\")\n} else {\n\tfmt.Println(\"Invalid circle\")\n}\n"}
{"sample": "package dblinkedlist\n\ntype Node struct {\n\tPrev *Node\n\tNext *Node\n\tValue interface{}\n}\n\ntype List struct {\n\tHead *Node\n\tTail *Node\n\tLen  int\n}\n\nfunc (l *List) PushFront(v interface{}) {\n\tn := &Node{nil, nil, v}\n\tif l.Len == 0 {\n\t\tl.Head = n\n\t\tl.Tail = n\n\t} else {\n\t\tl.Head.Prev = n\n\t\tn.Next = l.Head\n\t\tl.Head = n\n\t}\n\tl.Len++\n}\n\nfunc (l *List) PushBack(v interface{}) {\n\tn := &Node{nil, nil, v}\n\tif l.Len == 0 {\n\t\tl.Head = n\n\t\tl.Tail = n\n\t} else {\n\t\tl.Tail.Next = n\n\t\tn.Prev = l.Tail\n\t\tl.Tail = n\n\t}\n\tl.Len++\n}\n\nfunc (l *List) Remove(n *Node) {\n\tif n.Prev == nil {\n\t\tl.Head = n.Next\n\t} else {\n\t\tn.Prev.Next = n.Next\n\t}\n\tif n.Next == nil {\n\t\tl.Tail = n.Prev\n\t} else {\n\t\tn.Next.Prev = n.Prev\n\t}\n\tl.Len--\n}"}
{"sample": "func execStatement(stmt *sql.Stmt, args ...interface{}) (sql.Result, error) {\n\tresult, err := stmt.Exec(args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc factorial(n int) (int, error) {\n\tif n < 0 {\n\t\treturn 0, errors.New(\"factorial undefined for negative number\")\n\t}\n\tresult := 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tresult *= i\n\t}\n\n\treturn result, nil\n}\n\nfunc main() {\n\tfmt.Println(factorial(5)) // expects 120, nil\n\tfmt.Println(factorial(-3)) // expects 0, \"factorial undefined for negative number\"\n}"}
{"sample": "package pancakesort\n\nfunc flip(arr []int, k int) {\n\tfor i := 0; i < k/2; i++ {\n\t\tarr[i], arr[k-i-1] = arr[k-i-1], arr[i]\n\t}\n}\n\nfunc findMaxIndex(arr []int, n int) int {\n\tmaxIndex := 0\n\tfor i := 0; i < n; i++ {\n\t\tif arr[i] > arr[maxIndex] {\n\t\t\tmaxIndex = i\n\t\t}\n\t}\n\treturn maxIndex\n}\n\nfunc pancakeSort(arr []int) []int {\n\tn := len(arr)\n\tfor currSize := n; currSize > 1; currSize-- {\n\t\tmaxIndex := findMaxIndex(arr, currSize)\n\t\tif maxIndex != currSize-1 {\n\t\t\tflip(arr, maxIndex+1)\n\t\t\tflip(arr, currSize)\n\t\t}\n\t}\n\treturn arr\n}"}
{"sample": "package resource\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/bmc-toolbox/dora/filter\"\n\t\"github.com/bmc-toolbox/dora/model\"\n\t\"github.com/bmc-toolbox/dora/storage\"\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/manyminds/api2go\"\n)\n\n// ScannedPortResource for api2go routes\ntype ScannedPortResource struct {\n\tScannedPortStorage *storage.ScannedPortStorage\n}\n\n// FindAll Scans\nfunc (s ScannedPortResource) FindAll(r api2go.Request) (api2go.Responder, error) {\n\t_, scans, err := s.queryAndCountAllWrapper(r)\n\treturn &Response{Res: scans}, err\n}\n\n// FindOne Scanner\nfunc (s ScannedPortResource) FindOne(ID string, r api2go.Request) (api2go.Responder, error) {\n\tres, err := s.ScannedPortStorage.GetOne(strings.Replace(ID, \"-\", \"/\", -1))\n\tif err == gorm.ErrRecordNotFound {\n\t\treturn &Response{}, api2go.NewHTTPError(err, err.Error(), http.StatusNotFound)\n\t}\n\treturn &Response{Res: res}, err\n}\n\n// PaginatedFindAll can be used to load Scans in chunks\nfunc (s ScannedPortResource) PaginatedFindAll(r api2go.Request) (uint, api2go.Responder, error) {\n\tcount, scans, err := s.queryAndCountAllWrapper(r)\n\treturn uint(count), &Response{Res: scans}, err\n}\n\n// queryAndCountAllWrapper retrieve the data to be used for FindAll and PaginatedFindAll in a standard way\nfunc (s ScannedPortResource) queryAndCountAllWrapper(r api2go.Request) (count int, scans []model.ScannedPort, err error) {\n\tfor _, invalidQuery := range []string{\"page[number]\", \"page[size]\"} {\n\t\t_, invalid := r.QueryParams[invalidQuery]\n\t\tif invalid {\n\t\t\treturn count, scans, ErrPageSizeAndNumber\n\t\t}\n\t}\n\n\tfilters, hasFilters := filter.NewFilterSet(&r)\n\toffset, limit := filter.OffSetAndLimitParse(&r)\n\n\tif hasFilters {\n\t\tcount, scans, err = s.ScannedPortStorage.GetAllByFilters(offset, limit, filters)\n\t\tfilters.Clean()\n\t\tif err != nil {\n\t\t\treturn count, scans, err\n\t\t}\n\t}\n\n\tif !hasFilters {\n\t\tcount, scans, err = s.ScannedPortStorage.GetAll(offset, limit)\n\t\tif err != nil {\n\t\t\treturn count, scans, err\n\t\t}\n\t}\n\n\treturn count, scans, err\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine 1 finished\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(1 * time.Second)\n\t\tfmt.Println(\"Goroutine 2 finished\")\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n)\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\ttmpl, err := template.ParseFiles(\"home.html\")\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing template:\", err)\n\t\treturn\n\t}\n\terr = tmpl.Execute(w, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error executing template:\", err)\n\t\treturn\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", homeHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nimport \"math/rand\"\n\nfunc main() {\n\tfmt.Println(RandomInt())\n}\n\nfunc RandomInt() int {\n\treturn rand.Intn(100)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\n\ntype WeatherResponse struct {\n\tWeather []struct {\n\t\tDescription string `json:\"description\"`\n\t} `json:\"weather\"`\n\tMain struct {\n\t\tTemp float64 `json:\"temp\"`\n\t} `json:\"main\"`\n}\n\nfunc main() {\n\turl := \"https://api.openweathermap.org/data/2.5/weather?q=London&appid=YOUR_APP_ID\"\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response WeatherResponse\n\terr = json.NewDecoder(resp.Body).Decode(&response)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"The temperature in London is %.2f degrees Celsius and the weather is %s\\n\", response.Main.Temp-273.15, response.Weather[0].Description)\n}"}
{"sample": "func main() {\n\tpath, err := os.Executable()\n\tif err != nil {\n\t\tfmt.Println(\"Error getting executable path:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Executable path:\", path)\n}"}
{"sample": "func DecodeJSONBody(w http.ResponseWriter, r *http.Request, dst interface{}) error {\n\tdecoder := json.NewDecoder(r.Body)\n\terr := decoder.Decode(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc EncodeJSONBody(w http.ResponseWriter, body interface{}) error {\n\tencoder := json.NewEncoder(w)\n\terr := encoder.Encode(body)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Sum calculates the sum of two integers and returns the result.\nfunc Sum(a, b int) int {\n\treturn a + b\n}"}
{"sample": "package mutcontext\n\nimport (\n\t\"context\"\n\t\"testing\"\n)\n\nfunc TestCreateNew(t *testing.T) {\n\tparent := context.Background()\n\tctx := CreateNew(parent)\n\tm := ctx.(*mutableContext)\n\tif m.Context != parent {\n\t\tt.Error(\"invalid context\")\n\t}\n\n\t_, ok := m.Deadline()\n\tif ok {\n\t\tt.Error(\"unexpected deadline\")\n\t}\n\n\tif m.Done() != nil {\n\t\tt.Error(\"unexpected done\", m.Done())\n\t}\n\n\tif m.Err() != nil {\n\t\tt.Error(\"unexpected err\", m.Err())\n\t}\n\n\tif v := m.Value(\"unexpected\"); v != nil {\n\t\tt.Error(\"unexpected value\", v)\n\t}\n\tm.Set(\"expected\", \"foobar\")\n\tif v := m.Value(\"expected\"); v != \"foobar\" {\n\t\tt.Error(\"unexpected value\", v)\n\t}\n\tcalled := false\n\tm.SetCleanup(func() {\n\t\tcalled = true\n\t})\n\terr := m.Cancel()\n\tif err != ErrNoCancel {\n\t\tt.Error(\"incorrect error\", err)\n\t}\n\tif !called {\n\t\tt.Error(\"cleanup was not called\")\n\t}\n\tif !m.Completed() {\n\t\tt.Error(\"cancelled flag not set\")\n\t}\n}\n\nfunc TestCreateNewCancel(t *testing.T) {\n\tparent, cancel := context.WithCancel(context.Background())\n\tctx := CreateNewCancel(parent, cancel)\n\tm := ctx.(*mutableContext)\n\tif m.Context != parent {\n\t\tt.Error(\"invalid context\")\n\t}\n\tif m.CancelFunc == nil {\n\t\tt.Error(\"invalid cancel func\")\n\t}\n\terr := m.Cancel()\n\tif err != nil {\n\t\tt.Error(\"unexpected error\", err)\n\t}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintAreaOfCircle(5)\n}\n\n// Function to print the area of a circle\nfunc PrintAreaOfCircle(radius float64) {\n\tfmt.Println(math.Pi * radius * radius)\n}"}
{"sample": "package main\n\nimport \"io/ioutil\"\n\nfunc main() {\n\tcontent, _ := ReadFile(\"example.txt\")\n\tfmt.Println(content)\n}\n\nfunc ReadFile(filename string) ([]byte, error) {\n\treturn ioutil.ReadFile(filename)\n}"}
{"sample": "http.HandleFunc(\"/books\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle books endpoint\n\tswitch r.Method {\n\tcase \"GET\":\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get books\")\n\tcase \"POST\":\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create book\")\n\tcase \"PUT\":\n\t\t// Handle PUT request\n\t\tfmt.Fprint(w, \"Update book\")\n\tcase \"DELETE\":\n\t\t// Handle DELETE request\n\t\tfmt.Fprint(w, \"Delete book\")\n\t}\n})\n"}
{"sample": "package main\n\n// RetryOnError retries a function if it returns an error\nfunc RetryOnError(fn func() error, retries int) error {\n\tfor i := 0; i < retries; i++ {\n\t\terr := fn()\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\tlog.Println(\"Retry\", i, \"failed with\", err)\n\t}\n\treturn fmt.Errorf(\"failed after %d retries\", retries)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadFile reads and returns the content of a file.\nfunc ReadFile(filePath string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// WriteFile writes the content to a file.\nfunc WriteFile(filePath string, content []byte) error {\n\treturn ioutil.WriteFile(filePath, content, 0644)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tPrintDivisors(100)\n}\n\nfunc PrintDivisors(n int) {\n\tfor i := 1; i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfmt.Println(i)\n\t\t}\n\t}\n}"}
{"sample": "package main\n\n// HandleErrorWithDefault handles an error, returns a default value if an error occurs\nfunc HandleErrorWithDefault(err error, defaultValue string) string {\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn defaultValue\n\t}\n\treturn \"\"\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc chooseColor(color string) string {\n\tswitch color {\n\tcase \"red\":\n\t\treturn \"You chose red.\"\n\tcase \"blue\":\n\t\treturn \"You chose blue.\"\n\tcase \"green\":\n\t\treturn \"You chose green.\"\n\tdefault:\n\t\treturn \"Sorry, didn't recognize your color\"\n\t}\n}\n\nfunc main() {\n\tcurrentTime := time.Now()\n\tfmt.Println(currentTime.Format(\"January 2, 2006\"))\n\n\tcolor := \"blue\"\n\tmessage := chooseColor(color)\n\tfmt.Println(message)\n}"}
{"sample": "type Config struct {\n\tDatabaseURL string\n\tPort        int\n}\n\nfunc LoadConfigFromFile(path string) (*Config, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tconfig := &Config{}\n\terr = json.NewDecoder(file).Decode(config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn config, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"encoding/csv\"\n\t\"os\"\n)\n\nfunc main() {\n\tdata := [][]string{{\"Name\", \"Age\"} {\"John Doe\", \"30\"} {\"Jane Smith\", \"25\"}}\n\n\tfile, err := os.Create(\"data.csv\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\tdefer writer.Flush()\n\n\tfor _, record := range data {\n\t\twriter.Write(record)\n\t}\n\n\tfmt.Println(\"Data written to CSV file\")\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// ReverseString reverses a given string and returns the result.\nfunc ReverseString(str string) string {\n\tchars := []rune(str)\n\tfor i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {\n\t\tchars[i], chars[j] = chars[j], chars[i]\n\t}\n\treturn string(chars)\n}"}
{"sample": "package tree\n\nimport (\n\t\"testing\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"BST\", func() {\n\tvar bst *BST\n\tAssertBSTBehavior := func() {\n\t\tIt(\"should be empty\", func() {\n\t\t\tExpect(bst.IsEmpty()).To(BeTrue())\n\t\t\tExpect(bst.Size()).To(BeZero())\n\t\t})\n\n\t\tIt(\"can Add nodes\", func() {\n\t\t\tbst.Add(10)\n\t\t\tbst.Add(19)\n\t\t\tbst.Add(5)\n\t\t\tbst.Add(18)\n\t\t\tbst.Add(27)\n\t\t\tbst.Add(1)\n\t\t\tbst.Add(10)\n\t\t\tbst.Add(18)\n\t\t\tbst.Add(15)\n\t\t\tbst.Add(22)\n\n\t\t\tExpect(bst.IsEmpty()).To(BeFalse())\n\t\t\tExpect(bst.Size()).To(Equal(8))\n\t\t})\n\n\t\tIt(\"can know whether node contains\", func() {\n\t\t\tExpect(bst.Contains(10)).To(BeTrue())\n\t\t\tExpect(bst.Contains(19)).To(BeTrue())\n\t\t\tExpect(bst.Contains(5)).To(BeTrue())\n\t\t\tExpect(bst.Contains(11)).To(BeFalse())\n\t\t})\n\n\t\tSpecify(\"pre order traverse\", func() {\n\t\t\tbst.PreOrder()\n\t\t\tGinkgoWriter.Println(\"\\n\")\n\t\t})\n\n\t\tSpecify(\"in order traverse\", func() {\n\t\t\tbst.InOrder()\n\t\t\tGinkgoWriter.Println(\"\\n\")\n\t\t})\n\n\t\tSpecify(\"post order traverse\", func() {\n\t\t\tbst.PostOrder()\n\t\t\tGinkgoWriter.Println(\"\\n\")\n\t\t})\n\n\t\tSpecify(\"pre order nr traverse\", func() {\n\t\t\tbst.PreOrderNR()\n\t\t\tGinkgoWriter.Println(\"\\n\")\n\t\t})\n\n\t\tSpecify(\"level order\", func() {\n\t\t\tbst.LevelOrder()\n\t\t\tGinkgoWriter.Println(\"\\n\")\n\t\t})\n\n\t\tSpecify(\"get min/max node\", func() {\n\t\t\tExpect(bst.Min()).To(BeEquivalentTo(1))\n\t\t\tExpect(bst.Max()).To(BeEquivalentTo(27))\n\t\t})\n\n\t\tSpecify(\"delete min/max node\", func() {\n\t\t\tExpect(bst.RemoveMin()).To(BeEquivalentTo(1))\n\t\t\tExpect(bst.RemoveMax()).To(BeEquivalentTo(27))\n\t\t})\n\n\t\tSpecify(\"delete nodes\", func() {\n\t\t\tbst.Remove(1)\n\t\t\tbst.Remove(100)\n\t\t\tbst.Remove(18)\n\t\t\tbst.Remove(20)\n\t\t\tbst.Remove(15)\n\t\t\tbst.Remove(10)\n\t\t\tbst.Remove(5)\n\t\t\tbst.Remove(19)\n\t\t\tbst.Remove(22)\n\t\t})\n\t}\n\n\tDescribe(\"BST\", Ordered, func() {\n\t\tBeforeAll(func() {\n\t\t\tbst = NewBST()\n\t\t})\n\n\t\tAssertBSTBehavior()\n\t})\n})\n\nfunc TestBST(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"BST Suite\")\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n)\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"golang.org:80\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\t_, err = fmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tbuf := make([]byte, 512)\n\tfor {\n\t\tn, err := conn.Read(buf)\n\t\tif n > 0 {\n\t\t\tfmt.Print(string(buf[:n]))\n\t\t}\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}"}
{"sample": "// Using a pointer\n\nx := 5\nptr := &x\nfmt.Println(*ptr)\n"}
{"sample": "package main\n\n// IfErrorThenLog checks if an error exists, if so, logs it\nfunc IfErrorThenLog(err error) {\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n"}
{"sample": "// Check if a string ends with a specific suffix\nfunc EndsWith(str, suffix string) bool {\n\treturn strings.HasSuffix(str, suffix)\n}\n"}
{"sample": "package appointmentservice\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\ntype Appointment struct {\n\tID        int\n\tStartTime time.Time\n\tEndTime   time.Time\n\tUserID    int\n}\n\ntype AppointmentService struct {\n\tappointments []Appointment\n}\n\nfunc (s *AppointmentService) ScheduleAppointment(startTime, endTime time.Time, userID int) (int, error) {\n\tif startTime.Before(time.Now()) {\n\t\treturn 0, errors.New(\"start time must be in the future\")\n\t}\n\n\tif startTime.After(endTime) {\n\t\treturn 0, errors.New(\"end time must be after start time\")\n\t}\n\n\tfor _, appointment := range s.appointments {\n\t\tif appointment.StartTime.Before(endTime) && appointment.EndTime.After(startTime) {\n\t\t\treturn 0, errors.New(\"appointment conflicts with existing appointment\")\n\t\t}\n\t}\n\n\tid := len(s.appointments) + 1\n\ts.appointments = append(s.appointments, Appointment{\n\t\tID:        id,\n\t\tStartTime: startTime,\n\t\tEndTime:   endTime,\n\t\tUserID:    userID,\n\t})\n\n\treturn id, nil\n}\n\nfunc (s *AppointmentService) GetAppointmentsForUser(userID int) []Appointment {\n\tvar appointments []Appointment\n\tfor _, appointment := range s.appointments {\n\t\tif appointment.UserID == userID {\n\t\t\tappointments = append(appointments, appointment)\n\t\t}\n\t}\n\treturn appointments\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// SortInts sorts a slice of integers in ascending order.\nfunc SortInts(nums []int) {\n\tsort.Ints(nums)\n}"}
{"sample": "func main() {\n\tnumStr := \"42\"\n\tnum, err := strconv.Atoi(numStr)\n\tif err != nil {\n\t\tfmt.Println(\"Error converting string to int:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(num)\n}"}
{"sample": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc fibonacci(n int) []int {\n\tif n <= 1 {\n\t\treturn []int{n}\n\t}\n\n\tprev := fibonacci(n - 1)\n\tlast := prev[len(prev)-1]\n\tsecondLast := prev[len(prev)-2]\n\treturn append(prev, last+secondLast)\n}\n\nfunc main() {\n\tnumPtr := flag.String(\"num\", \"1\", \"an integer\")\n\tflag.Parse()\n\n\tnum, err := strconv.Atoi(*numPtr)\n\tif err != nil {\n\t\tfmt.Println(\"Invalid input for num\")\n\t\treturn\n\t}\n\n\tfmt.Printf(\"First %v fibonacci numbers: %v\\n\", num, fibonacci(num))\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// ReadCSVFile reads a CSV file and returns its content as a slice of records.\nfunc ReadCSVFile(filePath string) ([][]string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\trecords, err := reader.ReadAll()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn records, nil\n}\n\n// WriteCSVFile writes a slice of records to a CSV file.\nfunc WriteCSVFile(filePath string, records [][]string) error {\n\tfile, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\terr = writer.WriteAll(records)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twriter.Flush()\n\treturn writer.Error()\n}"}
{"sample": "package postgresclient\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n)\n\ntype PostgresClient struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresClient(connStr string) (*PostgresClient, error) {\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := db.Ping(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &PostgresClient{db: db}, nil\n}\n\nfunc (p *PostgresClient) Close() error {\n\treturn p.db.Close()\n}\n\nfunc (p *PostgresClient) Create(name string, age int) error {\n\t_, err := p.db.Exec(\"INSERT INTO users (name, age) VALUES ($1, $2)\", name, age)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (p *PostgresClient) Read(id int) (string, int, error) {\n\tvar name string\n\tvar age int\n\n\terr := p.db.QueryRow(\"SELECT name, age FROM users WHERE id = $1\", id).Scan(&name, &age)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn \"\", 0, fmt.Errorf(\"user not found\")\n\t\t}\n\t\treturn \"\", 0, err\n\t}\n\n\treturn name, age, nil\n}\n\nfunc (p *PostgresClient) Update(id int, name string, age int) error {\n\t_, err := p.db.Exec(\"UPDATE users SET name = $1, age = $2 WHERE id = $3\", name, age, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (p *PostgresClient) Delete(id int) error {\n\t_, err := p.db.Exec(\"DELETE FROM users WHERE id = $1\", id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc Example() {\n\tconnStr := \"postgres://user:password@localhost:5432/mydb?sslmode=disable\"\n\tclient, err := NewPostgresClient(connStr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer client.Close()\n\n\tif err := client.Create(\"John Doe\", 30); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tname, age, err := client.Read(1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\n\n\tif err := client.Update(1, \"Jane Doe\", 35); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := client.Delete(1); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {\n\tfmt.Printf(\"Worker %d started\\n\", id)\n\tdefer wg.Done() // Tell the waitgroup the worker has finished\n\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", id, j)\n\t\tresults <- j * 2\n\t\tfmt.Printf(\"Worker %d finished job %d\\n\", id, j)\n\t}\n\tfmt.Printf(\"Worker %d finished\\n\", id)\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tvar wg sync.WaitGroup // Create wait group to know when all workers have finished\n\n\tconst numWorkers = 4\n\twg.Add(numWorkers) // Add numWorkers to the WaitGroup where initial count is 0\n\n\tfor w := 1; w <= numWorkers; w++ {\n\t\tgo worker(w, jobs, results, &wg)\n\t}\n\n\tfor j := 1; j <= 20; j++ {\n\t\tjobs <- j\n\t}\n\n\tclose(jobs)\n\n\twg.Wait() // Here we wait until all workers have finished before closing out your program.\n\n\tfor a := 1; a <= 20; a++ {\n\t\t<-results\n\t}\n}```"}
{"sample": "func createForeignKey(tx *sql.Tx) error {\n\tstmt, err := tx.Prepare(\"ALTER TABLE users ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES other_table(id)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "func main() {\n\tstart := time.Now()\n\n\ttime.Sleep(2 * time.Second)\n\n\tduration := time.Since(start)\n\tfmt.Println(duration)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\n\ttime.Sleep(2 * time.Second)\n\n\tduration := time.Since(start)\n\tfmt.Println(duration)\n}"}
{"sample": "package main\n\nfunc main() {\n\tstr := \"Hello, World!\"\n\tReverseString(str)\n}\n\nfunc ReverseString(s string) string {\n\treturn string([]rune(s))\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintArrayInReverse([]int{1, 2, 3, 4, 5})\n}\n\n// Function to print the array in reverse order\nfunc PrintArrayInReverse(arr []int) {\n\tfor i := len(arr) - 1; i >= 0; i-- {\n\t\tfmt.Println(arr[i])\n\t}\n}"}
{"sample": "// Using defer for cleanup\n\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\n"}
{"sample": "/**\n * @Author         : s1m0n21\n * @Description    : Answer of https://leetcode-cn.com/problems/reshape-the-matrix/\n * @Project        : leetcode-go\n * @File           : answer.go\n * @Date           : 2022/1/13 12:39 PM\n */\n\npackage _reshape_the_matrix\n\nfunc matrixReshape(mat [][]int, r int, c int) [][]int {\n\tm, n := len(mat), len(mat[0])\n\tif m*n != r*c {\n\t\treturn mat\n\t}\n\n\tans := make([][]int, r)\n\tfor i := range ans {\n\t\tans[i] = make([]int, c)\n\t}\n\n\tx, y := 0, 0\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tans[x][y] = mat[i][j]\n\t\t\tif y+1 < c {\n\t\t\t\ty++\n\t\t\t} else {\n\t\t\t\tx++\n\t\t\t\ty = 0\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans\n}\n"}
{"sample": "type Student struct {\n\tName   string\n\tAge    int\n\tGrades []float64\n}\n"}
{"sample": "func createForeignKey(db *sql.DB) error {\n\tstmt, err := db.Prepare(\"ALTER TABLE users ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES other_table(id)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "func main() {\n\tr := chi.NewRouter()\n\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Welcome to the home page\")\n\t})\n\n\tr.Get(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"List of users\")\n\t})\n\n\tr.Get(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := chi.URLParam(r, \"id\")\n\t\tfmt.Fprintf(w, \"Get user with ID: %s\", id)\n\t})\n\n\thttp.ListenAndServe(\":8080\", r)\n}"}
{"sample": "func createTable(db *sql.DB) error {\n\tstmt, err := db.Prepare(`CREATE TABLE IF NOT EXISTS users (id SERIAL PRIMARY KEY, name VARCHAR(50))`)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--batch-size\", argparse.Int, 32, \"Batch size\")\nparser.AddArgument(\"--num-epochs\", argparse.Int, 10, \"Number of epochs\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--weight-decay\", argparse.Float, 0.001, \"Weight decay\")\nparser.AddArgument(\"--dropout\", argparse.Float, 0.5, \"Dropout rate\")\nparser.AddArgument(\"--mode\", argparse.String, \"train\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\nparser.AddArgument(\"--debug\", argparse.Bool, false, \"Enable debug mode\")\n"}
{"sample": "// Check if the request is of GET method\nfunc IsGetRequest(request *http.Request) bool {\n\treturn request.Method == http.MethodGet\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading file:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(content))\n}"}
{"sample": "package ccvalidator\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype CreditCard struct {\n\tNumber string\n}\n\nfunc (c *CreditCard) IsValid() bool {\n\treturn len(c.Number) >= 12 && len(c.Number) <= 19\n}\n\nfunc (c *CreditCard) Format() string {\n\treturn fmt.Sprintf(\"**** **** **** %s\", c.Number[len(c.Number)-4:])\n}\n\nfunc (c *CreditCard) GetIssuer() (string, error) {\n\tif len(c.Number) < 13 || len(c.Number) > 19 {\n\t\treturn \"\", errors.New(\"Invalid credit card number\")\n\t}\n\n\tif c.Number[0] == '4' {\n\t\treturn \"Visa\", nil\n\t} else if c.Number[0:2] == \"34\" || c.Number[0:2] == \"37\" {\n\t\treturn \"American Express\", nil\n\t} else if c.Number[0:2] >= \"51\" && c.Number[0:2] <= \"55\" {\n\t\treturn \"Mastercard\", nil\n\t} else if c.Number[0:4] == \"6011\" || (c.Number[0:3] >= \"644\" && c.Number[0:3] <= \"649\") || c.Number[0:2] == \"65\" {\n\t\treturn \"Discover\", nil\n\t} else {\n\t\treturn \"\", errors.New(\"Issuer not found\")\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadFile reads and returns the content of a file.\nfunc ReadFile(filePath string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// WriteFile writes the content to a file.\nfunc WriteFile(filePath string, content []byte) error {\n\treturn ioutil.WriteFile(filePath, content, 0644)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintStringLength(\"Hello, World!\")\n}\n\n// Function to print the length of a string\nfunc PrintStringLength(s string) {\n\tfmt.Println(len(s))\n}"}
{"sample": "func main() {\n\tstart := time.Now()\n\n\ttime.Sleep(2 * time.Second)\n\n\tduration := time.Since(start)\n\tfmt.Println(duration)\n}"}
{"sample": "func createTransaction(db *sql.DB) (*sql.Tx, error) {\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tx, nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/products\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"List of products\")\n\t}).Methods(\"GET\")\n\n\tr.HandleFunc(\"/products\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Create product\")\n\t}).Methods(\"POST\")\n\n\tr.HandleFunc(\"/products/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := mux.Vars(r)[\"id\"]\n\t\tfmt.Fprintf(w, \"Get product with ID: %s\", id)\n\t}).Methods(\"GET\")\n\n\tr.HandleFunc(\"/products/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := mux.Vars(r)[\"id\"]\n\t\tfmt.Fprintf(w, \"Update product with ID: %s\", id)\n\t}).Methods(\"PUT\")\n\n\tr.HandleFunc(\"/products/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := mux.Vars(r)[\"id\"]\n\t\tfmt.Fprintf(w, \"Delete product with ID: %s\", id)\n\t}).Methods(\"DELETE\")\n\n\thttp.Handle(\"/\", r)\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "ext := filepath.Ext(absPath)\nfmt.Println(\"Extension:\", ext)\n"}
{"sample": "file, err := os.Open(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\n"}
{"sample": "func main() {\n\tvar wg sync.WaitGroup\n\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine 1 executed\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(3 * time.Second)\n\t\tfmt.Println(\"Goroutine 2 executed\")\n\t}()\n\n\twg.Wait()\n}"}
{"sample": "// Check if a number is prime\nfunc IsPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= num; i++ {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"sample": "package leap\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"testing\"\n\n\t\"github.com/hybridgroup/gobot\"\n)\n\ntype NullReadWriteCloser struct{}\n\nvar writeError error = nil\n\nfunc (NullReadWriteCloser) Write(p []byte) (int, error) {\n\treturn len(p), writeError\n}\nfunc (NullReadWriteCloser) Read(b []byte) (int, error) {\n\treturn len(b), nil\n}\nfunc (NullReadWriteCloser) Close() error {\n\treturn nil\n}\n\nfunc initTestLeapMotionDriver() *LeapMotionDriver {\n\ta := NewLeapMotionAdaptor(\"bot\", \"\")\n\ta.connect = func(port string) (io.ReadWriteCloser, error) {\n\t\treturn &NullReadWriteCloser{}, nil\n\t}\n\ta.Connect()\n\treceive = func(ws io.ReadWriteCloser, buf *[]byte) {\n\t\tfile, _ := ioutil.ReadFile(\"./test/support/example_frame.json\")\n\t\tcopy(*buf, file)\n\t}\n\treturn NewLeapMotionDriver(a, \"bot\")\n}\n\nfunc TestLeapMotionDriver(t *testing.T) {\n\td := initTestLeapMotionDriver()\n\tgobot.Assert(t, d.Name(), \"bot\")\n\tgobot.Assert(t, d.Connection().Name(), \"bot\")\n}\nfunc TestLeapMotionDriverStart(t *testing.T) {\n\td := initTestLeapMotionDriver()\n\tgobot.Assert(t, len(d.Start()), 0)\n\n\td = initTestLeapMotionDriver()\n\twriteError = errors.New(\"write error\")\n\tgobot.Assert(t, d.Start()[0], errors.New(\"write error\"))\n\n}\n\nfunc TestLeapMotionDriverHalt(t *testing.T) {\n\td := initTestLeapMotionDriver()\n\tgobot.Assert(t, len(d.Halt()), 0)\n}\n\nfunc TestLeapMotionDriverParser(t *testing.T) {\n\td := initTestLeapMotionDriver()\n\tfile, _ := ioutil.ReadFile(\"./test/support/example_frame.json\")\n\tparsedFrame := d.ParseFrame(file)\n\n\tif parsedFrame.Hands == nil || parsedFrame.Pointables == nil || parsedFrame.Gestures == nil {\n\t\tt.Errorf(\"ParseFrame incorrectly parsed frame\")\n\t}\n\n\tgobot.Assert(t, parsedFrame.Timestamp, 4729292670)\n\tgobot.Assert(t, parsedFrame.Hands[0].X(), 117.546)\n\tgobot.Assert(t, parsedFrame.Hands[0].Y(), 236.007)\n\tgobot.Assert(t, parsedFrame.Hands[0].Z(), 76.3394)\n}\n"}
{"sample": "func Redirect(w http.ResponseWriter, r *http.Request, url string, code int) {\n\thttp.Redirect(w, r, url, code)\n}\n\nfunc NotFound(w http.ResponseWriter, r *http.Request) {\n\thttp.NotFound(w, r)\n}\n\nfunc Error(w http.ResponseWriter, error string, code int) {\n\thttp.Error(w, error, code)\n}"}
{"sample": "package kms\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/aws/aws-sdk-go/aws/awserr\"\n\tSDK \"github.com/aws/aws-sdk-go/service/kms\"\n\n\t\"github.com/evalphobia/aws-sdk-go-wrapper/config\"\n\t\"github.com/evalphobia/aws-sdk-go-wrapper/log\"\n\t\"github.com/evalphobia/aws-sdk-go-wrapper/private/pointers\"\n)\n\nconst (\n\tserviceName = \"KMS\"\n\taliasPrefix = \"alias/\"\n)\n\n// KMS has KMS client.\ntype KMS struct {\n\tclient *SDK.KMS\n\n\tlogger log.Logger\n}\n\n// New returns initialized *Rekognition.\nfunc New(conf config.Config) (*KMS, error) {\n\tsess, err := conf.Session()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsvc := &KMS{\n\t\tclient: SDK.New(sess),\n\t\tlogger: log.DefaultLogger,\n\t}\n\treturn svc, nil\n}\n\n// SetLogger sets logger.\nfunc (svc *KMS) SetLogger(logger log.Logger) {\n\tsvc.logger = logger\n}\n\n// CreateAlias executes CreateAlias operation.\nfunc (svc *KMS) CreateAlias(keyID, aliasName string) error {\n\tif !strings.HasPrefix(aliasName, aliasPrefix) {\n\t\taliasName = aliasPrefix + aliasName\n\t}\n\n\t_, err := svc.client.CreateAlias(&SDK.CreateAliasInput{\n\t\tTargetKeyId: pointers.String(keyID),\n\t\tAliasName:   pointers.String(aliasName),\n\t})\n\tif err != nil {\n\t\tsvc.Errorf(\"error on `CreateAlias` operation; keyID=%s; aliasName=%s; error=%s;\", keyID, aliasName, err.Error())\n\t\treturn err\n\t}\n\n\tsvc.Infof(\"success on `CreateAlias` operation; keyID=%s; aliasName=%s;\", keyID, aliasName)\n\treturn nil\n}\n\n// CreateKey executes CreateKey operation.\nfunc (svc *KMS) CreateKey(tags ...Tag) (*SDK.KeyMetadata, error) {\n\tvar kmsTags []*SDK.Tag\n\tfor _, tag := range tags {\n\t\tkmsTags = append(kmsTags, tag.Tag())\n\t}\n\n\toutput, err := svc.client.CreateKey(&SDK.CreateKeyInput{\n\t\tTags: kmsTags,\n\t})\n\tif err != nil {\n\t\tsvc.Errorf(\"error on `CreateKey` operation; error=%s;\", err.Error())\n\t\treturn nil, err\n\t}\n\n\tmetaData := output.KeyMetadata\n\tsvc.Infof(\"success on `CreateKey` operation; keyID=%s; arn=%s;\", *metaData.KeyId, *metaData.Arn)\n\treturn metaData, nil\n}\n\n// CreateKeyWithAlias creates a key and sets alias name.\nfunc (svc *KMS) CreateKeyWithAlias(aliasName string, tags ...Tag) (*SDK.KeyMetadata, error) {\n\tif !strings.HasPrefix(aliasName, aliasPrefix) {\n\t\taliasName = aliasPrefix + aliasName\n\t}\n\n\t_, err := svc.DescribeKey(aliasName)\n\tif err == nil {\n\t\treturn nil, fmt.Errorf(\"error: aliasName=[%s] is already exists\", aliasName)\n\t}\n\taerr, ok := err.(awserr.Error)\n\tif !ok {\n\t\treturn nil, err\n\t}\n\tswitch aerr.Code() {\n\tcase SDK.ErrCodeNotFoundException:\n\t\t// error must be NotFoundException.\n\tdefault:\n\t\treturn nil, err\n\t}\n\n\tmetaData, err := svc.CreateKey(tags...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = svc.CreateAlias(*metaData.KeyId, aliasName)\n\treturn metaData, err\n}\n\n// DescribeKey executes DescribeKey operation.\nfunc (svc *KMS) DescribeKey(keyName string) (metaData *SDK.KeyMetadata, err error) {\n\toutput, err := svc.client.DescribeKey(&SDK.DescribeKeyInput{\n\t\tKeyId: pointers.String(keyName),\n\t})\n\tif err != nil {\n\t\tsvc.Errorf(\"error on `DescribeKey` operation; keyName=%s; error=%s;\", keyName, err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn output.KeyMetadata, nil\n}\n\n// DeleteKey executes ScheduleKeyDeletion operation from Key name(key id, arn or alias).\nfunc (svc *KMS) DeleteKey(keyName string, day int) error {\n\tmetaData, err := svc.DescribeKey(keyName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn svc.ScheduleKeyDeletion(*metaData.KeyId, day)\n}\n\n// ScheduleKeyDeletion executes ScheduleKeyDeletion operation.\nfunc (svc *KMS) ScheduleKeyDeletion(keyID string, day int) error {\n\t_, err := svc.client.ScheduleKeyDeletion(&SDK.ScheduleKeyDeletionInput{\n\t\tKeyId:               pointers.String(keyID),\n\t\tPendingWindowInDays: pointers.Long(day),\n\t})\n\tif err != nil {\n\t\tsvc.Errorf(\"error on `ScheduleKeyDeletion` operation; keyID=%s; error=%s;\", keyID, err.Error())\n\t}\n\treturn err\n}\n\n// Encrypt executes Encrypt operation.\nfunc (svc *KMS) Encrypt(keyName string, plainData []byte) (encryptedData []byte, err error) {\n\toutput, err := svc.client.Encrypt(&SDK.EncryptInput{\n\t\tKeyId:     pointers.String(keyName),\n\t\tPlaintext: plainData,\n\t})\n\tif err != nil {\n\t\tsvc.Errorf(\"error on `Encrypt` operation; keyName=%s; error=%s;\", keyName, err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn output.CiphertextBlob, nil\n}\n\n// EncryptString executes Encrypt operation with base64 string.\nfunc (svc *KMS) EncryptString(keyName, plainText string) (base64Text string, err error) {\n\tencryptedData, err := svc.Encrypt(keyName, []byte(plainText))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.StdEncoding.EncodeToString(encryptedData), nil\n}\n\n// Decrypt executes Decrypt operation.\nfunc (svc *KMS) Decrypt(encryptedData []byte) (plainData []byte, err error) {\n\toutput, err := svc.client.Decrypt(&SDK.DecryptInput{\n\t\tCiphertextBlob: encryptedData,\n\t})\n\tif err != nil {\n\t\tsvc.Errorf(\"error on `Decrypt` operation; error=%s;\", err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn output.Plaintext, nil\n}\n\n// DecryptString executes Decrypt operation with base64 string.\nfunc (svc *KMS) DecryptString(base64Text string) (plainText string, err error) {\n\tbyt, err := base64.StdEncoding.DecodeString(base64Text)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tplainData, err := svc.Decrypt(byt)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(plainData), nil\n}\n\n// ReEncrypt executes ReEncrypt operation.\nfunc (svc *KMS) ReEncrypt(destinationKey string, encryptedData []byte) (resultEncryptedData []byte, err error) {\n\toutput, err := svc.client.ReEncrypt(&SDK.ReEncryptInput{\n\t\tDestinationKeyId: pointers.String(destinationKey),\n\t\tCiphertextBlob:   encryptedData,\n\t})\n\tif err != nil {\n\t\tsvc.Errorf(\"error on `ReEncrypt` operation; destinationKey=%s; error=%s;\", destinationKey, err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn output.CiphertextBlob, nil\n}\n\n// ReEncryptString executes ReEncrypt operation with base64 string.\nfunc (svc *KMS) ReEncryptString(destinationKey, base64Text string) (resultBase64Text string, err error) {\n\tbyt, err := base64.StdEncoding.DecodeString(base64Text)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tencryptedData, err := svc.ReEncrypt(destinationKey, byt)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.StdEncoding.EncodeToString(encryptedData), nil\n}\n\n// Infof logging information.\nfunc (svc *KMS) Infof(format string, v ...interface{}) {\n\tsvc.logger.Infof(serviceName, format, v...)\n}\n\n// Errorf logging error information.\nfunc (svc *KMS) Errorf(format string, v ...interface{}) {\n\tsvc.logger.Errorf(serviceName, format, v...)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(MultiplyTwoNumbers(4, 5))\n}\n\n// Function to multiply two numbers\nfunc MultiplyTwoNumbers(a, b int) int {\n\treturn a * b\n}"}
{"sample": "// Package bech32 implements bech32 encoding and decoding.\npackage bech32\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/iotaledger/iota.go/v2/bech32/internal/base32\"\n)\n\nconst (\n\tmaxStringLength = 90\n\tchecksumLength  = 6\n\tseparator       = '1'\n)\n\nvar charset = newEncoding(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\")\n\n// Encode encodes the String string and the src data as a Bech32 string.\n// It returns an error when the input is invalid.\nfunc Encode(hrp string, src []byte) (string, error) {\n\tdataLen := base32.EncodedLen(len(src))\n\tif len(hrp)+dataLen+checksumLength+1 > maxStringLength {\n\t\treturn \"\", fmt.Errorf(\"%w: String length=%d, data length=%d\", ErrInvalidLength, len(hrp), dataLen)\n\t}\n\t// validate the human-readable part\n\tif len(hrp) < 1 {\n\t\treturn \"\", fmt.Errorf(\"%w: String must not be empty\", ErrInvalidLength)\n\t}\n\tfor _, c := range hrp {\n\t\tif !isValidHRPChar(c) {\n\t\t\treturn \"\", fmt.Errorf(\"%w: not US-ASCII character in human-readable part\", ErrInvalidCharacter)\n\t\t}\n\t}\n\tif err := validateCase(hrp); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// convert the human-readable part to lower for the checksum\n\thrpLower := strings.ToLower(hrp)\n\n\t// convert to base32 and add the checksum\n\tdata := make([]uint8, base32.EncodedLen(len(src))+checksumLength)\n\tbase32.Encode(data, src)\n\tcopy(data[dataLen:], bech32CreateChecksum(hrpLower, data[:dataLen]))\n\n\t// enc the data part using the charset\n\tchars := charset.encode(data)\n\n\t// convert to a string using the corresponding charset\n\tvar res strings.Builder\n\tres.WriteString(hrp)\n\tres.WriteByte(separator)\n\tres.WriteString(chars)\n\n\t// return with the correct case\n\tif hrp == hrpLower {\n\t\treturn res.String(), nil\n\t}\n\treturn strings.ToUpper(res.String()), nil\n}\n\n// Decode decodes the Bech32 string s into its human-readable and data part.\n// It returns an error when s does not represent a valid Bech32 encoding.\n// An SyntaxError is returned when the error can be matched to a certain position in s.\nfunc Decode(s string) (string, []byte, error) {\n\tif len(s) > maxStringLength {\n\t\treturn \"\", nil, &SyntaxError{fmt.Errorf(\"%w: maximum length exceeded\", ErrInvalidLength), maxStringLength}\n\t}\n\t// validate the separator\n\thrpLen := strings.LastIndex(s, string(separator))\n\tif hrpLen == -1 {\n\t\treturn \"\", nil, ErrMissingSeparator\n\t}\n\tif hrpLen < 1 || hrpLen+checksumLength > len(s) {\n\t\treturn \"\", nil, &SyntaxError{fmt.Errorf(\"%w: invalid position\", ErrInvalidSeparator), hrpLen}\n\t}\n\t// validate characters in human-readable part\n\tfor i, c := range s[:hrpLen] {\n\t\tif !isValidHRPChar(c) {\n\t\t\treturn \"\", nil, &SyntaxError{fmt.Errorf(\"%w: not US-ASCII character in human-readable part\", ErrInvalidCharacter), i}\n\t\t}\n\t}\n\t// validate that the case of the entire string is consistent\n\tif err := validateCase(s); err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\t// convert everything to lower\n\ts = strings.ToLower(s)\n\thrp := s[:hrpLen]\n\tchars := s[hrpLen+1:]\n\n\t// decode the data part\n\tdata, err := charset.decode(chars)\n\tif err != nil {\n\t\treturn \"\", nil, &SyntaxError{fmt.Errorf(\"%w: non-charset character in data part\", ErrInvalidCharacter), hrpLen + 1 + len(data)}\n\t}\n\n\t// validate the checksum\n\tif len(data) < checksumLength || !bech32VerifyChecksum(hrp, data) {\n\t\treturn \"\", nil, &SyntaxError{ErrInvalidChecksum, len(s) - checksumLength}\n\t}\n\tdata = data[:len(data)-checksumLength]\n\n\t// decode the data part\n\tdst := make([]byte, base32.DecodedLen(len(data)))\n\tif _, err := base32.Decode(dst, data); err != nil {\n\t\tvar e *base32.CorruptInputError\n\t\tif errors.As(err, &e) {\n\t\t\treturn \"\", nil, &SyntaxError{e.Unwrap(), hrpLen + 1 + e.Offset}\n\t\t}\n\t\treturn \"\", nil, err\n\t}\n\treturn hrp, dst, nil\n}\n\nfunc isValidHRPChar(r rune) bool {\n\t// it must only contain US-ASCII characters, with each character having a value in the range [33-126]\n\treturn r >= 33 && r <= 126\n}\n\nfunc validateCase(s string) error {\n\tupper, lower := firstUpper(s), firstLower(s)\n\tif upper < lower && upper >= 0 {\n\t\treturn &SyntaxError{ErrMixedCase, lower}\n\t}\n\tif lower < upper && lower >= 0 {\n\t\treturn &SyntaxError{ErrMixedCase, upper}\n\t}\n\treturn nil\n}\n\nfunc firstUpper(s string) int {\n\tlower := strings.ToLower(s)\n\tfor i := range s {\n\t\tif lower[i] != s[i] {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc firstLower(s string) int {\n\tlower := strings.ToUpper(s)\n\tfor i := range s {\n\t\tif lower[i] != s[i] {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n"}
{"sample": "// EncodeToGob encodes an interface into a gob.\nfunc EncodeToGob(v interface{}) ([]byte, error) {\n\tbuf := new(bytes.Buffer)\n\tenc := gob.NewEncoder(buf)\n\tif err := enc.Encode(v); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n\n// DecodeFromGob decodes a gob into an interface.\nfunc DecodeFromGob(data []byte, v interface{}) error {\n\tbuf := bytes.NewBuffer(data)\n\tdec := gob.NewDecoder(buf)\n\treturn dec.Decode(v)\n}"}
{"sample": "package main\n\nimport \"strings\"\n\nfunc main() {\n\tstr := \"Hello, World!\"\n\tresult := CountWords(str)\n\tfmt.Println(result)\n}\n\nfunc CountWords(s string) int {\n\treturn len(strings.Fields(s))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello, World!\"))\n}\n\nfunc usersHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tusername := vars[\"username\"]\n\tfmt.Fprintf(w, \"Hello %s!\", username)\n}\n\nfunc main() {\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/\", homeHandler)\n\tr.HandleFunc(\"/users/{username}\", usersHandler)\n\n\thttp.ListenAndServe(\":8080\", r)\n}"}
{"sample": "func main() {\n\tnumStr := \"42\"\n\tnum, err := strconv.Atoi(numStr)\n\tif err != nil {\n\t\tfmt.Println(\"Error converting string to int:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(num)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc worker(ctx context.Context, jobQueue chan int, results chan<- int) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase job := <-jobQueue:\n\t\t\tfmt.Printf(\"working on job %d\\n\", job)\n\t\t\ttime.Sleep(time.Second)\n\t\t\tresults <- job * 2\n\t\t}\n\t}\n}\n\nfunc main() {\n\tconst numJobs = 5\n\tjobQueue := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\n\t// spin up workers\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel() // tell workers we're done when main() exits\n\n\tfor i := 0; i < 3; i++ {\n\t\tgo worker(ctx, jobQueue, results)\n\t}\n\n\t// add jobs to the jobQueue\n\tfor i := 0; i < numJobs; i++ {\n\t\tjobQueue <- i\n\t}\n\n\tclose(jobQueue)\n\n\t// collect results\n\tfor i := 0; i < numJobs; i++ {\n\t\tresult := <-results\n\t\tfmt.Printf(\"result: %d\\n\", result)\n\t}\n}"}
{"sample": "type Square struct {\n\tSide float64\n}\nfunc (s Square) Area() float64 {\n\treturn s.Side * s.Side\n}\n"}
{"sample": "package main\n\n// HandleCustomError handles a custom error type\nfunc HandleCustomError(err error) {\n\tif customErr, ok := err.(*CustomError); ok {\n\t\tlog.Println(customErr.Details)\n\t}\n}\n"}
{"sample": "err = ioutil.WriteFile(\"file.txt\", []byte(\"Hello, World!\"), 0644)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "func CreateDirectory(path string) error {\n\treturn os.MkdirAll(path, 0755)\n}\n\nfunc ListFiles(directory string) ([]os.FileInfo, error) {\n\treturn ioutil.ReadDir(directory)\n}\n\nfunc DeleteDirectory(path string) error {\n\treturn os.RemoveAll(path)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// GenerateRandomNumber generates a random number within the specified range.\nfunc GenerateRandomNumber(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input-dir\", argparse.String, \".\", \"Input directory\")\nparser.AddArgument(\"--output-dir\", argparse.String, \".\", \"Output directory\")\n"}
{"sample": "package messagerouter\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n)\n\ntype Message struct {\n\tID      int\n\tContent string\n}\n\ntype MessageRouter struct {\n\tmessages map[int]Message\n\tmutex    sync.RWMutex\n}\n\nfunc NewMessageRouter() *MessageRouter {\n\treturn &MessageRouter{\n\t\tmessages: make(map[int]Message),\n\t}\n}\n\nfunc (mr *MessageRouter) SendMessage(id int, content string) error {\n\tmr.mutex.Lock()\n\tdefer mr.mutex.Unlock()\n\n\tif _, ok := mr.messages[id]; ok {\n\t\treturn errors.New(\"message with that ID already exists\")\n\t}\n\n\tmr.messages[id] = Message{\n\t\tID:      id,\n\t\tContent: content,\n\t}\n\n\treturn nil\n}\n\nfunc (mr *MessageRouter) GetMessage(id int) (Message, error) {\n\tmr.mutex.RLock()\n\tdefer mr.mutex.RUnlock()\n\n\tif message, ok := mr.messages[id]; ok {\n\t\treturn message, nil\n\t}\n\n\treturn Message{}, errors.New(\"message not found\")\n}\n\nfunc (mr *MessageRouter) RouteMessage(id int) error {\n\tmessage, err := mr.GetMessage(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Printf(\"Routing message with ID %d and content %s\", message.ID, message.Content)\n\n\treturn nil\n}\n\nfunc (mr *MessageRouter) PrintMessages() {\n\tmr.mutex.RLock()\n\tdefer mr.mutex.RUnlock()\n\n\tfor _, message := range mr.messages {\n\t\tfmt.Printf(\"Message ID: %d, Content: %s\\n\", message.ID, message.Content)\n\t}\n}"}
{"sample": "package esclient\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/elastic/go-elasticsearch/v8\"\n\t\"github.com/elastic/go-elasticsearch/v8/esapi\"\n)\n\ntype EsClient struct {\n\tClient *elasticsearch.Client\n}\n\nfunc (c *EsClient) Search(index, query string) ([]byte, error) {\n\treq := esapi.SearchRequest{\n\t\tIndex: []string{index},\n\t\tBody:  strings.NewReader(query),\n\t}\n\n\tres, err := req.Do(context.Background(), c.Client)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\n\tif res.IsError() {\n\t\treturn nil, fmt.Errorf(\"failed to search documents: %s\", res.String())\n\t}\n\n\tvar b bytes.Buffer\n\tif _, err := b.ReadFrom(res.Body); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b.Bytes(), nil\n}\n\nfunc (c *EsClient) Index(index string, doc interface{}, id string) error {\n\tvar buf bytes.Buffer\n\tif err := json.NewEncoder(&buf).Encode(doc); err != nil {\n\t\treturn err\n\t}\n\n\treq := esapi.IndexRequest{\n\t\tIndex:      index,\n\t\tDocumentID: id,\n\t\tBody:       &buf,\n\t\tRefresh:    \"true\",\n\t}\n\n\tres, err := req.Do(context.Background(), c.Client)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer res.Body.Close()\n\n\tif res.IsError() {\n\t\treturn fmt.Errorf(\"failed to index document: %s\", res.String())\n\t}\n\n\treturn nil\n}\n\nfunc NewEsClient(address string) (*EsClient, error) {\n\tcfg := elasticsearch.Config{\n\t\tAddresses: []string{address},\n\t\tTransport: &http.Transport{\n\t\t\tMaxIdleConnsPerHost:   10,\n\t\t\tResponseHeaderTimeout: time.Second,\n\t\t\tDialContext:           (&net.Dialer{Timeout: time.Second}).DialContext,\n\t\t\tTLSHandshakeTimeout:   time.Second,\n\t\t\tExpectContinueTimeout: time.Second,\n\t\t},\n\t}\n\n\tclient, err := elasticsearch.NewClient(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &EsClient{client}, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/api/convert\", conversionHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc conversionHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\thttp.Error(w, \"Can only accept POST requests\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tdecoder := json.NewDecoder(r.Body)\n\tvar requestData map[string]interface{}\n\terr := decoder.Decode(&requestData)\n\tif err != nil {\n\t\thttp.Error(w, \"Unable to decode request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfromValue, ok := requestData[\"from\"].(float64)\n\tif !ok {\n\t\thttp.Error(w, \"Invalid from value\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfromUnit, ok := requestData[\"fromUnit\"].(string)\n\tif !ok {\n\t\thttp.Error(w, \"Invalid from unit\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttoUnit, ok := requestData[\"toUnit\"].(string)\n\tif !ok {\n\t\thttp.Error(w, \"Invalid to unit\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tconversionRate, err := getConversionRate(fromUnit, toUnit)\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid units\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttoValue := fromValue * conversionRate\n\n\tconversionResult := map[string]interface{}{\"to\": toValue, \"toUnit\": toUnit}\n\tjsonResult, err := json.Marshal(conversionResult)\n\tif err != nil {\n\t\thttp.Error(w, \"Unable to generate response\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Write(jsonResult)\n}\n\nfunc getConversionRate(fromUnit, toUnit string) (float64, error) {\n\tif fromUnit == \"miles\" && toUnit == \"kilometers\" {\n\t\treturn 1.60934, nil\n\t} else if fromUnit == \"pounds\" && toUnit == \"kilograms\" {\n\t\treturn 0.453592, nil\n\t} else {\n\t\treturn 0, fmt.Errorf(\"Units not valid\")\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\n// Database represents a connection to a database.\ntype Database struct {\n\tconn *sql.DB\n}\n\n// ConnectToDatabase connects to a database using the given connection string.\nfunc ConnectToDatabase(connectionString string) (*Database, error) {\n\tconn, err := sql.Open(\"postgres\", connectionString)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Database{conn} nil\n}\n\n// ExecuteQuery executes the given SQL query and returns the result.\nfunc (db *Database) ExecuteQuery(query string) (*sql.Rows, error) {\n\treturn db.conn.Query(query)\n}\n\n// CloseDatabaseConnection closes the connection to the database.\nfunc (db *Database) CloseDatabaseConnection() error {\n\treturn db.conn.Close()\n}"}
{"sample": "package slidesclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"golang.org/x/oauth2/google\"\n\t\"google.golang.org/api/slides/v1\"\n)\n\nfunc getSlidesClient() (*slides.Service, error) {\n\tctx := context.Background()\n\n\tcreds, err := google.FindDefaultCredentials(ctx, slides.SlidesScope)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve default credentials: %v\", err)\n\t}\n\n\tclient, err := google.DefaultClient(ctx, slides.SlidesScope)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve default client: %v\", err)\n\t}\n\n\tslidesService, err := slides.New(client)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to create slides client: %v\", err)\n\t}\n\n\treturn slidesService, nil\n}\n\nfunc createSlide(title string) error {\n\tslidesService, err := getSlidesClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpresentation := &slides.Presentation{\n\t\tTitle: title,\n\t}\n\n\tpresentation, err = slidesService.Presentations.Create(presentation).Do()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to create presentation: %v\", err)\n\t}\n\n\tfmt.Printf(\"Created presentation with ID: %s\\n\", presentation.PresentationId)\n\treturn nil\n}\n\nfunc addSlide(presentationID string) error {\n\tslidesService, err := getSlidesClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trequests := []*slides.Request{\n\t\t{\n\t\t\tCreateSlide: &slides.CreateSlideRequest{\n\t\t\t\tObjectId: \"\",\n\t\t\t},\n\t\t},\n\t}\n\n\tbatchUpdateRequest := &slides.BatchUpdatePresentationRequest{\n\t\tRequests: requests,\n\t}\n\n\t_, err = slidesService.Presentations.BatchUpdate(presentationID, batchUpdateRequest).Do()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to add slide to presentation: %v\", err)\n\t}\n\n\tfmt.Println(\"Added slide to presentation\")\n\treturn nil\n}\n\nfunc deleteSlide(presentationID string, slideID string) error {\n\tslidesService, err := getSlidesClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trequests := []*slides.Request{\n\t\t{\n\t\t\tDeleteObject: &slides.DeleteObjectRequest{\n\t\t\t\tObjectId: slideID,\n\t\t\t},\n\t\t},\n\t}\n\n\tbatchUpdateRequest := &slides.BatchUpdatePresentationRequest{\n\t\tRequests: requests,\n\t}\n\n\t_, err = slidesService.Presentations.BatchUpdate(presentationID, batchUpdateRequest).Do()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to delete slide from presentation: %v\", err)\n\t}\n\n\tfmt.Println(\"Deleted slide from presentation\")\n\treturn nil\n}\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tlog.Fatalf(\"Usage: %s <presentation title>\", os.Args[0])\n\t}\n\n\ttitle := os.Args[1]\n\tif err := createSlide(title); err != nil {\n\t\tlog.Fatalf(\"Unable to create slide: %v\", err)\n\t}\n\n\tpresentationID := \"presentation-id\" // Replace with actual presentation ID\n\tif err := addSlide(presentationID); err != nil {\n\t\tlog.Fatalf(\"Unable to add slide: %v\", err)\n\t}\n\n\tslideID := \"slide-id\" // Replace with actual slide ID\n\tif err := deleteSlide(presentationID, slideID); err != nil {\n\t\tlog.Fatalf(\"Unable to delete slide: %v\", err)\n\t}\n}"}
{"sample": "package main\n\n// Remove a file\nfunc main() {\n\terr := os.Remove(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package metadata\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"strconv\"\n\n\t\"github.com/incognitochain/incognito-chain/common\"\n\t\"github.com/incognitochain/incognito-chain/dataaccessobject/statedb\"\n\tmetadataCommon \"github.com/incognitochain/incognito-chain/metadata/common\"\n\tbtcrelaying \"github.com/incognitochain/incognito-chain/relaying/btc\"\n)\n\ntype PortalSubmitConfirmedTxRequest struct {\n\tMetadataBase\n\tTokenID       string // pTokenID in incognito chain\n\tUnshieldProof string\n\tBatchID       string\n}\n\ntype PortalSubmitConfirmedTxAction struct {\n\tMeta    PortalSubmitConfirmedTxRequest\n\tTxReqID common.Hash\n\tShardID byte\n}\n\ntype PortalSubmitConfirmedTxContent struct {\n\tTokenID      string\n\tUTXOs        []*statedb.UTXO\n\tBatchID      string\n\tTxReqID      common.Hash\n\tExternalTxID string\n\tExternalFee  uint64\n\tShardID      byte\n}\n\ntype PortalSubmitConfirmedTxStatus struct {\n\tTokenID      string\n\tUTXOs        []*statedb.UTXO\n\tBatchID      string\n\tTxHash       string\n\tExternalTxID string\n\tExternalFee  uint64\n\tStatus       int\n}\n\nfunc NewPortalSubmitConfirmedTxStatus(tokenID, batchID, externalTxID, txID string, UTXOs []*statedb.UTXO, status int, externalFee uint64) *PortalSubmitConfirmedTxStatus {\n\treturn &PortalSubmitConfirmedTxStatus{\n\t\tTokenID:      tokenID,\n\t\tUTXOs:        UTXOs,\n\t\tBatchID:      batchID,\n\t\tTxHash:       txID,\n\t\tExternalTxID: externalTxID,\n\t\tExternalFee:  externalFee,\n\t\tStatus:       status,\n\t}\n}\n\nfunc NewPortalSubmitConfirmedTxRequest(metaType int, unshieldProof, tokenID, batchID string) (*PortalSubmitConfirmedTxRequest, error) {\n\tmetadataBase := MetadataBase{\n\t\tType: metaType,\n\t}\n\n\tportalUnshieldReq := &PortalSubmitConfirmedTxRequest{\n\t\tTokenID:       tokenID,\n\t\tBatchID:       batchID,\n\t\tUnshieldProof: unshieldProof,\n\t}\n\n\tportalUnshieldReq.MetadataBase = metadataBase\n\n\treturn portalUnshieldReq, nil\n}\n\nfunc (r PortalSubmitConfirmedTxRequest) ValidateTxWithBlockChain(\n\ttxr Transaction,\n\tchainRetriever ChainRetriever,\n\tshardViewRetriever ShardViewRetriever,\n\tbeaconViewRetriever BeaconViewRetriever,\n\tshardID byte,\n\tdb *statedb.StateDB,\n) (bool, error) {\n\treturn true, nil\n}\n\nfunc (r PortalSubmitConfirmedTxRequest) ValidateSanityData(chainRetriever ChainRetriever, shardViewRetriever ShardViewRetriever, beaconViewRetriever BeaconViewRetriever, beaconHeight uint64, tx Transaction) (bool, bool, error) {\n\t// check tx type and version\n\tif tx.GetType() != common.TxNormalType {\n\t\treturn false, false, NewMetadataTxError(metadataCommon.PortalV4SubmitConfirmedTxRequestMetaError, errors.New(\"tx replace transaction must be TxNormalType\"))\n\t}\n\n\tif tx.GetVersion() != 2 {\n\t\treturn false, false, NewMetadataTxError(metadataCommon.PortalV4SubmitConfirmedTxRequestMetaError,\n\t\t\terrors.New(\"Tx submit confirmed tx request must be version 2\"))\n\t}\n\n\t// validate tokenID\n\tisPortalToken, err := chainRetriever.IsPortalToken(beaconHeight, r.TokenID, common.PortalVersion4)\n\tif !isPortalToken || err != nil {\n\t\treturn false, false, errors.New(\"TokenID is not supported currently on Portal v4\")\n\t}\n\n\t_, err = btcrelaying.ParseAndValidateSanityBTCProofFromB64EncodeStr(r.UnshieldProof)\n\tif r.BatchID == \"\" || err != nil {\n\t\treturn false, false, errors.New(\"BatchID or UnshieldProof is invalid\")\n\t}\n\n\treturn true, true, nil\n}\n\nfunc (r PortalSubmitConfirmedTxRequest) ValidateMetadataByItself() bool {\n\treturn r.Type == metadataCommon.PortalV4SubmitConfirmedTxMeta\n}\n\nfunc (r PortalSubmitConfirmedTxRequest) Hash() *common.Hash {\n\trecord := r.MetadataBase.Hash().String()\n\trecord += r.TokenID\n\trecord += r.BatchID\n\trecord += r.UnshieldProof\n\n\t// final hash\n\thash := common.HashH([]byte(record))\n\treturn &hash\n}\n\nfunc (r *PortalSubmitConfirmedTxRequest) BuildReqActions(tx Transaction, chainRetriever ChainRetriever, shardViewRetriever ShardViewRetriever, beaconViewRetriever BeaconViewRetriever, shardID byte, shardHeight uint64) ([][]string, error) {\n\tactionContent := PortalSubmitConfirmedTxAction{\n\t\tMeta:    *r,\n\t\tTxReqID: *tx.Hash(),\n\t\tShardID: shardID,\n\t}\n\tactionContentBytes, err := json.Marshal(actionContent)\n\tif err != nil {\n\t\treturn [][]string{}, err\n\t}\n\tactionContentBase64Str := base64.StdEncoding.EncodeToString(actionContentBytes)\n\taction := []string{strconv.Itoa(metadataCommon.PortalV4SubmitConfirmedTxMeta), actionContentBase64Str}\n\treturn [][]string{action}, nil\n}\n\nfunc (r *PortalSubmitConfirmedTxRequest) CalculateSize() uint64 {\n\treturn calculateSize(r)\n}\n"}
{"sample": "package middleware\n\nimport (\n\t\"net/http\"\n)\n\nfunc AuthMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check if user is authenticated\n\t\tif !isAuthenticated(r) {\n\t\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc isAuthenticated(r *http.Request) bool {\n\t// check if user is authenticated\n\t// implementation omitted for brevity\n\treturn true\n}"}
{"sample": "// Copyright 2021 SIA ZZ Dats. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage cose\n\n// SignMessage represents a COSE_Sign message.\ntype SignMessage struct {\n\tHeaders *Headers\n\tsigners []*Signer\n\tcontent []byte\n}\n\n// NewSignMessage creates a new SignMessage instance.\nfunc NewSignMessage() *SignMessage {\n\treturn &SignMessage{\n\t\tHeaders: NewHeaders(),\n\t\tsigners: make([]*Signer, 0),\n\t}\n}\n\n// GetMessageTag returns the COSE_Sign message tag.\nfunc (m *SignMessage) GetMessageTag() uint64 {\n\treturn MessageTagSign\n}\n\n// GetContent returns the message content.\nfunc (m *SignMessage) GetContent() []byte {\n\treturn m.content\n}\n\n// SetContent sets the message content.\nfunc (m *SignMessage) SetContent(content []byte) {\n\tm.content = content\n}\n\n// AddSigner adds a signer for the message.\nfunc (m *SignMessage) AddSigner(signer *Signer) {\n\tif signer == nil {\n\t\treturn\n\t}\n\tm.signers = append(m.signers, signer)\n}\n\nfunc (m *SignMessage) sign(e *Encoding, external []byte) (interface{}, error) {\n\tph, err := e.marshal(m.Headers.protected)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmsg := signMessage{\n\t\tProtected:   ph,\n\t\tUnprotected: m.Headers.unprotected,\n\t\tPayload:     m.GetContent(),\n\t\tSignatures:  make([]*signMessageSignature, len(m.signers)),\n\t}\n\tfor i, signer := range m.signers {\n\t\tsheaders, err := signer.GetHeaders()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tph, err := e.marshal(sheaders.protected)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdigest, err := msg.GetDigest(e, ph, external)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmsg.Signatures[i] = &signMessageSignature{\n\t\t\tProtected:   ph,\n\t\t\tUnprotected: sheaders.unprotected,\n\t\t}\n\t\tmsg.Signatures[i].Signature, err = signer.Sign(e.rand, digest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn msg, nil\n}\n\ntype signMessageSignature struct {\n\t_           struct{} `cbor:\",toarray\"`\n\tProtected   []byte\n\tUnprotected map[interface{}]interface{}\n\tSignature   []byte\n}\n\ntype signMessage struct {\n\t_           struct{} `cbor:\",toarray\"`\n\tProtected   []byte\n\tUnprotected map[interface{}]interface{}\n\tPayload     []byte\n\tSignatures  []*signMessageSignature\n}\n\nfunc (m *signMessage) GetDigest(e *Encoding, signerProtected []byte, external []byte) ([]byte, error) {\n\treturn e.marshal([]interface{}{\n\t\t\"Signature\",\n\t\tm.Protected,\n\t\tsignerProtected,\n\t\texternal,\n\t\tm.Payload,\n\t})\n}\n\nfunc newSignMessage(e *Encoding, c *signMessage) (*SignMessage, error) {\n\th, err := newHeaders(e, c.Protected, c.Unprotected)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &SignMessage{\n\t\tHeaders: h,\n\t\tcontent: c.Payload,\n\t}, nil\n}\n"}
{"sample": "package main\n\n// HandleError handles the error by logging and exiting\nfunc HandleError(err error) {\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package countingsort\n\nfunc CountingSort(arr []int) []int {\n\tif len(arr) == 0 {\n\t\treturn arr\n\t}\n\n\tmax := arr[0]\n\tfor _, val := range arr {\n\t\tif val > max {\n\t\t\tmax = val\n\t\t}\n\t}\n\n\tcounts := make([]int, max+1)\n\n\tfor _, val := range arr {\n\t\tcounts[val]++\n\t}\n\n\tfor i := 1; i < len(counts); i++ {\n\t\tcounts[i] += counts[i-1]\n\t}\n\n\tsorted := make([]int, len(arr))\n\n\tfor _, val := range arr {\n\t\tsorted[counts[val]-1] = val\n\t\tcounts[val]--\n\t}\n\n\treturn sorted\n}"}
{"sample": "package main\n\n// HandleErrAndRecover handles an error and recovers from a panic situation\nfunc HandleErrAndRecover(err error) {\n\tdefer RecoverFromPanic()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package sqlbridge\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc ConnectToDB(databaseURL string) (*sql.DB, error) {\n\tdb, err := sql.Open(\"mysql\", databaseURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = db.Ping(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n\nfunc GetAllUsers(db *sql.DB) ([]User, error) {\n\tvar users []User\n\n\trows, err := db.Query(\"SELECT * FROM users;\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar u User\n\t\tif err := rows.Scan(&u.ID, &u.Username, &u.Email); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tusers = append(users, u)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn users, nil\n}\n\nfunc CreateUser(db *sql.DB, user *User) error {\n\tr, err := db.Exec(\"INSERT INTO users (username, email) VALUES (?, ?);\", user.Username, user.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlastInsertedID, err := r.LastInsertId()\n\tif err != nil {\n\t\treturn err\n\t}\n\tuser.ID = int(lastInsertedID)\n\n\treturn nil\n}\n\nfunc GetUser(db *sql.DB, id int) (*User, error) {\n\tstmt, err := db.Prepare(\"SELECT id, username, email FROM users WHERE id = ?\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\tvar u User\n\terr = stmt.QueryRow(id).Scan(&u.ID, &u.Username, &u.Email)\n\tif err == sql.ErrNoRows {\n\t\treturn nil, nil\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &u, nil\n}\n\nfunc main() {\n\tdb, err := ConnectToDB(\"testuser:testpass@tcp(localhost:3306)/testdb\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(db)\n\n\tdefer db.Close()\n\n\tusers, err := GetAllUsers(db)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(users)\n\n\tu := &User{Username: \"testUser1\", Email: \"testUser1@test.com\"}\n\terr = CreateUser(db, u)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(u)\n\n\tuser, err := GetUser(db, u.ID)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(user)\n\n\tuser, err = GetUser(db, 12345)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(user)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nvar ctx = context.Background()\n\nfunc main() {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tpong, err := rdb.Ping(ctx).Result()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to Redis: %v\", err)\n\t}\n\n\tfmt.Printf(\"Redis connection established: %v\\n\", pong)\n\n\terr = rdb.Set(ctx, \"myKey\", \"Hello Redis!\", time.Minute).Err()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to set key-value pair: %v\", err)\n\t}\n\n\tval, err := rdb.Get(ctx, \"myKey\").Result()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to retrieve value: %v\", err)\n\t}\n\n\tfmt.Printf(\"Value of key myKey: %s\\n\", val)\n\n\terr = rdb.Del(ctx, \"myKey\").Err()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to delete key: %v\", err)\n\t}\n\n\tfmt.Printf(\"Key myKey deleted\")\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package azureblobclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/Azure/azure-storage-blob-go/azblob\"\n)\n\ntype BlobClient struct {\n\tcontainerURL azblob.ContainerURL\n}\n\nfunc NewBlobClient(accountName, accountKey, containerName string) (*BlobClient, error) {\n\tcredential, err := azblob.NewSharedKeyCredential(accountName, accountKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpipeline := azblob.NewPipeline(credential, azblob.PipelineOptions{})\n\tURL, _ := url.Parse(fmt.Sprintf(\"https://%s.blob.core.windows.net/%s\", accountName, containerName))\n\tcontainerURL := azblob.NewContainerURL(*URL, pipeline)\n\n\treturn &BlobClient{containerURL}, nil\n}\n\nfunc (c *BlobClient) UploadBlob(ctx context.Context, blobName string, data []byte) error {\n\tblobURL := c.containerURL.NewBlockBlobURL(blobName)\n\n\t_, err := azblob.UploadBufferToBlockBlob(ctx, data, blobURL, azblob.UploadToBlockBlobOptions{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *BlobClient) DownloadBlob(ctx context.Context, blobName string) ([]byte, error) {\n\tblobURL := c.containerURL.NewBlockBlobURL(blobName)\n\n\tresp, err := blobURL.Download(ctx, 0, azblob.CountToEnd, azblob.BlobAccessConditions{}, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Response().Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Response().Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"}
{"sample": "package main\n\n// IfErrorThenLogWithMessage checks if an error exists, if so, logs it with a message\nfunc IfErrorThenLogWithMessage(err error, message string) {\n\tif err != nil {\n\t\tlog.Printf(\"%s: %v\", message, err)\n\t}\n}\n"}
{"sample": "// Unmarshaling JSON\n\nvar data struct {\n\tField string `json:\"field\"`\n}\nerr := json.Unmarshal(jsonData, &data)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package filetransferservice\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc uploadFile(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tfile, header, err := r.FormFile(\"file\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tf, err := os.OpenFile(header.Filename, os.O_WRONLY|os.O_CREATE, 0666)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tif _, err := io.Copy(f, file); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"File uploaded successfully\")\n}\n\nfunc downloadFile(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"GET\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tfilename := r.URL.Query().Get(\"filename\")\n\tif filename == \"\" {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tw.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+filename)\n\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tif _, err := io.Copy(w, file); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n}"}
{"sample": "items := []int{3, 1, 4, 1, 5, 9}\nsort.Ints(items)\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"encoding/base64\"\n)\n\nfunc SendBasicAuthRequest() {\n\tclient := &http.Client{}\n\trequest, _ := http.NewRequest(\"GET\", \"https://example.com\", nil)\n\n\tusername := \"user\"\n\tpassword := \"pass\"\n\tauth := username + \":\" + password\n\tencodedAuth := base64.StdEncoding.EncodeToString([]byte(auth))\n\n\trequest.Header.Set(\"Authorization\", \"Basic \"+encodedAuth)\n\n\tresponse, _ := client.Do(request)\n\tdefer response.Body.Close()\n\n\t// Handle the response\n}\n"}
{"sample": "package stackimpl\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Stack is a simple implementation of a stack data structure\ntype Stack struct {\n\titems []int\n}\n\n// Push adds an item to the top of the stack\nfunc (s *Stack) Push(item int) {\n\ts.items = append(s.items, item)\n}\n\n// Pop removes and returns the item at the top of the stack\nfunc (s *Stack) Pop() (int, error) {\n\tif len(s.items) == 0 {\n\t\treturn 0, errors.New(\"stack is empty\")\n\t}\n\n\tindex := len(s.items) - 1\n\titem := s.items[index]\n\ts.items = s.items[:index]\n\n\treturn item, nil\n}\n\n// Peek returns the item at the top of the stack without removing it\nfunc (s *Stack) Peek() (int, error) {\n\tif len(s.items) == 0 {\n\t\treturn 0, errors.New(\"stack is empty\")\n\t}\n\n\treturn s.items[len(s.items)-1], nil\n}\n\n// Size returns the number of items in the stack\nfunc (s *Stack) Size() int {\n\treturn len(s.items)\n}\n\n// IsEmpty returns true if the stack is empty, false otherwise\nfunc (s *Stack) IsEmpty() bool {\n\treturn len(s.items) == 0\n}\n\nfunc main() {\n\ts := Stack{}\n\ts.Push(1)\n\ts.Push(2)\n\ts.Push(3)\n\n\tfmt.Println(s.Peek())\n\tfmt.Println(s.Pop())\n\tfmt.Println(s.Size())\n\tfmt.Println(s.IsEmpty())\n}"}
{"sample": "package main\n\n// Encode data as gob to a file\nfunc main() {\n\tdata := \"Some data\"\n\tfile, _ := os.Create(\"file.gob\")\n\tdefer file.Close()\n\tencoder := gob.NewEncoder(file)\n\terr := encoder.Encode(&data)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintAverageOfArray([]int{1, 2, 3, 4, 5})\n}\n\n// Function to print the average of elements in an array\nfunc PrintAverageOfArray(arr []int) {\n\tsum := 0\n\tfor _, value := range arr {\n\t\tsum += value\n\t}\n\tfmt.Println(float64(sum) / float64(len(arr)))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadFile reads and returns the content of a file.\nfunc ReadFile(filePath string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// WriteFile writes the content to a file.\nfunc WriteFile(filePath string, content []byte) error {\n\treturn ioutil.WriteFile(filePath, content, 0644)\n}"}
{"sample": "package cwl\n\nimport (\n\t\"github.com/commondream/yamlast\"\n)\n\nfunc (l *loader) preprocess(n node) (node, error) {\n\tswitch n.Kind {\n\n\tcase yamlast.MappingNode:\n\t\tfor i := 0; i < len(n.Children)-1; i += 2 {\n\t\t\tk := n.Children[i]\n\t\t\tv := n.Children[i+1]\n\t\t\tswitch k.Value {\n\t\t\tcase \"$import\":\n\t      if _, ok := l.resolver.(noResolver); ok {\n          return n, nil\n        }\n\t\t\t\tb, _, err := l.resolver.Resolve(l.base, v.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tyamlnode, err := yamlast.Parse(b)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\t// TODO set line/col/file of the new nodes\n\t\t\t\treturn yamlnode.Children[0], nil\n\n\t\t\tcase \"$include\":\n\t      if _, ok := l.resolver.(noResolver); ok {\n          return n, nil\n        }\n\t\t\t\tb, _, err := l.resolver.Resolve(l.base, v.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\t// TODO check line/col of the new node is correct\n\t\t\t\treturn node(&yamlast.Node{\n\t\t\t\t\tKind:   yamlast.ScalarNode,\n\t\t\t\t\tLine:   n.Line,\n\t\t\t\t\tColumn: n.Column,\n\t\t\t\t\tValue:  string(b),\n\t\t\t\t}), nil\n\n\t\t\t// TODO $mixin\n\n\t\t\tdefault:\n\t\t\t\tx, err := l.preprocess(v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tn.Children[i+1] = x\n\t\t\t}\n\t\t}\n\n\tcase yamlast.SequenceNode:\n\t\tfor i, c := range n.Children {\n\t\t\tx, err := l.preprocess(c)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tn.Children[i] = x\n\t\t}\n\t}\n\treturn n, nil\n}\n"}
{"sample": "// Send a PUT request to the specified URL with a JSON payload\nfunc Put(url string, payload []byte) (*http.Response, error) {\n\trequest, _ := http.NewRequest(\"PUT\", url, bytes.NewBuffer(payload))\n\treturn http.DefaultClient.Do(request)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc getUser(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"GET\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tusername := r.URL.Query().Get(\"username\")\n\n\tresponse, err := http.Get(\n\t\tfmt.Sprintf(\"https://api.github.com/users/%s\", username),\n\t)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(w, \"User not found\")\n\t\treturn\n\t}\n\n\tdefer response.Body.Close()\n\n\tbody, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tvar user User\n\tif err := json.Unmarshal(body, &user); err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/user\", getUser)\n\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package hotreloadserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, world!\")\n\t})\n\n\tgo func() {\n\t\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdefer watcher.Close()\n\n\tdone := make(chan bool)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase event, ok := <-watcher.Events:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif event.Op&fsnotify.Write == fsnotify.Write {\n\t\t\t\t\tlog.Println(\"modified file:\", event.Name)\n\t\t\t\t\tdone <- true\n\t\t\t\t}\n\t\t\tcase err, ok := <-watcher.Errors:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Println(\"error:\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\terr = watcher.Add(\".\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t<-done\n\n\tlog.Println(\"reloading...\")\n\ttime.Sleep(2 * time.Second)\n\tlog.Println(\"reloaded\")\n}"}
{"sample": "// Enable HTTP/2 support for the server\nfunc EnableHTTP2(server *http.Server) {\n\thttp2.ConfigureServer(server, &http2.Server{})\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/\", homeHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/users/{id}\", userHandler).Methods(\"GET\")\n\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\n\tlog.Printf(\"Server running on port %s\", port)\n\tif err := http.ListenAndServe(fmt.Sprintf(\":%s\", port), r); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Welcome to the home page!\")\n}\n\nfunc userHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid := vars[\"id\"]\n\tfmt.Fprintf(w, \"User ID: %s\", id)\n}"}
{"sample": "func main() {\n\tvar num int\n\tnumStr := \"42\"\n\n\terr := strconv.UnmarshalText([]byte(numStr), &num)\n\tif err != nil {\n\t\tfmt.Println(\"Error unmarshaling text:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(num)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/olivere/elastic/v7\"\n)\n\ntype Person struct {\n\tName string `json:\"name\"`\n\tAge  int    `json:\"age\"`\n}\n\nfunc main() {\n\tctx := context.Background()\n\n\tclient, err := elastic.NewClient()\n\tif err != nil {\n\t\t// Handle error\n\t}\n\n\tp1 := Person{Name: \"John Doe\", Age: 25}\n\tput1, err := client.Index().\n\t\tIndex(\"people\").\n\t\tId(\"1\").\n\t\tBodyJson(p1).\n\t\tDo(ctx)\n\tif err != nil {\n\t\t// Handle error\n\t}\n\tfmt.Printf(\"Indexed %s to index %s, type %s\\n\", put1.Id, put1.Index, put1.Type)\n}"}
{"sample": "package applog\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"sysvipc\"\n\t\"time\"\n)\n\ntype LOG_LEVEL uint8\n\nconst (\n\tDEBUG     = LOG_LEVEL(0)\n\tINFO      = LOG_LEVEL(1)\n\tCLEAN     = LOG_LEVEL(2)\n\tEVENT     = LOG_LEVEL(3)\n\tWARN      = LOG_LEVEL(4)\n\tERROR     = LOG_LEVEL(5)\n\tFATAL     = LOG_LEVEL(6)\n\tMAX_LEVEL = LOG_LEVEL(7)\n)\n\nfunc Level2Str(l LOG_LEVEL) string {\n\tswitch l {\n\tcase DEBUG:\n\t\treturn \"DEBUG\"\n\tcase INFO:\n\t\treturn \"INFO\"\n\tcase CLEAN:\n\t\treturn \"CLEAN\"\n\tcase EVENT:\n\t\treturn \"EVENT\"\n\tcase WARN:\n\t\treturn \"WARN\"\n\tcase ERROR:\n\t\treturn \"ERROR\"\n\tcase FATAL:\n\t\treturn \"FATAL\"\n\tdefault:\n\t\treturn \"UNDEFINE\"\n\t}\n}\n\ntype Logger struct {\n\tLogPath     string\n\tLogFilename string\n\tLogFullpath string\n\tAppName     string\n\tmutex       sync.Mutex\n}\n\nvar g_logger Logger\nvar g_debug_flag = false\nvar g_stdout_flag = false\nvar g_log_cfg *LogCfg\nvar g_mq sysvipc.MessageQueue\nvar g_log_available = false\n\nfunc Config() *LogCfg {\n\treturn g_log_cfg\n}\n\nfunc Log() *Logger {\n\treturn &g_logger\n}\n\nfunc DumpLog() string {\n\treturn fmt.Sprintf(\"LogPath: %s\\nLogFilename: %s\\nLogFullpath: %s\\nAppName: %s\\n\", g_logger.LogPath, g_logger.LogFilename, g_logger.LogFullpath, g_logger.AppName)\n}\n\nfunc InitLog(filename string, app_name string) error {\n\tg_logger.mutex.Lock()\n\tdefer g_logger.mutex.Unlock()\n\n\tif len(g_log_cfg.LogPath) < 1 || len(filename) < 1 || len(app_name) < 1 {\n\t\treturn errors.New(fmt.Sprintf(\"InitLog: invalid arguments path[%s] filename[%s] app_name[%s]\", g_log_cfg.LogPath, filename, app_name))\n\t}\n\t/* if filename == \"mq\"||\"MQ\u201c do not write to file */\n\tif filename != \"mq\" || filename != \"MQ\" {\n\t\terr := ValidateFile(g_log_cfg.LogPath + \"/\" + filename)\n\t\tif err != nil {\n\t\t\treturn errors.New(fmt.Sprintf(\"InitLog [%s/%s] failed, %v\", g_log_cfg.LogPath, filename, err))\n\t\t}\n\t\tg_logger.LogPath = g_log_cfg.LogPath\n\t} else {\n\t\tg_logger.LogPath = \"mq\"\n\t}\n\tg_logger.LogFilename = filename\n\tg_logger.LogFullpath = g_log_cfg.LogPath + \"/\" + filename\n\tg_logger.AppName = app_name\n\tg_log_available = true\n\treturn nil\n}\n\nfunc LoadLogCfg(config_file string) error {\n\tvar cfg LogCfg\n\terr := cfg.Load(config_file)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmq, err := sysvipc.GetMsgQueue(cfg.MQID, &sysvipc.MQFlags{true, false, 0660})\n\tif err != nil {\n\t\treturn err\n\t}\n\tg_log_cfg = &cfg\n\tg_mq = mq\n\n\treturn nil\n}\n\nfunc DebugLog(d bool) {\n\tg_debug_flag = d\n}\n\nfunc StdoutLog(s bool) {\n\tg_stdout_flag = s\n}\n\nfunc IncreaseKpi(kpi_name string) error {\n\treturn WriteKpi(kpi_name, 1)\n}\n\nfunc DecreaseKpi(kpi_name string) error {\n\treturn WriteKpi(kpi_name, 1)\n}\n\nfunc WriteKpi(kpi_name string, delta int64) error {\n\tg_logger.mutex.Lock()\n\tdefer g_logger.mutex.Unlock()\n\tif g_log_cfg == nil {\n\t\treturn errors.New(\"WriteKpi failed, mq not initialized\")\n\t}\n\toid, err := g_log_cfg.GetKpiOid(kpi_name)\n\tif err != nil {\n\t\treturn errors.New(\"WriteKpi failed, invalid kpi_name \" + kpi_name)\n\t}\n\tkpi_line := fmt.Sprintf(\"%s|%d\", oid, delta)\n\t//fmt.Printf(\"WriteKpi [%s][%v]\\n\", kpi_line, []byte(kpi_line))\n\tg_mq.Send(KPI_MSG_TYPE, []byte(kpi_line), &sysvipc.MQSendFlags{true})\n\treturn nil\n}\n\nfunc Db(format string, v ...interface{}) {\n\tWriteLog(DEBUG, \"\", format, v...)\n}\n\nfunc Info(format string, v ...interface{}) {\n\tWriteLog(INFO, \"\", format, v...)\n}\n\nfunc WriteLog(level LOG_LEVEL, alarm_name string, format string, v ...interface{}) {\n\tg_logger.mutex.Lock()\n\tdefer g_logger.mutex.Unlock()\n\n\tts := time.Now().Format(\"20060102-150405.000\")\n\tif !g_debug_flag && level == DEBUG {\n\t\treturn\n\t}\n\tline := ts + \"|\" + g_logger.AppName + \"|\" + Level2Str(level) + \"|\" + fmt.Sprintf(format, v...)\n\tif g_stdout_flag || !g_log_available { //if no log file available print to stdout\n\t\tfmt.Println(line)\n\t}\n\tif !g_log_available { //simple mode, only write to stdout\n\t\treturn\n\t}\n\n\tif g_logger.LogFilename == \"mq\" {\n\t\terr := g_mq.Send(LOG_MSG_TYPE, []byte(line+\"\\n\"), &sysvipc.MQSendFlags{true})\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"log failed to write to mq: %s\\n\", line)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tf, err := os.OpenFile(g_logger.LogFullpath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)\n\t\tif err != nil {\n\t\t\t//fmt.Printf(\"WriteLog [%s] failed\\n\", g_logger.LogFullpath)\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t\tdefer f.Close()\n\t\tf.Write([]byte(line + \"\\n\"))\n\t}\n\n\t////////////// write alarm string to mq ///////////////\n\t/*20160514030208|DC:AOC_001:C001|ERROR|.1.3.6.1.4.1.193.176.3.4.2|Cannot connect to backup DCC server. ip address: , port: 0. Invalid ip address or port. The current instance of dcc_client is DC:AOC_001:C001*/\n\tif g_log_cfg != nil && level > INFO && level < MAX_LEVEL {\n\t\toid, err := g_log_cfg.GetAlarmOid(alarm_name)\n\t\tif err != nil || oid == NO_ALARM {\n\t\t\treturn\n\t\t}\n\t\talarm_line := fmt.Sprintf(\"%s|%s|%s|.%s|%s\", time.Now().Format(\"20060102150405\"), g_logger.AppName, Level2Str(level), oid, fmt.Sprintf(format, v...))\n\t\t//fmt.Printf(\"WriteAlarm [%s][%v]\\n\", alarm_line, []byte(alarm_line))\n\t\tg_mq.Send(ALARM_MSG_TYPE, []byte(alarm_line), &sysvipc.MQSendFlags{true})\n\t}\n}\n"}
{"sample": "// Get the query parameters from the request URL\nfunc GetQueryParameters(request *http.Request) url.Values {\n\treturn request.URL.Query()\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\toptions := &redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t}\n\n\tclient := redis.NewClient(options)\n\n\tpingResult, err := client.Ping(context.Background()).Result()\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to Redis:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Connected to Redis. Ping result:\", pingResult)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://api.example.com/data\")\n\tif err != nil {\n\t\tfmt.Println(\"Error making HTTP request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "package nodes\n\nimport (\n\t\"fmt\"\n\t\"text/scanner\"\n)\n\ntype Scope struct {\n\tAt     scanner.Position\n\tParent *Scope\n\n\tVariables []*Variable\n\n\tChildren []*Scope\n}\n\nfunc (self *Scope) Position() scanner.Position {\n\treturn self.At\n}\n\nfunc (self *Scope) Clone(at scanner.Position) *Scope {\n\tscope := &Scope{\n\t\tAt:     at,\n\t\tParent: self,\n\n\t\tVariables: append([]*Variable(nil), self.Variables...),\n\t}\n\tself.Children = append(self.Children, scope)\n\treturn scope\n}\n\nfunc (self *Scope) AddVariable(variable *Variable) *Scope {\n\tcloned := self.Clone(variable.At)\n\tcloned.Variables = append([]*Variable{variable}, cloned.Variables...)\n\treturn cloned\n}\n\nfunc (self *Scope) FindVariable(name string) *Variable {\n\tfor _, node := range self.Variables {\n\t\tif node.Name.String() == name {\n\t\t\treturn node\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (self *Scope) Find(name string) Node {\n\tvar node Node\n\n\tnode = self.FindVariable(name)\n\tif node != nil {\n\t\treturn node\n\t}\n\n\treturn nil\n}\n\nfunc (self *Scope) DumpTree() {\n\tscope := self\n\tfor scope != nil {\n\t\tfmt.Printf(\"-- %p %s\\n\", scope, scope.At)\n\t\tscope = scope.Parent\n\t}\n}\n"}
{"sample": "var i int\nswitch i {\ncase 0:\n\tfmt.Println(\"i is zero\")\ncase 1:\n\tfmt.Println(\"i is one\")\ndefault:\n\tfmt.Println(\"i is not zero or one\")\n}\n"}
{"sample": "func main() {\n\tvar num int\n\tnumStr := \"42\"\n\n\terr := strconv.UnmarshalText([]byte(numStr), &num)\n\tif err != nil {\n\t\tfmt.Println(\"Error unmarshaling text:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(num)\n}"}
{"sample": "package feedbackservice\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/streadway/amqp\"\n)\n\ntype Feedback struct {\n\tID      string `json:\"id\"`\n\tMessage string `json:\"message\"`\n}\n\nfunc handleFeedback(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tvar feedback Feedback\n\terr := json.NewDecoder(r.Body).Decode(&feedback)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr = publishFeedbackToQueue(feedback)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprint(w, \"Feedback received successfully\")\n}\n\nfunc publishFeedbackToQueue(feedback Feedback) error {\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"feedback_queue\", // name\n\t\tfalse,            // durable\n\t\tfalse,            // delete when unused\n\t\tfalse,            // exclusive\n\t\tfalse,            // no-wait\n\t\tnil,              // arguments\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbody, err := json.Marshal(feedback)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ch.Publish(\n\t\t\"\",     // exchange\n\t\tq.Name, // routing key\n\t\tfalse,  // mandatory\n\t\tfalse,  // immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"application/json\",\n\t\t\tBody:        body,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/feedback\", handleFeedback).Methods(\"POST\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintCharFrequency prints the frequency of each character in a given string.\nfunc PrintCharFrequency(str string) {\n\tfreq := make(map[rune]int)\n\tfor _, char := range str {\n\t\tfreq[char]++\n\t}\n\tfor char, count := range freq {\n\t\tfmt.Printf(\"%c: %d\\n\", char, count)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintHelloNtimes(\"Hello, World!\", 5)\n}\n\n// Function to print a string n times\nfunc PrintHelloNtimes(s string, n int) {\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Println(s)\n\t}\n}"}
{"sample": "// Code generated by go-swagger; DO NOT EDIT.\n\npackage resource_controls\n\n// This file was generated by the swagger tool.\n// Editing this file might prove futile when you re-run the swagger generate command\n\nimport (\n\t\"github.com/go-openapi/runtime\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n)\n\n// New creates a new resource controls API client.\nfunc New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {\n\treturn &Client{transport: transport, formats: formats}\n}\n\n/*\nClient for resource controls API\n*/\ntype Client struct {\n\ttransport runtime.ClientTransport\n\tformats   strfmt.Registry\n}\n\n/*\nResourceControlCreate creates a new resource control\n\nCreate a new resource control to restrict access to a Docker resource.\n**Access policy**: restricted\n\n*/\nfunc (a *Client) ResourceControlCreate(params *ResourceControlCreateParams, authInfo runtime.ClientAuthInfoWriter) (*ResourceControlCreateOK, error) {\n\t// TODO: Validate the params before sending\n\tif params == nil {\n\t\tparams = NewResourceControlCreateParams()\n\t}\n\n\tresult, err := a.transport.Submit(&runtime.ClientOperation{\n\t\tID:                 \"ResourceControlCreate\",\n\t\tMethod:             \"POST\",\n\t\tPathPattern:        \"/resource_controls\",\n\t\tProducesMediaTypes: []string{\"application/json\"},\n\t\tConsumesMediaTypes: []string{\"application/json\"},\n\t\tSchemes:            []string{\"http\", \"https\"},\n\t\tParams:             params,\n\t\tReader:             &ResourceControlCreateReader{formats: a.formats},\n\t\tAuthInfo:           authInfo,\n\t\tContext:            params.Context,\n\t\tClient:             params.HTTPClient,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result.(*ResourceControlCreateOK), nil\n\n}\n\n/*\nResourceControlDelete removes a resource control\n\nRemove a resource control.\n**Access policy**: restricted\n\n*/\nfunc (a *Client) ResourceControlDelete(params *ResourceControlDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*ResourceControlDeleteNoContent, error) {\n\t// TODO: Validate the params before sending\n\tif params == nil {\n\t\tparams = NewResourceControlDeleteParams()\n\t}\n\n\tresult, err := a.transport.Submit(&runtime.ClientOperation{\n\t\tID:                 \"ResourceControlDelete\",\n\t\tMethod:             \"DELETE\",\n\t\tPathPattern:        \"/resource_controls/{id}\",\n\t\tProducesMediaTypes: []string{\"\"},\n\t\tConsumesMediaTypes: []string{\"\"},\n\t\tSchemes:            []string{\"http\", \"https\"},\n\t\tParams:             params,\n\t\tReader:             &ResourceControlDeleteReader{formats: a.formats},\n\t\tAuthInfo:           authInfo,\n\t\tContext:            params.Context,\n\t\tClient:             params.HTTPClient,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result.(*ResourceControlDeleteNoContent), nil\n\n}\n\n/*\nResourceControlUpdate updates a resource control\n\nUpdate a resource control.\n**Access policy**: restricted\n\n*/\nfunc (a *Client) ResourceControlUpdate(params *ResourceControlUpdateParams, authInfo runtime.ClientAuthInfoWriter) (*ResourceControlUpdateOK, error) {\n\t// TODO: Validate the params before sending\n\tif params == nil {\n\t\tparams = NewResourceControlUpdateParams()\n\t}\n\n\tresult, err := a.transport.Submit(&runtime.ClientOperation{\n\t\tID:                 \"ResourceControlUpdate\",\n\t\tMethod:             \"PUT\",\n\t\tPathPattern:        \"/resource_controls/{id}\",\n\t\tProducesMediaTypes: []string{\"application/json\"},\n\t\tConsumesMediaTypes: []string{\"application/json\"},\n\t\tSchemes:            []string{\"http\", \"https\"},\n\t\tParams:             params,\n\t\tReader:             &ResourceControlUpdateReader{formats: a.formats},\n\t\tAuthInfo:           authInfo,\n\t\tContext:            params.Context,\n\t\tClient:             params.HTTPClient,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result.(*ResourceControlUpdateOK), nil\n\n}\n\n// SetTransport changes the transport on the client\nfunc (a *Client) SetTransport(transport runtime.ClientTransport) {\n\ta.transport = transport\n}\n"}
{"sample": "func queryRows(stmt *sql.Stmt, args ...interface{}) (*sql.Rows, error) {\n\trows, err := stmt.Query(args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn rows, nil\n}\n"}
{"sample": "package ssh\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc connectSSH(user, password, host string, port int) (*ssh.Session, error) {\n\tconfig := &ssh.ClientConfig{\n\t\tUser: user,\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(password),\n\t\t},\n\t\tTimeout: time.Second * 5,\n\t\tHostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error {\n\t\t\treturn nil\n\t\t},\n\t}\n\n\taddr := fmt.Sprintf(\"%s:%d\", host, port)\n\tclient, err := ssh.Dial(\"tcp\", addr, config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session, nil\n}\n\nfunc executeCommand(command string) (string, error) {\n\tuser := os.Getenv(\"SSH_USER\")\n\tpassword := os.Getenv(\"SSH_PASSWORD\")\n\thost := os.Getenv(\"SSH_HOST\")\n\tport := 22\n\n\tsession, err := connectSSH(user, password, host, port)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer session.Close()\n\n\toutput, err := session.CombinedOutput(command)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(output), nil\n}\n\nfunc uploadFile(localPath, remotePath string) error {\n\tuser := os.Getenv(\"SSH_USER\")\n\tpassword := os.Getenv(\"SSH_PASSWORD\")\n\thost := os.Getenv(\"SSH_HOST\")\n\tport := 22\n\n\tsession, err := connectSSH(user, password, host, port)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer session.Close()\n\n\tfileBytes, err := ioutil.ReadFile(localPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = session.Run(fmt.Sprintf(\"mkdir -p %s\", remotePath))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfileName := fmt.Sprintf(\"%s/%s\", remotePath, filepath.Base(localPath))\n\tfile, err := session.Create(fileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\t_, err = file.Write(fileBytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package imapclient\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/mail\"\n\t\"net/smtp\"\n\t\"strings\"\n\n\t\"github.com/emersion/go-imap\"\n\t\"github.com/emersion/go-imap/client\"\n\t\"github.com/emersion/go-message\"\n)\n\nfunc fetchMessages() error {\n\tc, err := client.DialTLS(\"imap.example.com:993\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer c.Logout()\n\n\tif err := c.Login(\"username\", \"password\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Select INBOX\n\tmbox, err := c.Select(\"INBOX\", false)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Get the last 10 messages\n\tfrom := uint32(1)\n\tto := mbox.Messages\n\tif mbox.Messages > 10 {\n\t\t// We're using unsigned integers here, only subtract if the result is > 0\n\t\tfrom = mbox.Messages - 9\n\t}\n\n\tseqset := new(imap.SeqSet)\n\tseqset.AddRange(from, to)\n\n\tmessages := make(chan *imap.Message, 10)\n\tdone := make(chan error, 1)\n\tgo func() {\n\t\tdone <- c.Fetch(seqset, []imap.FetchItem{imap.FetchEnvelope}, messages)\n\t}()\n\n\tfor msg := range messages {\n\t\tr := msg.GetEnvelope()\n\n\t\tif r.Subject != \"\" {\n\t\t\tfmt.Println(\"Subject:\", r.Subject)\n\t\t}\n\t\tif r.From != nil {\n\t\t\tfmt.Println(\"From:\", r.From[0].PersonalName)\n\t\t}\n\t\tif r.Date != \"\" {\n\t\t\tfmt.Println(\"Date:\", r.Date)\n\t\t}\n\n\t\t// Get the whole message body\n\t\tsection := &imap.BodySectionName{}\n\t\titems := []imap.FetchItem{section.FetchItem()}\n\t\tmessages := make(chan *imap.Message, 1)\n\t\tdone := make(chan error, 1)\n\t\tgo func() {\n\t\t\tdone <- c.Fetch(seqset, items, messages)\n\t\t}()\n\n\t\tmsg := <-messages\n\t\tif err := <-done; err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tr := msg.GetBody(section)\n\t\tif r == nil {\n\t\t\tlog.Fatal(\"Server didn't returned message body\")\n\t\t}\n\n\t\t// Create a new mail reader\n\t\tmr, err := message.NewReader(r)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Print the message body\n\t\tif body, err := mail.ReadMessage(mr); err == nil {\n\t\t\tfmt.Println(\"Body:\", body.Body)\n\t\t}\n\t}\n\n\tif err := <-done; err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn nil\n}\n\nfunc sendEmail(to, subject, body string) error {\n\tfrom := \"youremail@example.com\"\n\tpass := \"yourpassword\"\n\n\tmsg := \"From: \" + from + \"\\n\" +\n\t\t\"To: \" + to + \"\\n\" +\n\t\t\"Subject: \" + subject + \"\\n\\n\" +\n\t\tbody\n\n\terr := smtp.SendMail(\"smtp.example.com:587\",\n\t\tsmtp.PlainAuth(\"\", from, pass, \"smtp.example.com\"),\n\t\tfrom, []string{to}, []byte(msg))\n\n\tif err != nil {\n\t\tlog.Printf(\"smtp error: %s\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc searchMessages(query string) error {\n\tc, err := client.DialTLS(\"imap.example.com:993\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer c.Logout()\n\n\tif err := c.Login(\"username\", \"password\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Select INBOX\n\tmbox, err := c.Select(\"INBOX\", false)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Search for messages\n\tcriteria := imap.NewSearchCriteria()\n\tcriteria.Text = []string{query}\n\tids, err := c.Search(criteria)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif len(ids) == 0 {\n\t\tfmt.Println(\"No results found\")\n\t\treturn nil\n\t}\n\n\tseqset := new(imap.SeqSet)\n\tseqset.AddNum(ids...)\n\n\tmessages := make(chan *imap.Message, 10)\n\tdone := make(chan error, 1)\n\tgo func() {\n\t\tdone <- c.Fetch(seqset, []imap.FetchItem{imap.FetchEnvelope}, messages)\n\t}()\n\n\tfor msg := range messages {\n\t\tr := msg.GetEnvelope()\n\n\t\tif r.Subject != \"\" {\n\t\t\tfmt.Println(\"Subject:\", r.Subject)\n\t\t}\n\t\tif r.From != nil {\n\t\t\tfmt.Println(\"From:\", r.From[0].PersonalName)\n\t\t}\n\t\tif r.Date != \"\" {\n\t\t\tfmt.Println(\"Date:\", r.Date)\n\t\t}\n\n\t\t// Get the whole message body\n\t\tsection := &imap.BodySectionName{}\n\t\titems := []imap.FetchItem{section.FetchItem()}\n\t\tmessages := make(chan *imap.Message, 1)\n\t\tdone := make(chan error, 1)\n\t\tgo func() {\n\t\t\tdone <- c.Fetch(seqset, items, messages)\n\t\t}()\n\n\t\tmsg := <-messages\n\t\tif err := <-done; err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tr := msg.GetBody(section)\n\t\tif r == nil {\n\t\t\tlog.Fatal(\"Server didn't returned message body\")\n\t\t}\n\n\t\t// Create a new mail reader\n\t\tmr, err := message.NewReader(r)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Print the message body\n\t\tif body, err := mail.ReadMessage(mr); err == nil {\n\t\t\tfmt.Println(\"Body:\", body.Body)\n\t\t}\n\t}\n\n\tif err := <-done; err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn nil\n}"}
{"sample": "package urlparse\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n)\n\nfunc validateURL(input string) (string, error) {\n\tu, err := url.Parse(input)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"invalid URL: %v\", err)\n\t}\n\n\tif u.Scheme != \"http\" && u.Scheme != \"https\" {\n\t\treturn \"\", fmt.Errorf(\"unsupported URL scheme: %v\", u.Scheme)\n\t}\n\n\treturn u.String(), nil\n}\n\nfunc parseURL(input string) (*url.URL, error) {\n\tu, err := url.Parse(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid URL: %v\", err)\n\t}\n\n\treturn u, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"time\"\n)\n\nfunc main() {\n\tfruits := []string{\"apple\", \"banana\", \"orange\", \"kiwi\"}\n\n\t// Sorting the slice in ascending order\n\tsort.Strings(fruits)\n\tfmt.Println(\"Sorted fruits:\", fruits)\n\n\t// Using a custom sorting function to sort the slice in descending order\n\tsort.Slice(fruits, func(i, j int) bool {\n\t\treturn fruits[i] > fruits[j]\n\t})\n\tfmt.Println(\"Reverse sorted fruits:\", fruits)\n\n\t// Generating a random number using the math/rand package\n\trand.Seed(time.Now().UnixNano())\n\trandomNumber := rand.Intn(100-1) + 1\n\tfmt.Println(\"Random number:\", randomNumber)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to open a channel\")\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when unused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\n\tmsgs, err := ch.Consume(\n\t\tq.Name, // queue\n\t\t\"\",     // consumer\n\t\ttrue,   // auto-ack\n\t\tfalse,  // exclusive\n\t\tfalse,  // no-local\n\t\tfalse,  // no-wait\n\t\tnil,    // args\n\t)\n\tfailOnError(err, \"Failed to register a consumer\")\n\n\tforever := make(chan bool)\n\n\tgo func() {\n\t\tfor d := range msgs {\n\t\t\tlog.Printf(\"Received a message: %s\", d.Body)\n\t\t}\n\t}()\n\n\tlog.Printf(\" [*] Waiting for messages. To exit press CTRL+C\")\n\t<-forever\n}\n\n// This code creates a connection to a RabbitMQ server, declares a queue, and waits for messages to be sent to the queue. When a message is received, it is printed to the console. This is a common pattern in message-based systems and demonstrates the use of the popular AMQP library in Go."}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype car struct {\n\tmake  string\n\tmodel string\n\tyear  int\n}\n\nfunc main() {\n\tfmt.Println(\"Welcome to the Car Inventory System\")\n\n\tinventory := make([]car, 0)\n\n\treader := bufio.NewReader(os.Stdin)\n\tfor {\n\t\tfmt.Println(\"Enter a command:\")\n\t\tcommand, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading input:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tcommand = strings.TrimSuffix(command, \"\\n\")\n\n\t\tswitch command {\n\t\tcase \"add\":\n\t\t\tfmt.Println(\"Enter car make:\")\n\t\t\tmake, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading input:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmake = strings.TrimSuffix(make, \"\\n\")\n\n\t\t\tfmt.Println(\"Enter car model:\")\n\t\t\tmodel, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading input:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmodel = strings.TrimSuffix(model, \"\\n\")\n\n\t\t\tfmt.Println(\"Enter car year:\")\n\t\t\tyearString, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading input:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tyearString = strings.TrimSuffix(yearString, \"\\n\")\n\n\t\t\tyear, err := strconv.Atoi(yearString)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Invalid year\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tnewCar := car{\n\t\t\t\tmake:  make,\n\t\t\t\tmodel: model,\n\t\t\t\tyear:  year,\n\t\t\t}\n\n\t\t\tinventory = append(inventory, newCar)\n\t\t\tfmt.Println(\"Added car successfully!\")\n\t\tcase \"view\":\n\t\t\tif len(inventory) == 0 {\n\t\t\t\tfmt.Println(\"No cars in inventory\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Println(\"=====================\")\n\t\t\tfor _, car := range inventory {\n\t\t\t\tfmt.Printf(\"%s %s - %d\\n\", car.make, car.model, car.year)\n\t\t\t}\n\t\t\tfmt.Println(\"=====================\")\n\t\tcase \"exit\":\n\t\t\tfmt.Println(\"Exiting...\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Invalid command. Valid commands are add, view, and exit.\")\n\t\t}\n\t}\n}"}
{"sample": "package main\n\n// ErrorHandlerWithDefault is a function that takes an error and a default error, if the error is nil it returns the default error\nfunc ErrorHandlerWithDefault(err error, defaultErr error) error {\n\tif err == nil {\n\t\treturn defaultErr\n\t}\n\treturn err\n}\n"}
{"sample": "// IfErrorThenLogAndExit checks if an error exists, if so, logs it and exits the program\nfunc IfErrorThenLogAndExit(err error) {\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tos.Exit(1)\n\t}\n}\n"}
{"sample": "func CopyDirectory(srcDir, dstDir string) error {\n\tentries, err := ioutil.ReadDir(srcDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, entry := range entries {\n\t\tsrcPath := filepath.Join(srcDir, entry.Name())\n\t\tdstPath := filepath.Join(dstDir, entry.Name())\n\n\t\tif entry.IsDir() {\n\t\t\tif err := CopyDirectory(srcPath, dstPath); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif err := CopyFile(srcPath, dstPath); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc CopyFile(srcFile, dstFile string) error {\n\tinput, err := ioutil.ReadFile(srcFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := ioutil.WriteFile(dstFile, input, 0644); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "func BubbleSort(arr []int) {\n\tfor i := 0; i < len(arr); i++ {\n\t\tfor j := 0; j < len(arr)-i-1; j++ {\n\t\t\tif arr[j] > arr[j+1] {\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "package dynamic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// SynthesizeExtras is a type that wants to pass extra values to the Synthesize\n// function. The key-value pairs will be included as-is without inspection by\n// the Synthesize function. This is useful for populated synthesized values with\n// functions or computed values.\ntype SynthesizeExtras interface {\n\t// SynthesizeExtras returns a map of extra values to include when passing\n\t// to Synthesize().\n\tSynthesizeExtras() map[string]interface{}\n}\n\n// SetField inserts a value into v at path.\n//\n// For example, if the marshalled representation of v is\n// {\"foo\": \"bar\", \"baz\": { \"value\": 5 }},\n// Then SetField(v, \"baz.value\", 10) will result in\n// {\"foo\": \"bar\", \"baz\": { \"value\": 10 }}.\n//\n// v's reflect.Kind must be reflect.Struct, or a non-nil error will\n// be returned. If the path refers to a struct field, then v must\n// be addressable, or an error will be returned.\nfunc SetField(v interface{}, path string, value interface{}) error {\n\tstrukt := reflect.Indirect(reflect.ValueOf(v))\n\tif !strukt.IsValid() {\n\t\treturn errors.New(\"SetField on nil Attributes\")\n\t}\n\tif kind := strukt.Kind(); kind != reflect.Struct {\n\t\treturn fmt.Errorf(\"invalid type (want struct): %v\", kind)\n\t}\n\tfieldsp := structFieldPool.Get().(*[]structField)\n\tdefer func() {\n\t\t*fieldsp = (*fieldsp)[:0]\n\t\tstructFieldPool.Put(fieldsp)\n\t}()\n\tgetJSONFields(strukt, true, fieldsp)\n\tfields := *fieldsp\n\tf, ok := lookupField(fields, path)\n\tif !ok {\n\t\treturn fmt.Errorf(\"dynamic: no such field: %q\", path)\n\t}\n\tfield := f.Value\n\tif !field.IsValid() {\n\t\treturn fmt.Errorf(\"dynamic: field is invalid: %s\", path)\n\t}\n\tif !field.CanSet() {\n\t\treturn fmt.Errorf(\"dynamic: struct field not addressable: %q\", path)\n\t}\n\tfield.Set(reflect.ValueOf(value))\n\treturn nil\n}\n\n// GetField gets a field from v according to its name.\n// If GetField doesn't find a struct field with the corresponding name, then\n// it will try to dynamically find the corresponding item in the 'Extended'\n// field. GetField is case-sensitive, but extended attribute names will be\n// converted to CamelCaps.\nfunc GetField(v interface{}, name string) (interface{}, error) {\n\tif len(name) == 0 {\n\t\treturn nil, errors.New(\"dynamic: empty path specified\")\n\t}\n\tif v == nil {\n\t\treturn nil, errors.New(\"dynamic: GetField with nil\")\n\t}\n\n\tif s := string([]rune(name)[0]); strings.Title(s) != s {\n\t\t// Exported fields are always upper-cased for the first rune\n\t\tname = strings.Title(s) + string([]rune(name)[1:])\n\t}\n\tstrukt := reflect.Indirect(reflect.ValueOf(v))\n\tif kind := strukt.Kind(); kind != reflect.Struct {\n\t\treturn nil, fmt.Errorf(\"invalid type (want struct): %v\", kind)\n\t}\n\tfield := strukt.FieldByName(name)\n\tif field.IsValid() {\n\t\tfield := reflect.Indirect(field)\n\t\tif field.Kind() == reflect.Map {\n\t\t\treturn reflectMapToMapParameters(field), nil\n\t\t}\n\t\treturn field.Interface(), nil\n\t}\n\n\treturn nil, fmt.Errorf(\"missing field: %q\", name)\n}\n\n// reflectMapToMapParameters turns a reflect.Map into a map[string]interface{}\nfunc reflectMapToMapParameters(v reflect.Value) interface{} {\n\tresult := make(map[string]interface{})\n\tfor _, key := range v.MapKeys() {\n\t\tif key.Kind() != reflect.String {\n\t\t\t// Fallback - if the map has a non-string key type, return the\n\t\t\t// variable as-is.\n\t\t\treturn v.Interface()\n\t\t}\n\t\tresult[key.Interface().(string)] = v.MapIndex(key).Interface()\n\t}\n\treturn result\n}\n\n// Synthesize recursively turns structs into map[string]interface{}\n// values. It works on most datatypes. Synthesize panics if it is\n// called on channels.\n//\n// Synthesize will use the json tag from struct fields to name map\n// keys, if the json tag is present.\nfunc Synthesize(v interface{}) interface{} {\n\tvalue := reflect.Indirect(reflect.ValueOf(v))\n\tswitch value.Kind() {\n\tcase reflect.Struct:\n\t\tresult := synthesizeStruct(value)\n\t\tif m, ok := v.(SynthesizeExtras); ok {\n\t\t\tfor k, v := range m.SynthesizeExtras() {\n\t\t\t\tresult[k] = v\n\t\t\t}\n\t\t}\n\t\tmeta, ok := result[\"metadata\"]\n\t\tif ok {\n\t\t\tmeta, ok := meta.(map[string]interface{})\n\t\t\tif ok {\n\t\t\t\t// hack alert! put the metadata fields into the top-level object\n\t\t\t\t// to avoid breaking user expectations.\n\t\t\t\tfor k, v := range meta {\n\t\t\t\t\tresult[k] = v\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result\n\tcase reflect.Slice, reflect.Array:\n\t\treturn synthesizeSlice(value)\n\tcase reflect.Map:\n\t\treturn synthesizeMap(value)\n\tcase reflect.Chan:\n\t\tpanic(\"can't synthesize channel\")\n\tcase reflect.Invalid:\n\t\t// We got passed a nil\n\t\treturn nil\n\tdefault:\n\t\tif value.CanInterface() {\n\t\t\treturn value.Interface()\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// SynthesizeMethods returns a map of method names to methods from v.\nfunc SynthesizeMethods(v interface{}) map[string]interface{} {\n\tvalue := reflect.ValueOf(v)\n\tif value.IsZero() {\n\t\treturn nil\n\t}\n\ttyp := value.Type()\n\tn := value.NumMethod()\n\tresult := make(map[string]interface{}, n)\n\tfor i := 0; i < n; i++ {\n\t\tmethodValue := value.Method(i)\n\t\tmethodType := typ.Method(i)\n\t\tresult[methodType.Name] = methodValue.Interface()\n\t}\n\treturn result\n}\n\nfunc synthesizeSlice(value reflect.Value) interface{} {\n\tlength := value.Len()\n\tslice := make([]interface{}, length)\n\tfor i := 0; i < length; i++ {\n\t\tval := value.Index(i)\n\t\tvar elt interface{} = nil\n\t\tif val.CanInterface() {\n\t\t\telt = val.Interface()\n\t\t}\n\t\tslice[i] = Synthesize(elt)\n\t}\n\treturn slice\n}\n\nfunc synthesizeMap(value reflect.Value) interface{} {\n\ttyp := value.Type()\n\tkeyT := typ.Key()\n\tif keyT.Kind() != reflect.String {\n\t\t// Maps without string keys are not supported\n\t\treturn map[string]interface{}{}\n\t}\n\tlength := value.Len()\n\tout := make(map[string]interface{}, length)\n\tfor _, key := range value.MapKeys() {\n\t\tval := value.MapIndex(key)\n\t\tvar elt interface{}\n\t\tif val.CanInterface() {\n\t\t\telt = val.Interface()\n\t\t}\n\t\tout[key.Interface().(string)] = Synthesize(elt)\n\t}\n\treturn out\n}\n\nfunc synthesizeStruct(value reflect.Value) map[string]interface{} {\n\tnumField := value.NumField()\n\tout := make(map[string]interface{}, numField)\n\tt := value.Type()\n\tfor i := 0; i < numField; i++ {\n\t\tfield := t.Field(i)\n\t\tif field.PkgPath != \"\" {\n\t\t\t// unexported fields are not included in the synthesis\n\t\t\tcontinue\n\t\t}\n\t\ts := structField{Field: field}\n\t\tfieldName, _ := s.jsonFieldName()\n\t\tfieldValue := value.Field(i)\n\n\t\tswitch fieldValue.Kind() {\n\t\tcase reflect.Struct:\n\t\t\t// Recursively convert all fields to synthesized values\n\t\t\tfields := synthesizeStruct(fieldValue)\n\n\t\t\t// flatten embedded fields to the top level\n\t\t\tif t.Field(i).Anonymous {\n\t\t\t\tfor k, v := range fields {\n\t\t\t\t\tout[k] = v\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tout[fieldName] = fields\n\t\t\t}\n\t\tcase reflect.Slice, reflect.Array:\n\t\t\tout[fieldName] = synthesizeSlice(fieldValue)\n\t\tcase reflect.Map:\n\t\t\tout[fieldName] = synthesizeMap(fieldValue)\n\t\tdefault:\n\t\t\tif fieldValue.CanInterface() {\n\t\t\t\tout[fieldName] = Synthesize(fieldValue.Interface())\n\t\t\t} else {\n\t\t\t\tout[fieldName] = nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out\n}\n"}
{"sample": "// Calling a function\n\nresult := add(1, 2)\nfmt.Println(result)\n"}
{"sample": "package main\n\nimport \"time\"\n\nfunc main() {\n\tPrintTime()\n}\n\nfunc PrintTime() {\n\tfmt.Println(time.Now())\n}"}
{"sample": "package jwtgen\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\ntype Claims struct {\n\tUsername string `json:\"username\"`\n\tjwt.StandardClaims\n}\n\nvar signingKey = []byte(\"secret\")\n\nfunc GenerateToken(username string) (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims{\n\t\tUsername: username,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tExpiresAt: time.Now().Add(time.Hour * 24).Unix(),\n\t\t\tIssuedAt:  time.Now().Unix(),\n\t\t},\n\t})\n\n\ttokenString, err := token.SignedString(signingKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn tokenString, nil\n}\n\nfunc verifyToken(tokenString string) (*Claims, error) {\n\ttoken, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {\n\t\treturn signingKey, nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif claims, ok := token.Claims.(*Claims); ok && token.Valid {\n\t\treturn claims, nil\n\t} else {\n\t\treturn nil, errors.New(\"Invalid token\")\n\t}\n}\n\nfunc main() {\n\ttoken, err := GenerateToken(\"example_user\")\n\tif err != nil {\n\t\tfmt.Println(\"Error generating token:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Generated Token:\", token)\n\n\tclaims, err := verifyToken(token)\n\tif err != nil {\n\t\tfmt.Println(\"Error verifying token:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Verified Token:\")\n\tfmt.Println(\"Username:\", claims.Username)\n\tfmt.Println(\"Expires At:\", time.Unix(claims.ExpiresAt, 0))\n\tfmt.Println(\"Issued At:\", time.Unix(claims.IssuedAt, 0))\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintReverseString prints a given string in reverse order.\nfunc PrintReverseString(str string) {\n\tfor i := len(str) - 1; i >= 0; i-- {\n\t\tfmt.Printf(\"%c\", str[i])\n\t}\n}"}
{"sample": "package ds\n\nimport (\n\th \"github.com/lebedev-yury/cities/test_helpers\"\n\t. \"github.com/smartystreets/goconvey/convey\"\n\t\"testing\"\n)\n\nfunc TestAppStatus(t *testing.T) {\n\tConvey(\"Test is indexed\", t, func() {\n\t\tConvey(\"Returns true when status is ok\", func() {\n\t\t\tappStatus := AppStatus{Statistics: &Statistics{Status: \"ok\"}}\n\t\t\tSo(appStatus.IsIndexed(), ShouldBeTrue)\n\t\t})\n\n\t\tConvey(\"Returns false when status is not ok\", func() {\n\t\t\tappStatus := AppStatus{}\n\t\t\tSo(appStatus.IsIndexed(), ShouldBeFalse)\n\t\t})\n\t})\n\n\tConvey(\"Test get app status\", t, func() {\n\t\tdb := h.CreateDB(t)\n\t\tCreateStatisticsBucket(db)\n\n\t\tConvey(\"When indexing is done\", func() {\n\t\t\th.PutToBucket(t, db, StatisticsBucketName, \"cities_count\", \"1000\")\n\t\t\th.PutToBucket(t, db, StatisticsBucketName, \"city_names_count\", \"2000\")\n\n\t\t\tappStatus := GetAppStatus(db)\n\n\t\t\tConvey(\"Sets app status to \\\"ok\\\"\", func() {\n\t\t\t\tSo(appStatus.Statistics.Status, ShouldEqual, \"ok\")\n\t\t\t})\n\n\t\t\tConvey(\"Has correct cities count\", func() {\n\t\t\t\tSo(appStatus.Statistics.CitiesCount, ShouldEqual, 1000)\n\t\t\t})\n\n\t\t\tConvey(\"Has correct city names count\", func() {\n\t\t\t\tSo(appStatus.Statistics.CityNamesCount, ShouldEqual, 2000)\n\t\t\t})\n\t\t})\n\n\t\tConvey(\"When still indexing\", func() {\n\t\t\th.DeleteFromBucket(t, db, StatisticsBucketName, \"cities_count\")\n\t\t\th.DeleteFromBucket(t, db, StatisticsBucketName, \"city_names_count\")\n\n\t\t\tappStatus := GetAppStatus(db)\n\n\t\t\tConvey(\"Sets the app status to \\\"indexing\\\"\", func() {\n\t\t\t\tSo(appStatus.Statistics.Status, ShouldEqual, \"indexing\")\n\t\t\t})\n\n\t\t\tConvey(\"Has 0 for cities count\", func() {\n\t\t\t\tSo(appStatus.Statistics.CitiesCount, ShouldEqual, 0)\n\t\t\t})\n\n\t\t\tConvey(\"Has 0 for city names count\", func() {\n\t\t\t\tSo(appStatus.Statistics.CityNamesCount, ShouldEqual, 0)\n\t\t\t})\n\t\t})\n\t})\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/handlers\"\n)\n\nfunc UseHandlers() {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, Handlers!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", handlers.LoggingHandler(os.Stdout, handler))\n}\n"}
{"sample": "func main() {\n\tclient := &http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", \"https://api.example.com/data\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer YOUR_API_TOKEN\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error making request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "// Using the strconv package\n\ni, err := strconv.Atoi(\"123\")\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc longRunningTask(ctx context.Context) {\n\tfmt.Println(\"Starting long-running task...\")\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(\"Task cancelled!\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Working...\")\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tgo longRunningTask(ctx)\n\n\ttime.Sleep(5 * time.Second)\n\tfmt.Println(\"Cancelling task...\")\n\tcancel()\n\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Done!\")\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintNumberInOctal(8)\n}\n\n// Function to print the octal representation of a number\nfunc PrintNumberInOctal(n int) {\n\tfmt.Printf(\"%o\\n\", n)\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "j, err := strconv.Atoi(\"456\")\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\n// FetchURL fetches the content of a URL using an HTTP GET request.\nfunc FetchURL(url string) (string, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil\n}"}
{"sample": "func main() {\n\tstr := \"Hello, World!\"\n\tupper := strings.ToUpper(str)\n\n\tfmt.Println(upper)\n}"}
{"sample": "package binsearch\n\nfunc binarySearch(arr []int, target int) int {\n\tlow := 0\n\thigh := len(arr) - 1\n\n\tfor low <= high {\n\t\tmid := (low + high) / 2\n\n\t\tif arr[mid] == target {\n\t\t\treturn mid\n\t\t} else if arr[mid] < target {\n\t\t\tlow = mid + 1\n\t\t} else {\n\t\t\thigh = mid - 1\n\t\t}\n\t}\n\n\treturn -1\n}"}
{"sample": "package cache\n\nimport (\n\t\"time\"\n\n\t\"github.com/go-redis/redis\"\n)\n\ntype RedisCache struct {\n\tredisClient *redis.Client\n\tkeyPrefix   string\n\tttl         time.Duration\n}\n\nfunc NewRedisCache(address, password, keyPrefix string, ttl time.Duration) RedisCache {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     address,\n\t\tPassword: password,\n\t\tDB:       0,\n\t})\n\n\tif _, err := client.Ping().Result(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn RedisCache{\n\t\tredisClient: client,\n\t\tkeyPrefix:   keyPrefix,\n\t\tttl:         ttl,\n\t}\n}\n\nfunc (c *RedisCache) Set(key string, value interface{}) error {\n\tcacheKey := c.keyPrefix + key\n\n\tif err := c.redisClient.Set(cacheKey, value, c.ttl).Err(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *RedisCache) Get(key string) (interface{}, error) {\n\tcacheKey := c.keyPrefix + key\n\n\tresult, err := c.redisClient.Get(cacheKey).Result()\n\tif err == redis.Nil {\n\t\treturn nil, nil\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n\nfunc (c *RedisCache) Delete(key string) error {\n\tcacheKey := c.keyPrefix + key\n\n\tif err := c.redisClient.Del(cacheKey).Err(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\nfunc GenerateFibonacci(n int) []int {\n\tfib := make([]int, n)\n\tfib[0], fib[1] = 0, 1\n\tfor i := 2; i < n; i++ {\n\t\tfib[i] = fib[i-1] + fib[i-2]\n\t}\n\treturn fib\n}\n"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype ApiResponse struct {\n\tArgs    map[string]string `json:\"args\"`\n\tHeaders map[string]string `json:\"headers\"`\n\tOrigin  string            `json:\"origin\"`\n\tURL     string            `json:\"url\"`\n}\n\nfunc handleApiResponse(w http.ResponseWriter, r *http.Request) {\n\tclient := http.DefaultClient\n\n\tresp, err := client.Get(\"https://httpbin.org/get\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tapiResp := &ApiResponse{}\n\n\tif err := json.Unmarshal(body, &apiResp); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(apiResp)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/api-response\", handleApiResponse)\n\n\tfmt.Println(\"Starting server on port :8080\")\n\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package rabbitmqimpl\n\nimport (\n\t\"log\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype RabbitMQ struct {\n\tconn *amqp.Connection\n\tch   *amqp.Channel\n\tq    amqp.Queue\n}\n\nfunc NewRabbitMQ(url, queueName string) (*RabbitMQ, error) {\n\tconn, err := amqp.Dial(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq, err := ch.QueueDeclare(\n\t\tqueueName, // name\n\t\tfalse,     // durable\n\t\tfalse,     // delete when unused\n\t\tfalse,     // exclusive\n\t\tfalse,     // no-wait\n\t\tnil,       // arguments\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &RabbitMQ{\n\t\tconn: conn,\n\t\tch:   ch,\n\t\tq:    q,\n\t}, nil\n}\n\nfunc (r *RabbitMQ) Publish(message []byte) error {\n\terr := r.ch.Publish(\n\t\t\"\",         // exchange\n\t\tr.q.Name,   // routing key\n\t\tfalse,      // mandatory\n\t\tfalse,      // immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        message,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (r *RabbitMQ) Consume() (<-chan amqp.Delivery, error) {\n\tmsgs, err := r.ch.Consume(\n\t\tr.q.Name, // queue\n\t\t\"\",       // consumer\n\t\ttrue,     // auto-ack\n\t\tfalse,    // exclusive\n\t\tfalse,    // no-local\n\t\tfalse,    // no-wait\n\t\tnil,      // args\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn msgs, nil\n}\n\nfunc (r *RabbitMQ) Close() error {\n\tif err := r.ch.Close(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := r.conn.Close(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc ExampleUsage() {\n\tr, err := NewRabbitMQ(\"amqp://guest:guest@localhost:5672/\", \"my_queue\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = r.Publish([]byte(\"Hello World!\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tmsgs, err := r.Consume()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor msg := range msgs {\n\t\tlog.Printf(\"Received message: %s\", msg.Body)\n\t}\n\n\terr = r.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// GenerateRandomNumber generates a random number within the specified range.\nfunc GenerateRandomNumber(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}"}
{"sample": "package main\n\nfunc CalculateFactorial(n int) int {\n\tif n <= 1 {\n\t\treturn 1\n\t}\n\treturn n * CalculateFactorial(n-1)\n}\n"}
{"sample": "package main\n\n// Globbing for matching files\nfunc main() {\n\tmatches, err := filepath.Glob(\"*.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfor _, match := range matches {\n\t\tfmt.Println(match)\n\t}\n}\n"}
{"sample": "func CreateNewFile(path string) (*os.File, error) {\n\treturn os.Create(path)\n}\n\nfunc WriteToFile(file *os.File, data []byte) error {\n\t_, err := file.Write(data)\n\treturn err\n}\n\nfunc CloseFile(file *os.File) error {\n\treturn file.Close()\n}"}
{"sample": "package main\n\nimport \"os\"\n\nfunc main() {\n\tfilename := \"example.txt\"\n\tos.Remove(filename)\n}"}
{"sample": "package main\n\n// This function gets the absolute path of a file\nfunc GetAbsolutePath(filename string) (string, error) {\n\tabsPath, err := filepath.Abs(filename)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn absPath, nil\n}\n\n// This function prints the absolute path of a file\nfunc PrintAbsolutePath(filename string) error {\n\tabsPath, err := GetAbsolutePath(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Println(\"Absolute path:\", absPath)\n\treturn nil\n}\n\nfunc main() {\n\terr := PrintAbsolutePath(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "func CreateDirectory(path string) error {\n\treturn os.Mkdir(path, 0755)\n}\n\nfunc RemoveDirectory(path string) error {\n\treturn os.RemoveAll(path)\n}\n\nfunc ListDirectory(path string) ([]string, error) {\n\tfiles, err := ioutil.ReadDir(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar fileNames []string\n\tfor _, file := range files {\n\t\tfileNames = append(fileNames, file.Name())\n\t}\n\treturn fileNames, nil\n}"}
{"sample": "// Copyright 2018 tsuru authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage v1\n\nimport (\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\n// +genclient\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// App is a specification for a App resource\ntype App struct {\n\tmetav1.TypeMeta   `json:\",inline\"`\n\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tSpec AppSpec `json:\"spec\"`\n}\n\n// AppSpec is the spec for a App resource\ntype AppSpec struct {\n\tNamespaceName      string              `json:\"namespaceName\"`\n\tServiceAccountName string              `json:\"serviceAccountName\"`\n\tDeployments        map[string][]string `json:\"deployments\"`\n\tServices           map[string][]string `json:\"services\"`\n}\n\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// FooList is a list of Foo resources\ntype AppList struct {\n\tmetav1.TypeMeta `json:\",inline\"`\n\tmetav1.ListMeta `json:\"metadata\"`\n\n\tItems []App `json:\"items\"`\n}\n"}
{"sample": "package main\n\n// Get file information\nfunc main() {\n\tinfo, err := os.Stat(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"File size:\", info.Size())\n}\n"}
{"sample": "func DownloadFileFromS3(svc *s3.S3, bucket, key string) (*s3.GetObjectOutput, error) {\n\tinput := &s3.GetObjectInput{\n\t\tBucket: aws.String(bucket),\n\t\tKey:    aws.String(key),\n\t}\n\tresult, err := svc.GetObject(input)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\nfunc UploadFileToS3(svc *s3.S3, bucket, key string, file *os.File) error {\n\t_, err := svc.PutObject(&s3.PutObjectInput{\n\t\tBucket: aws.String(bucket),\n\t\tKey:    aws.String(key),\n\t\tBody:   file,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"sample": "func createIndex(tx *sql.Tx) error {\n\tstmt, err := tx.Prepare(\"CREATE INDEX idx_name ON users (name)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package analyticsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/api/analyticsreporting/v4\"\n\t\"google.golang.org/api/option\"\n)\n\ntype AnalyticsClient struct {\n\tsvc *analyticsreporting.Service\n}\n\nfunc NewAnalyticsClient(ctx context.Context, keyFile string) (*AnalyticsClient, error) {\n\tsvc, err := analyticsreporting.NewService(ctx, option.WithCredentialsFile(keyFile))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create analytics reporting service: %v\", err)\n\t}\n\n\treturn &AnalyticsClient{svc: svc}, nil\n}\n\nfunc (c *AnalyticsClient) GetReport(ctx context.Context, viewID string, startDate, endDate time.Time) (*analyticsreporting.GetReportsResponse, error) {\n\treq := &analyticsreporting.GetReportsRequest{\n\t\tReportRequests: []*analyticsreporting.ReportRequest{\n\t\t\t{\n\t\t\t\tViewId: viewID,\n\t\t\t\tDateRanges: []*analyticsreporting.DateRange{\n\t\t\t\t\t{\n\t\t\t\t\t\tStartDate: startDate.Format(\"2006-01-02\"),\n\t\t\t\t\t\tEndDate:   endDate.Format(\"2006-01-02\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tMetrics: []*analyticsreporting.Metric{\n\t\t\t\t\t{\n\t\t\t\t\t\tExpression: \"ga:sessions\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tDimensions: []*analyticsreporting.Dimension{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"ga:country\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tresp, err := c.svc.Reports.BatchGet(req).Context(ctx).Do()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to get analytics report: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/jmoiron/sqlx\"\n\t\"github.com/your-username/project-name/db\"\n\tpb \"github.com/your-username/project-name/proto\"\n\t\"google.golang.org/grpc\"\n)\n\ntype server struct{}\n\nfunc (s *server) GetUsers(ctx context.Context, req *pb.UserRequest) (*pb.UserResponse, error) {\n\tvar users []db.User\n\terr := sqlx.Select(db.Conn, &users, \"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\tvar userResponses []*pb.User\n\n\tfor _, user := range users {\n\t\tuserResponses = append(userResponses, &pb.User{\n\t\t\tId:    user.ID,\n\t\t\tName:  user.Name,\n\t\t\tEmail: user.Email,\n\t\t})\n\t}\n\n\treturn &pb.UserResponse{Users: userResponses}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", 50051))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\n\tpb.RegisterUserServiceServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}\n\nfunc init() {\n\tvar err error\n\tdb.Conn, err = sqlx.Connect(\"mysql\", \"root:password@tcp(127.0.0.1:3306)/mydb\")\n\tif err != nil {\n\t\tpanic(errors.New(\"Could not connect to MySQL.\"))\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\tfiles, err := filepath.Glob(\"*.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error finding files:\", err)\n\t\treturn\n\t}\n\n\tfor _, file := range files {\n\t\tfmt.Println(file)\n\t}\n}"}
{"sample": "package types\n\nimport (\n\t\"time\"\n)\n\nconst (\n\tStakeTokenDenom = \"rowan\"\n)\n\ntype AuthAccountValueCoin struct {\n\tDenom  string `json:\"denom\"`\n\tAmount string `json:\"amount\"`\n}\n\ntype AuthAccountValue struct {\n\tAddress       string                 `json:\"address\"`\n\tCoins         []AuthAccountValueCoin `json:\"coins\"`\n\tPublicKey     interface{}            `json:\"public_key\"`\n\tAccountNumber string                 `json:\"account_number\"`\n\tSequence      string                 `json:\"sequence\"`\n}\n\ntype AuthAccount struct {\n\tType  string           `json:\"type\"`\n\tValue AuthAccountValue `json:\"value\"`\n}\n\ntype AuthParams struct {\n\tMaxMemoCharacters      string `json:\"max_memo_characters\"`\n\tTxSigLimit             string `json:\"tx_sig_limit\"`\n\tTxSizeCostPerByte      string `json:\"tx_size_cost_per_byte\"`\n\tSigVerifyCostEd25519   string `json:\"sig_verify_cost_ed25519\"`\n\tSigVerifyCostSecp256K1 string `json:\"sig_verify_cost_secp256k1\"`\n}\n\ntype Auth struct {\n\tParams   AuthParams    `json:\"params\"`\n\tAccounts []AuthAccount `json:\"accounts\"`\n}\n\ntype GovTallyParams struct {\n\tQuorum    string `json:\"quorum\"`\n\tThreshold string `json:\"threshold\"`\n\tVeto      string `json:\"veto\"`\n}\n\ntype GovVotingParams struct {\n\tVotingPeriod string `json:\"voting_period\"`\n}\n\ntype GovMinDeposit []struct {\n\tDenom  string `json:\"denom\"`\n\tAmount string `json:\"amount\"`\n}\n\ntype GovDepositParams struct {\n\tMinDeposit       GovMinDeposit `json:\"min_deposit\"`\n\tMaxDepositPeriod string        `json:\"max_deposit_period\"`\n}\n\ntype Gov struct {\n\tStartingProposalID string           `json:\"starting_proposal_id\"`\n\tDeposits           interface{}      `json:\"deposits\"`\n\tVotes              interface{}      `json:\"votes\"`\n\tProposals          interface{}      `json:\"proposals\"`\n\tDepositParams      GovDepositParams `json:\"deposit_params\"`\n\tVotingParams       GovVotingParams  `json:\"voting_params\"`\n\tTallyParams        GovTallyParams   `json:\"tally_params\"`\n}\n\ntype GentxValueSignaturePubKey struct {\n\tType  string `json:\"type\"`\n\tValue string `json:\"value\"`\n}\n\ntype GentxValueSignature struct {\n\tPubKey    GentxValueSignaturePubKey `json:\"pub_key\"`\n\tSignature string                    `json:\"signature\"`\n}\n\ntype GentxValueFee struct {\n\tAmount []interface{} `json:\"amount\"`\n\tGas    string        `json:\"gas\"`\n}\n\ntype GentxValueMsgValueValue struct {\n\tDenom  string `json:\"denom\"`\n\tAmount string `json:\"amount\"`\n}\n\ntype GentxValueMsgValueCommission struct {\n\tRate          string `json:\"rate\"`\n\tMaxRate       string `json:\"max_rate\"`\n\tMaxChangeRate string `json:\"max_change_rate\"`\n}\n\ntype GentxValueMsgValueDescription struct {\n\tMoniker         string `json:\"moniker\"`\n\tIdentity        string `json:\"identity\"`\n\tWebsite         string `json:\"website\"`\n\tSecurityContact string `json:\"security_contact\"`\n\tDetails         string `json:\"details\"`\n}\n\ntype GentxValueMsgValue struct {\n\tDescription       GentxValueMsgValueDescription `json:\"description\"`\n\tCommission        GentxValueMsgValueCommission  `json:\"commission\"`\n\tMinSelfDelegation string                        `json:\"min_self_delegation\"`\n\tDelegatorAddress  string                        `json:\"delegator_address\"`\n\tValidatorAddress  string                        `json:\"validator_address\"`\n\tPubkey            string                        `json:\"pubkey\"`\n\tValue             GentxValueMsgValueValue       `json:\"value\"`\n}\n\ntype GentxValueMsg struct {\n\tType  string             `json:\"type\"`\n\tValue GentxValueMsgValue `json:\"value\"`\n}\n\ntype GentxValue struct {\n\tMsg        []GentxValueMsg       `json:\"msg\"`\n\tFee        GentxValueFee         `json:\"fee\"`\n\tSignatures []GentxValueSignature `json:\"signatures\"`\n\tMemo       string                `json:\"memo\"`\n}\n\ntype Gentx struct {\n\tType  string     `json:\"type\"`\n\tValue GentxValue `json:\"value\"`\n}\n\ntype Genutil struct {\n\tGentxs []Gentx `json:\"gentxs\"`\n}\n\ntype Upgrade struct{}\n\ntype CLPParams struct {\n\tMinCreatePoolThreshold string `json:\"min_create_pool_threshold\"`\n}\n\ntype CLP struct {\n\tParams                CLPParams   `json:\"params\"`\n\tAddressWhitelist      interface{} `json:\"address_whitelist\"`\n\tPoolList              interface{} `json:\"pool_list\"`\n\tLiquidityProviderList interface{} `json:\"liquidity_provider_list\"`\n\tCLPModuleAddress      string      `json:\"clp_module_address\"`\n}\n\ntype Faucet struct {\n\tValue string `json:\"value\"`\n}\n\ntype Supply struct {\n\tSupply []interface{} `json:\"supply\"`\n}\n\ntype Staking struct {\n\tParams               StakingParams `json:\"params\"`\n\tLastTotalPower       string        `json:\"last_total_power\"`\n\tLastValidatorPowers  interface{}   `json:\"last_validator_powers\"`\n\tValidators           interface{}   `json:\"validators\"`\n\tDelegations          interface{}   `json:\"delegations\"`\n\tUnbondingDelegations interface{}   `json:\"unbonding_delegations\"`\n\tRedelegations        interface{}   `json:\"redelegations\"`\n\tExported             bool          `json:\"exported\"`\n}\n\ntype StakingParams struct {\n\tUnbondingTime     string `json:\"unbonding_time\"`\n\tMaxValidators     int    `json:\"max_validators\"`\n\tMaxEntries        int    `json:\"max_entries\"`\n\tHistoricalEntries int    `json:\"historical_entries\"`\n\tBondDenom         string `json:\"bond_denom\"`\n}\n\ntype Distribution struct {\n\tParams                          DistributionParams `json:\"params\" yaml:\"params\"`\n\tFeePool                         interface{}        `json:\"fee_pool\" yaml:\"fee_pool\"`\n\tDelegatorWithdrawInfos          interface{}        `json:\"delegator_withdraw_infos\" yaml:\"delegator_withdraw_infos\"`\n\tPreviousProposer                interface{}        `json:\"previous_proposer\" yaml:\"previous_proposer\"`\n\tOutstandingRewards              interface{}        `json:\"outstanding_rewards\" yaml:\"outstanding_rewards\"`\n\tValidatorAccumulatedCommissions interface{}        `json:\"validator_accumulated_commissions\" yaml:\"validator_accumulated_commissions\"`\n\tValidatorHistoricalRewards      interface{}        `json:\"validator_historical_rewards\" yaml:\"validator_historical_rewards\"`\n\tValidatorCurrentRewards         interface{}        `json:\"validator_current_rewards\" yaml:\"validator_current_rewards\"`\n\tDelegatorStartingInfos          interface{}        `json:\"delegator_starting_infos\" yaml:\"delegator_starting_infos\"`\n\tValidatorSlashEvents            interface{}        `json:\"validator_slash_events\" yaml:\"validator_slash_events\"`\n}\n\ntype DistributionParams struct {\n\tCommunityTax        interface{} `json:\"community_tax\" yaml:\"community_tax\"`\n\tBaseProposerReward  interface{} `json:\"base_proposer_reward\" yaml:\"base_proposer_reward\"`\n\tBonusProposerReward interface{} `json:\"bonus_proposer_reward\" yaml:\"bonus_proposer_reward\"`\n\tWithdrawAddrEnabled interface{} `json:\"withdraw_addr_enabled\" yaml:\"withdraw_addr_enabled\"`\n}\n\ntype Slashing struct {\n\tParams       SlashingParams `json:\"params\" yaml:\"params\"`\n\tSigningInfos interface{}    `json:\"signing_infos\" yaml:\"signing_infos\"`\n\tMissedBlocks interface{}    `json:\"missed_blocks\" yaml:\"missed_blocks\"`\n}\n\ntype SlashingParams struct {\n\tSignedBlocksWindow      interface{} `json:\"signed_blocks_window\" yaml:\"signed_blocks_window\"`\n\tMinSignedPerWindow      interface{} `json:\"min_signed_per_window\" yaml:\"min_signed_per_window\"`\n\tDowntimeJailDuration    interface{} `json:\"downtime_jail_duration\" yaml:\"downtime_jail_duration\"`\n\tSlashFractionDoubleSign interface{} `json:\"slash_fraction_double_sign\" yaml:\"slash_fraction_double_sign\"`\n\tSlashFractionDowntime   interface{} `json:\"slash_fraction_downtime\" yaml:\"slash_fraction_downtime\"`\n}\ntype Bank struct {\n\tSendEnabled bool `json:\"send_enabled\"`\n}\n\ntype AppState struct {\n\tBank         Bank         `json:\"bank\"`\n\tStaking      Staking      `json:\"staking\"`\n\tParams       interface{}  `json:\"params\"`\n\tSupply       Supply       `json:\"supply\"`\n\tEthbridge    interface{}  `json:\"ethbridge\"`\n\tCLP          CLP          `json:\"clp\"`\n\tUpgrade      Upgrade      `json:\"upgrade\"`\n\tOracle       interface{}  `json:\"oracle\"`\n\tGenutil      Genutil      `json:\"genutil\"`\n\tGov          Gov          `json:\"gov\"`\n\tAuth         Auth         `json:\"auth\"`\n\tSlashing     Slashing     `json:\"slashing\"`\n\tDistribution Distribution `json:\"distribution\"`\n\tFaucet       Faucet       `json:\"faucet\"`\n\tDispensation interface{}  `json:\"dispensation\"`\n}\n\ntype Evidence struct {\n\tMaxAgeNumBlocks string `json:\"max_age_num_blocks\"`\n\tMaxAgeDuration  string `json:\"max_age_duration\"`\n}\n\ntype Validator struct {\n\tPubKeyTypes []string `json:\"pub_key_types\"`\n}\n\ntype Block struct {\n\tMaxBytes   string `json:\"max_bytes\"`\n\tMaxGas     string `json:\"max_gas\"`\n\tTimeIotaMs string `json:\"time_iota_ms\"`\n}\n\ntype ConsensusParams struct {\n\tBlock     Block     `json:\"block\"`\n\tEvidence  Evidence  `json:\"evidence\"`\n\tValidator Validator `json:\"validator\"`\n}\n\ntype Genesis struct {\n\tGenesisTime     time.Time       `json:\"genesis_time\"`\n\tChainID         string          `json:\"chain_id\"`\n\tConsensusParams ConsensusParams `json:\"consensus_params\"`\n\tAppHash         string          `json:\"app_hash\"`\n\tAppState        AppState        `json:\"app_state\"`\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(IsPrime(29))\n}\n\n// Function to check if a number is prime\nfunc IsPrime(n int) bool {\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"sample": "package primegen\n\nfunc GeneratePrimes(n int) []int {\n\tif n < 2 {\n\t\treturn nil\n\t}\n\n\tprimes := []int{2}\n\tfor i := 3; i <= n; i += 2 {\n\t\tisPrime := true\n\t\tfor _, prime := range primes {\n\t\t\tif prime*prime > i {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif i%prime == 0 {\n\t\t\t\tisPrime = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif isPrime {\n\t\t\tprimes = append(primes, i)\n\t\t}\n\t}\n\n\treturn primes\n}"}
{"sample": "package main\n\n// This function creates a new file\nfunc CreateFile(filename string) (*os.File, error) {\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn file, nil\n}\n\n// This function writes to an open file\nfunc WriteFile(file *os.File, data []byte) error {\n\t_, err := file.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tfile, err := CreateFile(\"newfile.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\terr = WriteFile(file, []byte(\"Hello, World!\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\trdb := redis.NewClient(&redis.Options{\n\t\t// Replace with your Redis server's address and password\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\tpong, err := rdb.Ping(ctx).Result()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to ping Redis: %v\", err)\n\t}\n\tlog.Printf(\"Connected to Redis: %v\", pong)\n\n\t// Set value with expiration of 1 hour\n\terr = rdb.Set(ctx, \"foo\", \"bar\", time.Hour).Err()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to set value in Redis: %v\", err)\n\t}\n\n\t// Retrieve value\n\tval, err := rdb.Get(ctx, \"foo\").Result()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to retrieve value from Redis: %v\", err)\n\t}\n\tfmt.Println(\"Value from Redis:\", val)\n}\n\n// Output:\n// Connected to Redis: PONG\n// Value from Redis: bar"}
{"sample": "package utils\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc GetUser(id int) (*User, error) {\n\tresp, err := http.Get(\"https://jsonplaceholder.typicode.com/users/\" + string(id))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"Failed to get user\")\n\t}\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar user User\n\terr = json.Unmarshal(bodyBytes, &user)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &user, nil\n}"}
{"sample": "d, err := os.CreateTempDir(\"\", \"tempDir*\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer os.RemoveAll(d)\nfmt.Println(\"Temp dir name:\", d)\n"}
{"sample": "func ParseForm(r *http.Request) error {\n\treturn r.ParseForm()\n}\n\nfunc GetFormValue(r *http.Request, fieldName string) string {\n\treturn r.FormValue(fieldName)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Using the Split function from the strings package\n\tstr := \"This is a string that needs to be split\"\n\tbrokenString := strings.Split(str, \" \")\n\n\tfor _, s := range brokenString {\n\t\tfmt.Println(s)\n\t}\n}"}
{"sample": "// Send a PATCH request to the specified URL with a JSON payload\nfunc Patch(url string, payload []byte) (*http.Response, error) {\n\trequest, _ := http.NewRequest(\"PATCH\", url, bytes.NewBuffer(payload))\n\treturn http.DefaultClient.Do(request)\n}\n"}
{"sample": "var person struct {\n\tName string `json:\"name\"`\n}\nerr := json.Unmarshal(jsonData, &person)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package webcrawler\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/PuerkitoBio/goquery\"\n)\n\ntype WebCrawler struct {\n\tvisited map[string]bool\n}\n\nfunc NewWebCrawler() *WebCrawler {\n\treturn &WebCrawler{\n\t\tvisited: make(map[string]bool),\n\t}\n}\n\nfunc (w *WebCrawler) Crawl(url string, depth int) error {\n\tif depth == 0 {\n\t\treturn nil\n\t}\n\n\tif w.visited[url] {\n\t\treturn nil\n\t}\n\n\tw.visited[url] = true\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tdoc, err := goquery.NewDocumentFromReader(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"Parsing:\", url)\n\n\tdoc.Find(\"a\").Each(func(i int, s *goquery.Selection) {\n\t\thref, ok := s.Attr(\"href\")\n\t\tif ok && strings.HasPrefix(href, \"http\") {\n\t\t\tw.Crawl(href, depth-1)\n\t\t}\n\t})\n\n\treturn nil\n}"}
{"sample": "package properties\n\n// Code generated by go generate; DO NOT EDIT.\n// It's generated by \"github.com/KablamoOSS/kombustion/generate\"\n\n// ClusterScalingTrigger Documentation: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticmapreduce-cluster-scalingtrigger.html\ntype ClusterScalingTrigger struct {\n\tCloudWatchAlarmDefinition interface{} `yaml:\"CloudWatchAlarmDefinition\"`\n}\n\n// ClusterScalingTrigger validation\nfunc (resource ClusterScalingTrigger) Validate() []error {\n\terrors := []error{}\n\n\treturn errors\n}\n"}
{"sample": "// PrintErrorOrContinue prints the error if it exists, otherwise continues execution\nfunc PrintErrorOrContinue(err error) {\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\t// Continue execution...\n\t}\n}\n"}
{"sample": "package pop3server\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\ntype POP3Server struct {\n\tUsername string\n\tPassword string\n}\n\nfunc (s *POP3Server) Start() error {\n\tln, err := net.Listen(\"tcp\", \":110\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tgo s.handleConnection(conn)\n\t}\n}\n\nfunc (s *POP3Server) handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\tconn.Write([]byte(\"+OK POP3 server ready\\r\\n\"))\n\n\tscanner := bufio.NewScanner(conn)\n\n\tfor scanner.Scan() {\n\t\tcommand := scanner.Text()\n\t\tparts := strings.Fields(command)\n\n\t\tswitch parts[0] {\n\t\tcase \"USER\":\n\t\t\tif len(parts) < 2 || parts[1] != s.Username {\n\t\t\t\tconn.Write([]byte(\"-ERR Invalid username\\r\\n\"))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconn.Write([]byte(\"+OK Password required\\r\\n\"))\n\t\tcase \"PASS\":\n\t\t\tif len(parts) < 2 || parts[1] != s.Password {\n\t\t\t\tconn.Write([]byte(\"-ERR Invalid password\\r\\n\"))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconn.Write([]byte(\"+OK Logged in\\r\\n\"))\n\t\tcase \"QUIT\":\n\t\t\tconn.Write([]byte(\"+OK Goodbye\\r\\n\"))\n\t\t\treturn\n\t\tdefault:\n\t\t\tconn.Write([]byte(\"-ERR Unknown command\\r\\n\"))\n\t\t}\n\t}\n}\n\nfunc main() {\n\tserver := &POP3Server{\n\t\tUsername: \"user\",\n\t\tPassword: \"pass\",\n\t}\n\n\tif err := server.Start(); err != nil {\n\t\tfmt.Println(\"Error starting server:\", err)\n\t}\n}"}
{"sample": "package httpmiddleware\n\nimport (\n\t\"net/http\"\n)\n\nfunc AuthMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if user is authenticated\n\t\tif !isAuthenticated(r) {\n\t\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\t// Call the next handler\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc RateLimitMiddleware(next http.Handler, limit int) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if user has exceeded the rate limit\n\t\tif !hasExceededRateLimit(r, limit) {\n\t\t\thttp.Error(w, \"Rate limit exceeded\", http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\n\t\t// Call the next handler\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc LoggingMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Log the request\n\t\tlogRequest(r)\n\n\t\t// Call the next handler\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// Helper functions\nfunc isAuthenticated(r *http.Request) bool {\n\t// Check if user is authenticated\n\treturn true\n}\n\nfunc hasExceededRateLimit(r *http.Request, limit int) bool {\n\t// Check if user has exceeded the rate limit\n\treturn false\n}\n\nfunc logRequest(r *http.Request) {\n\t// Log the request\n}"}
{"sample": "package dockercli\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/docker/pkg/stdcopy\"\n\t\"github.com/spf13/cobra\"\n)\n\nfunc runContainer(cmd *cobra.Command, args []string) {\n\tctx := context.Background()\n\n\tcli, err := client.NewEnvClient()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error connecting to Docker daemon: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tconfig := &container.Config{\n\t\tImage:        \"alpine:latest\",\n\t\tTty:          true,\n\t\tAttachStdin:  false,\n\t\tAttachStdout: true,\n\t\tAttachStderr: true,\n\t\tCmd:          []string{\"echo\", \"Hello World!\"},\n\t}\n\n\tresp, err := cli.ContainerCreate(ctx, config, nil, nil, \"\")\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error creating container: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{}); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error starting container: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tstatusCh, errCh := cli.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)\n\tgo func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Error waiting for container: %v\\n\", err)\n\t\t\t}\n\t\tcase <-statusCh:\n\t\t}\n\t}()\n\n\tout, err := cli.ContainerLogs(ctx, resp.ID, types.ContainerLogsOptions{ShowStdout: true, ShowStderr: true, Follow: true})\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error getting container logs: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tgo func() {\n\t\tsigCh := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigCh, syscall.SIGTERM, syscall.SIGINT)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-sigCh:\n\t\t\t\tif err := cli.ContainerStop(ctx, resp.ID, nil); err != nil {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"Error stopping container: %v\\n\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tif _, err := stdcopy.StdCopy(os.Stdout, os.Stderr, out); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error copying container logs: %v\\n\", err)\n\t}\n\ttime.Sleep(5 * time.Second)\n}"}
{"sample": "dictionary := map[string]int{\"one\": 1, \"two\": 2}\ndelete(dictionary, \"one\")\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintTable prints the multiplication table of a given number up to a specified limit.\nfunc PrintTable(num, limit int) {\n\tfor i := 1; i <= limit; i++ {\n\t\tresult := num * i\n\t\tfmt.Printf(\"%d x %d = %d\\n\", num, i, result)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// SortInts sorts a slice of integers in ascending order.\nfunc SortInts(nums []int) {\n\tsort.Ints(nums)\n}"}
{"sample": "type FileHandler struct {\n\tfilePath string\n}\n\nfunc (f *FileHandler) ReadFile() ([]byte, error) {\n\tfile, err := os.Open(f.filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\tbytes, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn bytes, nil\n}\n\nfunc (f *FileHandler) WriteFile(data []byte) error {\n\tfile, err := os.Create(f.filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\t_, err = file.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://jsonplaceholder.typicode.com/posts/1\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "package websocket\n\nimport (\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/madhouseminers/chatshare-server/internal/clients\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\ntype messageBus interface {\n\tDirect(message *clients.Message, clientName string)\n\tAddClient(client clients.Client)\n\tRemoveClient(client clients.Client)\n\tBroadcast(message *clients.Message)\n}\n\ntype httpServer struct {\n\tbus messageBus\n}\n\nfunc StartServer(bus messageBus, ws *sync.WaitGroup) *httpServer {\n\tserver := &http.Server{\n\t\tAddr: \":8080\",\n\t}\n\th := &httpServer{bus: bus}\n\thttp.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) {\n\t\t_, err := writer.Write([]byte(\"OK\"))\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error responding to health check: \" + err.Error())\n\t\t}\n\t})\n\thttp.HandleFunc(\"/ws\", h.upgradeHandler)\n\tws.Add(1)\n\tgo func() {\n\t\terr := server.ListenAndServe()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Unable to close server: \" + err.Error())\n\t\t}\n\t\tws.Done()\n\t}()\n\treturn h\n}\n\nfunc (h *httpServer) upgradeHandler(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Error upgrading request: \" + err.Error())\n\t\treturn\n\t}\n\tcreateHandler(conn, h.bus)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Square calculates the square of a number and returns the result.\nfunc Square(num int) int {\n\treturn num * num\n}"}
{"sample": "package main\n\n// Read file content\nfunc main() {\n\tcontent, err := ioutil.ReadFile(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(content))\n}\n"}
{"sample": "go func() {\n\tfmt.Println(\"Running in a goroutine\")\n}()\n"}
{"sample": "func commitTransaction(tx *sql.Tx) error {\n\terr := tx.Commit()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"}
{"sample": "type Stack struct {\n\titems []int\n}\n\nfunc (s *Stack) Push(item int) {\n\ts.items = append(s.items, item)\n}\n\nfunc (s *Stack) Pop() int {\n\tlength := len(s.items)\n\tremoved := s.items[length-1]\n\ts.items = s.items[:length-1]\n\treturn removed\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"List of users\")\n\t}).Methods(\"GET\")\n\n\tr.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Create user\")\n\t}).Methods(\"POST\")\n\n\tr.HandleFunc(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tvars := mux.Vars(r)\n\t\tid := vars[\"id\"]\n\t\tfmt.Fprintln(w, \"Get user by ID\", id)\n\t}).Methods(\"GET\")\n\n\tr.HandleFunc(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tvars := mux.Vars(r)\n\t\tid := vars[\"id\"]\n\t\tfmt.Fprintln(w, \"Update user\", id)\n\t}).Methods(\"PUT\")\n\n\tr.HandleFunc(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tvars := mux.Vars(r)\n\t\tid := vars[\"id\"]\n\t\tfmt.Fprintln(w, \"Delete user\", id)\n\t}).Methods(\"DELETE\")\n\n\thttp.Handle(\"/\", r)\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintEvenNumbersUpToN(20)\n}\n\n// Function to print even numbers up to n\nfunc PrintEvenNumbersUpToN(n int) {\n\tfor i := 0; i <= n; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "// Copyright 2017 Northern.tech AS\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\n// Code generated by mockery v1.0.0\npackage mocks\n\nimport context \"context\"\nimport mock \"github.com/stretchr/testify/mock\"\nimport model \"github.com/mendersoftware/useradm/model\"\n\n// DataStore is an autogenerated mock type for the DataStore type\ntype DataStore struct {\n\tmock.Mock\n}\n\n// CreateUser provides a mock function with given fields: ctx, u\nfunc (_m *DataStore) CreateUser(ctx context.Context, u *model.User) error {\n\tret := _m.Called(ctx, u)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(context.Context, *model.User) error); ok {\n\t\tr0 = rf(ctx, u)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n\n// DeleteUser provides a mock function with given fields: ctx, id\nfunc (_m *DataStore) DeleteUser(ctx context.Context, id string) error {\n\tret := _m.Called(ctx, id)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(context.Context, string) error); ok {\n\t\tr0 = rf(ctx, id)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n\n// GetUserByEmail provides a mock function with given fields: ctx, email\nfunc (_m *DataStore) GetUserByEmail(ctx context.Context, email string) (*model.User, error) {\n\tret := _m.Called(ctx, email)\n\n\tvar r0 *model.User\n\tif rf, ok := ret.Get(0).(func(context.Context, string) *model.User); ok {\n\t\tr0 = rf(ctx, email)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(*model.User)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(context.Context, string) error); ok {\n\t\tr1 = rf(ctx, email)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// GetUserById provides a mock function with given fields: ctx, id\nfunc (_m *DataStore) GetUserById(ctx context.Context, id string) (*model.User, error) {\n\tret := _m.Called(ctx, id)\n\n\tvar r0 *model.User\n\tif rf, ok := ret.Get(0).(func(context.Context, string) *model.User); ok {\n\t\tr0 = rf(ctx, id)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(*model.User)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(context.Context, string) error); ok {\n\t\tr1 = rf(ctx, id)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// GetUsers provides a mock function with given fields: ctx\nfunc (_m *DataStore) GetUsers(ctx context.Context) ([]model.User, error) {\n\tret := _m.Called(ctx)\n\n\tvar r0 []model.User\n\tif rf, ok := ret.Get(0).(func(context.Context) []model.User); ok {\n\t\tr0 = rf(ctx)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).([]model.User)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(context.Context) error); ok {\n\t\tr1 = rf(ctx)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// UpdateUser provides a mock function with given fields: ctx, id, u\nfunc (_m *DataStore) UpdateUser(ctx context.Context, id string, u *model.UserUpdate) error {\n\tret := _m.Called(ctx, id, u)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(context.Context, string, *model.UserUpdate) error); ok {\n\t\tr0 = rf(ctx, id, u)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n"}
{"sample": "package bigtableclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"cloud.google.com/go/bigtable\"\n\t\"google.golang.org/api/option\"\n)\n\ntype BigtableClient struct {\n\tclient *bigtable.Client\n}\n\nfunc NewBigtableClient(projectID, instanceID string) (*BigtableClient, error) {\n\tctx := context.Background()\n\tclient, err := bigtable.NewClient(ctx, projectID, instanceID, option.WithCredentialsFile(\"path/to/credentials.json\"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create client: %v\", err)\n\t}\n\treturn &BigtableClient{client: client}, nil\n}\n\nfunc (bt *BigtableClient) CreateTable(tableName string, familyName string) error {\n\tctx := context.Background()\n\tadminClient := bt.client.AdminClient()\n\n\ttables, err := adminClient.Tables(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get tables: %v\", err)\n\t}\n\n\tfor _, table := range tables {\n\t\tif table == tableName {\n\t\t\tlog.Printf(\"table %s already exists\", tableName)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif err := adminClient.CreateTable(ctx, tableName); err != nil {\n\t\treturn fmt.Errorf(\"failed to create table: %v\", err)\n\t}\n\n\tif err := adminClient.CreateColumnFamily(ctx, tableName, familyName); err != nil {\n\t\treturn fmt.Errorf(\"failed to create column family: %v\", err)\n\t}\n\n\tlog.Printf(\"table %s created successfully\", tableName)\n\treturn nil\n}\n\nfunc (bt *BigtableClient) WriteToTable(tableName string, familyName string, rowKey string, data map[string]string) error {\n\tctx := context.Background()\n\n\ttbl := bt.client.Open(tableName)\n\trow := tbl.Row(rowKey)\n\n\tmut := bigtable.NewMutation()\n\tfor k, v := range data {\n\t\tmut.Set(familyName, k, bigtable.Now(), []byte(v))\n\t}\n\n\tif err := row.Apply(ctx, mut); err != nil {\n\t\treturn fmt.Errorf(\"failed to apply row mutation: %v\", err)\n\t}\n\n\tlog.Printf(\"data written to table %s successfully\", tableName)\n\treturn nil\n}\n\nfunc (bt *BigtableClient) ReadFromTable(tableName string, familyName string, rowKey string) (map[string]string, error) {\n\tctx := context.Background()\n\n\ttbl := bt.client.Open(tableName)\n\trow, err := tbl.ReadRow(ctx, rowKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read row: %v\", err)\n\t}\n\n\tdata := make(map[string]string)\n\tfor col, cell := range row[familyName] {\n\t\tdata[col] = string(cell.Value)\n\t}\n\n\treturn data, nil\n}\n\nfunc (bt *BigtableClient) DeleteTable(tableName string) error {\n\tctx := context.Background()\n\tadminClient := bt.client.AdminClient()\n\n\tif err := adminClient.DeleteTable(ctx, tableName); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete table: %v\", err)\n\t}\n\n\tlog.Printf(\"table %s deleted successfully\", tableName)\n\treturn nil\n}\n\nfunc (bt *BigtableClient) Close() {\n\tbt.client.Close()\n\tlog.Println(\"bigtable client closed\")\n}"}
{"sample": "// IfErrorReturn checks if an error exists and returns it if so\nfunc IfErrorReturn(err error) error {\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"}
{"sample": "package rsaencdec\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\ntype RSA struct {\n\tprivateKey *rsa.PrivateKey\n\tpublicKey  *rsa.PublicKey\n}\n\nfunc GenerateKey(keySize int) (*RSA, error) {\n\tprivateKey, err := rsa.GenerateKey(rand.Reader, keySize)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &RSA{\n\t\tprivateKey: privateKey,\n\t\tpublicKey:  &privateKey.PublicKey,\n\t}, nil\n}\n\nfunc (r *RSA) ExtractPrivateKey(filename string) error {\n\tprivKeyBytes, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tblock, _ := pem.Decode(privKeyBytes)\n\tif block == nil {\n\t\treturn errors.New(\"failed to decode PEM block containing private key\")\n\t}\n\n\tprivKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tr.privateKey = privKey\n\tr.publicKey = &privKey.PublicKey\n\n\treturn nil\n}\n\nfunc (r *RSA) Encrypt(msg []byte) ([]byte, error) {\n\treturn rsa.EncryptPKCS1v15(rand.Reader, r.publicKey, msg)\n}\n\nfunc (r *RSA) Decrypt(cipherText []byte) ([]byte, error) {\n\treturn rsa.DecryptPKCS1v15(rand.Reader, r.privateKey, cipherText)\n}\n\nfunc (r *RSA) SavePrivateKey(filename string) error {\n\tprivKeyBytes := x509.MarshalPKCS1PrivateKey(r.privateKey)\n\tblock := &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: privKeyBytes,\n\t}\n\n\terr := ioutil.WriteFile(filename, pem.EncodeToMemory(block), 0600)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package deliveryservice\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Delivery struct {\n\tID          uuid.UUID\n\tRecipient   string\n\tDestination string\n\tStatus      string\n\tCreatedAt   time.Time\n\tUpdatedAt   time.Time\n}\n\ntype DeliveryService struct {\n\tDB *sql.DB\n}\n\nfunc (ds *DeliveryService) CreateDelivery(recipient, destination string) (*Delivery, error) {\n\tdelivery := &Delivery{\n\t\tID:          uuid.New(),\n\t\tRecipient:   recipient,\n\t\tDestination: destination,\n\t\tStatus:      \"created\",\n\t\tCreatedAt:   time.Now(),\n\t\tUpdatedAt:   time.Now(),\n\t}\n\n\t_, err := ds.DB.Exec(\"INSERT INTO deliveries (id, recipient, destination, status, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6)\",\n\t\tdelivery.ID, delivery.Recipient, delivery.Destination, delivery.Status, delivery.CreatedAt, delivery.UpdatedAt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn delivery, nil\n}\n\nfunc (ds *DeliveryService) UpdateDeliveryStatus(id uuid.UUID, status string) (*Delivery, error) {\n\tdelivery, err := ds.GetDelivery(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif delivery.Status == \"delivered\" {\n\t\treturn nil, errors.New(\"delivery has already been delivered\")\n\t}\n\n\tdelivery.Status = status\n\tdelivery.UpdatedAt = time.Now()\n\n\t_, err = ds.DB.Exec(\"UPDATE deliveries SET status = $1, updated_at = $2 WHERE id = $3\", delivery.Status, delivery.UpdatedAt, delivery.ID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn delivery, nil\n}\n\nfunc (ds *DeliveryService) GetDelivery(id uuid.UUID) (*Delivery, error) {\n\tdelivery := &Delivery{}\n\n\trow := ds.DB.QueryRow(\"SELECT id, recipient, destination, status, created_at, updated_at FROM deliveries WHERE id = $1\", id)\n\terr := row.Scan(&delivery.ID, &delivery.Recipient, &delivery.Destination, &delivery.Status, &delivery.CreatedAt, &delivery.UpdatedAt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn delivery, nil\n}\n\nfunc (ds *DeliveryService) ListDeliveries() ([]*Delivery, error) {\n\tdeliveries := []*Delivery{}\n\n\trows, err := ds.DB.Query(\"SELECT id, recipient, destination, status, created_at, updated_at FROM deliveries\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tdelivery := &Delivery{}\n\t\terr := rows.Scan(&delivery.ID, &delivery.Recipient, &delivery.Destination, &delivery.Status, &delivery.CreatedAt, &delivery.UpdatedAt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdeliveries = append(deliveries, delivery)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn deliveries, nil\n}\n\nfunc (ds *DeliveryService) DeleteDelivery(id uuid.UUID) error {\n\t_, err := ds.DB.Exec(\"DELETE FROM deliveries WHERE id = $1\", id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (d *Delivery) String() string {\n\treturn fmt.Sprintf(\"Delivery{ID: %s, Recipient: %s, Destination: %s, Status: %s, CreatedAt: %s, UpdatedAt: %s}\",\n\t\td.ID, d.Recipient, d.Destination, d.Status, d.CreatedAt, d.UpdatedAt)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Greet greets a person with the given name.\nfunc Greet(name string) {\n\tfmt.Printf(\"Hello, %s!\", name)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype Todo struct {\n\tID        string `json:\"id,omitempty\"`\n\tTask      string `json:\"task,omitempty\"`\n\tCompleted bool   `json:\"completed,omitempty\"`\n}\n\nvar todos []Todo\n\nfunc getTodos(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(todos)\n}\n\nfunc getTodoById(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tparams := mux.Vars(r)\n\tfor _, item := range todos {\n\t\tif item.ID == params[\"id\"] {\n\t\t\tjson.NewEncoder(w).Encode(item)\n\t\t\treturn\n\t\t}\n\t}\n\tjson.NewEncoder(w).Encode(&Todo{})\n}\n\nfunc createTodo(w http.ResponseWriter, r *http.Request) {\n\tvar todo Todo\n\t_ = json.NewDecoder(r.Body).Decode(&todo)\n\ttodos = append(todos, todo)\n\tjson.NewEncoder(w).Encode(todos)\n}\n\nfunc main() {\n\ttodos = append(todos, Todo{ID: \"1\", Task: \"Task 1\", Completed: false})\n\ttodos = append(todos, Todo{ID: \"2\", Task: \"Task 2\", Completed: true})\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/todos\", getTodos).Methods(\"GET\")\n\tr.HandleFunc(\"/todos/{id}\", getTodoById).Methods(\"GET\")\n\tr.HandleFunc(\"/todos\", createTodo).Methods(\"POST\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}"}
{"sample": "// Creating a custom error\n\nvar ErrCustom = errors.New(\"custom error\")\n"}
{"sample": "package ansible\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc RunAnsiblePlaybook(playbookPath string, inventoryPath string) error {\n\tcmd := exec.Command(\"ansible-playbook\", \"-i\", inventoryPath, playbookPath)\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error running ansible-playbook: %v, output: %s\", err, output)\n\t}\n\treturn nil\n}\n\nfunc RunAnsibleAdhocCommand(inventoryPath string, module string, args string) error {\n\tcmd := exec.Command(\"ansible\", \"-i\", inventoryPath, \"-m\", module, \"-a\", args, \"all\")\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error running ansible adhoc command: %v, output: %s\", err, output)\n\t}\n\treturn nil\n}\n\nfunc RunAnsiblePing(inventoryPath string) error {\n\tcmd := exec.Command(\"ansible\", \"-i\", inventoryPath, \"-m\", \"ping\", \"all\")\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error running ansible ping: %v, output: %s\", err, output)\n\t}\n\treturn nil\n}"}
{"sample": "func BubbleSort(arr []int) {\n\tfor i := 0; i < len(arr); i++ {\n\t\tfor j := 0; j < len(arr)-1-i; j++ {\n\t\t\tif arr[j] > arr[j+1] {\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "package sqlserverclient\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t_ \"github.com/denisenkom/go-mssqldb\"\n)\n\ntype SQLServerClient struct {\n\tserver   string\n\tport     int\n\tuser     string\n\tpassword string\n\tdatabase string\n}\n\ntype Employee struct {\n\tID        int\n\tFirstName string\n\tLastName  string\n\tAge       int\n}\n\nfunc NewSQLServerClient(server string, port int, user string, password string, database string) *SQLServerClient {\n\treturn &SQLServerClient{\n\t\tserver:   server,\n\t\tport:     port,\n\t\tuser:     user,\n\t\tpassword: password,\n\t\tdatabase: database,\n\t}\n}\n\nfunc (c *SQLServerClient) Connect() (*sql.DB, error) {\n\tconnString := fmt.Sprintf(\"server=%s;port=%d;user id=%s;password=%s;database=%s\", c.server, c.port, c.user, c.password, c.database)\n\tdb, err := sql.Open(\"sqlserver\", connString)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tif err = db.PingContext(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n\nfunc (c *SQLServerClient) GetEmployee(id int) (*Employee, error) {\n\tdb, err := c.Connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tquery := fmt.Sprintf(\"SELECT * FROM Employees WHERE ID=%d\", id)\n\trow := db.QueryRowContext(ctx, query)\n\n\tvar employee Employee\n\tif err := row.Scan(&employee.ID, &employee.FirstName, &employee.LastName, &employee.Age); err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn nil, fmt.Errorf(\"no employee with id %d\", id)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn &employee, nil\n}\n\nfunc (c *SQLServerClient) AddEmployee(employee *Employee) error {\n\tdb, err := c.Connect()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tquery := fmt.Sprintf(\"INSERT INTO Employees (FirstName, LastName, Age) VALUES ('%s', '%s', %d)\", employee.FirstName, employee.LastName, employee.Age)\n\t_, err = db.ExecContext(ctx, query)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *SQLServerClient) UpdateEmployee(employee *Employee) error {\n\tdb, err := c.Connect()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tquery := fmt.Sprintf(\"UPDATE Employees SET FirstName='%s', LastName='%s', Age=%d WHERE ID=%d\", employee.FirstName, employee.LastName, employee.Age, employee.ID)\n\t_, err = db.ExecContext(ctx, query)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *SQLServerClient) DeleteEmployee(id int) error {\n\tdb, err := c.Connect()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tquery := fmt.Sprintf(\"DELETE FROM Employees WHERE ID=%d\", id)\n\t_, err = db.ExecContext(ctx, query)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *SQLServerClient) GetAllEmployees() ([]Employee, error) {\n\tdb, err := c.Connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tquery := \"SELECT * FROM Employees\"\n\trows, err := db.QueryContext(ctx, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar employees []Employee\n\tfor rows.Next() {\n\t\tvar employee Employee\n\t\tif err := rows.Scan(&employee.ID, &employee.FirstName, &employee.LastName, &employee.Age); err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\temployees = append(employees, employee)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn employees, nil\n}"}
{"sample": "func BinarySearch(arr []int, target int) int {\n\tleft, right := 0, len(arr)-1\n\tfor left <= right {\n\t\tmid := (left + right) / 2\n\t\tif arr[mid] == target {\n\t\t\treturn mid\n\t\t}\n\t\tif arr[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else {\n\t\t\tright = mid - 1\n\t\t}\n\t}\n\treturn -1\n}"}
{"sample": "// Spawning a goroutine\n\ngo func() {\n\tfmt.Println(\"Hello from a goroutine\")\n}()\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"log\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})\n\n\thttp.HandleFunc(\"/about\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"About page\")\n\t})\n\n\thttp.HandleFunc(\"/contact\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Contact page\")\n\t})\n\n\thttp.HandleFunc(\"/api/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"API endpoint: Get all users\")\n\t})\n\n\thttp.HandleFunc(\"/api/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"API endpoint: Get user by ID: %s\", http.Vars(r)[\"id\"])\n\t})\n\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"Error starting server: \", err)\n\t}\n}"}
{"sample": "func main() {\n\tpath := \"/path/to/directory\"\n\n\terr := filepath.Walk(path, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error walking path:\", err)\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Println(path)\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tfmt.Println(\"Error walking path:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// ReverseString reverses a given string and returns the result.\nfunc ReverseString(str string) string {\n\tchars := []rune(str)\n\tfor i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {\n\t\tchars[i], chars[j] = chars[j], chars[i]\n\t}\n\treturn string(chars)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(ComputeAverage([]float64{1.2, 2.3, 3.4, 4.5, 5.6}))\n}\n\n// Function to compute average of an array\nfunc ComputeAverage(arr []float64) float64 {\n\tsum := 0.0\n\tfor _, value := range arr {\n\t\tsum += value\n\t}\n\treturn sum / float64(len(arr))\n}"}
{"sample": "http.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle users endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get users\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create user\")\n\t}\n})\n"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--config\", argparse.String, \"config.json\", \"Config file\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype employee struct {\n\tname   string\n\tage    int\n\tsalary int\n}\n\ntype  BySalary  []employee\n\nfunc (b BySalary) Len() int           { return len(b) }\nfunc (b BySalary) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }\nfunc (b BySalary) Less(i, j int) bool { return b[i].salary < b[j].salary }\n\nfunc main() {\n\temployees := []employee{\n\t\t{name: \"Alice\", age: 23, salary: 50000},\n\t\t{name: \"Bob\", age: 25, salary: 70000},\n\t\t{name: \"Charlie\", age: 21, salary: 40000},\n\t\t{name: \"David\", age: 27, salary: 90000},\n\t}\n\n\tfmt.Println(\"Before:\")\n\tfor _, e := range employees {\n\t\tfmt.Printf(\"%s: age=%d, salary=%d\\n\", e.name, e.age, e.salary)\n\t}\n\n\tsort.Sort(BySalary(employees))\n\n\tfmt.Println(\"\\nAfter:\")\n\tfor _, e := range employees {\n\t\tfmt.Printf(\"%s: age=%d, salary=%d\\n\", e.name, e.age, e.salary)\n\t}\n}\n\n// Output:\n//\n// Before:\n// Alice: age=23, salary=50000\n// Bob: age=25, salary=70000\n// Charlie: age=21, salary=40000\n// David: age=27, salary=90000\n//\n// After:\n// Charlie: age=21, salary=40000\n// Alice: age=23, salary=50000\n// Bob: age=25, salary=70000\n// David: age=27, salary=90000\n\n// Output will vary as per the input employs details & Runtime."}
{"sample": "package oracledb\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/godror/godror\"\n)\n\ntype User struct {\n\tID       int\n\tUsername string\n\tEmail    string\n}\n\nfunc Connect() (*sql.DB, error) {\n\tdb, err := sql.Open(\"godror\", \"user/password@host:port/sid\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = db.Ping()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n\nfunc CreateUser(db *sql.DB, user User) error {\n\tquery := `INSERT INTO users (id, username, email) VALUES (:1, :2, :3)`\n\t_, err := db.Exec(query, user.ID, user.Username, user.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc GetUser(db *sql.DB, id int) (User, error) {\n\tquery := `SELECT id, username, email FROM users WHERE id = :1`\n\trow := db.QueryRow(query, id)\n\n\tvar user User\n\terr := row.Scan(&user.ID, &user.Username, &user.Email)\n\tif err != nil {\n\t\treturn User{}, err\n\t}\n\n\treturn user, nil\n}\n\nfunc UpdateUser(db *sql.DB, user User) error {\n\tquery := `UPDATE users SET username = :1, email = :2 WHERE id = :3`\n\t_, err := db.Exec(query, user.Username, user.Email, user.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc DeleteUser(db *sql.DB, id int) error {\n\tquery := `DELETE FROM users WHERE id = :1`\n\t_, err := db.Exec(query, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc ExampleUsage() {\n\tdb, err := Connect()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tuser := User{\n\t\tID:       1,\n\t\tUsername: \"johndoe\",\n\t\tEmail:    \"johndoe@example.com\",\n\t}\n\n\terr = CreateUser(db, user)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tuser, err = GetUser(db, 1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(user)\n\n\tuser.Username = \"janedoe\"\n\tuser.Email = \"janedoe@example.com\"\n\n\terr = UpdateUser(db, user)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = DeleteUser(db, 1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package webhookmgr\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype Webhook struct {\n\tEvent  string      `json:\"event\"`\n\tData   interface{} `json:\"data\"`\n\tTarget string      `json:\"target\"`\n}\n\ntype WebhookHandler struct {\n\thandlers map[string]func(interface{})\n\tmu       sync.RWMutex\n}\n\nfunc (wh *WebhookHandler) RegisterHandler(event string, handler func(interface{})) {\n\twh.mu.Lock()\n\tdefer wh.mu.Unlock()\n\twh.handlers[event] = handler\n}\n\nfunc (wh *WebhookHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPost {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tvar webhook Webhook\n\tif err := json.Unmarshal(body, &webhook); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\twh.mu.RLock()\n\thandler, ok := wh.handlers[webhook.Event]\n\twh.mu.RUnlock()\n\n\tif !ok {\n\t\tlog.Printf(\"No handler found for event: %s\", webhook.Event)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\thandler(webhook.Data)\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"Webhook processed successfully\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\tclient := &http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", \"https://api.example.com/data\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer YOUR_API_TOKEN\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error making request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "func getAllUsers(db *sql.DB) ([]User, error) {\n\trows, err := db.Query(\"SELECT id, name FROM users\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar users []User\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(&user.ID, &user.Name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\n\treturn users, nil\n}\n"}
{"sample": "package ssestream\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Message struct {\n\tID        int       `json:\"id\"`\n\tTimestamp time.Time `json:\"timestamp\"`\n\tText      string    `json:\"text\"`\n}\n\nfunc streamHandler(w http.ResponseWriter, r *http.Request) {\n\tflusher, ok := w.(http.Flusher)\n\tif !ok {\n\t\thttp.Error(w, \"Streaming unsupported\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n\tw.Header().Set(\"Cache-Control\", \"no-cache\")\n\tw.Header().Set(\"Connection\", \"keep-alive\")\n\n\tenc := json.NewEncoder(w)\n\n\tfor i := 0; ; i++ {\n\t\tmsg := Message{\n\t\t\tID:        i,\n\t\t\tTimestamp: time.Now(),\n\t\t\tText:      fmt.Sprintf(\"Message %d\", i),\n\t\t}\n\n\t\tif err := enc.Encode(msg); err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tflusher.Flush()\n\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n\nfunc StartServer() {\n\thttp.HandleFunc(\"/stream\", streamHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-redis/redis\"\n)\n\nfunc main() {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\tpong, err := client.Ping().Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(pong)\n\n\terr = client.Set(\"key\", \"value\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tval, err := client.Get(\"key\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"key\", val)\n\n\tkeys := client.Keys(\"*\")\n\tif err := keys.Err(); err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"keys:\", keys.Val())\n\n\tn, err := client.Del(\"key\").Result()\n\tfmt.Println(n, err)\n}"}
{"sample": "package workerpool\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype Job struct {\n\tID        int\n\tTask      func() error\n\tRetries   int\n\tCompleted bool\n}\n\nfunc NewJob(id int, task func() error, retries int) *Job {\n\treturn &Job{\n\t\tID:        id,\n\t\tTask:      task,\n\t\tRetries:   retries,\n\t\tCompleted: false,\n\t}\n}\n\ntype WorkerPool struct {\n\tworkers   []*Worker\n\tjobQueue  chan *Job\n\twaitGroup sync.WaitGroup\n}\n\nfunc NewWorkerPool(numWorkers int, jobQueueSize int) *WorkerPool {\n\tworkers := make([]*Worker, numWorkers)\n\tfor i := 0; i < numWorkers; i++ {\n\t\tworkers[i] = NewWorker(i)\n\t}\n\n\treturn &WorkerPool{\n\t\tworkers:   workers,\n\t\tjobQueue:  make(chan *Job, jobQueueSize),\n\t\twaitGroup: sync.WaitGroup{},\n\t}\n}\n\nfunc (wp *WorkerPool) Start() {\n\tfor _, worker := range wp.workers {\n\t\twp.waitGroup.Add(1)\n\t\tgo worker.start(wp.jobQueue, &wp.waitGroup)\n\t}\n}\n\nfunc (wp *WorkerPool) Stop() {\n\tclose(wp.jobQueue)\n\twp.waitGroup.Wait()\n}\n\nfunc (wp *WorkerPool) AddJob(job *Job) {\n\twp.jobQueue <- job\n}\n\ntype Worker struct {\n\tID int\n}\n\nfunc NewWorker(id int) *Worker {\n\treturn &Worker{\n\t\tID: id,\n\t}\n}\n\nfunc (w *Worker) start(jobQueue chan *Job, waitGroup *sync.WaitGroup) {\n\tfor job := range jobQueue {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", w.ID, job.ID)\n\n\t\terr := job.Task()\n\t\tif err != nil && job.Retries > 0 {\n\t\t\tjob.Retries--\n\t\t\tjobQueue <- job\n\t\t} else {\n\t\t\tjob.Completed = true\n\t\t}\n\n\t\tfmt.Printf(\"Worker %d completed job %d\\n\", w.ID, job.ID)\n\t}\n\n\twaitGroup.Done()\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintNumberInHexadecimal(255)\n}\n\n// Function to print the hexadecimal representation of a number\nfunc PrintNumberInHexadecimal(n int) {\n\tfmt.Printf(\"%x\\n\", n)\n}"}
{"sample": "// Create a new HTTP server with the specified address and handler\nfunc NewServer(addr string, handler http.Handler) *http.Server {\n\treturn &http.Server{\n\t\tAddr:    addr,\n\t\tHandler: handler,\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\n\t\"myapp/protobuf\"\n)\n\ntype server struct {\n\tprotobuf.UnimplementedMyServiceServer\n}\n\nfunc (s *server) SayHello(ctx context.Context, in *protobuf.HelloRequest) (*protobuf.HelloReply, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &protobuf.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tprotobuf.RegisterMyServiceServer(s, &server{})\n\tfmt.Println(\"Server started at port 8080\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nfunc IsPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gobuffalo/packr/v2\"\n)\n\nfunc UseGzipCompression() {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, Gzip!\")\n\t})\n\n\tpackrHandler := packr.GzipHandler(handler)\n\n\thttp.ListenAndServe(\":8080\", packrHandler)\n}\n"}
{"sample": "/* Copyright 2020 The Bazel Authors. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// This test file was first seen on:\n// https://github.com/bazelbuild/bazel-skylib/blob/f80bc733d4b9f83d427ce3442be2e07427b2cc8d/gazelle/bzl/BUILD.\n// It was modified for the needs of this extension.\n\npackage js\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/bazelbuild/bazel-gazelle/testtools\"\n\t\"github.com/bazelbuild/rules_go/go/tools/bazel\"\n\t\"github.com/emirpasic/gods/lists/singlylinkedlist\"\n\t\"github.com/ghodss/yaml\"\n)\n\nconst (\n\textensionDir      = \"gazelle/\"\n\ttestDataPath      = extensionDir + \"testdata/\"\n\tgazelleBinaryName = \"gazelle_bin\"\n)\n\nvar gazellePath = mustFindGazelle()\n\nfunc TestGazelleBinary(t *testing.T) {\n\ttests := map[string][]bazel.RunfileEntry{}\n\n\trunfiles, err := bazel.ListRunfiles()\n\tif err != nil {\n\t\tt.Fatalf(\"bazel.ListRunfiles() error: %v\", err)\n\t}\n\tfor _, f := range runfiles {\n\t\tif strings.HasPrefix(f.ShortPath, testDataPath) {\n\t\t\trelativePath := strings.TrimPrefix(f.ShortPath, testDataPath)\n\t\t\tparts := strings.SplitN(relativePath, \"/\", 2)\n\t\t\tif len(parts) < 2 {\n\t\t\t\t// This file is not a part of a testcase since it must be in a dir that\n\t\t\t\t// is the test case and then have a path inside of that.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttests[parts[0]] = append(tests[parts[0]], f)\n\t\t}\n\t}\n\tif len(tests) == 0 {\n\t\tt.Fatal(\"no tests found\")\n\t}\n\n\tfor testName, files := range tests {\n\t\tfmt.Println(t)\n\t\ttestPath(t, testName, files)\n\t}\n}\n\nfunc testPath(t *testing.T, name string, files []bazel.RunfileEntry) {\n\tt.Run(name, func(t *testing.T) {\n\t\tvar inputs []testtools.FileSpec\n\t\tvar goldens []testtools.FileSpec\n\n\t\tvar config *testYAML\n\t\tfor _, f := range files {\n\t\t\tpath := f.Path\n\t\t\ttrim := testDataPath + name + \"/\"\n\t\t\tshortPath := strings.TrimPrefix(f.ShortPath, trim)\n\t\t\tinfo, err := os.Stat(path)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"os.Stat(%q) error: %v\", path, err)\n\t\t\t}\n\n\t\t\tif info.IsDir() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontent, err := ioutil.ReadFile(path)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"ioutil.ReadFile(%q) error: %v\", path, err)\n\t\t\t}\n\n\t\t\tif filepath.Base(shortPath) == \"test.yaml\" {\n\t\t\t\tif config != nil {\n\t\t\t\t\tt.Fatal(\"only 1 test.yaml is supported\")\n\t\t\t\t}\n\t\t\t\tconfig = new(testYAML)\n\t\t\t\tif err := yaml.Unmarshal(content, config); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif strings.HasSuffix(shortPath, \".in\") {\n\t\t\t\tinputs = append(inputs, testtools.FileSpec{\n\t\t\t\t\tPath:    filepath.Join(name, strings.TrimSuffix(shortPath, \".in\")),\n\t\t\t\t\tContent: string(content),\n\t\t\t\t})\n\t\t\t} else if strings.HasSuffix(shortPath, \".out\") {\n\t\t\t\tgoldens = append(goldens, testtools.FileSpec{\n\t\t\t\t\tPath:    filepath.Join(name, strings.TrimSuffix(shortPath, \".out\")),\n\t\t\t\t\tContent: string(content),\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tinputs = append(inputs, testtools.FileSpec{\n\t\t\t\t\tPath:    filepath.Join(name, shortPath),\n\t\t\t\t\tContent: string(content),\n\t\t\t\t})\n\t\t\t\tgoldens = append(goldens, testtools.FileSpec{\n\t\t\t\t\tPath:    filepath.Join(name, shortPath),\n\t\t\t\t\tContent: string(content),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\ttestdataDir, cleanup := testtools.CreateFiles(t, inputs)\n\t\tdefer cleanup()\n\t\tdefer func() {\n\t\t\tif t.Failed() {\n\t\t\t\tfilepath.Walk(testdataDir, func(path string, info os.FileInfo, err error) error {\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tt.Logf(\"%q exists\", strings.TrimPrefix(path, testdataDir))\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t}\n\t\t}()\n\n\t\tworkspaceRoot := filepath.Join(testdataDir, name)\n\n\t\targs := []string{\"-build_file_name=BUILD,BUILD.bazel\"}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\t\tdefer cancel()\n\t\tcmd := exec.CommandContext(ctx, gazellePath, args...)\n\t\tvar stdout, stderr bytes.Buffer\n\t\tcmd.Stdout = &stdout\n\t\tcmd.Stderr = &stderr\n\t\tcmd.Dir = workspaceRoot\n\t\tif err := cmd.Run(); err != nil {\n\t\t\tvar e *exec.ExitError\n\t\t\tif !errors.As(err, &e) {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\terrs := singlylinkedlist.New()\n\t\tactualExitCode := cmd.ProcessState.ExitCode()\n\t\tif config.Expect.ExitCode != actualExitCode {\n\t\t\terrs.Add(fmt.Errorf(\"expected gazelle exit code: %d\\ngot: %d\",\n\t\t\t\tconfig.Expect.ExitCode, actualExitCode,\n\t\t\t))\n\t\t}\n\t\tactualStdout := stdout.String()\n\t\tif strings.TrimSpace(config.Expect.Stdout) != strings.TrimSpace(actualStdout) {\n\t\t\terrs.Add(fmt.Errorf(\"expected gazelle stdout: %s\\ngot: %s\",\n\t\t\t\tconfig.Expect.Stdout, actualStdout,\n\t\t\t))\n\t\t}\n\t\tactualStderr := stderr.String()\n\t\tif strings.TrimSpace(config.Expect.Stderr) != strings.TrimSpace(actualStderr) {\n\t\t\terrs.Add(fmt.Errorf(\"expected gazelle stderr: %s\\ngot: %s\",\n\t\t\t\tconfig.Expect.Stderr, actualStderr,\n\t\t\t))\n\t\t}\n\t\tif !errs.Empty() {\n\t\t\terrsIt := errs.Iterator()\n\t\t\tfor errsIt.Next() {\n\t\t\t\terr := errsIt.Value().(error)\n\t\t\t\tt.Log(err)\n\t\t\t}\n\t\t\tt.FailNow()\n\t\t}\n\n\t\ttesttools.CheckFiles(t, testdataDir, goldens)\n\t})\n}\n\nfunc mustFindGazelle() string {\n\tgazellePath, ok := bazel.FindBinary(\"\", gazelleBinaryName)\n\tif !ok {\n\t\tpanic(\"could not find gazelle binary\")\n\t}\n\treturn gazellePath\n}\n\ntype testYAML struct {\n\tExpect struct {\n\t\tExitCode int    `json:\"exit_code\"`\n\t\tStdout   string `json:\"stdout\"`\n\t\tStderr   string `json:\"stderr\"`\n\t} `json:\"expect\"`\n}\n"}
{"sample": "package ascii85coder\n\nimport (\n\t\"bytes\"\n\t\"encoding/ascii85\"\n)\n\nfunc Encode(data []byte) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tencoder := ascii85.NewEncoder(&buf)\n\tif _, err := encoder.Write(data); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := encoder.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n\nfunc Decode(data []byte) ([]byte, error) {\n\tdecoder := ascii85.NewDecoder(bytes.NewReader(data))\n\tvar buf bytes.Buffer\n\tif _, err := buf.ReadFrom(decoder); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}"}
{"sample": "// Enable TLS configuration for the client\nfunc EnableTLS(client *http.Client) {\n\tclient.Transport = &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true}\n\t}\n}\n"}
{"sample": "type Circle struct {\n\tRadius float64\n}\n"}
{"sample": "// IfErrorThenCustomError checks if an error exists, if so, returns a custom error\nfunc IfErrorThenCustomError(err error, customError string) error {\n\tif err != nil {\n\t\treturn errors.New(customError)\n\t}\n\treturn nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// GenerateRandomNumber generates a random number within the specified range.\nfunc GenerateRandomNumber(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}"}
{"sample": "err = os.Truncate(\"file.txt\", 100)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "path := filepath.Join(\"dir\", \"file.txt\")\nfmt.Println(\"Joined path:\", path)\n"}
{"sample": "//   Copyright 2016 DigitalOcean\n//\n//   Licensed under the Apache License, Version 2.0 (the \"License\");\n//   you may not use this file except in compliance with the License.\n//   You may obtain a copy of the License at\n//\n//       http://www.apache.org/licenses/LICENSE-2.0\n//\n//   Unless required by applicable law or agreed to in writing, software\n//   distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//   See the License for the specific language governing permissions and\n//   limitations under the License.\n\n// Command ceph_exporter provides a Prometheus exporter for a Ceph cluster.\npackage main\n\nimport (\n\t\"flag\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/ceph/go-ceph/rados\"\n\t\"github.com/phpor/ceph_exporter/collectors\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\n// This horrible thing is a copy of tcpKeepAliveListener, tweaked to\n// specifically check if it hits EMFILE when doing an accept, and if so,\n// terminate the process.\n\ntype emfileAwareTcpListener struct {\n\t*net.TCPListener\n}\n\nfunc (ln emfileAwareTcpListener) Accept() (c net.Conn, err error) {\n\ttc, err := ln.AcceptTCP()\n\tif err != nil {\n\t\tif oerr, ok := err.(*net.OpError); ok {\n\t\t\tif serr, ok := oerr.Err.(*os.SyscallError); ok && serr.Err == syscall.EMFILE {\n\t\t\t\t// This calls os.Exit(1) and terminates the process\n\t\t\t\tlog.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t}\n\t\t// Default return\n\t\treturn\n\t}\n\ttc.SetKeepAlive(true)\n\ttc.SetKeepAlivePeriod(3 * time.Minute)\n\treturn tc, nil\n}\n\n// CephExporter wraps all the ceph collectors and provides a single global\n// exporter to extracts metrics out of. It also ensures that the collection\n// is done in a thread-safe manner, the necessary requirement stated by\n// prometheus. It also implements a prometheus.Collector interface in order\n// to register it correctly.\ntype CephExporter struct {\n\tmu         sync.Mutex\n\tcollectors []prometheus.Collector\n}\n\n// Verify that the exporter implements the interface correctly.\nvar _ prometheus.Collector = &CephExporter{}\n\n// NewCephExporter creates an instance to CephExporter and returns a reference\n// to it. We can choose to enable a collector to extract stats out of by adding\n// it to the list of collectors.\nfunc NewCephExporter(conn *rados.Conn, cluster string) *CephExporter {\n\treturn &CephExporter{\n\t\tcollectors: []prometheus.Collector{\n\t\t\tcollectors.NewClusterUsageCollector(conn, cluster),\n\t\t\tcollectors.NewPoolUsageCollector(conn, cluster),\n\t\t\tcollectors.NewClusterHealthCollector(conn, cluster),\n\t\t\tcollectors.NewMonitorCollector(conn, cluster),\n\t\t\tcollectors.NewOSDCollector(conn, cluster),\n\t\t},\n\t}\n}\n\n// Describe sends all the descriptors of the collectors included to\n// the provided channel.\nfunc (c *CephExporter) Describe(ch chan<- *prometheus.Desc) {\n\tfor _, cc := range c.collectors {\n\t\tcc.Describe(ch)\n\t}\n}\n\n// Collect sends the collected metrics from each of the collectors to\n// prometheus. Collect could be called several times concurrently\n// and thus its run is protected by a single mutex.\nfunc (c *CephExporter) Collect(ch chan<- prometheus.Metric) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tfor _, cc := range c.collectors {\n\t\tcc.Collect(ch)\n\t}\n}\n\nfunc main() {\n\tvar (\n\t\taddr        = flag.String(\"telemetry.addr\", \":9128\", \"host:port for ceph exporter\")\n\t\tmetricsPath = flag.String(\"telemetry.path\", \"/metrics\", \"URL path for surfacing collected metrics\")\n\t\tcephConfig  = flag.String(\"ceph.config\", \"\", \"path to ceph config file\")\n\t\tcephUser    = flag.String(\"ceph.user\", \"admin\", \"Ceph user to connect to cluster.\")\n\n\t\texporterConfig = flag.String(\"exporter.config\", \"/etc/ceph/exporter.yml\", \"Path to ceph exporter config.\")\n\t)\n\tflag.Parse()\n\n\tif fileExists(*exporterConfig) {\n\n\t\tcfg, err := ParseConfig(*exporterConfig)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Error: %v\", err)\n\t\t}\n\n\t\tfor _, cluster := range cfg.Cluster {\n\n\t\t\tconn, err := rados.NewConnWithUser(cluster.User)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"cannot create new ceph connection: %s\", err)\n\t\t\t}\n\n\t\t\terr = conn.ReadConfigFile(cluster.ConfigFile)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"cannot read ceph config file: %s\", err)\n\t\t\t}\n\n\t\t\tif err := conn.Connect(); err != nil {\n\t\t\t\tlog.Fatalf(\"cannot connect to ceph cluster: %s\", err)\n\t\t\t}\n\t\t\t// defer Shutdown to program exit\n\t\t\tdefer conn.Shutdown()\n\n\t\t\tlog.Printf(\"Starting ceph exporter for cluster: %s\", cluster.ClusterLabel)\n\t\t\terr = prometheus.Register(NewCephExporter(conn, cluster.ClusterLabel))\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"cannot export cluster: %s error: %v\", cluster.ClusterLabel, err)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconn, err := rados.NewConnWithUser(*cephUser)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"cannot create new ceph connection: %s\", err)\n\t\t}\n\n\t\tif *cephConfig != \"\" {\n\t\t\terr = conn.ReadConfigFile(*cephConfig)\n\t\t} else {\n\t\t\terr = conn.ReadDefaultConfigFile()\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"cannot read ceph config file: %s\", err)\n\t\t}\n\n\t\tif err := conn.Connect(); err != nil {\n\t\t\tlog.Fatalf(\"cannot connect to ceph cluster: %s\", err)\n\t\t}\n\t\tdefer conn.Shutdown()\n\n\t\tprometheus.MustRegister(NewCephExporter(conn, \"ceph\"))\n\t}\n\n\thttp.Handle(*metricsPath, promhttp.Handler())\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(`<html>\n\t\t\t<head><title>Ceph Exporter</title></head>\n\t\t\t<body>\n\t\t\t<h1>Ceph Exporter</h1>\n\t\t\t<p><a href='` + *metricsPath + `'>Metrics</a></p>\n\t\t\t</body>\n\t\t\t</html>`))\n\t})\n\n\tlog.Printf(\"Starting ceph exporter on %q\", *addr)\n\t// Below is essentially http.ListenAndServe(), but using our custom\n\t// emfileAwareTcpListener that will die if we run out of file descriptors\n\tln, err := net.Listen(\"tcp\", *addr)\n\tif err == nil {\n\t\terr := http.Serve(emfileAwareTcpListener{ln.(*net.TCPListener)}, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"unable to serve requests: %s\", err)\n\t\t}\n\t}\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to create listener: %s\", err)\n\t}\n}\n"}
{"sample": "func main() {\n\thttp.HandleFunc(\"/\", handleRoot)\n\thttp.HandleFunc(\"/users\", handleUsers)\n\thttp.HandleFunc(\"/products\", handleProducts)\n\thttp.HandleFunc(\"/items\", handleItems)\n\thttp.HandleFunc(\"/orders\", handleOrders)\n\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc handleRoot(w http.ResponseWriter, r *http.Request) {\n\t// Handle root endpoint\n\tfmt.Fprint(w, \"Hello, World!\")\n}\n\nfunc handleUsers(w http.ResponseWriter, r *http.Request) {\n\t// Handle users endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get users\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create user\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleProducts(w http.ResponseWriter, r *http.Request) {\n\t// Handle products endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get products\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create product\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleItems(w http.ResponseWriter, r *http.Request) {\n\t// Handle items endpoint\n\tswitch r.Method {\n\tcase \"GET\":\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get items\")\n\tcase \"POST\":\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create item\")\n\tdefault:\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleOrders(w http.ResponseWriter, r *http.Request) {\n\t// Handle orders endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get orders\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create order\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n"}
{"sample": "type Message struct {\n\tSender    string\n\tRecipient string\n\tContent   string\n}\n\ntype Messenger struct {\n\tMessages []*Message\n\tmu       sync.Mutex\n}\n\nfunc (m *Messenger) Send(msg *Message) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.Messages = append(m.Messages, msg)\n}"}
{"sample": "// Copyright (c) 2020-2021 The Decred developers\n// Use of this source code is governed by an ISC\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n\tcmv1 \"github.com/decred/politeia/politeiawww/api/comments/v1\"\n\tpclient \"github.com/decred/politeia/politeiawww/client\"\n)\n\n// cmdComments retreives the comments for the specified proposal.\ntype cmdComments struct {\n\tArgs struct {\n\t\tToken string `positional-arg-name:\"token\"` // Censorship token\n\t} `positional-args:\"true\" required:\"true\"`\n}\n\n// Execute executes the cmdComments command.\n//\n// This function satisfies the go-flags Commander interface.\nfunc (c *cmdComments) Execute(args []string) error {\n\t// Setup client\n\topts := pclient.Opts{\n\t\tHTTPSCert:  cfg.HTTPSCert,\n\t\tCookies:    cfg.Cookies,\n\t\tHeaderCSRF: cfg.CSRF,\n\t\tVerbose:    cfg.Verbose,\n\t\tRawJSON:    cfg.RawJSON,\n\t}\n\tpc, err := pclient.New(cfg.Host, opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get comments\n\tcm := cmv1.Comments{\n\t\tToken: c.Args.Token,\n\t}\n\tcr, err := pc.Comments(cm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Print comments\n\tfor _, v := range cr.Comments {\n\t\tprintComment(v)\n\t\tprintf(\"\\n\")\n\t}\n\n\treturn nil\n}\n\n// commentsHelpMsg is printed to stdout by the help command.\nconst commentsHelpMsg = `comments \"token\" \n\nGet the comments for a record.\n\nIf the record is unvetted, the --unvetted flag must be used. Retrieving the\ncomments on an unvetted record requires the user be either an admin or the\nrecord author.\n\nArguments:\n1. token  (string, required)  Proposal censorship token\n`\n"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n)\n\ntype Customer struct {\n\tID     int\n\tName   string\n\tEmail  string\n\tStatus string\n}\n\nfunc main() {\n\tconnStr := \"postgres://postgres:password@localhost:5432/testdb?sslmode=disable\"\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// creating a new customer\n\tnewCust := Customer{\n\t\tName:   \"John Doe\",\n\t\tEmail:  \"johndoe@example.com\",\n\t\tStatus: \"active\",\n\t}\n\tquery := \"INSERT INTO customers (name, email, status) VALUES ($1, $2, $3) RETURNING id\"\n\tvar id int\n\terr = db.QueryRow(query, newCust.Name, newCust.Email, newCust.Status).Scan(&id)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"New customer created with ID: %d\", id)\n\n\t// updating an existing customer\n\tupdateQuery := \"UPDATE customers SET email=$1 WHERE id=$2\"\n\tres, err := db.Exec(updateQuery, \"newemail@example.com\", id)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\trowsAffected, err := res.RowsAffected()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Updated %d rows\", rowsAffected)\n\n\t// retrieving a customer\n\trow := db.QueryRow(\"SELECT id, name, email, status FROM customers WHERE id=$1\", id)\n\tvar customer Customer\n\terr = row.Scan(&customer.ID, &customer.Name, &customer.Email, &customer.Status)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(customer)\n}"}
{"sample": "func main() {\n\thttp.HandleFunc(\"/\", handleRoot)\n\thttp.HandleFunc(\"/users\", handleUsers)\n\thttp.HandleFunc(\"/products\", handleProducts)\n\thttp.HandleFunc(\"/items\", handleItems)\n\thttp.HandleFunc(\"/orders\", handleOrders)\n\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc handleRoot(w http.ResponseWriter, r *http.Request) {\n\t// Handle root endpoint\n\tfmt.Fprint(w, \"Hello, World!\")\n}\n\nfunc handleUsers(w http.ResponseWriter, r *http.Request) {\n\t// Handle users endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get users\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create user\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleProducts(w http.ResponseWriter, r *http.Request) {\n\t// Handle products endpoint\n\tswitch r.Method {\n\tcase \"GET\":\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get products\")\n\tcase \"POST\":\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create product\")\n\tdefault:\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleItems(w http.ResponseWriter, r *http.Request) {\n\t// Handle items endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get items\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create item\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleOrders(w http.ResponseWriter, r *http.Request) {\n\t// Handle orders endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get orders\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create order\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n"}
{"sample": "// HandleErrorGracefully logs the error and recovers from a panic\nfunc HandleErrorGracefully(err *error) {\n\tif r := recover(); r != nil {\n\t\tif err, ok := r.(error); ok {\n\t\t\t*err = err\n\t\t\tlog.Println(\"Recovered from panic with error:\", (*err).Error())\n\t\t}\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// SplitCSV splits a CSV string into a slice of fields.\nfunc SplitCSV(csv string) []string {\n\treader := csv.NewReader(strings.NewReader(csv))\n\tfields, err := reader.Read()\n\tif err != nil {\n\t\treturn nil\n\t}\n\treturn fields\n}\n\n// JoinCSV joins a slice of fields into a CSV string.\nfunc JoinCSV(fields []string) string {\n\tvar buf strings.Builder\n\twriter := csv.NewWriter(&buf)\n\twriter.Write(fields)\n\twriter.Flush()\n\treturn buf.String()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tvar num int\n\tnumStr := \"42\"\n\n\terr := strconv.UnmarshalText([]byte(numStr), &num)\n\tif err != nil {\n\t\tfmt.Println(\"Error unmarshaling text:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(num)\n}"}
{"sample": "package messages\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype content map[string]interface{}\n\nfunc init() {\n\thttp.HandleFunc(\"/json-example\", handler)\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tdecoder := json.NewDecoder(r.Body)\n\tvar c content\n\terr := decoder.Decode(&c)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprintf(w, \"Error decoding JSON: %+v\", err)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, \"Received JSON: %+v\\n\", c)\n\tw.WriteHeader(http.StatusOK)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(\"Starting up...\")\n\n\tdoneCh := make(chan bool, 1)\n\tsigCh := make(chan os.Signal, 1)\n\tsignal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\tsig := <-sigCh\n\t\tfmt.Printf(\"Signal received: %v. Shutting down...\\n\", sig)\n\t\tdoneCh <- true\n\t}()\n\n\t// Work to be done here\n\tfor i := 1; i <= 10; i++ {\n\t\tselect {\n\t\tcase <-doneCh:\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Printf(\"Working... (%d/10)\\n\", i)\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}\n\n\tfmt.Println(\"Finished working, shutting down\")\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--format\", argparse.String, \"json\", \"Output format\")\n"}
{"sample": "package argparser\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar name string\n\tvar age int\n\tvar married bool\n\n\tflag.StringVar(&name, \"name\", \"\", \"Name of the person\")\n\tflag.IntVar(&age, \"age\", 0, \"Age of the person\")\n\tflag.BoolVar(&married, \"married\", false, \"Marital status of the person\")\n\n\tflag.Parse()\n\n\tif name == \"\" {\n\t\tfmt.Println(\"Name is required\")\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Name: %s\\n\", name)\n\tfmt.Printf(\"Age: %d\\n\", age)\n\tfmt.Printf(\"Married: %t\\n\", married)\n}"}
{"sample": "package main\n\nfunc GetUniqueValues(arr []int) []int {\n\tunique := make(map[int]bool)\n\tresult := []int{}\n\tfor _, num := range arr {\n\t\tif !unique[num] {\n\t\t\tunique[num] = true\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\toptions := &redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t}\n\n\tclient := redis.NewClient(options)\n\n\tpingResult, err := client.Ping(context.Background()).Result()\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to Redis:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Connected to Redis. Ping result:\", pingResult)\n}"}
{"sample": "func DeleteFile(filename string) error {\n\treturn os.Remove(filename)\n}\n\nfunc RenameFile(oldName, newName string) error {\n\treturn os.Rename(oldName, newName)\n}\n\nfunc MoveFile(src, dst string) error {\n\treturn os.Rename(src, dst)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"ls\", \"-l\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tfmt.Println(\"Error running command:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(output))\n}"}
{"sample": "// FetchURL fetches the content of a URL.\nfunc FetchURL(url string) (string, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(body), nil\n}\n\n// DownloadFile downloads a file from a URL.\nfunc DownloadFile(url, filePath string) error {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tout, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\t_, err = io.Copy(out, resp.Body)\n\treturn err\n}"}
{"sample": "package queue\n\ntype CommittableMessage struct {\n\tid        int\n\tmessage   string\n\tcommitted bool\n}\n\ntype Consumer struct {\n\tidsCh   chan<- int\n\tmsgsCh  chan<- string\n\tackCh   <-chan int\n\tnackCh  <-chan int\n\tallSync <-chan struct{}\n}\n\nfunc WithCommitQueue(capacity int) (\n\tcommittable <-chan CommittableMessage,\n\tcommitted <-chan int,\n) {\n\t//allocate bufer go-channel of messages \n\tinQPc, outQPc := make(chan orcaMessageChannel, maxWorkers)\n\n\t}\n\n\t// buffer cache separately collected urls\n}).Unmarshal(hubbleWrite chan<- []db.LogLocations) error {\"capacity\"}\n\n}  \n\ncosalind is a python testcase automation network which involve third external symbolic imlems during construction\n\n// This better performances for also different trry == s*(kk*k+... would \ngetAcc http.Handle (\"/css/style.CSS>\", AccTheadLists(randFunctionVariable(pCacheDevID be.nProbBispDMURLTemplate(\"//iss\")) \"async\">)?=T0>) log.Fatalf(tnmeConn.Change.T[ut.Output])\r\nmore flexibility updates: session logs); optionally check such Py list funcs used\"\"\"dataGridView1\n\nsystem.runtime.* never stream info L/B streaming proces \n\nsin,sxn important 'killed')).month-Start \n                                 Hour-MM- */\nstrconv.FormatUint(id1 $gitchPorDDep.IPOrgase(code), trottlingNew)])/ last >= last\n\ntssk by alY2-alPL __ditso__\n},{\n\t-ipv The *.Code(hsrphHdrURL)(invalid 'kd')\nretry.Errors.Header \"poflesClck(xlPacketParts (sensor):\n\thttp Log messageid.Clien*/\n}));\n\nandresP hmap.http.RequireType(typeof(is the tracne durubg pm2 depende*/) -sorted edgeFormaterErrArr.Handle(func()\n})webElementX"}
{"sample": "err = os.Mkdir(\"newdir\", 0755)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(\"Starting the program...\")\n\tgo printMessage(\"Hello\")\n\tgo printMessage(\"World\")\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"Program ended\")\n}\n\nfunc printMessage(message string) {\n\tfor i := 1; i <= 5; i++ {\n\t\tfmt.Println(message)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/hashicorp/raft\"\n)\n\ntype myFSM struct {\n\tmu      sync.Mutex\n\tstorage map[string]string\n}\n\nfunc (fsm *myFSM) apply(logEntry *raft.Log) interface{} {\n\tvar cmd KVCommand\n\terr := cmd.Decode(logEntry.Data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfsm.mu.Lock()\n\tdefer fsm.mu.Unlock()\n\n\tswitch cmd.Op {\n\tcase OpSet:\n\t\tfsm.storage[cmd.Key] = cmd.Value\n\tcase OpDelete:\n\t\tdelete(fsm.storage, cmd.Key)\n\t}\n\n\treturn nil\n}\n\nfunc (fsm *myFSM) snapshot() (raft.FSMSnapshot, error) {\n\tfsm.mu.Lock()\n\tdefer fsm.mu.Unlock()\n\n\tstorage := make(map[string]string, len(fsm.storage))\n\tfor k, v := range fsm.storage {\n\t\tstorage[k] = v\n\t}\n\n\treturn &mySnapshot{storage: storage}, nil\n}\n\nfunc (fsm *myFSM) restore(snap io.ReadCloser) error {\n\tsnapshot := &mySnapshot{}\n\terr := snapshot.Decode(snap)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfsm.mu.Lock()\n\tdefer fsm.mu.Unlock()\n\tfsm.storage = snapshot.storage\n\n\treturn nil\n}\n\nfunc main() {\n\tfsm := &myFSM{storage: make(map[string]string)}\n\tconfig := raft.DefaultConfig()\n\tconfig.LocalID = raft.ServerID(\"node1\")\n\tconfig.Logger = log.New(os.Stderr, \"[raft]\", log.LstdFlags)\n\tconfig.SnapshotThreshold = 1000\n\n\ttrans, err := raft.NewTCPTransport(\"127.0.0.1:0\", nil, 3, time.Second, config.Logger)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tpeerStore := raft.NewJSONPeers(\"peers.json\", trans)\n\tsnapshotStore, err := raft.NewFileSnapshotStore(\"snapshots\", 1, config.Logger)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\traftInstance, err := raft.NewRaft(config, fsm, raft.NewInmemStore(), raft.NewInmemStore(), snapshotStore, peerStore, trans)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// join to leader\n\terr = raftInstance.BootstrapCluster(raft.Configuration{\n\t\tServers: []raft.Server{\n\t\t\t{\n\t\t\t\tID:      config.LocalID,\n\t\t\t\tAddress: trans.LocalAddr(),\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// start gRPC server\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", 8080))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tkv.RegisterKVServiceServer(s, &kvServer{raftInstance})\n\tgo func() {\n\t\tif err := s.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\t// start command line interface\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tfmt.Println(\"Enter command:\")\n\t\t\t\tfmt.Println(\"1. set key value\")\n\t\t\t\tfmt.Println(\"2. get key\")\n\t\t\t\tfmt.Println(\"3. delete key\")\n\t\t\t\tfmt.Println(\"4. exit\")\n\t\t\t\tvar cmd int\n\t\t\t\tfmt.Scanln(&cmd)\n\t\t\t\tswitch cmd {\n\t\t\t\tcase 1:\n\t\t\t\t\tfmt.Print(\"Enter key: \")\n\t\t\t\t\tvar key string\n\t\t\t\t\tfmt.Scanln(&key)\n\t\t\t\t\tfmt.Print(\"Enter value: \")\n\t\t\t\t\tvar value string\n\t\t\t\t\tfmt.Scanln(&value)\n\t\t\t\t\tdata, err := json.Marshal(KVCommand{Op: OpSet, Key: key, Value: value})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t_, err = raftInstance.Apply(data, 5*time.Second)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t}\n\t\t\t\tcase 2:\n\t\t\t\t\tfmt.Print(\"Enter key: \")\n\t\t\t\t\tvar key string\n\t\t\t\t\tfmt.Scanln(&key)\n\t\t\t\t\tdata, err := json.Marshal(KVCommand{Op: OpGet, Key: key})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tfuture := raftInstance.Apply(data, 5*time.Second)\n\t\t\t\t\tif err := future.Error(); err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif future.Response() == nil {\n\t\t\t\t\t\tfmt.Println(\"Not found\")\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tcmd := future.Response().(KVCommand)\n\t\t\t\t\tfmt.Printf(\"%s=%s\\n\", cmd.Key, cmd.Value)\n\t\t\t\tcase 3:\n\t\t\t\t\tfmt.Print(\"Enter key: \")\n\t\t\t\t\tvar key string\n\t\t\t\t\tfmt.Scanln(&key)\n\t\t\t\t\tdata, err := json.Marshal(KVCommand{Op: OpDelete, Key: key})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t_, err = raftInstance.Apply(data, 5*time.Second)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t}\n\t\t\t\tcase 4:\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// wait until canceled\n\t<-ctx.Done()\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintPerimeterOfSquare(5)\n}\n\n// Function to print the perimeter of a square\nfunc PrintPerimeterOfSquare(side float64) {\n\tfmt.Println(4 * side)\n}"}
{"sample": "func main() {\n\tdata := [][]string{{\"Name\", \"Age\"} {\"John Doe\", \"30\"} {\"Jane Smith\", \"25\"}}\n\n\tfile, err := os.Create(\"data.csv\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\tdefer writer.Flush()\n\n\tfor _, record := range data {\n\t\twriter.Write(record)\n\t}\n\n\tfmt.Println(\"Data written to CSV file\")\n}"}
{"sample": "func ReadFileLineByLine(filename string) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tfmt.Println(scanner.Text())\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"sample": "package auth\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\ntype User struct {\n\tID       int64\n\tUsername string\n\tPassword string\n}\n\ntype Auth struct {\n\tSigningKey []byte\n}\n\nfunc (a *Auth) GenerateToken(user *User) (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"exp\": time.Now().Add(time.Hour * 24).Unix(),\n\t\t\"iat\": time.Now().Unix(),\n\t\t\"sub\": user.ID,\n\t})\n\n\ttokenString, err := token.SignedString(a.SigningKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn tokenString, nil\n}\n\nfunc (a *Auth) ValidateToken(tokenString string) (*User, error) {\n\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, errors.New(\"invalid token\")\n\t\t}\n\n\t\treturn a.SigningKey, nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n\t\tif userID, ok := claims[\"sub\"].(float64); ok {\n\t\t\treturn &User{ID: int64(userID)}, nil\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"invalid token\")\n}"}
{"sample": "// PrintErrorAndExit prints the error and exits the program\nfunc PrintErrorAndExit(err error) {\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package snmpclient\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/gosnmp/gosnmp\"\n)\n\nfunc getSNMP() {\n\tparams := &gosnmp.GoSNMP{\n\t\tTarget:    \"localhost\",\n\t\tPort:      161,\n\t\tCommunity: \"public\",\n\t\tVersion:   gosnmp.Version2c,\n\t\tTimeout:   time.Duration(2) * time.Second,\n\t\tMaxOids:   gosnmp.MaxOids,\n\t}\n\n\terr := params.Connect()\n\tif err != nil {\n\t\tlog.Fatalf(\"Connect err: %v\", err)\n\t}\n\tdefer params.Conn.Close()\n\n\tresult, err := params.Get([]string{\".1.3.6.1.2.1.1.1.0\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"Get err: %v\", err)\n\t}\n\n\tfor _, variable := range result.Variables {\n\t\tswitch variable.Type {\n\t\tcase gosnmp.OctetString:\n\t\t\tfmt.Printf(\"Response: %s : %s \\n\", variable.Name, string(variable.Value.([]byte)))\n\t\tdefault:\n\t\t\tfmt.Printf(\"Response: %s : %d \\n\", variable.Name, gosnmp.ToBigInt(variable.Value))\n\t\t}\n\t}\n}\n\nfunc listenSNMP() {\n\tconn, err := net.ListenPacket(\"udp\", \"127.0.0.1:162\")\n\tif err != nil {\n\t\tlog.Fatalf(\"ListenPacket err: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tbuf := make([]byte, 1024)\n\t\tn, addr, err := conn.ReadFrom(buf)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"ReadFrom err: %v\", err)\n\t\t}\n\n\t\tfmt.Printf(\"Received: %s from %s\\n\", buf[:n], addr)\n\t}\n}"}
{"sample": "type Node struct {\n\tData int\n\tNext *Node\n}\n\ntype LinkedList struct {\n\tHead *Node\n}\n\nfunc (l *LinkedList) InsertFirst(data int) {\n\tl.Head = &Node{Data: data, Next: l.Head}\n}\n\nfunc (l *LinkedList) RemoveFirst() {\n\tif l.Head != nil {\n\t\tl.Head = l.Head.Next\n\t}\n}"}
{"sample": "package main\n\nfunc main() {\n\tfmt.Println(GetGreatest(4, 7, 2))\n}\n\nfunc GetGreatest(nums ...int) int {\n\tgreatest := nums[0]\n\tfor _, num := range nums {\n\t\tif num > greatest {\n\t\t\tgreatest = num\n\t\t}\n\t}\n\treturn greatest\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintMinOfArray([]int{1, 2, 3, 4, 5})\n}\n\n// Function to print the minimum element in an array\nfunc PrintMinOfArray(arr []int) {\n\tmin := arr[0]\n\tfor _, value := range arr {\n\t\tif value < min {\n\t\t\tmin = value\n\t\t}\n\t}\n\tfmt.Println(min)\n}"}
{"sample": "// Iterating over a slice\n\nslice := []int{1, 2, 3, 4, 5}\nfor _, value := range slice {\n\tfmt.Println(value)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-chi/chi\"\n)\n\nfunc UseChi() {\n\trouter := chi.NewRouter()\n\n\trouter.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, Chi!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", router)\n}\n"}
{"sample": "var ErrInvalidInput = errors.New(\"invalid input\")\n"}
{"sample": "package json2xml\n\nimport (\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\ntype Person struct {\n\tName     string `json:\"name\" xml:\"name\"`\n\tAge      int    `json:\"age\" xml:\"age\"`\n\tLocation string `json:\"location\" xml:\"location\"`\n}\n\nfunc Convert(jsonFileName string, xmlFileName string) error {\n\tjsonFile, err := ioutil.ReadFile(jsonFileName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read json file: %v\", err)\n\t}\n\n\tvar person Person\n\tif err := json.Unmarshal(jsonFile, &person); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal json: %v\", err)\n\t}\n\n\txmlPerson, err := xml.MarshalIndent(person, \"\", \"  \")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal to xml: %v\", err)\n\t}\n\n\tif err := ioutil.WriteFile(xmlFileName, xmlPerson, 0644); err != nil {\n\t\treturn fmt.Errorf(\"failed to write to xml file: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tif err := Convert(\"person.json\", \"person.xml\"); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\ntype Book struct {\n\tID    int    `db:\"id\"`\n\tTitle string `db: \"title\"`\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"sqlite3\", \"./library.db\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT id, title FROM books ORDER BY title ASC\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdefer rows.Close()\n\n\tvar books []Book\n\n\tfor rows.Next() {\n\t\tvar book Book\n\t\tif err := rows.Scan(&book.ID, &book.Title); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tbooks = append(books, book)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, book := range books {\n\t\tfmt.Printf(\"%d - %s\\n\", book.ID, book.Title)\n\t}\n}"}
{"sample": "func ExecuteSQLQuery(db *sql.DB, query string, args ...interface{}) (*sql.Rows, error) {\n\treturn db.Query(query, args...)\n}\n\nfunc ExecuteSQLStatement(db *sql.DB, stmt string, args ...interface{}) (sql.Result, error) {\n\treturn db.Exec(stmt, args...)\n}\n\nfunc CloseDB(db *sql.DB) error {\n\treturn db.Close()\n}"}
{"sample": "func main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar nums []int\n\n\tfor i := 0; i < 5; i++ {\n\t\tnum := rand.Intn(100)\n\t\tnums = append(nums, num)\n\t}\n\n\tfmt.Println(nums)\n}"}
{"sample": "package main\n\n// Open file in append mode and write to it\nfunc main() {\n\tfile, err := os.OpenFile(\"file.txt\", os.O_APPEND|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\t_, err = file.Write([]byte(\"Appending text\\n\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package main\n\n// HandleErrAndExit handles an error and exits\nfunc HandleErrAndExit(err error, exitCode int) {\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tos.Exit(exitCode)\n\t}\n}\n"}
{"sample": "func main() {\n\tvar wg sync.WaitGroup\n\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine 1 executed\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(3 * time.Second)\n\t\tfmt.Println(\"Goroutine 2 executed\")\n\t}()\n\n\twg.Wait()\n}"}
{"sample": "// Enable secure HTTPS server with TLS certificate and key\nfunc EnableTLS(server *http.Server, certFile, keyFile string) error {\n\treturn server.ListenAndServeTLS(certFile, keyFile)\n}\n"}
{"sample": "type Job interface {\n\tProcess() error\n}\n\ntype Worker struct {\n\tJobQueue chan Job\n}\n\nfunc NewWorker() *Worker {\n\treturn &Worker{JobQueue: make(chan Job)}\n}\n\nfunc (w *Worker) Start() {\n\tgo func() {\n\t\tfor job := range w.JobQueue {\n\t\t\tif err := job.Process(); err != nil {\n\t\t\t\tlog.Printf(\"Error processing job: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n}"}
{"sample": "func main() {\n\thttp.HandleFunc(\"/\", handleRoot)\n\thttp.HandleFunc(\"/users\", handleUsers)\n\thttp.HandleFunc(\"/products\", handleProducts)\n\thttp.HandleFunc(\"/items\", handleItems)\n\thttp.HandleFunc(\"/orders\", handleOrders)\n\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc handleRoot(w http.ResponseWriter, r *http.Request) {\n\t// Handle root endpoint\n\tfmt.Fprint(w, \"Hello, World!\")\n}\n\nfunc handleUsers(w http.ResponseWriter, r *http.Request) {\n\t// Handle users endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get users\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create user\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleProducts(w http.ResponseWriter, r *http.Request) {\n\t// Handle products endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get products\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create product\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleItems(w http.ResponseWriter, r *http.Request) {\n\t// Handle items endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get items\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create item\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc handleOrders(w http.ResponseWriter, r *http.Request) {\n\t// Handle orders endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get orders\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create order\")\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n"}
{"sample": "users := make(map[string]string)\n"}
{"sample": "package logstash\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\n// LogstashClient is a client for sending logs to Logstash.\ntype LogstashClient struct {\n\tconn net.Conn\n}\n\n// NewLogstashClient creates a new Logstash client.\nfunc NewLogstashClient(host string, port int) (*LogstashClient, error) {\n\tconn, err := net.DialTimeout(\"tcp\", fmt.Sprintf(\"%s:%d\", host, port), 5*time.Second)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &LogstashClient{conn: conn}, nil\n}\n\n// Send sends a log message to Logstash.\nfunc (c *LogstashClient) Send(timestamp time.Time, message string, fields map[string]interface{}) error {\n\tevent := make(map[string]interface{})\n\tevent[\"@timestamp\"] = timestamp.UTC().Format(\"2006-01-02T15:04:05.999Z\")\n\tevent[\"@message\"] = message\n\n\tfor k, v := range fields {\n\t\tevent[strings.ToLower(k)] = v\n\t}\n\n\tbytes, err := json.Marshal(event)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.conn.Write(bytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Close closes the connection to Logstash.\nfunc (c *LogstashClient) Close() {\n\tc.conn.Close()\n\tlog.Println(\"Connection to Logstash closed\")\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\ntype Calculator struct {\n\tResult float64\n}\n\nfunc (c *Calculator) Add(numbers ...float64) {\n\tfor _, n := range numbers {\n\t\tc.Result += n\n\t}\n}\n\nfunc (c *Calculator) Subtract(numbers ...float64) {\n\tfor _, n := range numbers {\n\t\tc.Result -= n\n\t}\n}\n\nfunc (c *Calculator) Multiply(numbers ...float64) {\n\tfor _, n := range numbers {\n\t\tc.Result *= n\n\t}\n}\n\nfunc (c *Calculator) Divide(numbers ...float64) error {\n\tzero := 0.0\n\tfor _, n := range numbers {\n\t\tif n == zero {\n\t\t\treturn fmt.Errorf(\"Cannot divide by 0\")\n\t\t}\n\t\tc.Result /= n\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tmyCalc := Calculator{}\n\n\tmyCalc.Add(5, 2, 3)        // Returns 10\n\tmyCalc.Subtract(5, 2, 3)   // Returns 0\n\tmyCalc.Multiply(5, 2, 3)   // Returns 30\n\tmyCalc.Divide(2, 5, 1.5)   // Returns 2\n\tmyCalc.Divide(4, 0, 1.2)   // Returns error message\n\tfmt.Println(myCalc.Result) // Should return 2\n}"}
{"sample": "func main() {\n\tquit := make(chan os.Signal)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-quit\n\t\tfmt.Println(\"Received termination signal\")\n\t\tos.Exit(0)\n\t}()\n\n\tfmt.Println(\"Waiting for termination signal\")\n\tselect {}\n}"}
{"sample": "func insertUser(db *sql.DB, id int, name string) error {\n\tstmt, err := db.Prepare(\"INSERT INTO users (id, name) VALUES ($1, $2)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(id, name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "f, err := os.CreateTemp(\"\", \"temp*\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer os.Remove(f.Name())\nfmt.Println(\"Temp file name:\", f.Name())\n"}
{"sample": "package logging\n\nimport (\n\t\"context\"\n\tv1 \"github.com/ClessLi/bifrost/api/bifrost/v1\"\n\tsvcv1 \"github.com/ClessLi/bifrost/internal/bifrost/service/v1\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype loggingWebServerConfigService struct {\n\tsvc svcv1.WebServerConfigService\n}\n\nfunc (l loggingWebServerConfigService) GetServerNames(ctx context.Context) (servernames *v1.ServerNames, err error) {\n\tdefer func(begin time.Time) {\n\t\tlogF := newLogFormatter(ctx, l.svc.GetServerNames)\n\t\tlogF.SetBeginTime(begin)\n\t\tdefer logF.Result()\n\t\tif servernames != nil {\n\t\t\tvar result []string\n\t\t\tfor _, serverName := range *servernames {\n\t\t\t\tresult = append(result, serverName.Name)\n\t\t\t}\n\t\t\tlogF.SetResult(\"ServerNames: \" + strings.Join(result, \", \"))\n\t\t}\n\t\tlogF.SetErr(err)\n\t}(time.Now().Local())\n\treturn l.svc.GetServerNames(ctx)\n}\n\nfunc (l loggingWebServerConfigService) Get(ctx context.Context, servername *v1.ServerName) (wsc *v1.WebServerConfig, err error) {\n\tdefer func(begin time.Time) {\n\t\tlogF := newLogFormatter(ctx, l.svc.Get)\n\t\tlogF.SetBeginTime(begin)\n\t\tdefer logF.Result()\n\t\tlogF.AddInfos(\n\t\t\t\"request server name\", servername.Name,\n\t\t)\n\t\tif wsc != nil {\n\t\t\tlogF.SetResult(getLimitResult(wsc.JsonData))\n\t\t}\n\t\tlogF.SetErr(err)\n\t}(time.Now().Local())\n\treturn l.svc.Get(ctx, servername)\n}\n\nfunc (l loggingWebServerConfigService) Update(ctx context.Context, config *v1.WebServerConfig) (err error) {\n\tdefer func(begin time.Time) {\n\t\tlogF := newLogFormatter(ctx, l.svc.Update)\n\t\tlogF.SetBeginTime(begin)\n\t\tdefer logF.Result()\n\t\tlogF.AddInfos(\n\t\t\t\"request server name\", config.ServerName.Name,\n\t\t)\n\t\tif err == nil {\n\t\t\tlogF.SetResult(\"update web server config succeeded\")\n\t\t}\n\t\tlogF.SetErr(err)\n\t}(time.Now().Local())\n\treturn l.svc.Update(ctx, config)\n}\n\nfunc newWebServerConfigMiddleware(svc svcv1.ServiceFactory) svcv1.WebServerConfigService {\n\treturn &loggingWebServerConfigService{svc: svc.WebServerConfig()}\n}\n"}
{"sample": "http.HandleFunc(\"/items\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle items endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get items\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create item\")\n\t}\n})\n"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--config\", argparse.String, \"config.yaml\", \"Config file\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 4, \"Number of threads\")\nparser.AddArgument(\"--max-iter\", argparse.Int, 1000, \"Maximum number of iterations\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--batch-size\", argparse.Int, 16, \"Batch size\")\nparser.AddArgument(\"--mode\", argparse.String, \"default\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\nparser.AddArgument(\"--debug\", argparse.Bool, false, \"Enable debug mode\")\nparser.AddArgument(\"--gpu\", argparse.Bool, true, \"Enable GPU usage\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 8, \"Number of threads\")\nparser.AddArgument(\"--log-file\", argparse.String, \"log.txt\", \"Log file\")\nparser.AddArgument(\"--timeout\", argparse.Duration, 5*time.Minute, \"Timeout duration\")\n"}
{"sample": "file, err := os.Open(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\n"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc worker(ctx context.Context) {\n\tfor {\n\t\tselect {\n\t\tdefault:\n\t\t\tfmt.Println(\"doing some work...\")\n\t\t\ttime.Sleep(time.Millisecond * 500)\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(\"gracefully shutting down\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Second * 3)\n\t\tcancel()\n\t}()\n\n\tworker(ctx)\n\n\tselect {\n\tcase <-time.After(time.Second * 5):\n\t\tfmt.Println(\"finished\")\n\t}\n}"}
{"sample": "package helpers\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// APIResponse is a helper struct to parse JSON responses from APIs\ntype APIResponse struct {\n\tStatusCode int             `json:\"-\"`\n\tBody       json.RawMessage `json:\"body\"`\n}\n\n// SendAPIRequest sends an HTTP request to an API and returns the response as a byte slice\nfunc SendAPIRequest(method, url string, headers map[string]string, body []byte) ([]byte, error) {\n\tclient := &http.Client{Timeout: 10 * time.Second}\n\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor key, value := range headers {\n\t\treq.Header.Set(key, value)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Body.Close()\n\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode >= 400 {\n\t\treturn nil, errors.New(string(respBody))\n\t}\n\n\treturn respBody, nil\n}"}
{"sample": "package main\n\n// WrapError wraps an error with another error\nfunc WrapError(err error, wrapErr error) error {\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%w\", wrapErr)\n\t}\n\treturn nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\toptions := &redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t}\n\n\tclient := redis.NewClient(options)\n\n\tpingResult, err := client.Ping(context.Background()).Result()\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to Redis:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Connected to Redis. Ping result:\", pingResult)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"database/sql\"\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\nfunc main() {\n\tdb, err := sql.Open(\"sqlite3\", \"mydb.db\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to SQLite:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating table:\", err)\n\t\treturn\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (name) VALUES ('John Doe')\")\n\tif err != nil {\n\t\tfmt.Println(\"Error inserting into table:\", err)\n\t\treturn\n\t}\n\n\trows, err := db.Query(\"SELECT id, name FROM users\")\n\tif err != nil {\n\t\tfmt.Println(\"Error querying table:\", err)\n\t\treturn\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\terr = rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error scanning row:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Println(id, name)\n\t}\n}"}
{"sample": "func CreateZipFile(outputFile string, inputFiles []string) error {\n\tzipFile, err := os.Create(outputFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zipFile.Close()\n\n\tzipWriter := zip.NewWriter(zipFile)\n\tdefer zipWriter.Close()\n\n\tfor _, file := range inputFiles {\n\t\tf, err := os.Open(file)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\n\t\tinfo, err := f.Stat()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\theader, err := zip.FileInfoHeader(info)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\theader.Method = zip.Deflate\n\n\t\twriter, err := zipWriter.CreateHeader(header)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = io.Copy(writer, f)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}"}
{"sample": "db, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/mydb\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to MySQL:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE IF NOT EXISTS users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255))\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating table:\", err)\n\t\treturn\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (name) VALUES ('John Doe')\")\n\tif err != nil {\n\t\tfmt.Println(\"Error inserting into table:\", err)\n\t\treturn\n\t}\n\n\trows, err := db.Query(\"SELECT id, name FROM users\")\n\tif err != nil {\n\t\tfmt.Println(\"Error querying table:\", err)\n\t\treturn\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\terr = rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error scanning row:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Println(id, name)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/go-chi/chi\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := chi.NewRouter()\n\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Welcome to the home page\")\n\t})\n\n\tr.Get(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"List of users\")\n\t})\n\n\tr.Get(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := chi.URLParam(r, \"id\")\n\t\tfmt.Fprintf(w, \"Get user with ID: %s\", id)\n\t})\n\n\thttp.ListenAndServe(\":8080\", r)\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "func rollbackTransaction(tx *sql.Tx) error {\n\terr := tx.Rollback()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package main\n\nfunc AddTwoNumbers(a, b int) int {\n\treturn a + b\n}\n"}
{"sample": "package sha3hash\n\nimport (\n\t\"crypto/sha3\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc ComputeSHA3Hash(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := sha3.New256()\n\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(\"%x\", hash.Sum(nil)), nil\n}"}
{"sample": "package shellsort\n\nfunc ShellSort(arr []int) {\n\tn := len(arr)\n\tgap := n / 2\n\n\tfor gap > 0 {\n\t\tfor i := gap; i < n; i++ {\n\t\t\ttemp := arr[i]\n\t\t\tj := i\n\n\t\t\tfor j >= gap && arr[j-gap] > temp {\n\t\t\t\tarr[j] = arr[j-gap]\n\t\t\t\tj -= gap\n\t\t\t}\n\n\t\t\tarr[j] = temp\n\t\t}\n\n\t\tgap /= 2\n\t}\n}"}
{"sample": "package pop3client\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"net/textproto\"\n)\n\nfunc receiveMail() ([]string, error) {\n\tconn, err := net.Dial(\"tcp\", \"mail.example.com:110\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\ttp := textproto.NewConn(conn)\n\n\t_, err = tp.ReadLine()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := tp.PrintfLine(\"USER username\"); err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tp.ReadLine()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := tp.PrintfLine(\"PASS password\"); err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tp.ReadLine()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := tp.PrintfLine(\"LIST\"); err != nil {\n\t\treturn nil, err\n\t}\n\n\tlines, err := tp.ReadDotLines()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn lines, nil\n}\n\nfunc main() {\n\tmails, err := receiveMail()\n\tif err != nil {\n\t\tfmt.Println(\"Error receiving mail:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Received mails:\")\n\tfor _, mail := range mails {\n\t\tfmt.Println(mail)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// SortInts sorts a slice of integers in ascending order.\nfunc SortInts(nums []int) {\n\tsort.Ints(nums)\n}"}
{"sample": "package gziputil\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\n// Compress takes a filename, reads its contents, compresses them, and returns the resulting gzip file contents as a []byte.\nfunc Compress(filename string) ([]byte, error) {\n\tcontents, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf bytes.Buffer\n\tzw := gzip.NewWriter(&buf)\n\tdefer zw.Close()\n\n\tif _, err := zw.Write(contents); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buf.Bytes(), nil\n}\n\n// Decompress takes a gzip file name, reads its contents and decompresses them, and returns the resulting file contents as a []byte.\nfunc Decompress(gzipfile string) ([]byte, error) {\n\tfd, err := os.Open(gzipfile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer fd.Close()\n\n\tzr, err := gzip.NewReader(fd)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tvar buf bytes.Buffer\n\tif _, err := io.Copy(&buf, zr); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := zr.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buf.Bytes(), nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// IsEven checks if a number is even and returns true if it is.\nfunc IsEven(num int) bool {\n\treturn num%2 == 0\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// ReadCSVFile reads a CSV file and returns its content as a slice of records.\nfunc ReadCSVFile(filePath string) ([][]string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\trecords, err := reader.ReadAll()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn records, nil\n}\n\n// WriteCSVFile writes a slice of records to a CSV file.\nfunc WriteCSVFile(filePath string, records [][]string) error {\n\tfile, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\terr = writer.WriteAll(records)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twriter.Flush()\n\treturn writer.Error()\n}"}
{"sample": "package main\n\n// Change the mode of a file\nfunc main() {\n\terr := os.Chmod(\"file.txt\", 0644)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "var ErrNotFound = errors.New(\"not found\")\n"}
{"sample": "// Using append to add to a slice\n\nslice := []int{1, 2, 3}\nslice = append(slice, 4)\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/smtp\"\n)\n\nfunc main() {\n\tfrom := \"sender@example.com\"\n\tpassword := \"password\"\n\tto := \"recipient@example.com\"\n\n\tmsg := []byte(\"Subject: Hello\\n\\nThis is the email body.\")\n\n\tauth := smtp.PlainAuth(\"\", from, password, \"smtp.example.com\")\n\terr := smtp.SendMail(\"smtp.example.com:587\", auth, from, []string{to} msg)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending email:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Email sent successfully\")\n}"}
{"sample": "http.HandleFunc(\"/books\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle books endpoint\n\tswitch r.Method {\n\tcase \"GET\":\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get books\")\n\tcase \"POST\":\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create book\")\n\t}\n})\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\trand.Seed(time.Now().UnixNano())\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tsleepTime := rand.Intn(1000)\n\t\t\ttime.Sleep(time.Duration(sleepTime) * time.Millisecond)\n\t\t\tfmt.Printf(\"Goroutine %d slept for %dms\\n\", id, sleepTime)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package config\n\nimport (\n\t\"os\"\n\t\"strconv\"\n)\n\ntype Config struct {\n\tPort        int\n\tDatabaseURL string\n}\n\nfunc LoadConfig() (*Config, error) {\n\tport, err := strconv.Atoi(os.Getenv(\"PORT\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdbURL := os.Getenv(\"DATABASE_URL\")\n\n\treturn &Config{\n\t\tPort:        port,\n\t\tDatabaseURL: dbURL,\n\t}, nil\n}"}
{"sample": "package sha256hash\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc ComputeSHA256Hash(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := sha256.New()\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintTableOfNumber(5)\n}\n\n// Function to print the multiplication table of a number\nfunc PrintTableOfNumber(n int) {\n\tfor i := 1; i <= 10; i++ {\n\t\tfmt.Printf(\"%d * %d = %d\\n\", n, i, n*i)\n\t}\n}"}
{"sample": "/*\nCopyright 2018 The Knative Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage v1alpha1\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"time\"\n\n\tbuild \"github.com/knative/build/pkg/apis/build/v1alpha1\"\n\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\n\t\"github.com/knative/pkg/apis\"\n)\n\n// +genclient\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// Configuration represents the \"floating HEAD\" of a linear history of Revisions,\n// and optionally how the containers those revisions reference are built.\n// Users create new Revisions by updating the Configuration's spec.\n// The \"latest created\" revision's name is available under status, as is the\n// \"latest ready\" revision's name.\n// See also: https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration\ntype Configuration struct {\n\tmetav1.TypeMeta `json:\",inline\"`\n\t// +optional\n\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n\t// Spec holds the desired state of the Configuration (from the client).\n\t// +optional\n\tSpec ConfigurationSpec `json:\"spec,omitempty\"`\n\n\t// Status communicates the observed state of the Configuration (from the controller).\n\t// +optional\n\tStatus ConfigurationStatus `json:\"status,omitempty\"`\n}\n\n// Check that Configuration may be validated and defaulted.\nvar _ apis.Validatable = (*Configuration)(nil)\nvar _ apis.Defaultable = (*Configuration)(nil)\n\n// ConfigurationSpec holds the desired state of the Configuration (from the client).\ntype ConfigurationSpec struct {\n\t// TODO: Generation does not work correctly with CRD. They are scrubbed\n\t// by the APIserver (https://github.com/kubernetes/kubernetes/issues/58778)\n\t// So, we add Generation here. Once that gets fixed, remove this and use\n\t// ObjectMeta.Generation instead.\n\t// +optional\n\tGeneration int64 `json:\"generation,omitempty\"`\n\n\t// Build optionally holds the specification for the build to\n\t// perform to produce the Revision's container image.\n\t// +optional\n\tBuild *build.BuildSpec `json:\"build,omitempty\"`\n\n\t// RevisionTemplate holds the latest specification for the Revision to\n\t// be stamped out. If a Build specification is provided, then the\n\t// RevisionTemplate's BuildName field will be populated with the name of\n\t// the Build object created to produce the container for the Revision.\n\t// +optional\n\tRevisionTemplate RevisionTemplateSpec `json:\"revisionTemplate\"`\n}\n\n// ConfigurationConditionType is used to communicate the status of the reconciliation process.\n// See also: https://github.com/knative/serving/blob/master/docs/spec/errors.md#error-conditions-and-reporting\ntype ConfigurationConditionType string\n\nconst (\n\t// ConfigurationConditionReady is set when the configuration's latest\n\t// underlying revision has reported readiness.\n\tConfigurationConditionReady ConfigurationConditionType = \"Ready\"\n)\n\ntype ConfigurationConditionSlice []ConfigurationCondition\n\n// Len implements sort.Interface\nfunc (ccs ConfigurationConditionSlice) Len() int {\n\treturn len(ccs)\n}\n\n// Less implements sort.Interface\nfunc (ccs ConfigurationConditionSlice) Less(i, j int) bool {\n\treturn ccs[i].Type < ccs[j].Type\n}\n\n// Swap implements sort.Interface\nfunc (ccs ConfigurationConditionSlice) Swap(i, j int) {\n\tccs[i], ccs[j] = ccs[j], ccs[i]\n}\n\nvar _ sort.Interface = (ConfigurationConditionSlice)(nil)\n\n// ConfigurationCondition defines a readiness condition for a Configuration.\n// See: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#typical-status-properties\ntype ConfigurationCondition struct {\n\tType ConfigurationConditionType `json:\"type\" description:\"type of Configuration condition\"`\n\n\tStatus corev1.ConditionStatus `json:\"status\" description:\"status of the condition, one of True, False, Unknown\"`\n\n\t// +optional\n\t// We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic\n\t// differences (all other things held constant).\n\tLastTransitionTime VolatileTime `json:\"lastTransitionTime,omitempty\" description:\"last time the condition transit from one status to another\"`\n\n\t// +optional\n\tReason string `json:\"reason,omitempty\" description:\"one-word CamelCase reason for the condition's last transition\"`\n\n\t// +optional\n\tMessage string `json:\"message,omitempty\" description:\"human-readable message indicating details about last transition\"`\n}\n\n// ConfigurationStatus communicates the observed state of the Configuration (from the controller).\ntype ConfigurationStatus struct {\n\t// Conditions communicates information about ongoing/complete\n\t// reconciliation processes that bring the \"spec\" inline with the observed\n\t// state of the world.\n\t// +optional\n\tConditions ConfigurationConditionSlice `json:\"conditions,omitempty\"`\n\n\t// LatestReadyRevisionName holds the name of the latest Revision stamped out\n\t// from this Configuration that has had its \"Ready\" condition become \"True\".\n\t// +optional\n\tLatestReadyRevisionName string `json:\"latestReadyRevisionName,omitempty\"`\n\n\t// LatestCreatedRevisionName is the last revision that was created from this\n\t// Configuration. It might not be ready yet, for that use LatestReadyRevisionName.\n\t// +optional\n\tLatestCreatedRevisionName string `json:\"latestCreatedRevisionName,omitempty\"`\n\n\t// ObservedGeneration is the 'Generation' of the Configuration that\n\t// was last processed by the controller. The observed generation is updated\n\t// even if the controller failed to process the spec and create the Revision.\n\t// +optional\n\tObservedGeneration int64 `json:\"observedGeneration,omitempty\"`\n}\n\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// ConfigurationList is a list of Configuration resources\ntype ConfigurationList struct {\n\tmetav1.TypeMeta `json:\",inline\"`\n\tmetav1.ListMeta `json:\"metadata\"`\n\n\tItems []Configuration `json:\"items\"`\n}\n\nfunc (r *Configuration) GetGeneration() int64 {\n\treturn r.Spec.Generation\n}\n\nfunc (r *Configuration) SetGeneration(generation int64) {\n\tr.Spec.Generation = generation\n}\n\nfunc (r *Configuration) GetSpecJSON() ([]byte, error) {\n\treturn json.Marshal(r.Spec)\n}\n\n// IsReady looks at the conditions on the ConfigurationStatus.\n// ConfigurationConditionReady returns true if ConditionStatus is True\nfunc (cs *ConfigurationStatus) IsReady() bool {\n\tif c := cs.GetCondition(ConfigurationConditionReady); c != nil {\n\t\treturn c.Status == corev1.ConditionTrue\n\t}\n\treturn false\n}\n\n// IsLatestReadyRevisionNameUpToDate returns true if the Configuration is ready\n// and LatestCreateRevisionName is equal to LatestReadyRevisionName. Otherwise\n// it returns false.\nfunc (cs *ConfigurationStatus) IsLatestReadyRevisionNameUpToDate() bool {\n\treturn cs.IsReady() &&\n\t\tcs.LatestCreatedRevisionName == cs.LatestReadyRevisionName\n}\n\nfunc (config *ConfigurationStatus) GetCondition(t ConfigurationConditionType) *ConfigurationCondition {\n\tfor _, cond := range config.Conditions {\n\t\tif cond.Type == t {\n\t\t\treturn &cond\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (cs *ConfigurationStatus) setCondition(new *ConfigurationCondition) {\n\tif new == nil {\n\t\treturn\n\t}\n\tt := new.Type\n\tvar conditions ConfigurationConditionSlice\n\tfor _, cond := range cs.Conditions {\n\t\tif cond.Type != t {\n\t\t\tconditions = append(conditions, cond)\n\t\t} else {\n\t\t\t// If we'd only update the LastTransitionTime, then return.\n\t\t\tnew.LastTransitionTime = cond.LastTransitionTime\n\t\t\tif reflect.DeepEqual(new, &cond) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tnew.LastTransitionTime = VolatileTime{metav1.NewTime(time.Now())}\n\tconditions = append(conditions, *new)\n\tsort.Sort(conditions)\n\tcs.Conditions = conditions\n}\n\nfunc (cs *ConfigurationStatus) InitializeConditions() {\n\tfor _, cond := range []ConfigurationConditionType{\n\t\tConfigurationConditionReady,\n\t} {\n\t\tif rc := cs.GetCondition(cond); rc == nil {\n\t\t\tcs.setCondition(&ConfigurationCondition{\n\t\t\t\tType:   cond,\n\t\t\t\tStatus: corev1.ConditionUnknown,\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc (cs *ConfigurationStatus) SetLatestCreatedRevisionName(name string) {\n\tcs.LatestCreatedRevisionName = name\n\tif cs.LatestReadyRevisionName != name {\n\t\tcs.setCondition(&ConfigurationCondition{\n\t\t\tType:   ConfigurationConditionReady,\n\t\t\tStatus: corev1.ConditionUnknown,\n\t\t})\n\t}\n}\n\nfunc (cs *ConfigurationStatus) SetLatestReadyRevisionName(name string) {\n\tcs.LatestReadyRevisionName = name\n\tfor _, cond := range []ConfigurationConditionType{\n\t\tConfigurationConditionReady,\n\t} {\n\t\tcs.setCondition(&ConfigurationCondition{\n\t\t\tType:   cond,\n\t\t\tStatus: corev1.ConditionTrue,\n\t\t})\n\t}\n}\n\nfunc (cs *ConfigurationStatus) MarkLatestCreatedFailed(name, message string) {\n\tcct := []ConfigurationConditionType{ConfigurationConditionReady}\n\tif cs.LatestReadyRevisionName == \"\" {\n\t\tcct = append(cct, ConfigurationConditionReady)\n\t}\n\tfor _, cond := range cct {\n\t\tcs.setCondition(&ConfigurationCondition{\n\t\t\tType:    cond,\n\t\t\tStatus:  corev1.ConditionFalse,\n\t\t\tReason:  \"RevisionFailed\",\n\t\t\tMessage: fmt.Sprintf(\"Revision %q failed with message: %q.\", name, message),\n\t\t})\n\t}\n}\n\nfunc (cs *ConfigurationStatus) MarkRevisionCreationFailed(message string) {\n\tcs.setCondition(&ConfigurationCondition{\n\t\tType:    ConfigurationConditionReady,\n\t\tStatus:  corev1.ConditionFalse,\n\t\tReason:  \"RevisionFailed\",\n\t\tMessage: fmt.Sprintf(\"Revision creation failed with message: %q.\", message),\n\t})\n}\n\nfunc (cs *ConfigurationStatus) MarkLatestReadyDeleted() {\n\tcct := []ConfigurationConditionType{ConfigurationConditionReady}\n\tfor _, cond := range cct {\n\t\tcs.setCondition(&ConfigurationCondition{\n\t\t\tType:    cond,\n\t\t\tStatus:  corev1.ConditionFalse,\n\t\t\tReason:  \"RevisionDeleted\",\n\t\t\tMessage: fmt.Sprintf(\"Revision %q was deleted.\", cs.LatestReadyRevisionName),\n\t\t})\n\t}\n\tcs.LatestReadyRevisionName = \"\"\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tnames := []string{\"John\", \"Mary\", \"Jane\", \"Bob\", \"Alice\"}\n\tprefix := \"J\"\n\n\tfilteredNames := filter(names, func(name string) bool {\n\t\treturn strings.HasPrefix(name, prefix)\n\t})\n\n\tfmt.Println(filteredNames) // Output: [John Jane]\n}\n\nfunc filter(strings []string, filterFunc func(string) bool) []string {\n\tfiltered := make([]string, 0)\n\tfor _, str := range strings {\n\t\tif filterFunc(str) {\n\t\t\tfiltered = append(filtered, str)\n\t\t}\n\t}\n\treturn filtered\n}"}
{"sample": "func main() {\n\tstr := \"hello world\"\n\tcontains := strings.Contains(str, \"world\")\n\n\tfmt.Println(contains)\n}"}
{"sample": "type Counter struct {\n\tcount int\n\tmu    sync.Mutex\n}\n\nfunc (c *Counter) Increment() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.count++\n}\n\nfunc (c *Counter) Value() int {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.count\n}"}
{"sample": "// HandleErrorInDeferredFunction handles an error in a deferred function\nfunc HandleErrorInDeferredFunction(err *error) {\n\tif r := recover(); r != nil {\n\t\t*err = fmt.Errorf(\"deferred function error: %v\", r)\n\t}\n}\n"}
{"sample": "var data struct {\n\tField string `json:\"field\"`\n}\nerr := json.Unmarshal(jsonData, &data)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package auth\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/aws/aws-sdk-go/aws/credentials\"\n\tv4 \"github.com/aws/aws-sdk-go/aws/signer/v4\"\n\t\"github.com/nspcc-dev/neo-go/pkg/crypto/keys\"\n\t\"github.com/nspcc-dev/neofs-api-go/pkg/object\"\n\t\"github.com/nspcc-dev/neofs-s3-gw/creds/accessbox\"\n\t\"github.com/nspcc-dev/neofs-s3-gw/creds/tokens\"\n\t\"github.com/nspcc-dev/neofs-sdk-go/pkg/pool\"\n\t\"go.uber.org/zap\"\n)\n\n// authorizationFieldRegexp -- is regexp for credentials with Base58 encoded cid and oid and '0' (zero) as delimiter.\nvar authorizationFieldRegexp = regexp.MustCompile(`AWS4-HMAC-SHA256 Credential=(?P<access_key_id_cid>[^/]+)0(?P<access_key_id_oid>[^/]+)/(?P<date>[^/]+)/(?P<region>[^/]*)/(?P<service>[^/]+)/aws4_request,\\s*SignedHeaders=(?P<signed_header_fields>.+),\\s*Signature=(?P<v4_signature>.+)`)\n\ntype (\n\t// Center is a user authentication interface.\n\tCenter interface {\n\t\tAuthenticate(request *http.Request) (*accessbox.Box, error)\n\t}\n\n\tcenter struct {\n\t\treg *regexpSubmatcher\n\t\tcli tokens.Credentials\n\t}\n\n\t// Params stores node connection parameters.\n\tParams struct {\n\t\tPool   pool.Pool\n\t\tLogger *zap.Logger\n\t}\n\n\tprs int\n)\n\n// ErrNoAuthorizationHeader is returned for unauthenticated requests.\nvar ErrNoAuthorizationHeader = errors.New(\"no authorization header\")\n\nfunc (p prs) Read(_ []byte) (n int, err error) {\n\tpanic(\"implement me\")\n}\n\nfunc (p prs) Seek(_ int64, _ int) (int64, error) {\n\tpanic(\"implement me\")\n}\n\nvar _ io.ReadSeeker = prs(0)\n\n// New creates an instance of AuthCenter.\nfunc New(conns pool.Pool, key *keys.PrivateKey) Center {\n\treturn &center{\n\t\tcli: tokens.New(conns, key),\n\t\treg: &regexpSubmatcher{re: authorizationFieldRegexp},\n\t}\n}\n\nfunc (c *center) Authenticate(r *http.Request) (*accessbox.Box, error) {\n\tqueryValues := r.URL.Query()\n\tif queryValues.Get(\"X-Amz-Algorithm\") == \"AWS4-HMAC-SHA256\" {\n\t\treturn nil, errors.New(\"pre-signed form of request is not supported\")\n\t}\n\n\tauthHeaderField := r.Header[\"Authorization\"]\n\tif len(authHeaderField) != 1 {\n\t\treturn nil, ErrNoAuthorizationHeader\n\t}\n\n\tsms1 := c.reg.getSubmatches(authHeaderField[0])\n\tif len(sms1) != 7 {\n\t\treturn nil, errors.New(\"bad Authorization header field\")\n\t}\n\n\tsignedHeaderFieldsNames := strings.Split(sms1[\"signed_header_fields\"], \";\")\n\tif len(signedHeaderFieldsNames) == 0 {\n\t\treturn nil, errors.New(\"wrong format of signed headers part\")\n\t}\n\n\tsignatureDateTime, err := time.Parse(\"20060102T150405Z\", r.Header.Get(\"X-Amz-Date\"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse x-amz-date header field: %w\", err)\n\t}\n\n\taccessKeyID := fmt.Sprintf(\"%s0%s\", sms1[\"access_key_id_cid\"], sms1[\"access_key_id_oid\"])\n\taccessKeyAddress := fmt.Sprintf(\"%s/%s\", sms1[\"access_key_id_cid\"], sms1[\"access_key_id_oid\"])\n\n\taddress := object.NewAddress()\n\tif err = address.Parse(accessKeyAddress); err != nil {\n\t\treturn nil, fmt.Errorf(\"could not parse AccessBox address: %s : %w\", accessKeyID, err)\n\t}\n\n\tbox, err := c.cli.GetBox(r.Context(), address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\totherRequest := r.Clone(context.TODO())\n\totherRequest.Header = make(http.Header)\n\n\tfor key, val := range r.Header {\n\t\tfor _, name := range signedHeaderFieldsNames {\n\t\t\tif strings.EqualFold(key, name) {\n\t\t\t\totherRequest.Header[key] = val\n\t\t\t}\n\t\t}\n\t}\n\n\tawsCreds := credentials.NewStaticCredentials(accessKeyID, box.Gate.AccessKey, \"\")\n\tsigner := v4.NewSigner(awsCreds)\n\tsigner.DisableURIPathEscaping = true\n\n\t// body not required\n\tif _, err := signer.Sign(otherRequest, nil, sms1[\"service\"], sms1[\"region\"], signatureDateTime); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to sign temporary HTTP request: %w\", err)\n\t}\n\n\tsms2 := c.reg.getSubmatches(otherRequest.Header.Get(\"Authorization\"))\n\tif sms1[\"v4_signature\"] != sms2[\"v4_signature\"] {\n\t\treturn nil, errors.New(\"failed to pass authentication procedure\")\n\t}\n\n\treturn box, nil\n}\n"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--config\", argparse.String, \"config.yaml\", \"Config file\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 4, \"Number of threads\")\nparser.AddArgument(\"--max-iter\", argparse.Int, 1000, \"Maximum number of iterations\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--batch-size\", argparse.Int, 16, \"Batch size\")\nparser.AddArgument(\"--mode\", argparse.String, \"default\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\n"}
{"sample": "// Create a new HTTP file server handler for serving static files\nfunc NewFileServer(directory string) http.Handler {\n\treturn http.FileServer(http.Dir(directory))\n}\n"}
{"sample": "package validate\n\nimport \"fmt\"\n\nfunc StreamAnalyticsJobStreamingUnits(i interface{}, k string) (w []string, es []error) {\n\tv, ok := i.(int)\n\tif !ok {\n\t\tes = append(es, fmt.Errorf(\"expected type of %s to be int\", k))\n\t\treturn\n\t}\n\n\t//  Property 'streamingUnits' value '5' is not in the acceptable set: '1','3','6','12', and multiples of 6 up to your quota\"\n\tif v == 1 || v == 3 {\n\t\treturn\n\t}\n\n\tif v < 1 || v > 120 {\n\t\tes = append(es, fmt.Errorf(\"expected %s to be in the range (1 - 120), got %d\", k, v))\n\t\treturn\n\t}\n\n\tif v%6 != 0 {\n\t\tes = append(es, fmt.Errorf(\"expected %s to be divisible by 6, got %d\", k, v))\n\t\treturn\n\t}\n\n\treturn\n}\n"}
{"sample": "data := struct {\n\tField string `json:\"field\"`\n}{\"value\"}\njsonData, err := json.Marshal(data)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t_ \"github.com/lib/pq\"\n\t\"log\"\n)\n\nconst (\n\tdbUser     = \"postgres\"\n\tdbPassword = \"password\"\n\tdbName     = \"test\"\n)\n\nfunc main() {\n\tdbinfo := fmt.Sprintf(\"user=%s password=%s dbname=%s sslmode=disable\",\n\t\t   dbUser, dbPassword, dbName)\n\n\tdb, err := sql.Open(\"postgres\", dbinfo)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\terr := rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Println(id, name)\n\t}\n}"}
{"sample": "package textproc\n\nimport (\n\t\"bufio\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc ProcessFile(fname string) error {\n\tfile, err := os.Open(fname)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\n\t\t// Process the line here\n\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\targs := os.Args[1:]\n\tfmt.Println(\"Command-line arguments:\", args)\n}"}
{"sample": "package staticserv\n\nimport (\n\t\"net/http\"\n)\n\nfunc serveStaticFiles(w http.ResponseWriter, r *http.Request) {\n\t// Set the directory to serve static files from\n\tfs := http.FileServer(http.Dir(\"static\"))\n\n\t// Serve the static files\n\tfs.ServeHTTP(w, r)\n}\n\nfunc main() {\n\t// Set up the HTTP server\n\thttp.HandleFunc(\"/\", serveStaticFiles)\n\n\t// Start the server\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package hammingdist\n\nimport \"errors\"\n\n// HammingDistance returns the Hamming distance between two strings of equal length.\nfunc HammingDistance(s1, s2 string) (int, error) {\n\tif len(s1) != len(s2) {\n\t\treturn 0, errors.New(\"strings must be of equal length\")\n\t}\n\n\tdistance := 0\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\tdistance++\n\t\t}\n\t}\n\n\treturn distance, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Create(\"output.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tfmt.Fprintln(file, \"Hello, World!\")\n}"}
{"sample": "func main() {\n\tquit := make(chan os.Signal)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-quit\n\t\tfmt.Println(\"Received termination signal\")\n\t\tos.Exit(0)\n\t}()\n\n\tfmt.Println(\"Waiting for termination signal\")\n\tselect {}\n}"}
{"sample": "func (h *HTTPHandler) Post(url string, contentType string, body io.Reader) (*http.Response, error) {\n\treq, err := http.NewRequest(http.MethodPost, url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Content-Type\", contentType)\n\tresp, err := h.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, nil\n}"}
{"sample": "func main() {\n\tselect {\n\tcase <-time.After(2 * time.Second):\n\t\tfmt.Println(\"Timeout\")\n\tcase <-time.After(3 * time.Second):\n\t\tfmt.Println(\"Another timeout\")\n\t}\n}"}
{"sample": "// Enable gzip compression for the response\nfunc EnableGzipCompression(response http.ResponseWriter) {\n\tresponse.Header().Set(\"Content-Encoding\", \"gzip\")\n\tresponse.Header().Set(\"Vary\", \"Accept-Encoding\")\n\tresponseWriter := gzip.NewWriter(response)\n\tdefer responseWriter.Close()\n\t// Write response data to responseWriter\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://jsonplaceholder.typicode.com/posts\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tfmt.Println(\"Error: Unexpected status code\", resp.StatusCode)\n\t\treturn\n\t}\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(bodyBytes))\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// ReadCSVFile reads a CSV file and returns its content as a slice of records.\nfunc ReadCSVFile(filePath string) ([][]string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\trecords, err := reader.ReadAll()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn records, nil\n}\n\n// WriteCSVFile writes a slice of records to a CSV file.\nfunc WriteCSVFile(filePath string, records [][]string) error {\n\tfile, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\terr = writer.WriteAll(records)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twriter.Flush()\n\treturn writer.Error()\n}"}
{"sample": "package httpreq\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Request struct {\n\tMethod  string\n\tURL     string\n\tHeaders map[string]string\n\tBody    []byte\n}\n\nfunc Do(req Request) ([]byte, error) {\n\tclient := http.Client{}\n\n\tbody := bytes.NewBuffer(req.Body)\n\n\thttpReq, err := http.NewRequest(req.Method, req.URL, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor key, value := range req.Headers {\n\t\thttpReq.Header.Set(key, value)\n\t}\n\n\tresp, err := client.Do(httpReq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn respBody, nil\n}"}
{"sample": "package githubapi\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/google/go-github/v35/github\"\n\t\"golang.org/x/oauth2\"\n)\n\nfunc GetLatestRelease(owner, repo string) (*github.RepositoryRelease, error) {\n\tctx := context.Background()\n\n\tts := oauth2.StaticTokenSource(\n\t\t&oauth2.Token{AccessToken: \"YOUR_ACCESS_TOKEN\"},\n\t)\n\ttc := oauth2.NewClient(ctx, ts)\n\n\tclient := github.NewClient(tc)\n\n\trelease, _, err := client.Repositories.GetLatestRelease(ctx, owner, repo)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get latest release: %v\", err)\n\t}\n\n\treturn release, nil\n}\n\nfunc ListIssues(owner, repo string) ([]*github.Issue, error) {\n\tctx := context.Background()\n\n\tts := oauth2.StaticTokenSource(\n\t\t&oauth2.Token{AccessToken: \"YOUR_ACCESS_TOKEN\"},\n\t)\n\ttc := oauth2.NewClient(ctx, ts)\n\n\tclient := github.NewClient(tc)\n\n\topt := &github.IssueListByRepoOptions{\n\t\tState: \"all\",\n\t}\n\n\tissues, _, err := client.Issues.ListByRepo(ctx, owner, repo, opt)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list issues: %v\", err)\n\t}\n\n\treturn issues, nil\n}"}
{"sample": "// Get the value of a specific header from the response\nfunc GetHeader(response *http.Response, header string) string {\n\treturn response.Header.Get(header)\n}\n"}
{"sample": "func createIndex(db *sql.DB) error {\n\tstmt, err := db.Prepare(\"CREATE INDEX idx_name ON users (name)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package json\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n)\n\ntype Person struct {\n\tName    string `json:\"name\"`\n\tAge     int    `json:\"age\"`\n\tAddress struct {\n\t\tCity    string `json:\"city\"`\n\t\tCountry string `json:\"country\"`\n\t} `json:\"address\"`\n}\n\nfunc main() {\n\tperson := Person{\n\t\tName: \"John Doe\",\n\t\tAge:  30,\n\t\tAddress: struct {\n\t\t\tCity    string `json:\"city\"`\n\t\t\tCountry string `json:\"country\"`\n\t\t}{City: \"New York\", Country: \"USA\"},\n\t}\n\n\t// Marshaling struct to JSON\n\tjsonBytes, err := json.Marshal(person)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"JSON: %s\\n\", jsonBytes)\n\n\t// Unmarshaling JSON to struct\n\tvar newPerson Person\n\tif err := json.Unmarshal(jsonBytes, &newPerson); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"Name: %s\\nAge: %d\\nCity: %s\\nCountry: %s\\n\", newPerson.Name, newPerson.Age, newPerson.Address.City, newPerson.Address.Country)\n\n\t// Encoding JSON to stdout directly\n\tjsonEncoder := json.NewEncoder((fmt.Sprintf(os.Stdout, person)))\n\tif err := jsonEncoder.Encode(person); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "func HandleRequest(w http.ResponseWriter, r *http.Request) {\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tHandleGet(w, r)\n\tcase http.MethodPost:\n\t\tHandlePost(w, r)\n\tdefault:\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc HandleGet(w http.ResponseWriter, r *http.Request) {\n\t// Handle GET request\n}\n\nfunc HandlePost(w http.ResponseWriter, r *http.Request) {\n\t// Handle POST request\n}"}
{"sample": "package main\n\n// Create a temp file\nfunc main() {\n\tf, err := os.CreateTemp(\"\", \"temp*\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.Remove(f.Name())\n\tfmt.Println(\"Temp file name:\", f.Name())\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintHello(\"Go\")\n}\n\n// Function to print hello followed by a string\nfunc PrintHello(s string) {\n\tfmt.Println(\"Hello\", s)\n}"}
{"sample": "// Define a struct\n\ntype Employee struct {\n\tID int\n\tFirstName string\n\tLastName string\n}\n"}
{"sample": "func main() {\n\tstr := \"Hello, World!\"\n\tupper := strings.ToUpper(str)\n\n\tfmt.Println(upper)\n}"}
{"sample": "package namedpipe\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n// Create creates a named pipe with the given name.\nfunc Create(name string) error {\n\terr := syscall.Mkfifo(name, 0666)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not create named pipe: %v\", err)\n\t}\n\treturn nil\n}\n\n// Open opens a named pipe with the given name for reading.\nfunc Open(name string) (*os.File, error) {\n\tfifo, err := os.OpenFile(name, os.O_RDONLY, os.ModeNamedPipe)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not open named pipe: %v\", err)\n\t}\n\treturn fifo, nil\n}\n\n// Write writes data to a named pipe with the given name for writing.\nfunc Write(name string, data []byte) error {\n\tfifo, err := os.OpenFile(name, os.O_WRONLY, os.ModeNamedPipe)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not write to named pipe: %v\", err)\n\t}\n\tdefer fifo.Close()\n\n\t_, err = fifo.Write(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not write to named pipe: %v\", err)\n\t}\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Create(\"output.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tfmt.Fprintln(file, \"Hello, World!\")\n}"}
{"sample": "package main\n\n// PanicIfErrAndRecover panics if there's an error and recovers\nfunc PanicIfErrAndRecover(err error) {\n\tdefer RecoverFromPanic()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"}
{"sample": "resp, err := http.Get(\"http://example.com\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer resp.Body.Close()\n"}
{"sample": "// ReturnIfError returns early if an error is not nil\nfunc ReturnIfError(err error) {\n\tif err != nil {\n\t\treturn\n\t}\n}\n"}
{"sample": "// Serve an HTTP handler with graceful shutdown support\nfunc ServeWithGracefulShutdown(server *http.Server, idleTimeout, shutdownTimeout time.Duration) error {\n\tidleConnsClosed := make(chan struct{})\n\n\tgo func() {\n\t\tquit := make(chan os.Signal, 1)\n\t\tsignal.Notify(quit, os.Interrupt, syscall.SIGTERM)\n\t\t<-quit\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)\n\t\tdefer cancel()\n\n\t\tif err := server.Shutdown(ctx); err != nil {\n\t\t\tfmt.Println(\"Server shutdown error: \", err)\n\t\t}\n\n\t\tclose(idleConnsClosed)\n\t}()\n\n\tif err := server.ListenAndServe(); err != http.ErrServerClosed {\n\t\treturn err\n\t}\n\n\t<-idleConnsClosed\n\treturn nil\n}\n"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--mode\", argparse.String, \"default\", \"Execution mode\")\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintRectangle(5, 3)\n}\n\n// Function to print a rectangle of '*'\nfunc PrintRectangle(width, height int) {\n\tfor i := 0; i < height; i++ {\n\t\tfor j := 0; j < width; j++ {\n\t\t\tfmt.Print(\"*\")\n\t\t}\n\t\tfmt.Println()\n\t}\n}"}
{"sample": "type Runner interface {\n\tRun(distance int) error\n}\ntype MyRunner struct{}\nfunc (m MyRunner) Run(distance int) error {\n\treturn nil\n}\n"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--num-threads\", argparse.Int, 4, \"Number of threads\")\nparser.AddArgument(\"--max-iter\", argparse.Int, 1000, \"Maximum number of iterations\")\n"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfmt.Print(\"Enter your name: \")\n\tscanner.Scan()\n\tname := scanner.Text()\n\n\tfmt.Print(\"Enter your age: \")\n\tscanner.Scan()\n\tage, err := strconv.Atoi(scanner.Text())\n\tif err != nil {\n\t\tfmt.Println(\"Invalid age\")\n\t\treturn\n\t}\n\n\tyearsLeft := 100 - age\n\tfmt.Printf(\"Hi %s, you have %d years left until you turn 100\\n\", strings.Title(name), yearsLeft)\n}"}
{"sample": "// Check if a number is zero\nfunc IsZero(num int) bool {\n\treturn num == 0\n}\n"}
{"sample": "// Average calculates the average of a slice of floats.\nfunc Average(nums []float64) float64 {\n\ttotal := 0.0\n\tfor _, num := range nums {\n\t\ttotal += num\n\t}\n\treturn total / float64(len(nums))\n}\n\n// Median calculates the median of a slice of floats.\nfunc Median(nums []float64) float64 {\n\tsort.Float64s(nums)\n\tmiddle := len(nums) / 2\n\tif len(nums)%2 == 0 {\n\t\treturn (nums[middle-1] + nums[middle]) / 2\n\t}\n\treturn nums[middle]\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(FindGCD(48, 18))\n}\n\n// Function to find the Greatest Common Divisor (GCD)\nfunc FindGCD(a, b int) int {\n\tfor b != 0 {\n\t\ta, b = b, a%b\n\t}\n\treturn a\n}"}
{"sample": "package redditapi\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype RedditAPI struct {\n\tclient   *http.Client\n\tbaseURL  *url.URL\n\tUser     string\n\tPassword string\n}\n\ntype Post struct {\n\tTitle string `json:\"title\"`\n\tURL   string `json:\"url\"`\n}\n\ntype Subreddit struct {\n\tName  string `json:\"display_name\"`\n\tPosts []Post `json:\"posts\"`\n}\n\nfunc NewRedditAPI(user, password string) (*RedditAPI, error) {\n\tbaseURL, err := url.Parse(\"https://www.reddit.com/\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &RedditAPI{\n\t\tclient:   &http.Client{},\n\t\tbaseURL:  baseURL,\n\t\tUser:     user,\n\t\tPassword: password,\n\t}, nil\n}\n\nfunc (api *RedditAPI) GetSubreddit(name string) (*Subreddit, error) {\n\treq, err := http.NewRequest(\"GET\", api.baseURL.String()+\"/r/\"+name+\".json\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.SetBasicAuth(api.User, api.Password)\n\n\tresp, err := api.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(fmt.Sprintf(\"unexpected status code %d\", resp.StatusCode))\n\t}\n\n\tvar data struct {\n\t\tData struct {\n\t\t\tChildren []struct {\n\t\t\t\tData Post `json:\"data\"`\n\t\t\t} `json:\"children\"`\n\t\t} `json:\"data\"`\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(&data); err != nil {\n\t\treturn nil, err\n\t}\n\n\tsubreddit := &Subreddit{\n\t\tName: name,\n\t}\n\n\tfor _, child := range data.Data.Children {\n\t\tsubreddit.Posts = append(subreddit.Posts, child.Data)\n\t}\n\n\treturn subreddit, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package frapi\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\n\t\"github.com/bjorge/friendlyreservations/frdate\"\n)\n\nconst membershipStatusConstraintsGQL = `\n\nenum MembershipState {\n\t# membership has not been purchased or set to opt out\n\tOPEN\n\t# membership has been purchased\n\tPURCHASED\n\t# user has opted out\n\tOPTOUT\n}\n\ntype MembershipStatusConstraintsRecord {\n\tstatus: MembershipState!\n\tinfo: RestrictionRecord!\n\treservationCount: Int!\n\t# cannot opt out if reservations exist\n\toptOutAllowed: Boolean!\n\t# cannot purchase if over minimum balance\n\tpurchaseAllowed: Boolean!\n}\n\ntype MembershipStatusConstraints {\n\tuser: User!\n\tmemberships: [MembershipStatusConstraintsRecord]!\n}\n\n`\n\ntype membershipStatusConstraintsArgs struct {\n\tUserID     *string\n\tMaxVersion *int32\n}\n\n// MembershipStatusConstraints is called by the GQL framewor, see contentGQL\nfunc (r *PropertyResolver) MembershipStatusConstraints(args *membershipStatusConstraintsArgs) ([]*MembershipStatusConstraintsResolver, error) {\n\n\t// validate input\n\tif args.UserID != nil {\n\t\tusers := r.Users(&usersArgs{UserID: args.UserID})\n\t\tif len(users) != 1 {\n\t\t\treturn nil, fmt.Errorf(\"user for id %+v not found\", *args.UserID)\n\t\t}\n\t}\n\n\tif args.MaxVersion != nil {\n\t\tif *args.MaxVersion < 0 {\n\t\t\treturn nil, fmt.Errorf(\"maxVersion cannot be less than 0\")\n\t\t}\n\t}\n\n\t// rollup\n\tr.rollupMembershipStatus()\n\n\t// resolve\n\treturn r.resolveMembershipStatus(args)\n}\n\n// UserMembershipRecord contains the information for resolving a user membership\ntype UserMembershipRecord struct {\n\trestrictionID    string\n\tuserID           string\n\tstatus           MembershipState\n\tinDate           *frdate.Date\n\toutDate          *frdate.Date\n\tprePayStartDate  *frdate.Date\n\tpurchaseAllowed  *bool\n\toptOutAllowed    *bool\n\treservationCount int\n}\n\n// MembershipRecordResolver resolves one of the memberships for a user\ntype MembershipRecordResolver struct {\n\tmembership *UserMembershipRecord\n\tproperty   *PropertyResolver\n\tuserID     string\n}\n\n// MembershipStatusConstraintsResolver resolves the memberships for a user\ntype MembershipStatusConstraintsResolver struct {\n\tuserID         string\n\tallMemberShips []*UserMembershipRecord\n\tproperty       *PropertyResolver\n}\n\n// Memberships is called by the GQL framework, see membershipStatusGQL\nfunc (r *MembershipStatusConstraintsResolver) Memberships() []*MembershipRecordResolver {\n\n\tresolvers := []*MembershipRecordResolver{}\n\tfor _, membership := range r.allMemberShips {\n\t\tresolver := &MembershipRecordResolver{}\n\t\tresolver.membership = membership\n\t\tresolver.property = r.property\n\t\tresolver.userID = r.userID\n\t\tresolvers = append(resolvers, resolver)\n\t}\n\n\t// descending order so that newest on the top of the list\n\tsort.Slice(resolvers, func(i, j int) bool {\n\t\treturn resolvers[i].membership.inDate.After(resolvers[j].membership.inDate)\n\t})\n\treturn resolvers\n}\n\n// User is called by the GQL framework, see membershipStatusGQL\nfunc (r *MembershipStatusConstraintsResolver) User() *UserResolver {\n\tusers := r.property.Users(&usersArgs{UserID: &r.userID})\n\treturn users[0]\n}\n\n// Info is called by the GQL framework, see membershipStatusGQL\nfunc (r *MembershipRecordResolver) Info() *RestrictionRecordResolver {\n\trestrictions, _ := r.property.Restrictions(&restrictionsArgs{RestrictionID: &r.membership.restrictionID})\n\treturn restrictions[0]\n}\n\n// Status is called by the GQL framework, see membershipStatusGQL\nfunc (r *MembershipRecordResolver) Status() MembershipState {\n\treturn r.membership.status\n}\n\n// ReservationCount is called by the GQL framework, see membershipStatusGQL\nfunc (r *MembershipRecordResolver) ReservationCount() int32 {\n\treturn int32(r.membership.reservationCount)\n}\n\nvar bFalse = false\nvar bTrue = true\n\n// OptOutAllowed is called by the GQL framework, see membershipStatusGQL\nfunc (r *MembershipRecordResolver) OptOutAllowed() bool {\n\treturn *r.membership.optOutAllowed\n}\nfunc setOptOutAllowed(allMemberShips []*UserMembershipRecord) {\n\n\tfoundOpen := false\n\tfor _, resolver := range allMemberShips {\n\t\tif foundOpen {\n\t\t\t// don't allow updates after first OPEN record\n\t\t\tresolver.optOutAllowed = &bFalse\n\t\t} else {\n\t\t\tswitch resolver.status {\n\t\t\tcase OPEN:\n\t\t\t\tif !foundOpen {\n\t\t\t\t\tfoundOpen = true\n\t\t\t\t\tresolver.optOutAllowed = &bTrue\n\t\t\t\t}\n\t\t\tcase OPTOUT:\n\t\t\t\tresolver.optOutAllowed = &bFalse\n\t\t\tcase PURCHASED:\n\t\t\t\tresolver.optOutAllowed = &bTrue\n\t\t\tdefault:\n\t\t\t\tresolver.optOutAllowed = &bFalse\n\t\t\t}\n\t\t}\n\t\tif resolver.reservationCount > 0 {\n\t\t\tresolver.optOutAllowed = &bFalse\n\t\t}\n\t}\n}\n\n// PurchaseAllowed is called by the GQL framework, see membershipStatusGQL\nfunc setPurchaseAllowed(lowBalance bool, allMemberShips []*UserMembershipRecord, today *frdate.Date) {\n\n\tfoundOpen := false\n\tfor _, resolver := range allMemberShips {\n\t\tif foundOpen {\n\t\t\t// don't allow updates after first OPEN record\n\t\t\tresolver.purchaseAllowed = &bFalse\n\t\t} else {\n\t\t\tswitch resolver.status {\n\t\t\tcase OPEN:\n\t\t\t\tresolver.purchaseAllowed = &bTrue\n\t\t\t\tif !foundOpen {\n\t\t\t\t\tfoundOpen = true\n\t\t\t\t}\n\t\t\tcase OPTOUT:\n\t\t\t\tresolver.purchaseAllowed = &bTrue\n\t\t\tcase PURCHASED:\n\t\t\t\tresolver.purchaseAllowed = &bFalse\n\t\t\t}\n\t\t}\n\t\t// if before prepay start, then not allowed\n\t\tif today.Before(resolver.prePayStartDate) || lowBalance {\n\t\t\tresolver.purchaseAllowed = &bFalse\n\t\t}\n\t}\n\n}\n\n// PurchaseAllowed is called by the GQL framework, see membershipStatusGQL\nfunc (r *MembershipRecordResolver) PurchaseAllowed() bool {\n\treturn *r.membership.purchaseAllowed\n}\n\nfunc (r *PropertyResolver) resolveMembershipStatus(args *membershipStatusConstraintsArgs) ([]*MembershipStatusConstraintsResolver, error) {\n\n\t// get all the rollups\n\tversionedRollups := r.getRollups(&rollupArgs{maxVersion: args.MaxVersion}, membershipStatusRollupType)\n\n\t// get a datebuilder from the property timezone\n\tsettings, err := r.Settings(&settingsArgs{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdateBuilder := frdate.MustNewDateBuilder(settings.Timezone())\n\n\t// calculate the number of reservations per membership period per user\n\treservations, err := r.Reservations(&reservationsArgs{Order: ASCENDING, MaxVersion: args.MaxVersion})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// userID -> membershipID -> count\n\treservationCountMap := make(map[string]map[string]int)\n\tfor _, reservation := range reservations {\n\t\tif reservation.Canceled() {\n\t\t\tcontinue\n\t\t}\n\t\trInDate := dateBuilder.MustNewDate(reservation.StartDate())\n\t\trOutDate := dateBuilder.MustNewDate(reservation.EndDate())\n\t\tfor _, versionedRollup := range versionedRollups {\n\t\t\trollup := versionedRollup.(*MembershipRollupRecord)\n\t\t\tmInDate := dateBuilder.MustNewDate(rollup.InDate)\n\t\t\tmOutDate := dateBuilder.MustNewDate(rollup.OutDate)\n\t\t\tif frdate.DateOverlap(rInDate, rOutDate, mInDate, mOutDate) {\n\t\t\t\tuID := reservation.ReservedFor().UserID()\n\t\t\t\tif _, ok := reservationCountMap[uID]; !ok {\n\t\t\t\t\treservationCountMap[uID] = make(map[string]int)\n\t\t\t\t}\n\t\t\t\tmID := rollup.RestrictionID\n\t\t\t\tif _, ok := reservationCountMap[uID][mID]; !ok {\n\t\t\t\t\treservationCountMap[uID][mID] = 0\n\t\t\t\t}\n\t\t\t\treservationCountMap[uID][mID]++\n\t\t\t}\n\t\t}\n\t}\n\n\t// get all the users\n\tusers := r.Users(&usersArgs{})\n\n\tresolvers := []*MembershipStatusConstraintsResolver{}\n\n\t// for each user...\n\tfor _, user := range users {\n\t\t// return only a single user\n\t\tif args.UserID != nil {\n\t\t\tif user.UserID() != *args.UserID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tresolver := &MembershipStatusConstraintsResolver{}\n\t\tresolver.userID = user.UserID()\n\t\tresolver.property = r\n\n\t\tfor _, versionedRollup := range versionedRollups {\n\t\t\trollup := versionedRollup.(*MembershipRollupRecord)\n\n\t\t\trecord := &UserMembershipRecord{}\n\t\t\trecord.userID = resolver.userID\n\t\t\trecord.restrictionID = rollup.RestrictionID\n\t\t\trecord.inDate = dateBuilder.MustNewDate(rollup.InDate)\n\t\t\trecord.outDate = dateBuilder.MustNewDate(rollup.OutDate)\n\t\t\trecord.prePayStartDate = dateBuilder.MustNewDate(rollup.PrePayStartDate)\n\n\t\t\tif status, ok := rollup.Users[user.UserID()]; ok {\n\t\t\t\trecord.status = status\n\t\t\t} else {\n\t\t\t\trecord.status = OPEN\n\t\t\t}\n\n\t\t\t// set the reservation count in the record\n\t\t\tif count, ok := reservationCountMap[resolver.userID][record.restrictionID]; ok {\n\t\t\t\trecord.reservationCount = count\n\t\t\t} else {\n\t\t\t\trecord.reservationCount = 0\n\t\t\t}\n\n\t\t\tresolver.allMemberShips = append(resolver.allMemberShips, record)\n\t\t}\n\n\t\tif len(resolver.allMemberShips) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tsort.Slice(resolver.allMemberShips, func(i, j int) bool {\n\t\t\treturn resolver.allMemberShips[i].inDate.Before(resolver.allMemberShips[j].inDate)\n\t\t})\n\n\t\tsetOptOutAllowed(resolver.allMemberShips)\n\n\t\tledgers, err := r.Ledgers(&ledgersArgs{Reverse: &bTrue, UserID: &resolver.userID})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbalance := ledgers[0].Records()[0].balanceInternal().Raw()\n\t\tminBalance := settings.minBalanceInternal().Raw()\n\n\t\tsetPurchaseAllowed(balance < minBalance, resolver.allMemberShips, dateBuilder.Today())\n\n\t\tresolvers = append(resolvers, resolver)\n\n\t}\n\n\treturn resolvers, nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc EnableTLS() {\n\tserver := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: nil, // Set your handler here\n\t\tTLSConfig: &tls.Config{\n\t\t\tMinVersion:               tls.VersionTLS13,\n\t\t\tCurvePreferences:         []tls.CurveID{tls.CurveP521, tls.CurveP384, tls.CurveP256}\n\t\t\tPreferServerCipherSuites: true,\n\t\t\tCipherSuites: []uint16{\n\t\t\t\ttls.TLS_AES_256_GCM_SHA384,\n\t\t\t\ttls.TLS_AES_128_GCM_SHA256,\n\t\t\t\ttls.TLS_CHACHA20_POLY1305_SHA256,\n\t\t\t}\n\t\t}\n\t}\n\n\tserver.ListenAndServeTLS(\"cert.pem\", \"key.pem\")\n}\n"}
{"sample": "// Using a select statement\n\nselect {\n\tcase <-ch1:\n\t\t// do something\n\tcase <-ch2:\n\t\t// do something else\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// SortInts sorts a slice of integers in ascending order.\nfunc SortInts(nums []int) {\n\tsort.Ints(nums)\n}"}
{"sample": "// Send a request with custom headers\nfunc SendRequestWithHeaders(method, url string, headers map[string]string, body io.Reader) (*http.Response, error) {\n\trequest, _ := http.NewRequest(method, url, body)\n\tfor key, value := range headers {\n\t\trequest.Header.Set(key, value)\n\t}\n\treturn http.DefaultClient.Do(request)\n}\n"}
{"sample": "package sessions\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/sessions\"\n)\n\nvar (\n\t// ErrSessionNotFound is returned when a session is not found.\n\tErrSessionNotFound = errors.New(\"session not found\")\n)\n\n// SessionManager manages user sessions.\ntype SessionManager struct {\n\tstore     sessions.Store\n\tname      string\n\tmaxAge    int\n\tsecure    bool\n\thttpOnly  bool\n\tsameSite  http.SameSite\n}\n\n// NewSessionManager creates a new SessionManager.\nfunc NewSessionManager(store sessions.Store, name string, maxAge int, secure, httpOnly bool, sameSite http.SameSite) *SessionManager {\n\treturn &SessionManager{\n\t\tstore:     store,\n\t\tname:      name,\n\t\tmaxAge:    maxAge,\n\t\tsecure:    secure,\n\t\thttpOnly:  httpOnly,\n\t\tsameSite:  sameSite,\n\t}\n}\n\n// GetSession retrieves a session by its ID.\nfunc (sm *SessionManager) GetSession(r *http.Request, id string) (*sessions.Session, error) {\n\tsession, err := sm.store.Get(r, sm.name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif session.IsNew {\n\t\treturn nil, ErrSessionNotFound\n\t}\n\n\tif session.ID != id {\n\t\treturn nil, ErrSessionNotFound\n\t}\n\n\treturn session, nil\n}\n\n// CreateSession creates a new session for the given user ID.\nfunc (sm *SessionManager) CreateSession(w http.ResponseWriter, r *http.Request, id string) (*sessions.Session, error) {\n\tsession, err := sm.store.New(r, sm.name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.Values[\"id\"] = id\n\tsession.Options.MaxAge = sm.maxAge\n\tsession.Options.Secure = sm.secure\n\tsession.Options.HttpOnly = sm.httpOnly\n\tsession.Options.SameSite = sm.sameSite\n\n\tif err := session.Save(r, w); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session, nil\n}\n\n// DestroySession destroys the session with the given ID.\nfunc (sm *SessionManager) DestroySession(w http.ResponseWriter, r *http.Request, id string) error {\n\tsession, err := sm.GetSession(r, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsession.Options.MaxAge = -1\n\n\tif err := session.Save(r, w); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// RenewSession renews the session with the given ID.\nfunc (sm *SessionManager) RenewSession(w http.ResponseWriter, r *http.Request, id string) (*sessions.Session, error) {\n\tsession, err := sm.GetSession(r, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.Options.MaxAge = sm.maxAge\n\tsession.Options.Secure = sm.secure\n\tsession.Options.HttpOnly = sm.httpOnly\n\tsession.Options.SameSite = sm.sameSite\n\tsession.Options.Expires = time.Now().Add(time.Duration(sm.maxAge) * time.Second)\n\n\tif err := session.Save(r, w); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session, nil\n}"}
{"sample": "package redislock\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\ntype RedisLock struct {\n\tredisClient *redis.Client\n\tkey         string\n\tvalue       string\n\texpiration  time.Duration\n}\n\nfunc New(redisClient *redis.Client, key string, value string, expiration time.Duration) *RedisLock {\n\treturn &RedisLock{\n\t\tredisClient: redisClient,\n\t\tkey:         key,\n\t\tvalue:       value,\n\t\texpiration:  expiration,\n\t}\n}\n\nfunc (lock *RedisLock) Acquire() (bool, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\tok, err := lock.redisClient.SetNX(ctx, lock.key, lock.value, lock.expiration).Result()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif !ok {\n\t\treturn false, errors.New(\"lock already acquired\")\n\t}\n\n\treturn true, nil\n}\n\nfunc (lock *RedisLock) Release() error {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\t_, err := lock.redisClient.Del(ctx, lock.key).Result()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\nfunc BubbleSort(arr []int) {\n\tfor i := 0; i < len(arr)-1; i++ {\n\t\tfor j := 0; j < len(arr)-i-1; j++ {\n\t\t\tif arr[j] > arr[j+1] {\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"sample": "// Defining a function\n\nfunc add(a int, b int) int {\n\treturn a + b\n}\n"}
{"sample": "type Employee struct {\n\tID int\n\tName string\n\tAge int\n\tPosition string\n}\n\nfunc (e *Employee) UpdateAge(newAge int) {\n\te.Age = newAge\n}\n\nfunc (e *Employee) UpdatePosition(newPosition string) {\n\te.Position = newPosition\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/hello\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "func main() {\n\toptions := &redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t}\n\n\tclient := redis.NewClient(options)\n\n\tpingResult, err := client.Ping(context.Background()).Result()\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to Redis:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Connected to Redis. Ping result:\", pingResult)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"example.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tstat, err := file.Stat()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsize := stat.Size()\n\tbytes := make([]byte, size)\n\n\t_, err = file.Read(bytes)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tcontent := string(bytes)\n\tfmt.Println(content)\n}"}
{"sample": "// Calculate the power of a number\nfunc Power(base, exponent int) int {\n\tresult := 1\n\tfor i := 0; i < exponent; i++ {\n\t\tresult *= base\n\t}\n\treturn result\n}\n"}
{"sample": "package main\n\n// LogAndIgnoreError logs and ignores an error\nfunc LogAndIgnoreError(err error) {\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n"}
{"sample": "// Create a new HTTP redirect handler\nfunc NewRedirectHandler(url string, code int) http.Handler {\n\treturn http.RedirectHandler(url, code)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintEvenNumbers prints even numbers up to a given limit.\nfunc PrintEvenNumbers(limit int) {\n\tfor i := 0; i <= limit; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/NVIDIA/gpu-monitoring-tools/bindings/go/nvml\"\n)\n\n// NvmlMock : Implementation of Nvml using mocked calls\ntype NvmlMock struct {\n\tdevices       []NvmlMockDevice\n\tdriverVersion string\n\tcudaMajor     uint\n\tcudaMinor     uint\n\terrorOnInit   bool\n}\n\n// NvmlMockDevice : Implementation of NvmlDevice using mocked calls\ntype NvmlMockDevice struct {\n\tinstance   *nvml.Device\n\tattributes *nvml.DeviceAttributes\n\tmigEnabled bool\n\tmigDevices []NvmlMockDevice\n}\n\n// Init : Init the mock\nfunc (nvmlMock NvmlMock) Init() error {\n\tif nvmlMock.errorOnInit {\n\t\treturn fmt.Errorf(\"NvmlMock error on init\")\n\t}\n\treturn nil\n}\n\n// Shutdown : Shutdown the mock\nfunc (nvmlMock NvmlMock) Shutdown() error {\n\treturn nil\n}\n\n// GetDeviceCount : Return a fake number of devices\nfunc (nvmlMock NvmlMock) GetDeviceCount() (uint, error) {\n\treturn uint(len(nvmlMock.devices)), nil\n}\n\n// NewDevice : Get information about a fake GPU\nfunc (nvmlMock NvmlMock) NewDevice(id uint) (NvmlDevice, error) {\n\tif int(id) <= len(nvmlMock.devices) {\n\t\treturn nvmlMock.devices[id], nil\n\t}\n\treturn nil, fmt.Errorf(\"Invalid index: %d\", id)\n}\n\n// GetDriverVersion : Return a fake driver version\nfunc (nvmlMock NvmlMock) GetDriverVersion() (string, error) {\n\treturn nvmlMock.driverVersion, nil\n}\n\n// GetCudaDriverVersion : Return a fake cuda version\nfunc (nvmlMock NvmlMock) GetCudaDriverVersion() (*uint, *uint, error) {\n\treturn &nvmlMock.cudaMajor, &nvmlMock.cudaMinor, nil\n}\n\n// Instance : Return the underlying NVML device instance\nfunc (d NvmlMockDevice) Instance() *nvml.Device {\n\treturn d.instance\n}\n\n// IsMigEnabled : Returns whether MIG is enabled on the device or not\nfunc (d NvmlMockDevice) IsMigEnabled() (bool, error) {\n\treturn d.migEnabled, nil\n}\n\n// GetMigDevices : Returns the list of MIG devices configured on this device\nfunc (d NvmlMockDevice) GetMigDevices() ([]NvmlDevice, error) {\n\tvar devices []NvmlDevice\n\tfor _, m := range d.migDevices {\n\t\tdevices = append(devices, m)\n\t}\n\treturn devices, nil\n}\n\n// GetAttributes : Returns the set of of Devices attributes\nfunc (d NvmlMockDevice) GetAttributes() (nvml.DeviceAttributes, error) {\n\treturn *d.attributes, nil\n}\n"}
{"sample": "package elasticsearch\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/elastic/go-elasticsearch/v7\"\n\t\"github.com/elastic/go-elasticsearch/v7/esapi\"\n)\n\nfunc searchMovies(client *elasticsearch.Client, query string) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tquery := map[string]interface{}{\n\t\t\"query\": map[string]interface{}{\n\t\t\t\"match\": map[string]interface{}{\n\t\t\t\t\"title\": query,\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := json.NewEncoder(&buf).Encode(query); err != nil {\n\t\treturn nil, err\n\t}\n\n\tres, err := client.Search(\n\t\tclient.Search.WithContext(context.Background()),\n\t\tclient.Search.WithIndex(\"movies\"),\n\t\tclient.Search.WithBody(&buf),\n\t\tclient.Search.WithTrackTotalHits(true),\n\t\tclient.Search.WithPretty(),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.IsError() {\n\t\treturn nil, fmt.Errorf(\"failed to search movies: %s\", res.Status())\n\t}\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n\nfunc indexMovie(client *elasticsearch.Client, id string, movie *Movie) error {\n\tvar buf bytes.Buffer\n\tif err := json.NewEncoder(&buf).Encode(movie); err != nil {\n\t\treturn err\n\t}\n\n\treq := esapi.IndexRequest{\n\t\tIndex:      \"movies\",\n\t\tDocumentID: id,\n\t\tBody:       &buf,\n\t\tRefresh:    \"true\",\n\t}\n\n\tres, err := req.Do(context.Background(), client)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.IsError() {\n\t\treturn fmt.Errorf(\"failed to index movie: %s\", res.Status())\n\t}\n\n\treturn nil\n}\n\nfunc deleteMovie(client *elasticsearch.Client, id string) error {\n\treq := esapi.DeleteRequest{\n\t\tIndex:      \"movies\",\n\t\tDocumentID: id,\n\t\tRefresh:    \"true\",\n\t}\n\n\tres, err := req.Do(context.Background(), client)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.IsError() {\n\t\treturn fmt.Errorf(\"failed to delete movie: %s\", res.Status())\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/proto/file\"\n)\n\nfunc main() {\n\t// Set up a connection to the server.\n\tconn, err := grpc.Dial(address, grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewYourServiceClient(conn)\n\n\t// Contact the server and print out its response.\n\tname := \"John Doe\"\n\tctx := context.Background()\n\tr, err := c.YourRPC(ctx, &pb.YourRequest{Name: name})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"Response from server: %s\", r.Message)\n\n\t// Send a proto message\n\tprotoMessage := &pb.YourProtoMessage{Field: \"value\"}\n\ts, err := proto.Marshal(protoMessage)\n\tif err != nil {\n\t\tlog.Fatalf(\"could not marshal proto message: %v\", err)\n\t}\n\tr, err = c.YourRPC(ctx, &pb.YourRequest{Name: name, ProtoMessage: s})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet with proto message: %v\", err)\n\t}\n\tlog.Printf(\"Response from server with proto message: %s\", r.Message)\n}"}
{"sample": "package models\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"time\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype Post struct {\n\tID        int\n\tTitle     string\n\tContent   string\n\tCreatedAt time.Time\n}\n\nvar db *sql.DB\n\nfunc init() {\n\tvar err error\n\tdb, err = sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/mydb\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (p *Post) Create() error {\n\tstmt, err := db.Prepare(\"INSERT INTO posts(title, content, created_at) VALUES(?, ?, ?)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tres, err := stmt.Exec(p.Title, p.Content, time.Now())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tid, err := res.LastInsertId()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.ID = int(id)\n\n\treturn nil\n}\n\nfunc GetPost(id string) (*Post, error) {\n\tvar post Post\n\n\trow := db.QueryRow(\"SELECT id, title, content, created_at FROM posts WHERE id = ?\", id)\n\terr := row.Scan(&post.ID, &post.Title, &post.Content, &post.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, errors.New(\"post not found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn &post, nil\n}"}
{"sample": "// Add basic authentication to the request\nfunc AddBasicAuth(request *http.Request, username, password string) {\n\trequest.SetBasicAuth(username, password)\n}\n"}
{"sample": "package redisclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\ntype RedisClient struct {\n\tclient *redis.Client\n\tctx    context.Context\n}\n\nfunc NewRedisClient() *RedisClient {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif err := rdb.Ping(ctx).Err(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &RedisClient{\n\t\tclient: rdb,\n\t\tctx:    ctx,\n\t}\n}\n\nfunc (rc *RedisClient) Set(key string, value interface{}) error {\n\treturn rc.client.Set(rc.ctx, key, value, 0).Err()\n}\n\nfunc (rc *RedisClient) Get(key string) (string, error) {\n\treturn rc.client.Get(rc.ctx, key).Result()\n}\n\nfunc (rc *RedisClient) Delete(key string) error {\n\treturn rc.client.Del(rc.ctx, key).Err()\n}\n\nfunc (rc *RedisClient) Increment(key string) error {\n\treturn rc.client.Incr(rc.ctx, key).Err()\n}\n\nfunc (rc *RedisClient) Decrement(key string) error {\n\treturn rc.client.Decr(rc.ctx, key).Err()\n}\n\nfunc (rc *RedisClient) Close() error {\n\treturn rc.client.Close()\n}\n\nfunc Example() {\n\tclient := NewRedisClient()\n\n\tif err := client.Set(\"key\", \"value\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tvalue, err := client.Get(\"key\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(value)\n\n\tif err := client.Delete(\"key\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := client.Increment(\"counter\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := client.Decrement(\"counter\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := client.Close(); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintHelloWorld()\n}\n\n// Function to print hello world\nfunc PrintHelloWorld() {\n\tfmt.Println(\"Hello, World!\")\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// FindMin finds the minimum element in a given slice of integers.\nfunc FindMin(nums []int) int {\n\tmin := nums[0]\n\tfor _, num := range nums {\n\t\tif num < min {\n\t\t\tmin = num\n\t\t}\n\t}\n\treturn min\n}"}
{"sample": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int, errChan chan<- error) {\n\tfor j := range jobs {\n\t\tif j%2 == 0 {\n\t\t\tresults <- j * 2\n\t\t} else {\n\t\t\terrChan <- errors.New(\"cannot process odd jobs\")\n\t\t}\n\t\tfmt.Printf(\"worker %d processed job %d\\n\", id, j)\n\n\t}\n}\n\nfunc main() {\n\tnumJobs := 10\n\tjobs := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\terrChan := make(chan error, numJobs)\n\n\tfor w := 1; w <= 3; w++ {\n\t\tgo worker(w, jobs, results, errChan)\n\t}\n\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor r := range results {\n\t\t\tfmt.Printf(\"result: %d\\n\", r)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor err := range errChan {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t}\n\t}()\n\n\twg.Wait()\n}"}
{"sample": "// Check if the response status code indicates success\nfunc IsSuccessStatusCode(response *http.Response) bool {\n\treturn response.StatusCode >= 200 && response.StatusCode < 300\n}\n"}
{"sample": "package main\n\n// This function checks if a file exists\nfunc FileExists(filename string) bool {\n\t_, err := os.Stat(filename)\n\treturn !os.IsNotExist(err)\n}\n\n// This function prints if a file exists\nfunc PrintFileExists(filename string) {\n\texists := FileExists(filename)\n\tfmt.Println(\"File exists:\", exists)\n}\n\nfunc main() {\n\tPrintFileExists(\"file.txt\")\n}\n"}
{"sample": "package sqlitehandle\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\ntype Database struct {\n\tPath string\n\tconn *sql.DB\n}\n\nfunc OpenDatabase(path string) (*Database, error) {\n\tdb, err := sql.Open(\"sqlite3\", path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdatabase := &Database{Path: path, conn: db}\n\treturn database, nil\n}\n\nfunc (d *Database) CloseDatabase() error {\n\treturn d.conn.Close()\n}\n\nfunc (d *Database) CreateTable(name string, fields map[string]string) error {\n\tfieldList := \"\"\n\tfor k, v := range fields {\n\t\tfieldList += fmt.Sprintf(\"%s %s,\", k, v)\n\t}\n\n\tcreateStmt := fmt.Sprintf(\"CREATE TABLE IF NOT EXISTS %s (%s)\", name, fieldList[:len(fieldList)-1])\n\n\t_, err := d.conn.Exec(createStmt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (d *Database) InsertRecord(table string, values map[string]interface{}) (int64, error) {\n\tfieldList := \"\"\n\tplaceholderList := \"\"\n\tvalueArgs := []interface{}{}\n\n\tfor k, v := range values {\n\t\tfieldList += fmt.Sprintf(\"%s,\", k)\n\t\tplaceholderList += fmt.Sprintf(\"?,\")\n\t\tvalueArgs = append(valueArgs, v)\n\t}\n\n\tinsertStmt := fmt.Sprintf(\"INSERT INTO %s (%s) VALUES (%s)\", table, fieldList[:len(fieldList)-1], placeholderList[:len(placeholderList)-1])\n\n\tresult, err := d.conn.Exec(insertStmt, valueArgs...)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\trowID, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\treturn rowID, nil\n}\n\nfunc (d *Database) Query(queryStmt string) (*sql.Rows, error) {\n\trows, err := d.conn.Query(queryStmt)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\treturn rows, nil\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintDiamond(5)\n}\n\n// Function to print a diamond of '*'\nfunc PrintDiamond(n int) {\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n-i; j++ {\n\t\t\tfmt.Print(\" \")\n\t\t}\n\t\tfor k := 1; k <= 2*i-1; k++ {\n\t\t\tfmt.Print(\"*\")\n\t\t}\n\t\tfmt.Println()\n\t}\n\tfor i := n-1; i >= 1; i-- {\n\t\tfor j := 1; j <= n-i; j++ {\n\t\t\tfmt.Print(\" \")\n\t\t}\n\t\tfor k := 1; k <= 2*i-1; k++ {\n\t\t\tfmt.Print(\"*\")\n\t\t}\n\t\tfmt.Println()\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/\", homeHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/users/{user}\", userHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/posts/{id}\", postHandler).Methods(\"GET\", \"PUT\", \"DELETE\")\n\n\thttp.Handle(\"/\", r)\n\n\tfmt.Println(\"Server listening on port 8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Welcome to my website!\")\n}\n\nfunc userHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tuser := vars[\"user\"]\n\tfmt.Fprintf(w, \"Hello %s!\", user)\n}\n\nfunc postHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid := vars[\"id\"]\n\n\tswitch r.Method {\n\tcase \"GET\":\n\t\tfmt.Fprintf(w, \"You requested post %s\", id)\n\tcase \"PUT\":\n\t\tfmt.Fprintf(w, \"You updated post %s\", id)\n\tcase \"DELETE\":\n\t\tfmt.Fprintf(w, \"You deleted post %s\", id)\n\tdefault:\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\tfmt.Fprintf(w, \"Unsupported method\")\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/smtp\"\n)\n\nfunc main() {\n\tto := []string{\"recipient@example.com\"}\n\tsubject := \"Hello\"\n\tbody := \"Hello, World!\"\n\n\tmsg := fmt.Sprintf(\"To: %s\\r\\nSubject: %s\\r\\n\\r\\n%s\", strings.Join(to, \", \"), subject, body)\n\n\terr := smtp.SendMail(\"smtp.example.com:587\", smtp.PlainAuth(\"\", \"sender@example.com\", \"password\", \"smtp.example.com\"), \"sender@example.com\", to, []byte(msg))\n\tif err != nil {\n\t\tfmt.Println(\"Error sending email:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Email sent\")\n}"}
{"sample": "package pathfinding_test\n\nimport (\n\t\"pathfinding\"\n\t\"testing\"\n)\n\nfunc TestShortestPath(t *testing.T) {\n\tgraph := pathfinding.Graph{\n\t\t\"A\": {\"B\": 10, \"C\": 3},\n\t\t\"B\": {\"C\": 1, \"D\": 2},\n\t\t\"C\": {\"B\": 4, \"D\": 8, \"E\": 2},\n\t\t\"D\": {\"E\": 7},\n\t\t\"E\": {\"D\": 9},\n\t}\n\ttests := []struct {\n\t\tstart, end string\n\t\twant       int\n\t}{\n\t\t{\"A\", \"B\", 10},\n\t\t{\"A\", \"C\", 3},\n\t\t{\"A\", \"D\", 5},\n\t\t{\"A\", \"E\", 5},\n\t\t{\"B\", \"A\", -1},\n\t\t{\"B\", \"C\", 1},\n\t\t{\"B\", \"D\", 2},\n\t\t{\"B\", \"E\", 3},\n\t\t{\"C\", \"A\", -1},\n\t\t{\"C\", \"B\", 4},\n\t\t{\"C\", \"D\", 6},\n\t\t{\"C\", \"E\", 2},\n\t\t{\"D\", \"A\", -1},\n\t\t{\"D\", \"B\", -1},\n\t\t{\"D\", \"C\", -1},\n\t\t{\"D\", \"E\", 7},\n\t\t{\"E\", \"A\", -1},\n\t\t{\"E\", \"B\", -1},\n\t\t{\"E\", \"C\", -1},\n\t\t{\"E\", \"D\", 9},\n\t}\n\tfor _, tt := range tests {\n\t\tif got := graph.ShortestPath(tt.start, tt.end); got != tt.want {\n\t\t\tt.Errorf(\"graph.ShortestPath(%q, %q) = %v, want %v\", tt.start, tt.end, got, tt.want)\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\nfunc UseGorillaMux() {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, Gorilla Mux!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", router)\n}\n"}
{"sample": "func SelectionSort(arr []int) {\n\tfor i := 0; i < len(arr); i++ {\n\t\tminIndex := i\n\t\tfor j := i + 1; j < len(arr); j++ {\n\t\t\tif arr[j] < arr[minIndex] {\n\t\t\t\tminIndex = j\n\t\t\t}\n\t\t}\n\t\tarr[i], arr[minIndex] = arr[minIndex], arr[i]\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"index.html\", gin.H{\"title\": \"Home\"})\n\t})\n\n\tr.Run(\":8080\")\n}"}
{"sample": "nums := []int{2, 3, 5, 7, 11}\nfor index, num := range nums {\n\tfmt.Printf(\"nums[%d] = %d\\n\", index, num)\n}\n"}
{"sample": "// Remove duplicates from an array\nfunc RemoveDuplicates(arr []int) []int {\n\tresult := []int{}\n\tseen := make(map[int]bool)\n\tfor _, num := range arr {\n\t\tif !seen[num] {\n\t\t\tseen[num] = true\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n"}
{"sample": "func ParseJSON(r io.Reader) (map[string]interface{} error) {\n\tvar result map[string]interface{}\n\terr := json.NewDecoder(r).Decode(&result)\n\treturn result, err\n}\n\nfunc WriteJSON(w io.Writer, data map[string]interface{}) error {\n\treturn json.NewEncoder(w).Encode(data)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// GenerateRandomNumber generates a random number within the specified range.\nfunc GenerateRandomNumber(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}"}
{"sample": "type Cache struct {\n\tcache map[string]string\n\tmu    sync.RWMutex\n}\n\nfunc (c *Cache) Get(key string) (string, bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tval, ok := c.cache[key]\n\treturn val, ok\n}\n\nfunc (c *Cache) Set(key string, value string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.cache[key] = value\n}"}
{"sample": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis\"\n)\n\nfunc main() {\n\tvar (\n\t\taddr     string\n\t\tpassword string\n\t\tdb       int\n\t)\n\tflag.StringVar(&addr, \"addr\", \"localhost:6379\", \"redis address\")\n\tflag.StringVar(&password, \"password\", \"\", \"redis password (optional)\")\n\tflag.IntVar(&db, \"db\", 0, \"redis database\")\n\n\tflag.Parse()\n\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     addr,\n\t\tPassword: password,\n\t\tDB:       db,\n\t})\n\n\tpong, err := client.Ping().Result()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error connecting to Redis: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Connected to Redis: %v\\n\", pong)\n\n\tkey := \"count\"\n\terr = client.Set(key, 0, 0).Err()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting initial value for key %s: %v\\n\", key, err)\n\t\tos.Exit(1)\n\t}\n\n\tfor range time.NewTicker(1 * time.Second).C {\n\t\tval, err := client.Get(key).Int()\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"error getting value for key %s: %v\\n\", key, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tfmt.Printf(\"Count: %d\\n\", val)\n\n\t\terr = client.Incr(key).Err()\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"error incrementing value for key %s: %v\\n\", key, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n}"}
{"sample": "// Initialize a struct\n\ne := Employee{\n\tID: 1,\n\tFirstName: \"John\",\n\tLastName: \"Doe\",\n}\n"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "func Permutations(arr []int) [][]int {\n\tif len(arr) == 1 {\n\t\treturn [][]int{arr}\n\t}\n\tvar result [][]int\n\tfor i := 0; i < len(arr); i++ {\n\t\trest := make([]int, len(arr))\n\t\tcopy(rest, arr)\n\t\trest = append(rest[:i], rest[i+1:]...)\n\t\tfor _, perm := range Permutations(rest) {\n\t\t\tresult = append(result, append([]int{arr[i]} perm...))\n\t\t}\n\t}\n\treturn result\n}"}
{"sample": "package todogrpc\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/timestamppb\"\n\n\t\"models\"\n\tpb \"todogrpc/proto\"\n)\n\ntype server struct {\n\tpb.UnimplementedTodoServiceServer\n}\n\nfunc (s *server) AddTodo(ctx context.Context, req *pb.AddTodoRequest) (*pb.AddTodoResponse, error) {\n\ttodo := models.Todo{\n\t\tTitle:       req.GetTitle(),\n\t\tDescription: req.GetDescription(),\n\t\tDueDate:     req.GetDueDate().AsTime(),\n\t}\n\tif err := models.CreateTodo(&todo); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.AddTodoResponse{\n\t\tId: todo.ID,\n\t}, nil\n}\n\nfunc (s *server) GetTodoById(ctx context.Context, req *pb.GetTodoByIdRequest) (*pb.GetTodoByIdResponse, error) {\n\tid := req.GetId()\n\n\ttodo, err := models.GetTodoByID(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.GetTodoByIdResponse{\n\t\tId:          todo.ID,\n\t\tTitle:       todo.Title,\n\t\tDescription: todo.Description,\n\t\tDueDate:     timestamppb.New(todo.DueDate),\n\t}, nil\n}\n\nfunc StartServer() {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\"localhost:%d\", 8000))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\tpb.RegisterTodoServiceServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "file, err := os.Create(\"newfile.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tnum := 4.5\n\n\tfmt.Println(\"Floor:\", math.Floor(num))\n\tfmt.Println(\"Ceil:\", math.Ceil(num))\n\tfmt.Println(\"Round:\", math.Round(num))\n\tfmt.Println(\"Sqrt:\", math.Sqrt(num))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar wg sync.WaitGroup\n\nfunc main() {\n\tfmt.Println(\"Starting goroutines\")\n\twg.Add(2)\n\tgo printNumbers()\n\tgo printLetters()\n\tfmt.Println(\"Waiting for goroutines to finish\")\n\twg.Wait()\n\tfmt.Println(\"\\nTerminating program\")\n}\n\nfunc printNumbers() {\n\trand.Seed(time.Now().UnixNano())\n\tfor i := 1; i <= 10; i++ {\n\t\tfmt.Printf(\"%d \", rand.Intn(10))\n\t\ttime.Sleep(time.Millisecond * 500)\n\t}\n\twg.Done()\n}\n\nfunc printLetters() {\n\tfor i := 'a'; i <= 'j'; i++ {\n\t\tfmt.Printf(\"%c \", i)\n\t\ttime.Sleep(time.Millisecond * 500)\n\t}\n\twg.Done()\n}"}
{"sample": "package httpproxy\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n)\n\ntype Proxy struct {\n\tTransport http.RoundTripper\n}\n\nfunc (p *Proxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tlog.Printf(\"Proxying %s %s\", r.Method, r.URL)\n\n\ttransport := p.Transport\n\tif transport == nil {\n\t\ttransport = http.DefaultTransport\n\t}\n\n\tres, err := transport.RoundTrip(r)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadGateway)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tfor k, vv := range res.Header {\n\t\tfor _, v := range vv {\n\t\t\tw.Header().Add(k, v)\n\t\t}\n\t}\n\tw.WriteHeader(res.StatusCode)\n\tio.Copy(w, res.Body)\n}\n\nfunc NewProxy() *Proxy {\n\treturn &Proxy{}\n}\n\nfunc main() {\n\tproxy := NewProxy()\n\n\tserver := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: proxy,\n\t}\n\n\tlog.Fatal(server.ListenAndServe())\n}\n\nfunc ConnectDial(network, addr string) (net.Conn, error) {\n\treturn net.Dial(network, addr)\n}"}
{"sample": "package db\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jmoiron/sqlx\"\n\t_ \"github.com/lib/pq\"\n)\n\ntype dbConfig struct {\n\thost     string\n\tport     int\n\tuser     string\n\tpassword string\n\tdbname   string\n}\n\nfunc (c *dbConfig) dataSourceName() string {\n\treturn fmt.Sprintf(\"host=%s port=%d user=%s password=%s dbname=%s sslmode=disable\", c.host, c.port, c.user, c.password, c.dbname)\n}\n\nfunc connect() (*sqlx.DB, error) {\n\tconfig := dbConfig{\n\t\thost:     \"localhost\",\n\t\tport:     5432,\n\t\tuser:     \"user\",\n\t\tpassword: \"password\",\n\t\tdbname:   \"mydb\",\n\t}\n\n\tdb, err := sqlx.Connect(\"postgres\", config.dataSourceName())\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn db, nil\n}\n\nfunc query() {\n\tdb, err := connect()\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\trows, err := db.Queryx(\"SELECT * FROM users WHERE age > $1\", 18)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tfor rows.Next() {\n\t\tvar user struct {\n\t\t\tID   int\n\t\t\tName string\n\t\t\tAge  int\n\t\t}\n\n\t\tif err := rows.StructScan(&user); err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\n\t\tfmt.Printf(\"User: %v\\n\", user)\n\t}\n}"}
{"sample": "package docker_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/client\"\n)\n\nfunc TestDocker(t *testing.T) {\n\tcli, err := client.NewEnvClient()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\timageName := \"nginx:latest\"\n\tcontainerName := \"test-nginx\"\n\n\t_, err = cli.ImagePull(context.Background(), imageName, types.ImagePullOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresp, err := cli.ContainerCreate(context.Background(), &container.Config{\n\t\tImage: imageName,\n\t}, nil, nil, containerName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := cli.ContainerStart(context.Background(), resp.ID, types.ContainerStartOptions{}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcontainers, err := cli.ContainerList(context.Background(), types.ContainerListOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound := false\n\tfor _, c := range containers {\n\t\tif c.ID == resp.ID {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tt.Fatal(\"Container not found\")\n\t}\n\n\tif err := cli.ContainerStop(context.Background(), resp.ID, nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := cli.ContainerRemove(context.Background(), resp.ID, types.ContainerRemoveOptions{}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfmt.Println(\"Docker test passed\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar nums []int\n\n\tfor i := 0; i < 5; i++ {\n\t\tnum := rand.Intn(100)\n\t\tnums = append(nums, num)\n\t}\n\n\tfmt.Println(nums)\n}"}
{"sample": "// Calculate the factorial of a number\nfunc Factorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * Factorial(n-1)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tresult := Fibonacci(5)\n\tfmt.Println(result)\n}\n\nfunc Fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\treturn Fibonacci(n-1) + Fibonacci(n-2)\n}"}
{"sample": "package geocode\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype GeocodeResponse struct {\n\tStatus  string            `json:\"status\"`\n\tResults []GeocodeResult   `json:\"results\"`\n\tError   string            `json:\"error_message,omitempty\"`\n}\n\ntype GeocodeResult struct {\n\tFormattedAddress string              `json:\"formatted_address\"`\n\tGeometry         GeocodeGeometry     `json:\"geometry\"`\n\tAddressComponents []GeocodeComponent `json:\"address_components\"`\n}\n\ntype GeocodeGeometry struct {\n\tLocation GeocodeLocation `json:\"location\"`\n}\n\ntype GeocodeLocation struct {\n\tLat float64 `json:\"lat\"`\n\tLng float64 `json:\"lng\"`\n}\n\ntype GeocodeComponent struct {\n\tLongName  string   `json:\"long_name\"`\n\tShortName string   `json:\"short_name\"`\n\tTypes     []string `json:\"types\"`\n}\n\nfunc Geocode(address string) (*GeocodeResponse, error) {\n\turlStr := fmt.Sprintf(\"https://maps.googleapis.com/maps/api/geocode/json?address=%s\", url.QueryEscape(address))\n\tresp, err := http.Get(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response GeocodeResponse\n\terr = json.Unmarshal(body, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif response.Status != \"OK\" {\n\t\treturn nil, fmt.Errorf(\"Geocoding failed with status: %s\", response.Status)\n\t}\n\n\treturn &response, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"text/template\"\n)\n\ntype Person struct {\n\tName    string\n\tAge     int\n\tCountry string\n}\n\nfunc main() {\n\tperson := Person{\n\t\tName:    \"Alice\",\n\t\tAge:     30,\n\t\tCountry: \"USA\",\n\t}\n\n\ttmpl, err := template.ParseFiles(\"template.txt\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tbuf := new(bytes.Buffer)\n\tif err := tmpl.Execute(buf, person); err != nil {\n\t\tlog.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Println(buf.String())\n}\n \n// Example content in template.txt\n//\n// Name: {{.Name}}\n// Age: {{.Age}}\n// Country: {{.Country}}"}
{"sample": "package graphqlclient\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\turl string\n}\n\nfunc NewClient(url string) *Client {\n\treturn &Client{url: url}\n}\n\nfunc (c *Client) Query(query string, variables map[string]interface{}, response interface{}) error {\n\treqBody, err := json.Marshal(map[string]interface{}{\n\t\t\"query\":     query,\n\t\t\"variables\": variables,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq, err := http.NewRequest(http.MethodPost, c.url, bytes.NewBuffer(reqBody))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"received non-200 status code: %d\", resp.StatusCode)\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(response); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package filewatcher\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n\n// Watcher watches for file changes and reports them\ntype Watcher struct {\n\twatcher *fsnotify.Watcher\n\tdone    chan bool\n}\n\n// NewWatcher creates a new Watcher\nfunc NewWatcher() (*Watcher, error) {\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Watcher{\n\t\twatcher: watcher,\n\t\tdone:    make(chan bool),\n\t}, nil\n}\n\n// Watch watches a given file or directory\nfunc (w *Watcher) Watch(path string) {\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase event := <-w.watcher.Events:\n\t\t\t\tlog.Printf(\"File %s %s\\n\", event.Name, event.Op)\n\t\t\tcase err := <-w.watcher.Errors:\n\t\t\t\tlog.Println(\"error:\", err)\n\t\t\tcase <-w.done:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\terr := w.watcher.Add(path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n// Stop stops watching for file changes\nfunc (w *Watcher) Stop() {\n\tw.done <- true\n\ttime.Sleep(time.Millisecond * 100)\n\tw.watcher.Close()\n}\n\nfunc ExampleUsage() {\n\twatcher, err := NewWatcher()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer watcher.Stop()\n\n\twatcher.Watch(os.Args[1])\n\n\tselect {}\n}"}
{"sample": "package calendarclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/api/calendar/v3\"\n\t\"google.golang.org/api/option\"\n)\n\ntype CalendarClient struct {\n\tservice *calendar.Service\n}\n\nfunc NewCalendarClient(credentialsFile string) (*CalendarClient, error) {\n\tctx := context.Background()\n\n\tcreds, err := google.FindDefaultCredentials(ctx, calendar.CalendarScope)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif credentialsFile != \"\" {\n\t\tcreds, err = google.CredentialsFromFile(ctx, credentialsFile, calendar.CalendarScope)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tclient := oauth2.NewClient(ctx, creds.TokenSource)\n\n\tsrv, err := calendar.NewService(ctx, option.WithHTTPClient(client))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &CalendarClient{service: srv}, nil\n}\n\nfunc (c *CalendarClient) ListEvents(calendarID string, start, end time.Time) ([]*calendar.Event, error) {\n\tevents, err := c.service.Events.List(calendarID).\n\t\tTimeMin(start.Format(time.RFC3339)).\n\t\tTimeMax(end.Format(time.RFC3339)).\n\t\tDo()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn events.Items, nil\n}\n\nfunc (c *CalendarClient) CreateEvent(calendarID string, event *calendar.Event) (*calendar.Event, error) {\n\tnewEvent, err := c.service.Events.Insert(calendarID, event).Do()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newEvent, nil\n}\n\nfunc (c *CalendarClient) DeleteEvent(calendarID, eventID string) error {\n\terr := c.service.Events.Delete(calendarID, eventID).Do()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *CalendarClient) UpdateEvent(calendarID, eventID string, event *calendar.Event) (*calendar.Event, error) {\n\tupdatedEvent, err := c.service.Events.Update(calendarID, eventID, event).Do()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn updatedEvent, nil\n}\n\nfunc (c *CalendarClient) GetEvent(calendarID, eventID string) (*calendar.Event, error) {\n\tevent, err := c.service.Events.Get(calendarID, eventID).Do()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn event, nil\n}\n\nfunc (c *CalendarClient) PrintEvent(event *calendar.Event) {\n\tfmt.Printf(\"Event: %s (%s)\\n\", event.Summary, event.Id)\n\tfmt.Printf(\"\\tStart Time: %s\\n\", event.Start.DateTime)\n\tfmt.Printf(\"\\tEnd Time: %s\\n\", event.End.DateTime)\n\tfmt.Printf(\"\\tDescription: %s\\n\", event.Description)\n\tfmt.Printf(\"\\tLocation: %s\\n\", event.Location)\n}\n\nfunc (c *CalendarClient) PrintEvents(events []*calendar.Event) {\n\tfor _, event := range events {\n\t\tc.PrintEvent(event)\n\t}\n}\n\nfunc (c *CalendarClient) Close() {\n\tlog.Println(\"Closing calendar client\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", helloWorldHandler)\n\thttp.HandleFunc(\"/about\", aboutHandler)\n\n\tfmt.Println(\"Listening on port 8080...\")\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc helloWorldHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World!\")\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"This is a simple web server written in Go.\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gofrs/uuid\"\n)\n\nfunc main() {\n\tid, err := uuid.NewV4()\n\tif err != nil {\n\t\tfmt.Println(\"Error generating UUID:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"UUID:\", id.String())\n}"}
{"sample": "package http2fileserver\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\thttp.ServeFile(w, r, r.URL.Path[1:])\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\n\tconfig := &tls.Config{NextProtos: []string{\"h2\"}}\n\tserver := &http.Server{\n\t\tAddr:      \":8080\",\n\t\tTLSConfig: config,\n\t}\n\n\thttp2Enabled := false // set to true if HTTP/2 is enabled\n\n\tif http2Enabled {\n\t\terr := server.ListenAndServeTLS(\"server.crt\", \"server.key\")\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"ListenAndServeTLS: %s\", err)\n\t\t}\n\t} else {\n\t\thttp2Server := &http2.Server{}\n\t\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.Proto == \"HTTP/2.0\" {\n\t\t\t\thttp2Server.ServeHTTP(w, r)\n\t\t\t} else {\n\t\t\t\thandler(w, r)\n\t\t\t}\n\t\t})\n\t\tfmt.Printf(\"Serving files over HTTP/2 on port %s...\\n\", server.Addr)\n\t\terr := server.ListenAndServeTLS(\"server.crt\", \"server.key\")\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"ListenAndServeTLS: %s\", err)\n\t\t}\n\t}\n}"}
{"sample": "// Set a response status code\nfunc SetStatusCode(response http.ResponseWriter, statusCode int) {\n\tresponse.WriteHeader(statusCode)\n}\n"}
{"sample": "func WriteToResponseWriter(w http.ResponseWriter, data []byte) (int, error) {\n\treturn w.Write(data)\n}\n\nfunc ReadFromRequestBody(r *http.Request) ([]byte, error) {\n\treturn ioutil.ReadAll(r.Body)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tvar counter int\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tcounter++\n\t\t\twg.Done()\n\t\t}()\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"Counter value: \", counter)\n}"}
{"sample": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Create(\"log.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tlogger := log.New(file, \"my-app\", log.LstdFlags)\n\n\tlogger.Println(\"Starting application...\")\n\t// ...\n\tlogger.Println(\"Application stopped.\")\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintSquares prints the squares of numbers up to a specified limit.\nfunc PrintSquares(limit int) {\n\tfor i := 1; i <= limit; i++ {\n\t\tfmt.Println(i * i)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"database/sql\"\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/mydb\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to MySQL:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE IF NOT EXISTS users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255))\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating table:\", err)\n\t\treturn\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (name) VALUES ('John Doe')\")\n\tif err != nil {\n\t\tfmt.Println(\"Error inserting into table:\", err)\n\t\treturn\n\t}\n\n\trows, err := db.Query(\"SELECT id, name FROM users\")\n\tif err != nil {\n\t\tfmt.Println(\"Error querying table:\", err)\n\t\treturn\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\terr = rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error scanning row:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Println(id, name)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintTable prints the multiplication table of a given number up to a specified limit.\nfunc PrintTable(num, limit int) {\n\tfor i := 1; i <= limit; i++ {\n\t\tresult := num * i\n\t\tfmt.Printf(\"%d x %d = %d\\n\", num, i, result)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID        int\n\tUsername  string\n\tEmail     string\n\tCreatedAt time.Time\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"root:[password]@tcp(localhost:3306)/my_db\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Create a new user\n\tusername := \"JohnDoe\"\n\temail := \"johndoe@example.com\"\n\n\tinsertQuery := fmt.Sprintf(\"INSERT INTO users (username, email, created_at) VALUES ('%s', '%s', NOW())\", username, email)\n\tresult, err := db.Exec(insertQuery)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlastInsertId, err := result.LastInsertId()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"Created a new user with Id: %d\\n\", lastInsertId)\n\n\t// Get all users\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tvar users []User\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tusers = append(users, user)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"Total users: %d\\n\", len(users))\n\n\t// Get a specific user\n\tvar user User\n\tquery := fmt.Sprintf(\"SELECT id, username, email, created_at FROM users WHERE id = %d\", lastInsertId)\n\terr = db.QueryRow(query).Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"Found user: %+v\\n\", user)\n}"}
{"sample": "type Stack struct {\n\tstack []interface{}\n\tmu    sync.Mutex\n}\n\nfunc (s *Stack) Push(value interface{}) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.stack = append(s.stack, value)\n}\n\nfunc (s *Stack) Pop() (interface{} error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif len(s.stack) == 0 {\n\t\treturn nil, errors.New(\"stack is empty\")\n\t}\n\tvalue := s.stack[len(s.stack)-1]\n\ts.stack = s.stack[:len(s.stack)-1]\n\treturn value, nil\n}"}
{"sample": "func main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\t// Define the routes\n\tr.HandleFunc(\"/\", homeHandler)\n\tr.HandleFunc(\"/about\", aboutHandler)\n\tr.HandleFunc(\"/contact\", contactHandler)\n\n\t// Serve the files in the \"static\" directory\n\tr.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(\"static\"))))\n\n\t// Start the server\n\tfmt.Println(\"Starting server on port 8080\")\n\thttp.ListenAndServe(\":8080\", r)\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Welcome to the home page!\"))\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"This is the about page.\"))\n}\n\nfunc contactHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Please contact us at hello@example.com\"))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar wg sync.WaitGroup\n\tchannel := make(chan int)\n\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\ttime.Sleep(time.Duration(rand.Intn(5)) * time.Second)\n\t\t\tchannel <- id\n\t\t\tfmt.Printf(\"Worker %d has finished\\n\", id)\n\t\t}(i)\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(channel)\n\t}()\n\n\tfor id := range channel {\n\t\tfmt.Printf(\"Worker %d has received the signal\\n\", id)\n\t}\n\tfmt.Println(\"All workers have finished\")\n}"}
{"sample": "package cassandraclient\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/gocql/gocql\"\n)\n\ntype CassandraClient struct {\n\tsession *gocql.Session\n}\n\nfunc NewCassandraClient(hosts []string, keyspace string) (*CassandraClient, error) {\n\tcluster := gocql.NewCluster(hosts...)\n\tcluster.Keyspace = keyspace\n\tcluster.Consistency = gocql.Quorum\n\tcluster.Timeout = 30 * time.Second\n\n\tsession, err := cluster.CreateSession()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &CassandraClient{session: session}, nil\n}\n\nfunc (c *CassandraClient) Close() {\n\tc.session.Close()\n}\n\nfunc (c *CassandraClient) InsertUser(id int, name string, email string) error {\n\tquery := \"INSERT INTO users (id, name, email) VALUES (?, ?, ?)\"\n\tif err := c.session.Query(query, id, name, email).Exec(); err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *CassandraClient) GetUser(id int) (string, string, error) {\n\tvar name, email string\n\tquery := \"SELECT name, email FROM users WHERE id = ?\"\n\tif err := c.session.Query(query, id).Scan(&name, &email); err != nil {\n\t\tlog.Println(err)\n\t\treturn \"\", \"\", err\n\t}\n\n\treturn name, email, nil\n}\n\nfunc (c *CassandraClient) GetUsers() ([]string, error) {\n\tvar names []string\n\tquery := \"SELECT name FROM users\"\n\titer := c.session.Query(query).Iter()\n\tvar name string\n\tfor iter.Scan(&name) {\n\t\tnames = append(names, name)\n\t}\n\tif err := iter.Close(); err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\treturn names, nil\n}\n\nfunc (c *CassandraClient) CreateSchema() error {\n\tquery := `\n\t\tCREATE TABLE IF NOT EXISTS users (\n\t\t\tid int,\n\t\t\tname text,\n\t\t\temail text,\n\t\t\tPRIMARY KEY (id)\n\t\t)\n\t`\n\tif err := c.session.Query(query).Exec(); err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc ExampleUsage() {\n\thosts := []string{\"127.0.0.1\"}\n\tkeyspace := \"mykeyspace\"\n\n\tclient, err := NewCassandraClient(hosts, keyspace)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer client.Close()\n\n\tif err := client.CreateSchema(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := client.InsertUser(1, \"Alice\", \"alice@example.com\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tname, email, err := client.GetUser(1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"Name: %s, Email: %s\\n\", name, email)\n\n\tusers, err := client.GetUsers()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"Users: %v\\n\", users)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// FormatDate formats a given time in the specified layout.\nfunc FormatDate(t time.Time, layout string) string {\n\treturn t.Format(layout)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintEvenNumbers prints even numbers up to a given limit.\nfunc PrintEvenNumbers(limit int) {\n\tfor i := 0; i <= limit; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "package smtpclient\n\nimport (\n\t\"fmt\"\n\t\"net/smtp\"\n)\n\nfunc sendEmail(to []string, subject string, body string) error {\n\tfrom := \"example@gmail.com\"\n\tpassword := \"password\"\n\tsmtpHost := \"smtp.gmail.com\"\n\tsmtpPort := \"587\"\n\n\tauth := smtp.PlainAuth(\"\", from, password, smtpHost)\n\n\tmsg := []byte(fmt.Sprintf(\"To: %s\\r\\nSubject: %s\\r\\n\\r\\n%s\", to, subject, body))\n\n\terr := smtp.SendMail(smtpHost+\":\"+smtpPort, auth, from, to, msg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "func scanRow(row *sql.Row, dest ...interface{}) error {\n\terr := row.Scan(dest...)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn ErrNoRows\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n"}
{"sample": "package taskservice\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/pkg/errors\"\n)\n\ntype Task struct {\n\tID        string\n\tTitle     string\n\tDueDate   time.Time\n\tCompleted bool\n}\n\ntype TaskService struct {\n\ttasks []Task\n}\n\nfunc NewTaskService() *TaskService {\n\treturn &TaskService{}\n}\n\nfunc (ts *TaskService) AddTask(ctx context.Context, title string, dueDate time.Time) (string, error) {\n\tif title == \"\" {\n\t\treturn \"\", errors.New(\"title cannot be empty\")\n\t}\n\n\tid := uuid.New().String()\n\n\ttask := Task{\n\t\tID:      id,\n\t\tTitle:   title,\n\t\tDueDate: dueDate,\n\t}\n\n\tts.tasks = append(ts.tasks, task)\n\n\treturn id, nil\n}\n\nfunc (ts *TaskService) CompleteTask(ctx context.Context, id string) error {\n\tfor i, task := range ts.tasks {\n\t\tif task.ID == id {\n\t\t\tts.tasks[i].Completed = true\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn errors.New(\"task not found\")\n}\n\nfunc (ts *TaskService) GetTasks(ctx context.Context) ([]Task, error) {\n\treturn ts.tasks, nil\n}\n\nfunc (ts *TaskService) GetTask(ctx context.Context, id string) (Task, error) {\n\tfor _, task := range ts.tasks {\n\t\tif task.ID == id {\n\t\t\treturn task, nil\n\t\t}\n\t}\n\n\treturn Task{}, errors.New(\"task not found\")\n}\n\nfunc (ts *TaskService) DeleteTask(ctx context.Context, id string) error {\n\tfor i, task := range ts.tasks {\n\t\tif task.ID == id {\n\t\t\tts.tasks = append(ts.tasks[:i], ts.tasks[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn errors.New(\"task not found\")\n}\n\nfunc (ts *TaskService) UpdateTask(ctx context.Context, id string, title string, dueDate time.Time) error {\n\tfor i, task := range ts.tasks {\n\t\tif task.ID == id {\n\t\t\tif title != \"\" {\n\t\t\t\tts.tasks[i].Title = title\n\t\t\t}\n\t\t\tif !dueDate.IsZero() {\n\t\t\t\tts.tasks[i].DueDate = dueDate\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn errors.New(\"task not found\")\n}\n\nfunc (ts *TaskService) Run() error {\n\tlog.Println(\"Task service started\")\n\n\t// Do some background task processing here\n\n\treturn nil\n}"}
{"sample": "package firestoreclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"cloud.google.com/go/firestore\"\n\t\"google.golang.org/api/option\"\n)\n\ntype FirestoreClient struct {\n\tclient *firestore.Client\n\tctx    context.Context\n}\n\nfunc NewFirestoreClient(ctx context.Context, projectID, credentialsPath string) (*FirestoreClient, error) {\n\tclient, err := firestore.NewClient(ctx, projectID, option.WithCredentialsFile(credentialsPath))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create Firestore client: %v\", err)\n\t}\n\n\treturn &FirestoreClient{client, ctx}, nil\n}\n\nfunc (c *FirestoreClient) Close() error {\n\treturn c.client.Close()\n}\n\nfunc (c *FirestoreClient) GetDocument(collection, document string) (map[string]interface{}, error) {\n\tdocRef := c.client.Collection(collection).Doc(document)\n\tdoc, err := docRef.Get(c.ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get document %s from collection %s: %v\", document, collection, err)\n\t}\n\n\treturn doc.Data(), nil\n}\n\nfunc (c *FirestoreClient) SetDocument(collection, document string, data map[string]interface{}) error {\n\tdocRef := c.client.Collection(collection).Doc(document)\n\t_, err := docRef.Set(c.ctx, data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to set document %s in collection %s: %v\", document, collection, err)\n\t}\n\n\treturn nil\n}"}
{"sample": "// Check if a string is alphanumeric\nfunc IsAlphanumeric(str string) bool {\n\treturn regexp.MustCompile(`^[a-zA-Z0-9]+$`).MatchString(str)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc UseGin() {\n\trouter := gin.Default()\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello, Gin!\")\n\t})\n\n\trouter.Run(\":8080\")\n}\n"}
{"sample": "// Set a response header with the specified key and value\nfunc SetResponseHeader(response http.ResponseWriter, key, value string) {\n\tresponse.Header().Set(key, value)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc main() {\n\tunsorted := []int{5, 9, 1, 4, 8, 3, 7, 6, 2}\n\n\tsort.Ints(unsorted)\n\n\tfmt.Println(unsorted)\n}"}
{"sample": "package main\n\nfunc main() {\n\tnumbers := []int{5, 8, 3, 1}\n\tSum := SumNumbers(numbers)\n\tfmt.Println(Sum)\n}\n\nfunc SumNumbers(numbers []int) int {\n\tsum := 0\n\tfor _, num := range numbers {\n\t\tsum += num\n\t}\n\treturn sum\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"database/sql\"\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/mydb\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to MySQL:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE IF NOT EXISTS users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255))\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating table:\", err)\n\t\treturn\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (name) VALUES ('John Doe')\")\n\tif err != nil {\n\t\tfmt.Println(\"Error inserting into table:\", err)\n\t\treturn\n\t}\n\n\trows, err := db.Query(\"SELECT id, name FROM users\")\n\tif err != nil {\n\t\tfmt.Println(\"Error querying table:\", err)\n\t\treturn\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\terr = rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error scanning row:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Println(id, name)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintTable prints the multiplication table of a given number up to a specified limit.\nfunc PrintTable(num, limit int) {\n\tfor i := 1; i <= limit; i++ {\n\t\tresult := num * i\n\t\tfmt.Printf(\"%d x %d = %d\\n\", num, i, result)\n\t}\n}"}
{"sample": "content, err := ioutil.ReadFile(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Println(string(content))\n"}
{"sample": "// Convert a string to uppercase\nfunc ToUpperCase(str string) string {\n\treturn strings.ToUpper(str)\n}\n"}
{"sample": "package http2push\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"golang.org/x/net/http2\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif pusher, ok := w.(http.Pusher); ok {\n\t\t\tif err := pusher.Push(\"/style.css\", nil); err != nil {\n\t\t\t\tlog.Printf(\"Failed to push: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\tfmt.Fprintf(w, `\n\t\t\t<!DOCTYPE html>\n\t\t\t<html>\n\t\t\t\t<head>\n\t\t\t\t\t<title>HTTP/2 Server Push Example</title>\n\t\t\t\t\t<link rel=\"stylesheet\" href=\"/style.css\">\n\t\t\t\t</head>\n\t\t\t\t<body>\n\t\t\t\t\t<h1>HTTP/2 Server Push Example</h1>\n\t\t\t\t\t<p>Welcome to the world of HTTP/2 server push!</p>\n\t\t\t\t</body>\n\t\t\t</html>\n\t\t`)\n\t})\n\n\thttp.HandleFunc(\"/style.css\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprint(w, `\n\t\t\tbody {\n\t\t\t\tbackground-color: #f2f2f2;\n\t\t\t}\n\n\t\t\th1 {\n\t\t\t\tcolor: #333;\n\t\t\t\tfont-size: 2.5em;\n\t\t\t\ttext-align: center;\n\t\t\t}\n\n\t\t\tp {\n\t\t\t\tcolor: #666;\n\t\t\t\tfont-size: 1.2em;\n\t\t\t\ttext-align: center;\n\t\t\t}\n\t\t`)\n\t})\n\n\thttp2Server := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: http.DefaultServeMux,\n\t}\n\n\thttp2.ConfigureServer(http2Server, nil)\n\n\tlog.Fatal(http2Server.ListenAndServeTLS(\"server.crt\", \"server.key\"))\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package aesencdec\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc encryptFile(key []byte, inputFile string, outputFile string) error {\n\tplaintext, err := ioutil.ReadFile(inputFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n\tiv := ciphertext[:aes.BlockSize]\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\treturn err\n\t}\n\n\tstream := cipher.NewCFBEncrypter(block, iv)\n\tstream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)\n\n\tif err := ioutil.WriteFile(outputFile, ciphertext, 0644); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc decryptFile(key []byte, inputFile string, outputFile string) error {\n\tciphertext, err := ioutil.ReadFile(inputFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(ciphertext) < aes.BlockSize {\n\t\treturn errors.New(\"ciphertext too short\")\n\t}\n\tiv := ciphertext[:aes.BlockSize]\n\tciphertext = ciphertext[aes.BlockSize:]\n\n\tstream := cipher.NewCFBDecrypter(block, iv)\n\n\tplaintext := make([]byte, len(ciphertext))\n\tstream.XORKeyStream(plaintext, ciphertext)\n\n\tif err := ioutil.WriteFile(outputFile, plaintext, 0644); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tkey := []byte(\"example-key-1234\")\n\n\terr := encryptFile(key, \"input.txt\", \"output.enc\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = decryptFile(key, \"output.enc\", \"output.txt\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// cleanup\n\tos.Remove(\"output.enc\")\n}"}
{"sample": "func (t *BinaryTree) InOrderTraversal(fn func(int)) {\n\tinOrderTraversal(t.Root, fn)\n}\n\nfunc inOrderTraversal(node *TreeNode, fn func(int)) {\n\tif node != nil {\n\t\tinOrderTraversal(node.Left, fn)\n\t\tfn(node.Data)\n\t\tinOrderTraversal(node.Right, fn)\n\t}\n}"}
{"sample": "func main() {\n\ttmpl, err := template.ParseFiles(\"template.html\")\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing template:\", err)\n\t\treturn\n\t}\n\n\tdata := struct{\n\t\tName string\n\t\tAge  int\n\t}{\n\t\tName: \"John Doe\",\n\t\tAge:  30,\n\t}\n\n\terr = tmpl.Execute(os.Stdout, data)\n\tif err != nil {\n\t\tfmt.Println(\"Error executing template:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"data.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tstat, err := file.Stat()\n\tif err != nil {\n\t\tfmt.Println(\"Error getting file info:\", err)\n\t\treturn\n\t}\n\n\tsize := stat.Size()\n\tdata := make([]byte, size)\n\n\t_, err = file.Read(data)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading file:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"File contents:\", string(data))\n}"}
{"sample": "/* messages.go\r\n   (c) Scott M Baker, http://www.smbaker.com/\r\n\r\n   JSON message structures, sent from Plugin to Streamdeck\r\n*/\r\n\r\npackage streamdeck\r\n\r\nconst (\r\n\tTARGET_BOTH     = 0\r\n\tTARGET_HARDWARE = 1\r\n\tTARGET_SOFTWARE = 2\r\n\r\n\tTYPE_JPG = \"image/jpg\"\r\n\tTYPE_PNG = \"image/png\"\r\n\tTYPE_BMP = \"image/bmp\"\r\n)\r\n\r\ntype RegisterMessage struct {\r\n\tEvent string `json:\"event\"`\r\n\tUuid  string `json:\"uuid\"`\r\n}\r\n\r\ntype ProfilePayload struct {\r\n\tProfile string `json:\"profile\"`\r\n}\r\n\r\ntype SwitchProfileMessage struct {\r\n\tEvent   string         `json:\"event\"`\r\n\tContext string         `json:\"context\"`\r\n\tDevice  string         `json:\"device\"`\r\n\tPayload ProfilePayload `json:\"payload\"`\r\n}\r\n\r\ntype SetImagePayload struct {\r\n\tImage  string `json:\"image\"`\r\n\tTarget int    `json:\"target\"`\r\n}\r\n\r\ntype SetImageMessage struct {\r\n\tEvent   string          `json:\"event\"`\r\n\tContext string          `json:\"context\"`\r\n\tPayload SetImagePayload `json:\"payload\"`\r\n}\r\n\r\ntype SetTitlePayload struct {\r\n\tTitle  string `json:\"title\"`\r\n\tTarget int    `json:\"target\"`\r\n}\r\n\r\ntype SetTitleMessage struct {\r\n\tEvent   string          `json:\"event\"`\r\n\tContext string          `json:\"context\"`\r\n\tPayload SetTitlePayload `json:\"payload\"`\r\n}\r\n\r\ntype ShowAlertMessage struct {\r\n\tEvent   string `json:\"event\"`\r\n\tContext string `json:\"context\"`\r\n}\r\n\r\ntype ShowOkMessage struct {\r\n\tEvent   string `json:\"event\"`\r\n\tContext string `json:\"context\"`\r\n}\r\n\r\ntype GetSettingsMessage struct {\r\n\tEvent   string `json:\"event\"`\r\n\tContext string `json:\"context\"`\r\n}\r\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintTriangle(5)\n}\n\n// Function to print a triangle of '*'\nfunc PrintTriangle(n int) {\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j <= i; j++ {\n\t\t\tfmt.Print(\"*\")\n\t\t}\n\t\tfmt.Println()\n\t}\n}"}
{"sample": "// Using if-else conditional\n\nif condition {\n\t// execute this block\n} else {\n\t// execute this block\n}\n"}
{"sample": "package ticketservice\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"ticketservice/models\"\n)\n\nfunc createTicket(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttitle := r.FormValue(\"title\")\n\tdescription := r.FormValue(\"description\")\n\tcreatedBy := r.FormValue(\"created_by\")\n\n\tticket := models.Ticket{\n\t\tTitle:       title,\n\t\tDescription: description,\n\t\tCreatedBy:   createdBy,\n\t}\n\n\tif err := ticket.Create(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"Ticket created successfully\")\n}\n\nfunc getTicket(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"GET\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tid := r.URL.Query().Get(\"id\")\n\n\tticket, err := models.GetTicket(id)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"Ticket: %v\", ticket)\n}\n\nfunc updateTicket(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"PUT\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tid := r.FormValue(\"id\")\n\tstatus := r.FormValue(\"status\")\n\n\tif err := models.UpdateTicketStatus(id, status); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"Ticket status updated successfully\")\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID       int\n\tUsername string\n\tPassword string\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/mydb\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT id, username, password FROM users WHERE username=?\", \"johndoe\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tvar user User\n\tfor rows.Next() {\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Password)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"User: %+v\\n\", user)\n}"}
{"sample": "// Parse and handle form data from the request\nfunc ParseFormData(request *http.Request) error {\n\tif err := request.ParseForm(); err != nil {\n\t\treturn err\n\t}\n\t// Access form data using request.Form\n\treturn nil\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// ReverseString reverses a given string and returns the result.\nfunc ReverseString(str string) string {\n\tchars := []rune(str)\n\tfor i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {\n\t\tchars[i], chars[j] = chars[j], chars[i]\n\t}\n\treturn string(chars)\n}"}
{"sample": "func main() {\n\tconfig := Configuration{}\n\n\tfile, err := os.Open(\"config.json\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening config file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tdecoder := json.NewDecoder(file)\n\terr = decoder.Decode(&config)\n\tif err != nil {\n\t\tfmt.Println(\"Error decoding JSON:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Config:\", config)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\nfunc main() {\n\tquit := make(chan os.Signal)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-quit\n\t\tfmt.Println(\"Received termination signal\")\n\t\tos.Exit(0)\n\t}()\n\n\tfmt.Println(\"Waiting for termination signal\")\n\tselect {}\n}"}
{"sample": "package main\n\nfunc main() {\n\tresult := AddNumbers(5, 7)\n\tfmt.Println(result)\n}\n\nfunc AddNumbers(a, b int) int {\n\treturn a + b\n}"}
{"sample": "func main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "func main() {\n\tvar wg sync.WaitGroup\n\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine 1 executed\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(3 * time.Second)\n\t\tfmt.Println(\"Goroutine 2 executed\")\n\t}()\n\n\twg.Wait()\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintIsNumberDivisibleBy(10, 5)\n}\n\n// Function to check if a number is divisible by another number\nfunc PrintIsNumberDivisibleBy(n, m int) {\n\tfmt.Println(n%m == 0)\n}"}
{"sample": "// Query executes a query on a database.\nfunc Query(db *sql.DB, query string) (*sql.Rows, error) {\n\treturn db.Query(query)\n}\n\n// Execute executes a command on a database.\nfunc Execute(db *sql.DB, command string) (sql.Result, error) {\n\treturn db.Exec(command)\n}"}
{"sample": "// Set a request header with the specified key and value\nfunc SetHeader(request *http.Request, key, value string) {\n\trequest.Header.Set(key, value)\n}\n"}
{"sample": "package main\n\nfunc CheckPalindromeLinkedList(head *ListNode) bool {\n\tfast := head\n\tslow := head\n\tstack := []int{}\n\tfor fast != nil && fast.Next != nil {\n\t\tstack = append(stack, slow.Val)\n\t\tslow = slow.Next\n\t\tfast = fast.Next.Next\n\t}\n\tif fast != nil {\n\t\tslow = slow.Next\n\t}\n\tfor slow != nil {\n\t\ttop := len(stack) - 1\n\t\tif slow.Val != stack[top] {\n\t\t\treturn false\n\t\t}\n\t\tslow = slow.Next\n\t\tstack = stack[:top]\n\t}\n\treturn true\n}\n"}
{"sample": "// CopyFile copies a file from src to dst.\nfunc CopyFile(src, dst string) error {\n\tinput, err := ioutil.ReadFile(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(dst, input, 0644)\n}\n\n// MoveFile moves a file from src to dst.\nfunc MoveFile(src, dst string) error {\n\treturn os.Rename(src, dst)\n}"}
{"sample": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc main() {\n\tapiKey := \"abcdefghijklmnopqrstuvwxyz\"\n\tapiSecret := \"0123456789\"\n\n\tclient := http.Client{}\n\n\t// Add authentication parameters to POST request\n\tdata := url.Values{}\n\tdata.Add(\"param1\", \"value1\")\n\tdata.Add(\"param2\", \"value2\")\n\treq, err := http.NewRequest(\"POST\", \"https://api.example.com/resource\", bytes.NewBufferString(data.Encode()))\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.SetBasicAuth(apiKey, apiSecret)\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Retrieve response body and check for errors\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif resp.StatusCode != 200 {\n\t\tpanic(fmt.Errorf(\"Request returned a non-success http code of %v and body: %v\", resp.StatusCode, string(body)))\n\t}\n\n\t// Print out the results\n\tfmt.Printf(\"API response is: %v\\n\", string(body) \"\")\n}"}
{"sample": "// Copyright \u00a9 2013-2016 Galvanized Logic Inc.\n// Use is governed by a BSD-style license found in the LICENSE file.\n\npackage main\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/gazed/vu\"\n\t\"github.com/gazed/vu/math/lin\"\n)\n\n// hud is the 2D controller for all parts of the games heads-up-display (HUD).\ntype hud struct {\n\tui   *vu.Ent  // 2D scene.\n\tarea          // Hud fills up the full screen.\n\tpl   *player  // Player model.\n\txp   *xpbar   // Show cores collected and current energy.\n\tmm   *minimap // Show overhead map centered on player.\n\tce   *vu.Ent  // Cloaking effect.\n\tte   *vu.Ent  // Teleport effect.\n\tee   *vu.Ent  // Energy loss effect.\n}\n\n// newHud creates all the various parts of the heads up display.\nfunc newHud(eng vu.Eng, sentryCount, wx, wy, ww, wh int) *hud {\n\thd := &hud{}\n\thd.ui = eng.AddScene().SetUI()\n\thd.ui.Cam().SetClip(0, 10)\n\thd.setSize(wx, wy, ww, wh)\n\n\t// create the HUD parts.\n\thd.pl = newPlayer(hd.ui.AddPart(), hd.w, hd.h)\n\thd.xp = newXpbar(hd.ui, hd.w, hd.h)\n\thd.mm = newMinimap(eng, sentryCount)\n\thd.ce = hd.cloakingEffect(hd.ui.AddPart())\n\thd.te = hd.teleportEffect(hd.ui.AddPart())\n\thd.ee = hd.energyLossEffect(hd.ui.AddPart())\n\thd.resize(hd.w, hd.h)\n\treturn hd\n}\n\n// setSize adjusts the size of the hud to the current screen dimensions.\nfunc (hd *hud) setSize(screenX, screenY, screenWidth, screenHeight int) {\n\thd.x, hd.y, hd.w, hd.h = 0, 0, screenWidth, screenHeight\n\thd.cx, hd.cy = hd.center()\n}\n\n// resize adapts the overlay to a new window size.\nfunc (hd *hud) resize(screenWidth, screenHeight int) {\n\thd.setSize(0, 0, screenWidth, screenHeight)\n\thd.xp.resize(screenWidth, screenHeight)\n\thd.mm.resize(screenWidth, screenHeight)\n\n\t// resize the animation effects.\n\thd.ce.SetScale(float64(hd.w), float64(hd.h), 1)\n\thd.ce.SetAt(hd.cx, hd.cy, -1)\n\thd.te.SetScale(float64(hd.w), float64(hd.h), 1)\n\thd.te.SetAt(hd.cx, hd.cy, -1)\n\thd.ee.SetScale(float64(hd.w), float64(hd.h), 1)\n\thd.ee.SetAt(hd.cx, hd.cy, -1)\n}\n\n// setVisible turns the HUD on/off. This is used when transitioning\n// between levels.\nfunc (hd *hud) setVisible(isVisible bool) {\n\thd.ui.Cull(!isVisible)\n\thd.mm.setVisible(isVisible)\n}\n\n// setLevel is called when a level transition happens.\nfunc (hd *hud) setLevel(lvl *level) {\n\thd.pl.setLevel(lvl)\n\thd.xp.setLevel(lvl)\n\thd.mm.setLevel(lvl.cam, lvl)\n}\n\n// have the hud wrap the minimap specifics so as to provide a single\n// outside interface.\nfunc (hd *hud) addWall(gamex, gamez float64)              { hd.mm.addWall(gamex, gamez) }\nfunc (hd *hud) remCore(gamex, gamez float64)              { hd.mm.remCore(gamex, gamez) }\nfunc (hd *hud) addCore(gamex, gamez float64)              { hd.mm.addCore(gamex, gamez) }\nfunc (hd *hud) resetCores()                               { hd.mm.resetCores() }\nfunc (hd *hud) update(c *vu.Camera, sentries []*sentinel) { hd.mm.update(c, sentries) }\n\n// cloakingEffect creates the model shown when the user cloaks.\nfunc (hd *hud) cloakingEffect(ce *vu.Ent) *vu.Ent {\n\tce.Cull(true)\n\tce.MakeModel(\"textured\", \"msh:icon\", \"tex:cloakon\")\n\tce.SetAlpha(0.5)\n\treturn ce\n}\nfunc (hd *hud) cloakingActive(isActive bool) { hd.ce.Cull(!isActive) }\n\n// teleportEffect creates the model shown when the user teleports.\nfunc (hd *hud) teleportEffect(te *vu.Ent) *vu.Ent {\n\tte.Cull(true)\n\tm := te.MakeModel(\"uvra\", \"msh:icon\", \"tex:smoke\")\n\tm.SetAlpha(0.5).SetUniform(\"spin\", 10.0).SetUniform(\"fd\", 1000)\n\treturn te\n}\nfunc (hd *hud) teleportActive(isActive bool) { hd.te.Cull(!isActive) }\nfunc (hd *hud) teleportFade(alpha float64) {\n\thd.te.SetAlpha(lin.Clamp(alpha, 0, 1))\n}\n\n// energyLossEffect creates the model shown when the player gets hit\n// by a sentinel.\nfunc (hd *hud) energyLossEffect(ee *vu.Ent) *vu.Ent {\n\tee.Cull(true)\n\tm := ee.MakeModel(\"uvra\", \"msh:icon\", \"tex:loss\")\n\tm.SetAlpha(0.5).SetUniform(\"fd\", 1000).SetUniform(\"spin\", 2.0)\n\treturn ee\n}\nfunc (hd *hud) energyLossActive(isActive bool) { hd.ee.Cull(!isActive) }\nfunc (hd *hud) energyLossFade(alpha float64) {\n\thd.ee.SetAlpha(lin.Clamp(alpha, 0, 1))\n}\n\n// hud\n// ===========================================================================\n// player\n\n// player shows the trooper model that corresponds to the player. This allows\n// an alternative view, albeit less useful, of the current players health.\n//\n// Player can ignore resizes since it is in the lower left corner.\ntype player struct {\n\tcx, cy float64  // Center location.\n\tplayer *trooper // Composite model of the player.\n\tbg     *vu.Ent  // Health status background.\n}\n\n// newPlayer sets the player hud location and creates the white background.\nfunc newPlayer(pov *vu.Ent, screenWidth, screenHeight int) *player {\n\tpl := &player{}\n\tpl.cx, pl.cy = 100, 100\n\tpl.bg = pov.SetScale(110, 110, 1).SetAt(pl.cx, pl.cy, 0)\n\tpl.bg.MakeModel(\"textured\", \"msh:icon\", \"tex:hudbg\")\n\treturn pl\n}\n\n// setLevel gives the player its tilt. Note that nothing else\n// uses the player rotation/location fields.\nfunc (pl *player) setLevel(lvl *level) {\n\tpl.player = lvl.player\n\n\t// twist the player about 15 degrees around X and 15 degrees around Z.\n\tpl.player.part.SetView(&lin.Q{X: 0.24, Y: 0.16, Z: 0.16, W: 0.95})\n\tpl.player.part.SetAt(pl.cx, pl.cy, 0)\n}\n\n// player\n// ===========================================================================\n// xpbar\n\n// xpbar reflects the players health and energy statistics using different\n// progress bars.\ntype xpbar struct {\n\tarea\n\tborder int      // Offset from the edge of the screen.\n\tlinew  int      // Line width for the box.\n\tbh, bw int      // Bar height and width.\n\tbg     *vu.Ent  // Health background bar.\n\tfg     *vu.Ent  // Health foreground bar.\n\tcbg    *vu.Ent  // Cloak energy background bar.\n\tcfg    *vu.Ent  // Cloak energy foreground bar.\n\ttbg    *vu.Ent  // Teleport energy background bar.\n\ttfg    *vu.Ent  // Teleport energy foreground bar.\n\thb     *vu.Ent  // Display health amount.\n\thbw    int      // Display health width in pixels.\n\ttk     *vu.Ent  // Display teleport key.\n\ttkw    int      // Display key width in pixels.\n\tck     *vu.Ent  // Display cloak key.\n\tckw    int      // Display key width in pixels.\n\ttr     *trooper // Current player injected with SetStage.\n}\n\n// newXpbar creates all three status bars.\nfunc newXpbar(scene *vu.Ent, screenWidth, screenHeight int) *xpbar {\n\txp := &xpbar{}\n\txp.border = 5\n\txp.linew = 2\n\txp.setSize(screenWidth, screenHeight)\n\n\t// add the xp background and foreground bars.\n\txp.bg = scene.AddPart()\n\txp.bg.MakeModel(\"colored\", \"msh:square\", \"mat:tgray\")\n\txp.fg = scene.AddPart()\n\txp.fg.MakeModel(\"textured\", \"msh:icon\", \"tex:xpcyan\", \"tex:xpred\")\n\n\t// add the xp bar text.\n\txp.hb = scene.AddPart()\n\txp.hb.MakeLabel(\"labeled\", \"lucidiaSu22\")\n\n\t// teleport energy background and foreground bars.\n\txp.tbg = scene.AddPart()\n\txp.tbg.MakeModel(\"colored\", \"msh:square\", \"mat:tgray\")\n\txp.tfg = scene.AddPart()\n\txp.tfg.MakeModel(\"textured\", \"msh:icon\", \"tex:xpblue\", \"tex:xpred\")\n\n\t// the teleport bar text.\n\txp.tk = scene.AddPart().MakeLabel(\"labeled\", \"lucidiaSu18\")\n\n\t// cloak energy background and foreground bars.\n\txp.cbg = scene.AddPart()\n\txp.cbg.MakeModel(\"colored\", \"msh:square\", \"mat:tgray\")\n\txp.cfg = scene.AddPart()\n\txp.cfg.MakeModel(\"textured\", \"msh:icon\", \"tex:xpblue\")\n\n\t// the cloak bar text.\n\txp.ck = scene.AddPart().MakeLabel(\"labeled\", \"lucidiaSu18\")\n\txp.resize(screenWidth, screenHeight)\n\treturn xp\n}\n\n// resize adjusts the graphics to fit the new window dimensions.\nfunc (xp *xpbar) resize(screenWidth, screenHeight int) {\n\txp.setSize(screenWidth, screenHeight)\n\txp.bg.SetAt(xp.cx+5, xp.cy+5, 1)\n\txp.bg.SetScale(float64(xp.bw/2), float64(xp.bh-xp.y), 1)\n\n\t// adjust the teleport energy bar.\n\txp.tbg.SetAt(xp.cx-float64(xp.w)/10, xp.cy+35, 1)\n\txp.tbg.SetScale(float64(xp.bw/10), float64(xp.bh-xp.y)-5, 1)\n\tbw := xp.tkw\n\txp.tk.SetAt(xp.cx-float64(xp.bw)/10-float64(bw/2), xp.cy+26, 0)\n\n\t// adjust the cloaking energy bar.\n\txp.cbg.SetAt(xp.cx+float64(xp.bw)/10, xp.cy+35, 1)\n\txp.cbg.SetScale(float64(xp.bw/10), float64(xp.bh-xp.y)-5, 1)\n\tbw = xp.ckw\n\txp.ck.SetAt(xp.cx+float64(xp.bw)/10-float64(bw/2), xp.cy+26, 0)\n\n\t// adjust the energy amounts for the bars.\n\tif xp.tr != nil {\n\t\txp.healthUpdated(xp.tr.health())\n\t\txp.energyUpdated(xp.tr.energy())\n\t}\n}\n\n// setSize adjusts the xpbars area according to the given screen dimensions.\nfunc (xp *xpbar) setSize(screenWidth, screenHeight int) {\n\txp.x, xp.y = 5, 5 // bottom left corner.\n\txp.w, xp.h = screenWidth, screenHeight\n\txp.bw, xp.bh = screenWidth-2*xp.border, 20\n\txp.cx, xp.cy = float64(screenWidth)*0.5-float64(xp.border), float64(xp.bh)*0.5+float64(xp.border)\n}\n\n// healthMonitor:healthUpdated. Updates the health banner when it changes.\nfunc (xp *xpbar) healthUpdated(health, warn, high int) {\n\tmaxCores := high / gameCellGain[xp.tr.lvl-1]\n\tcoresNeeded := (high - health) / gameCellGain[xp.tr.lvl-1]\n\tcoreCount := strconv.Itoa(maxCores-coresNeeded) + \"/\" + strconv.Itoa(maxCores)\n\txp.hb.SetStr(coreCount)\n\txp.hbw, _ = xp.hb.Size()\n\txp.hb.SetAt(xp.cx-float64(xp.hbw/2), xp.cy*0.5, 0)\n\n\t// turn on the warning colour if player has less than the starting amount of cores.\n\tbarMax := float64(xp.bw/2 - xp.linew)\n\tif health >= warn {\n\t\txp.fg.SetFirst(\"xpcyan\")\n\t} else {\n\t\txp.fg.SetFirst(\"xpred\")\n\t}\n\thealthBar := float64(health) / float64(high) * barMax\n\tzeroSpot := float64(xp.border) + healthBar + float64(xp.linew-xp.border)\n\txp.fg.SetAt(zeroSpot+5, xp.cy+5, 0)\n\txp.fg.SetScale(healthBar, float64(xp.bh-xp.y-xp.linew)-1, 1)\n}\n\n// energyMonitor:energyUpdated. Update the energy banner when it changes.\nfunc (xp *xpbar) energyUpdated(teleportEnergy, tmax, cloakEnergy, cmax int) {\n\ttratio := float64(teleportEnergy) / float64(tmax)\n\tif tratio == 1.0 {\n\t\txp.tfg.SetFirst(\"xpblue\")\n\t} else {\n\t\txp.tfg.SetFirst(\"xpred\")\n\t}\n\txp.tfg.SetAt(xp.cx-float64(xp.w)/10, xp.cy+35, 0)\n\txp.tfg.SetScale((float64(xp.bw/10))*tratio, float64(xp.bh-xp.y)-7, 1)\n\tcratio := float64(cloakEnergy) / float64(cmax)\n\txp.cfg.SetAt(xp.cx+float64(xp.w)/10-1, xp.cy+35, 0)\n\txp.cfg.SetScale((float64(xp.bw/10))*cratio, float64(xp.bh-xp.y)-7, 1)\n}\n\n// setLevel sets the xpbars values and must be called at least once before rendering.\nfunc (xp *xpbar) setLevel(lvl *level) {\n\txp.tr = lvl.player\n\txp.tr.monitorHealth(\"xpbar\", xp)\n\txp.tr.monitorEnergy(\"xpbar\", xp)\n\txp.healthUpdated(xp.tr.health())\n\txp.energyUpdated(xp.tr.energy())\n}\n\n// updateKeys needs to be called on startup and whenever the displayed key\n// mappings are changed.\nfunc (xp *xpbar) updateKeys(teleportKey, cloakKey int) {\n\tif xp.tk != nil && xp.ck != nil {\n\t\tif tsym := vu.Symbol(teleportKey); tsym > 0 {\n\t\t\txp.tk.SetStr(string(tsym))\n\t\t}\n\t\tif csym := vu.Symbol(cloakKey); csym > 0 {\n\t\t\txp.ck.SetStr(string(csym))\n\t\t}\n\t}\n}\n\n// xpbar\n// ===========================================================================\n// minimap\n\n// minimap displays a limited portion of the current level from the overhead\n// 2D perspective.\ntype minimap struct {\n\tui     *vu.Ent   // 2D overlay scene.\n\tarea             // Rectangular area.\n\tcores  []*vu.Ent // Keep track of the cores for removal.\n\ttop    *vu.Ent   // Map scale and position on screen.\n\troot   *vu.Ent   // Reposition map as player move.s\n\tbg     *vu.Ent   // The white background.\n\tscale  float64   // Minimap sizing.\n\tppm    *vu.Ent   // Player position marker.\n\tcpm    *vu.Ent   // Center of map position marker.\n\tspms   []*vu.Ent // Sentry position markers.\n\tradius int       // Limits map visibility. Distance squared in pixels.\n}\n\n// newMinimap initializes the minimap. It still needs to be populated.\nfunc newMinimap(eng vu.Eng, numTroops int) *minimap {\n\tmm := &minimap{}\n\tmm.radius = 120\n\tmm.scale = 5.0\n\tmm.cores = []*vu.Ent{}\n\tmm.ui = eng.AddScene().SetUI()\n\tmm.ui.Cam().SetClip(0, 10)\n\tmm.ui.SetCuller(mm) // mm implements Culler\n\n\t// parent for all the visible minimap pieces.\n\tmm.top = mm.ui.AddPart().SetScale(mm.scale, mm.scale, 1)\n\tmm.root = mm.top.AddPart()\n\n\t// add the white background to highlight player marker.\n\tmm.bg = mm.root.AddPart().SetScale(110, 110, 1)\n\tmm.bg = mm.root.AddPart().SetScale(110, 110, 1)\n\tmm.bg.MakeModel(\"textured\", \"msh:icon\", \"tex:hudbg\")\n\n\t// create the sentinel position markers\n\tmm.spms = []*vu.Ent{}\n\tfor cnt := 0; cnt < numTroops; cnt++ {\n\t\ttpm := mm.root.AddPart()\n\t\ttpm.MakeModel(\"colored\", \"msh:square\", \"mat:tred\")\n\t\tmm.spms = append(mm.spms, tpm)\n\t}\n\n\t// create the player marker and center map marker.\n\tmm.cpm = mm.root.AddPart()\n\tmm.cpm.MakeModel(\"colored\", \"msh:square\", \"mat:blue\")\n\tmm.ppm = mm.root.AddPart()\n\tmm.ppm.MakeModel(\"colored\", \"msh:tri\", \"mat:tblack\")\n\treturn mm\n}\n\n// setVisible (un)hides all the minimap objects.\nfunc (mm *minimap) setVisible(isVisible bool) {\n\tmm.ui.Cull(!isVisible)\n}\n\n// Culled returns true if the given Pov is to far away from the player.\n// Used to limit the minimap view to map elements close to the player.\nfunc (mm *minimap) Culled(cam *vu.Camera, wx, wy, wz float64) bool {\n\tpx, py, _ := mm.ppm.World()\n\tdx := px - wx\n\tdy := py - wy\n\treturn (dx*dx + dy*dy) > float64(mm.radius*mm.radius)\n}\n\n// resize is responsible for keeping the minimap at the bottom\n// right corner of the application window.\nfunc (mm *minimap) resize(width, height int) {\n\tmm.x, mm.y, mm.w, mm.h = width-mm.radius-10, 125, width, height\n\tmm.top.SetAt(float64(mm.x), float64(mm.y), 0)\n}\n\n// setLevel is called when a level transition happens.\nfunc (mm *minimap) setLevel(cam *vu.Camera, lvl *level) {\n\tx, _, z := cam.At()\n\n\t// adjust the center location based on the game maze center.\n\tmm.cx, mm.cy = float64(lvl.gcx*lvl.units), float64(lvl.gcy*lvl.units)\n\tmm.ppm.SetAt(x, -z, 0)\n\tmm.bg.SetAt(x, -z, 0)\n\tmm.ppm.SetAa(0, 0, 1, lin.Rad(cam.Yaw))\n\tmm.setSentryAt(lvl.sentries)\n\tlvl.player.monitorHealth(\"mmap\", mm)\n}\n\n// addWall adds a block representing a wall to the minimap.\nfunc (mm *minimap) addWall(x, y float64) {\n\twall := mm.root.AddPart().SetAt(x, -y, 0)\n\twall.MakeModel(\"colored\", \"msh:square\", \"mat:gray\")\n}\n\n// addCore adds a small block representing an energy core to the minimap.\nfunc (mm *minimap) addCore(gamex, gamez float64) {\n\tcm := mm.root.AddPart().SetAt(gamex, -gamez, 0).SetScale(0.5, 0.5, 1)\n\tcm.MakeModel(\"colored\", \"msh:square\", \"mat:green\")\n\tmm.cores = append(mm.cores, cm)\n}\n\n// remCore removes a collected energy core from the minimap.\nfunc (mm *minimap) remCore(gamex, gamez float64) {\n\tgx, gy := lin.Round(gamex, 0), lin.Round(-gamez, 0)\n\tfor index, core := range mm.cores {\n\t\tcx, cy, _ := core.At()\n\t\tcx, cy = lin.Round(cx, 0), lin.Round(cy, 0)\n\t\tif cx == gx && cy == gy {\n\t\t\tcore.Dispose()\n\t\t\tmm.cores = append(mm.cores[:index], mm.cores[index+1:]...)\n\t\t\treturn\n\t\t}\n\t}\n\tlogf(\"hud.mapOverlay.remCore: failed to remove a core.\")\n}\n\n// resetCores is expected to be called when switching levels so that\n// this level is clear of cores the next time it is activated.\nfunc (mm *minimap) resetCores() {\n\tfor _, core := range mm.cores {\n\t\tcore.Dispose()\n\t}\n\tmm.cores = []*vu.Ent{}\n}\n\n// healthMonitor:healthUpdated. Update the center colour of the maze\n// based on the player health.\nfunc (mm *minimap) healthUpdated(health, warn, high int) {\n\tif health == high {\n\t\tmm.cpm.SetColor(0, 0.62, 0.6)\n\t} else {\n\t\tmm.cpm.SetColor(0.4, 0.5, 0.8)\n\t}\n}\n\n// update adjusts the minimap according to the players new position.\nfunc (mm *minimap) update(cam *vu.Camera, sentries []*sentinel) {\n\tx, _, z := cam.At()\n\tmm.root.SetAt(-x, z, 0)\n\tmm.setCenterAt(x, -z)\n\tmm.bg.SetAt(x, -z, 0)\n\tmm.ppm.SetAt(x, -z, 0)\n\tmm.ppm.SetAa(0, 0, 1, lin.Rad(cam.Yaw))\n\tmm.setSentryAt(sentries)\n}\n\n// set the position of the maze center marker. Ensure the center marker\n// is always visible to the player knows where the maze is if they wander\n// to far away.\nfunc (mm *minimap) setCenterAt(x, y float64) {\n\tradius := float64(mm.radius) / 5.1\n\ttoc := &lin.V3{X: x - mm.cx, Y: y - mm.cy, Z: 0} // vector from player to center\n\tdtoc := toc.Len()                                // distance to center\n\tmm.cpm.SetAt(mm.cx, mm.cy, 0)                    // set marker at center...\n\tif dtoc > radius {                               // ... unless the distance is to great\n\t\ttoc.Unit().Scale(toc, radius)\n\t\tmm.cpm.SetAt(x-toc.X, y-toc.Y, 0)\n\t}\n}\n\n// set the position for all the sentry markers.\nfunc (mm *minimap) setSentryAt(sentinels []*sentinel) {\n\tif len(mm.spms) != len(sentinels) {\n\t\tlogf(\"hud.minimap.setSentryAt: sentry length mismatch\")\n\t\treturn\n\t}\n\tfor cnt, sentry := range sentinels {\n\t\ttpm := mm.spms[cnt]\n\t\tx, _, z := sentry.location()\n\t\ttpm.SetAt(x, -z, 0)\n\t}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintSumOfArray([]int{1, 2, 3, 4, 5})\n}\n\n// Function to print the sum of elements in an array\nfunc PrintSumOfArray(arr []int) {\n\tsum := 0\n\tfor _, value := range arr {\n\t\tsum += value\n\t}\n\tfmt.Println(sum)\n}"}
{"sample": "package main\n\nfunc LinearSearch(arr []int, target int) int {\n\tfor i, num := range arr {\n\t\tif num == target {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n"}
{"sample": "func ShellSort(arr []int) []int {\n\tgap := len(arr) / 2\n\tfor gap > 0 {\n\t\tfor i := gap; i < len(arr); i++ {\n\t\t\ttemp := arr[i]\n\t\t\tj := i\n\t\t\tfor ; j >= gap && arr[j-gap] > temp; j -= gap {\n\t\t\t\tarr[j] = arr[j-gap]\n\t\t\t}\n\t\t\tarr[j] = temp\n\t\t}\n\t\tgap /= 2\n\t}\n\treturn arr\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\tfmt.Println(\"Starting work...\")\n\ttime.Sleep(time.Second * 2)\n\tfmt.Println(\"Finished work!\")\n\telapsed := time.Since(start)\n\tfmt.Printf(\"Time elapsed: %v\\n\", elapsed)\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\nfunc main() {\n\tdb, err := sql.Open(\"sqlite3\", \"test.db\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to SQLite database:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL)\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating table:\", err)\n\t\treturn\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (name) VALUES ('John Doe')\")\n\tif err != nil {\n\t\tfmt.Println(\"Error inserting into table:\", err)\n\t\treturn\n\t}\n\n\trows, err := db.Query(\"SELECT id, name FROM users\")\n\tif err != nil {\n\t\tfmt.Println(\"Error querying table:\", err)\n\t\treturn\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\terr = rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error scanning row:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Println(id, name)\n\t}\n}"}
{"sample": "func queryRow(stmt *sql.Stmt, args ...interface{}) *sql.Row {\n\trow := stmt.QueryRow(args...)\n\treturn row\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintMaxOfArray([]int{1, 2, 3, 4, 5})\n}\n\n// Function to print the maximum element in an array\nfunc PrintMaxOfArray(arr []int) {\n\tmax := arr[0]\n\tfor _, value := range arr {\n\t\tif value > max {\n\t\t\tmax = value\n\t\t}\n\t}\n\tfmt.Println(max)\n}"}
{"sample": "// CurrentTime returns the current time in the specified format.\nfunc CurrentTime(format string) string {\n\treturn time.Now().Format(format)\n}\n\n// ParseTime parses a string into time.Time according to the specified format.\nfunc ParseTime(s, format string) (time.Time, error) {\n\treturn time.Parse(format, s)\n}"}
{"sample": "// Copyright 2021 The Matrix.org Foundation C.I.C.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage router\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/matrix-org/pinecone/types\"\n)\n\n// SourceAddr implements net.Addr, containing a source-routed\n// path to another node.\ntype SourceAddr struct {\n\ttypes.SwitchPorts\n}\n\nfunc (a *SourceAddr) Network() string {\n\treturn \"ps\"\n}\n\nfunc (a *SourceAddr) String() string {\n\treturn fmt.Sprintf(\"path %v\", a.SwitchPorts)\n}\n\n// GreedyAddr implements net.Addr, containing a greedy-routed\n// set of destination coordinates to another node.\ntype GreedyAddr struct {\n\ttypes.SwitchPorts\n}\n\nfunc (a *GreedyAddr) Network() string {\n\treturn \"pg\"\n}\n\nfunc (a *GreedyAddr) String() string {\n\treturn fmt.Sprintf(\"coords %v\", a.SwitchPorts)\n}\n\n// ReadFrom reads the next packet that was delivered to this\n// node over the Pinecone network. Only traffic packets will\n// be returned here - no protocol messages will be included.\n// The net.Addr returned will contain the appropriate return\n// path based on the mechanism used to deliver the packet.\n// If the packet was delivered using greedy routing, then the\n// net.Addr will contain the source coordinates. If the packet\n// was delivered using source routing, then the net.Addr will\n// contain the source-routed path back to the sender.\nfunc (r *Router) ReadFrom(p []byte) (n int, addr net.Addr, err error) {\n\tframe := <-r.recv\n\tswitch frame.Type {\n\tcase types.TypeGreedy:\n\t\taddr = &GreedyAddr{frame.Source}\n\n\tcase types.TypeSource:\n\t\taddr = &SourceAddr{frame.Source} // TODO: should get the remainder of the path\n\n\tcase types.TypeVirtualSnakeBootstrap:\n\t\taddr = &frame.SourceKey\n\n\tcase types.TypeVirtualSnake:\n\t\taddr = &frame.SourceKey\n\n\tdefault:\n\t\tr.log.Println(\"Not expecting non-source/non-greedy frame\")\n\t\treturn\n\t}\n\n\tn = len(frame.Payload)\n\tcopy(p, frame.Payload)\n\treturn\n}\n\n// WriteTo sends a packet into the Pinecone network. The\n// packet will be sent as a traffic packet. The net.Addr must\n// be one of the Pinecone address types (e.g. GreedyAddr or\n// SourceAddr), as this will dictate the method of delivery\n// used to forward the packet.\nfunc (r *Router) WriteTo(p []byte, addr net.Addr) (n int, err error) {\n\ttimer := time.NewTimer(time.Second * 5)\n\tdefer func() {\n\t\tif !timer.Stop() {\n\t\t\t<-timer.C\n\t\t}\n\t}()\n\n\tswitch ga := addr.(type) {\n\tcase *GreedyAddr:\n\t\tselect {\n\t\tcase <-timer.C:\n\t\t\treturn 0, fmt.Errorf(\"router appears to be deadlocked\")\n\t\tcase r.send <- types.Frame{\n\t\t\tVersion:     types.Version0,\n\t\t\tType:        types.TypeGreedy,\n\t\t\tDestination: ga.SwitchPorts,\n\t\t\tSource:      r.Coords(),\n\t\t\tPayload:     p,\n\t\t}:\n\t\t\treturn len(p), nil\n\t\t}\n\n\tcase *SourceAddr:\n\t\tselect {\n\t\tcase <-timer.C:\n\t\t\treturn 0, fmt.Errorf(\"router appears to be deadlocked\")\n\t\tcase r.send <- types.Frame{\n\t\t\tVersion:     types.Version0,\n\t\t\tType:        types.TypeSource,\n\t\t\tDestination: ga.SwitchPorts,\n\t\t\tPayload:     p,\n\t\t}:\n\t\t\treturn len(p), nil\n\t\t}\n\n\tcase *types.PublicKey:\n\t\tselect {\n\t\tcase <-timer.C:\n\t\t\treturn 0, fmt.Errorf(\"router appears to be deadlocked\")\n\t\tcase r.send <- types.Frame{\n\t\t\tVersion:        types.Version0,\n\t\t\tType:           types.TypeVirtualSnake,\n\t\t\tDestinationKey: *ga,\n\t\t\tSourceKey:      r.PublicKey(),\n\t\t\tPayload:        p,\n\t\t}:\n\t\t\treturn len(p), nil\n\t\t}\n\n\tdefault:\n\t\terr = fmt.Errorf(\"unknown address type\")\n\t\treturn\n\t}\n}\n\n// LocalAddr returns a net.Addr containing the greedy routing\n// coordinates for this node.\nfunc (r *Router) LocalAddr() net.Addr {\n\tpublic := r.PublicKey()\n\treturn &public\n}\n\n// SetDeadline is not implemented.\nfunc (r *Router) SetDeadline(t time.Time) error {\n\treturn nil\n}\n\n// SetReadDeadline is not implemented.\nfunc (r *Router) SetReadDeadline(t time.Time) error {\n\treturn nil\n}\n\n// SetWriteDeadline is not implemented.\nfunc (r *Router) SetWriteDeadline(t time.Time) error {\n\treturn nil\n}\n"}
{"sample": "// Check if a given number is even\nfunc IsEven(num int) bool {\n\treturn num%2 == 0\n}\n"}
{"sample": "func dropIndex(db *sql.DB) error {\n\tstmt, err := db.Prepare(\"DROP INDEX IF EXISTS idx_name\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package main\n\n// Rename a file\nfunc main() {\n\terr := os.Rename(\"oldname.txt\", \"newname.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package wsmanage\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\ntype Client struct {\n\tconn *websocket.Conn\n\tsend chan []byte\n}\n\ntype Manager struct {\n\tclients map[*Client]bool\n\tbroadcast chan []byte\n\tregister chan *Client\n\tunregister chan *Client\n}\n\nfunc (m *Manager) Start() {\n\tfor {\n\t\tselect {\n\t\tcase client := <-m.register:\n\t\t\tm.clients[client] = true\n\t\tcase client := <-m.unregister:\n\t\t\tif _, ok := m.clients[client]; ok {\n\t\t\t\tdelete(m.clients, client)\n\t\t\t\tclose(client.send)\n\t\t\t}\n\t\tcase message := <-m.broadcast:\n\t\t\tfor client := range m.clients {\n\t\t\t\tselect {\n\t\t\t\tcase client.send <- message:\n\t\t\t\tdefault:\n\t\t\t\t\tclose(client.send)\n\t\t\t\t\tdelete(m.clients, client)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *Client) Read() {\n\tdefer func() {\n\t\tc.conn.Close()\n\t}()\n\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tmanager.broadcast <- message\n\t}\n}\n\nfunc (c *Client) Write() {\n\tdefer func() {\n\t\tc.conn.Close()\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase message, ok := <-c.send:\n\t\t\tif !ok {\n\t\t\t\tc.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.conn.WriteMessage(websocket.TextMessage, message)\n\t\t}\n\t}\n}\n\nfunc handleWebSocket(manager *Manager, w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tclient := &Client{conn: conn, send: make(chan []byte, 256)}\n\tmanager.register <- client\n\n\tgo client.Read()\n\tgo client.Write()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\tfileNames, err := ioutil.ReadDir(\".\")\n\tif err != nil {\n\t\tfmt.Println(\"Error reading directory:\", err)\n\t\treturn\n\t}\n\n\tfor _, file := range fileNames {\n\t\tfmt.Println(file.Name())\n\t}\n}"}
{"sample": "// Find the maximum element in a matrix\nfunc FindMaxInMatrix(matrix [][]int) int {\n\tmax := matrix[0][0]\n\tfor _, row := range matrix {\n\t\tfor _, num := range row {\n\t\t\tif num > max {\n\t\t\t\tmax = num\n\t\t\t}\n\t\t}\n\t}\n\treturn max\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintIsNumberPrime(7)\n}\n\n// Function to check if a number is prime\nfunc PrintIsNumberPrime(n int) {\n\tif n <= 1 {\n\t\tfmt.Println(false)\n\t\treturn\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfmt.Println(false)\n\t\t\treturn\n\t\t}\n\t}\n\tfmt.Println(true)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://jsonplaceholder.typicode.com/posts\")\n\tif err != nil {\n\t\tfmt.Println(\"Error making HTTP request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// SortStrings sorts a slice of strings in lexicographical order.\nfunc SortStrings(strs []string) {\n\tsort.Strings(strs)\n}"}
{"sample": "func Fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\tvar n1, n2, fib int = 0, 1, 0\n\tfor i := 2; i <= n; i++ {\n\t\tfib = n1 + n2\n\t\tn1 = n2\n\t\tn2 = fib\n\t}\n\treturn fib\n}"}
{"sample": "type Cache struct {\n\tcache map[string]string\n}\n\nfunc NewCache() *Cache {\n\treturn &Cache{cache: make(map[string]string)}\n}\n\nfunc (c *Cache) Get(key string) (string, bool) {\n\tvalue, found := c.cache[key]\n\treturn value, found\n}\n\nfunc (c *Cache) Set(key, value string) {\n\tc.cache[key] = value\n}\n\nfunc (c *Cache) Delete(key string) {\n\tdelete(c.cache, key)\n}"}
{"sample": "/*\n * Copyright (c) 2017, MegaEase\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage spec\n\nimport (\n\t\"fmt\"\n\n\tk8sresource \"k8s.io/apimachinery/pkg/api/resource\"\n\n\t\"github.com/megaease/easegress/pkg/filter/requestadaptor\"\n\t\"github.com/megaease/easegress/pkg/object/httpserver\"\n)\n\nconst (\n\tAutoScaleMetricCPU         = \"cpu\"\n\tAutoScaleMetricConcurrency = \"concurrency\"\n\tAutoScaleMetricRPS         = \"rps\"\n\n\t// ProviderKnative is the faas provider Knative.\n\tProviderKnative = \"knative\"\n)\n\ntype (\n\t// Admin describes the Function.\n\tAdmin struct {\n\t\t// SyncInterval is the interval for reconciling local FaaSFunction state and FaaSProvider's.\n\t\tSyncInterval string `yaml:\"syncInterval\" jsonschema:\"required,format=duration\"`\n\n\t\t// Provider is the FaaSProvider.\n\t\tProvider string `yaml:\"provider\" jsonschema:\"required\"`\n\n\t\t// HTTPServer is the HTTP traffic gate for accepting ingress traffic.\n\t\tHTTPServer *httpserver.Spec `yaml:\"httpServer\" jsonschema:\"required\"`\n\n\t\t// Currently we only supports knative type faas provider, so this filed should be\n\t\t// \"required\" right now.\n\t\tKnative *Knative `yaml:\"knative\" jsonschema:\"required\"`\n\t}\n\n\t// Function contains the FaaSFunction's spec ,runtime status with a build-in fsm.\n\tFunction struct {\n\t\tSpec   *Spec   `yaml:\"spec\" jsonschema:\"required\"`\n\t\tStatus *Status `yaml:\"status\" jsonschema:\"required\"`\n\t\tFsm    *FSM    `yaml:\"fsm\" jsonschema:\"omitempty\"`\n\t}\n\n\t// Spec is the spec of FaaSFunction.\n\tSpec struct {\n\t\tName           string `yaml:\"name\" jsonschema:\"required\"`\n\t\tImage          string `yaml:\"image\" jsonschema:\"required\"`\n\t\tPort           int    `yaml:\"port\" jsonschema:\"omitempty\"`\n\t\tAutoScaleType  string `yaml:\"autoScaleType\" jsonschema:\"required\"`\n\t\tAutoScaleValue string `yaml:\"autoScaleValue\" jsonschema:\"required\"`\n\t\tMinReplica     int    `yaml:\"minReplica\" jsonschema:\"omitempty\"`\n\t\tMaxReplica     int    `yaml:\"maxReplica\" jsonschema:\"omitempty\"`\n\t\tLimitCPU       string `yaml:\"limitCPU\" jsonschema:\"omitempty\"`\n\t\tLimitMemory    string `yaml:\"limitMemory\" jsonschema:\"omitempty\"`\n\t\tRequestCPU     string `yaml:\"requestCPU\" jsonschema:\"omitempty\"`\n\t\tRequestMemory  string `yaml:\"requestMemory\" jsonschema:\"omitempty\"`\n\n\t\tRequestAdaptor *requestadaptor.Spec `yaml:\"requestAdaptor\" jsonschema:\"required\"`\n\t}\n\n\t// Status is the status of faas function.\n\tStatus struct {\n\t\tName    string            `yaml:\"name\" jsonschema:\"required\"`\n\t\tState   State             `yaml:\"state\" jsonschema:\"required\"`\n\t\tEvent   Event             `yaml:\"event\" jsonschema:\"required\"`\n\t\tExtData map[string]string `yaml:\"extData\" jsonschema:\"omitempty\"`\n\t}\n\n\t// Knative is the faas provider Knative.\n\tKnative struct {\n\t\tHostSuffix      string `yaml:\"hostSuffix\" jsonschema:\"required\"`\n\t\tNetworkLayerURL string `yaml:\"networkLayerURL\" jsonschema:\"required,format=uri\"`\n\n\t\tNamespace string `yaml:\"namespace\" jsonschema:\"omitempty\"`\n\t\tTimeout   string `yaml:\"timeout\" jsonschema:\"omitempty,format=duration\"`\n\t}\n)\n\n// Validate valid FaaSFunction's spec.\nfunc (spec *Spec) Validate() error {\n\tif spec.MinReplica > spec.MaxReplica {\n\t\treturn fmt.Errorf(\"invalided minreplica: %d and maxreplica: %d\", spec.MinReplica, spec.MaxReplica)\n\t}\n\n\tswitch spec.AutoScaleType {\n\tcase AutoScaleMetricCPU, AutoScaleMetricConcurrency, AutoScaleMetricRPS:\n\t\t//\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown autoscale type: %s\", spec.AutoScaleType)\n\t}\n\n\tcheckK8s := func() (errMsg error) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\terrMsg = fmt.Errorf(\"k8s resource value check failed: %v\", err)\n\t\t\t}\n\t\t}()\n\n\t\t// check if k8s resource valid or note\n\t\tk8sresource.MustParse(spec.LimitMemory)\n\t\tk8sresource.MustParse(spec.LimitCPU)\n\t\tk8sresource.MustParse(spec.RequestCPU)\n\t\tk8sresource.MustParse(spec.RequestMemory)\n\t\treturn\n\t}\n\n\treturn checkK8s()\n}\n\n// Next turns function's states into next states by given event.\nfunc (function *Function) Next(event Event) (updated bool, err error) {\n\tupdated = false\n\toldState := function.Fsm.Current()\n\terr = function.Fsm.Next(event)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif oldState != function.Fsm.Current() {\n\t\tupdated = true\n\t\tfunction.Status.State = function.Fsm.currentState\n\t}\n\tfunction.Status.Event = event\n\treturn\n}\n"}
{"sample": "package internal\n\nimport (\n\t\"fmt\"\n\tG \"github.com/ionous/sashimi/game\"\n\t\"github.com/ionous/sashimi/meta\"\n\t\"github.com/ionous/sashimi/util/ident\"\n)\n\n// FIX? because we store property path, we cant test for equality directly.\n// ( therefore changed to pointer value for gopherjs optimization )\ntype gameValue struct {\n\tgame  *GameEventAdapter\n\tpath  PropertyPath\n\tptype meta.PropertyType\n\tvalue meta.Value\n}\n\nfunc (n *gameValue) Num() (ret float64) {\n\tif n.ptype != meta.NumProperty {\n\t\tn.log(\"Num(): property is not a number.\")\n\t} else {\n\t\tret = n.value.GetNum()\n\t}\n\treturn\n}\n\nfunc (n *gameValue) SetNum(value float64) {\n\tif n.ptype != meta.NumProperty {\n\t\tn.log(\"SetNum(): property is not a number.\")\n\t} else if e := n.value.SetNum(value); e != nil {\n\t\tn.log(\"SetNum(): error setting value: %v.\", e)\n\t}\n}\n\nfunc (n *gameValue) Text() (ret string) {\n\tif n.ptype != meta.TextProperty {\n\t\tn.log(\"Text(): property is not text.\")\n\t} else {\n\t\tret = n.value.GetText()\n\t}\n\treturn\n}\n\nfunc (n *gameValue) SetText(text string) {\n\tif n.ptype != meta.TextProperty {\n\t\tn.log(\"SetText(): property is not text.\")\n\t} else if e := n.value.SetText(text); e != nil {\n\t\tn.log(\"SetText(): error setting value: %v.\", e)\n\t}\n}\n\n// TBD: should these be logged? its sure nice to have be able to test objects generically for properties\nfunc (n *gameValue) Object() G.IObject {\n\tvar res ident.Id\n\tif n.ptype != meta.ObjectProperty {\n\t\tn.log(\"Object(): property is not an object.\")\n\t} else {\n\t\tres = n.value.GetObject()\n\t}\n\treturn n.game.NewGameObjectFromId(res)\n}\n\nfunc (n *gameValue) SetObject(obj G.IObject) {\n\tif n.ptype != meta.ObjectProperty {\n\t\tn.log(\"SetObject(): property is not an object.\")\n\t} else {\n\t\tvar id ident.Id\n\t\tif obj != nil {\n\t\t\tid = obj.Id()\n\t\t}\n\t\tif e := n.value.SetObject(id); e != nil {\n\t\t\tn.log(\"SetObject(): error setting value: %v.\", e)\n\t\t}\n\t}\n}\n\nfunc (n *gameValue) State() (ret ident.Id) {\n\tif n.ptype != meta.StateProperty {\n\t\tn.log(\"State(): property is not a state.\")\n\t} else {\n\t\tret = n.value.GetState()\n\t}\n\treturn\n}\n\nfunc (n *gameValue) SetState(val ident.Id) {\n\tif n.ptype != meta.StateProperty {\n\t\tn.log(\"SetState(): property is not a state.\")\n\t} else if e := n.value.SetState(val); e != nil {\n\t\tn.log(\"SetState(): error setting value: %v.\", e)\n\t}\n}\n\nfunc (n *gameValue) log(format string, v ...interface{}) {\n\tsuffix := fmt.Sprintf(format, v...)\n\tn.game.Println(n.path, suffix)\n}\n"}
{"sample": "// Calculate the product of all elements in an array\nfunc CalculateProduct(arr []int) int {\n\tproduct := 1\n\tfor _, num := range arr {\n\t\tproduct *= num\n\t}\n\treturn product\n}\n"}
{"sample": "package mongodb\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\ntype User struct {\n\tName  string `bson:\"name\"`\n\tEmail string `bson:\"email\"`\n}\n\nfunc NewClient(uri string) (*mongo.Client, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tclient, err := mongo.Connect(ctx, options.Client().ApplyURI(uri))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = client.Ping(ctx, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfmt.Println(\"Connected to MongoDB\")\n\n\treturn client, nil\n}\n\nfunc InsertUser(client *mongo.Client, user User) error {\n\tcollection := client.Database(\"mydb\").Collection(\"users\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\t_, err := collection.InsertOne(ctx, user)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"User inserted successfully\")\n\n\treturn nil\n}\n\nfunc GetUser(client *mongo.Client, email string) (User, error) {\n\tcollection := client.Database(\"mydb\").Collection(\"users\")\n\n\tvar user User\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\terr := collection.FindOne(ctx, User{Email: email}).Decode(&user)\n\tif err != nil {\n\t\treturn User{}, err\n\t}\n\n\treturn user, nil\n}\n\nfunc Close(client *mongo.Client) {\n\terr := client.Disconnect(context.Background())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"MongoDB connection closed\")\n}"}
{"sample": "func main() {\n\tvar nums []int\n\n\tfor i := 0; i < 5; i++ {\n\t\tnum := rand.Intn(100)\n\t\tnums = append(nums, num)\n\t}\n\n\tfmt.Println(nums)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// CountDigits counts the number of digits in a given integer.\nfunc CountDigits(num int) int {\n\tcount := 0\n\tfor num != 0 {\n\t\tnum /= 10\n\t\tcount++\n\t}\n\treturn count\n}"}
{"sample": "package accountservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype User struct {\n\tID        string\n\tFirstName string\n\tLastName  string\n\tEmail     string\n\tPassword  string\n\tCreatedAt time.Time\n}\n\ntype AccountService struct {\n\tusers []*User\n}\n\nfunc NewAccountService() *AccountService {\n\treturn &AccountService{\n\t\tusers: []*User{},\n\t}\n}\n\nfunc (a *AccountService) CreateUser(ctx context.Context, user *User) error {\n\tif user == nil {\n\t\treturn errors.New(\"user is nil\")\n\t}\n\n\tif user.ID != \"\" {\n\t\treturn errors.New(\"user ID must be empty\")\n\t}\n\n\tuser.ID = uuid.New().String()\n\tuser.CreatedAt = time.Now()\n\n\ta.users = append(a.users, user)\n\n\tlog.Printf(\"User created: %v\", user)\n\n\treturn nil\n}\n\nfunc (a *AccountService) GetUser(ctx context.Context, id string) (*User, error) {\n\tfor _, user := range a.users {\n\t\tif user.ID == id {\n\t\t\treturn user, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"user not found: %s\", id)\n}\n\nfunc (a *AccountService) UpdateUser(ctx context.Context, user *User) error {\n\tif user == nil {\n\t\treturn errors.New(\"user is nil\")\n\t}\n\n\tif user.ID == \"\" {\n\t\treturn errors.New(\"user ID is empty\")\n\t}\n\n\tfor i, u := range a.users {\n\t\tif u.ID == user.ID {\n\t\t\ta.users[i] = user\n\t\t\tlog.Printf(\"User updated: %v\", user)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"user not found: %s\", user.ID)\n}\n\nfunc (a *AccountService) DeleteUser(ctx context.Context, id string) error {\n\tfor i, user := range a.users {\n\t\tif user.ID == id {\n\t\t\ta.users = append(a.users[:i], a.users[i+1:]...)\n\t\t\tlog.Printf(\"User deleted: %s\", id)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"user not found: %s\", id)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc generateNums(ctx context.Context, c chan<- int) {\n\trand.Seed(time.Now().UnixNano())\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(\"Closing sender goroutine\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tnum := rand.Intn(100)\n\t\t\tc <- num\n\t\t\tfmt.Printf(\"Sent number %d\\n\", num)\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}\n}\n\nfunc receiveNums(ctx context.Context, c <-chan int) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(\"Closing receiver goroutine\")\n\t\t\treturn\n\t\tcase num := <-c:\n\t\t\tfmt.Printf(\"Received number %d\\n\", num)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tc := make(chan int)\n\n\tgo generateNums(ctx, c)\n\tgo receiveNums(ctx, c)\n\n\tfmt.Println(\"Waiting for termination switch\")\n\ttime.Sleep(10 * time.Second)\n\tfmt.Println(\"Terminating...\")\n\tcancel()\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Done\")\n}"}
{"sample": "// Code generated by protoc-gen-go-grpc. DO NOT EDIT.\n\npackage optimus\n\nimport (\n\tcontext \"context\"\n\tgrpc \"google.golang.org/grpc\"\n\tcodes \"google.golang.org/grpc/codes\"\n\tstatus \"google.golang.org/grpc/status\"\n)\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the grpc package it is being compiled against.\n// Requires gRPC-Go v1.32.0 or later.\nconst _ = grpc.SupportPackageIsVersion7\n\n// ProjectServiceClient is the client API for ProjectService service.\n//\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.\ntype ProjectServiceClient interface {\n\t// RegisterProject creates a new optimus project\n\tRegisterProject(ctx context.Context, in *RegisterProjectRequest, opts ...grpc.CallOption) (*RegisterProjectResponse, error)\n\t// ListProjects returns list of registered projects and configurations\n\tListProjects(ctx context.Context, in *ListProjectsRequest, opts ...grpc.CallOption) (*ListProjectsResponse, error)\n}\n\ntype projectServiceClient struct {\n\tcc grpc.ClientConnInterface\n}\n\nfunc NewProjectServiceClient(cc grpc.ClientConnInterface) ProjectServiceClient {\n\treturn &projectServiceClient{cc}\n}\n\nfunc (c *projectServiceClient) RegisterProject(ctx context.Context, in *RegisterProjectRequest, opts ...grpc.CallOption) (*RegisterProjectResponse, error) {\n\tout := new(RegisterProjectResponse)\n\terr := c.cc.Invoke(ctx, \"/odpf.optimus.core.v1beta1.ProjectService/RegisterProject\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nfunc (c *projectServiceClient) ListProjects(ctx context.Context, in *ListProjectsRequest, opts ...grpc.CallOption) (*ListProjectsResponse, error) {\n\tout := new(ListProjectsResponse)\n\terr := c.cc.Invoke(ctx, \"/odpf.optimus.core.v1beta1.ProjectService/ListProjects\", in, out, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// ProjectServiceServer is the server API for ProjectService service.\n// All implementations must embed UnimplementedProjectServiceServer\n// for forward compatibility\ntype ProjectServiceServer interface {\n\t// RegisterProject creates a new optimus project\n\tRegisterProject(context.Context, *RegisterProjectRequest) (*RegisterProjectResponse, error)\n\t// ListProjects returns list of registered projects and configurations\n\tListProjects(context.Context, *ListProjectsRequest) (*ListProjectsResponse, error)\n\tmustEmbedUnimplementedProjectServiceServer()\n}\n\n// UnimplementedProjectServiceServer must be embedded to have forward compatible implementations.\ntype UnimplementedProjectServiceServer struct {\n}\n\nfunc (UnimplementedProjectServiceServer) RegisterProject(context.Context, *RegisterProjectRequest) (*RegisterProjectResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method RegisterProject not implemented\")\n}\nfunc (UnimplementedProjectServiceServer) ListProjects(context.Context, *ListProjectsRequest) (*ListProjectsResponse, error) {\n\treturn nil, status.Errorf(codes.Unimplemented, \"method ListProjects not implemented\")\n}\nfunc (UnimplementedProjectServiceServer) mustEmbedUnimplementedProjectServiceServer() {}\n\n// UnsafeProjectServiceServer may be embedded to opt out of forward compatibility for this service.\n// Use of this interface is not recommended, as added methods to ProjectServiceServer will\n// result in compilation errors.\ntype UnsafeProjectServiceServer interface {\n\tmustEmbedUnimplementedProjectServiceServer()\n}\n\nfunc RegisterProjectServiceServer(s grpc.ServiceRegistrar, srv ProjectServiceServer) {\n\ts.RegisterService(&ProjectService_ServiceDesc, srv)\n}\n\nfunc _ProjectService_RegisterProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(RegisterProjectRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(ProjectServiceServer).RegisterProject(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/odpf.optimus.core.v1beta1.ProjectService/RegisterProject\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(ProjectServiceServer).RegisterProject(ctx, req.(*RegisterProjectRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\nfunc _ProjectService_ListProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(ListProjectsRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(ProjectServiceServer).ListProjects(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/odpf.optimus.core.v1beta1.ProjectService/ListProjects\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(ProjectServiceServer).ListProjects(ctx, req.(*ListProjectsRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}\n\n// ProjectService_ServiceDesc is the grpc.ServiceDesc for ProjectService service.\n// It's only intended for direct use with grpc.RegisterService,\n// and not to be introspected or modified (even as a copy)\nvar ProjectService_ServiceDesc = grpc.ServiceDesc{\n\tServiceName: \"odpf.optimus.core.v1beta1.ProjectService\",\n\tHandlerType: (*ProjectServiceServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"RegisterProject\",\n\t\t\tHandler:    _ProjectService_RegisterProject_Handler,\n\t\t},\n\t\t{\n\t\t\tMethodName: \"ListProjects\",\n\t\t\tHandler:    _ProjectService_ListProjects_Handler,\n\t\t},\n\t},\n\tStreams:  []grpc.StreamDesc{},\n\tMetadata: \"odpf/optimus/core/v1beta1/project.proto\",\n}\n"}
{"sample": "// Send a POST request to the specified URL with a JSON payload\nfunc Post(url string, payload []byte) (*http.Response, error) {\n\treturn http.Post(url, \"application/json\", bytes.NewBuffer(payload))\n}\n"}
{"sample": "func GetCurrentTime() time.Time {\n\treturn time.Now()\n}\n\nfunc FormatTime(t time.Time, layout string) string {\n\treturn t.Format(layout)\n}\n\nfunc ParseTime(layout, value string) (time.Time, error) {\n\treturn time.Parse(layout, value)\n}"}
{"sample": "package zookeeper\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samuel/go-zookeeper/zk\"\n)\n\nfunc Connect() (*zk.Conn, error) {\n\tserver := []string{\"localhost:2181\"}\n\tconn, _, err := zk.Connect(server, time.Second*5)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to ZooKeeper: %v\", err)\n\t}\n\n\treturn conn, nil\n}\n\nfunc CreateNode(conn *zk.Conn, path string, data []byte) error {\n\tflags := int32(0)\n\tacl := zk.WorldACL(zk.PermAll)\n\t_, err := conn.Create(path, data, flags, acl)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create node: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc UpdateNode(conn *zk.Conn, path string, data []byte) error {\n\texists, _, err := conn.Exists(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to check if node exists: %v\", err)\n\t}\n\n\tif !exists {\n\t\treturn fmt.Errorf(\"node does not exist\")\n\t}\n\n\t_, err = conn.Set(path, data, -1)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update node: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc DeleteNode(conn *zk.Conn, path string) error {\n\texists, stat, err := conn.Exists(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to check if node exists: %v\", err)\n\t}\n\n\tif !exists {\n\t\treturn fmt.Errorf(\"node does not exist\")\n\t}\n\n\terr = conn.Delete(path, stat.Version)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to delete node: %v\", err)\n\t}\n\n\treturn nil\n}"}
{"sample": "link := \"symbolic_link\"\nerr = os.Symlink(\"file.txt\", link)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "// Making a slice\n\nslice := make([]int, 10)\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\nfunc main() {\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGINT, syscall.SIGTERM)\n\n\tfmt.Println(\"Waiting for signal...\")\n\ts := <-c\n\n\tfmt.Println(\"Received signal:\", s)\n}"}
{"sample": "func getRowCount(rows *sql.Rows) (int, error) {\n\tcount := 0\n\tfor rows.Next() {\n\t\tcount++\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn 0, err\n\t}\n\treturn count, nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\tr.GET(\"/users\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"List of users\")\n\t})\n\n\tr.GET(\"/users/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\t\tc.String(http.StatusOK, \"Get user with ID: %s\", id)\n\t})\n\n\tr.Run(\":8080\")\n}"}
{"sample": "http.HandleFunc(\"/products\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle products endpoint\n\tswitch r.Method {\n\tcase \"GET\":\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get products\")\n\tcase \"POST\":\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create product\")\n\tcase \"PUT\":\n\t\t// Handle PUT request\n\t\tfmt.Fprint(w, \"Update product\")\n\tcase \"DELETE\":\n\t\t// Handle DELETE request\n\t\tfmt.Fprint(w, \"Delete product\")\n\t}\n})\n"}
{"sample": "package main\n\nimport (\n\t\"log\"\n\t\"github.com/streadway/amqp\"\n)\n\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to open a channel\")\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\",\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\n\tbody := \"Hello World!\"\n\terr = ch.Publish(\n\t\t\"\",\n\t\tq.Name,\n\t\tfalse,\n\t\tfalse,\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        []byte(body),\n\t\t}\n\t)\n\tfailOnError(err, \"Failed to publish a message\")\n\tlog.Printf(\" [x] Sent %s\", body)\n}"}
{"sample": "package mapreduce_test\n\nimport (\n\t\"mapreduce\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestMapReduce(t *testing.T) {\n\tdata := []string{\"apple\", \"orange\", \"banana\", \"apple\", \"banana\"}\n\n\t// Map phase\n\toutput := mapreduce.Map(data)\n\n\t// Sort output for reduce phase\n\tsort.Strings(output)\n\n\t// Reduce phase\n\tresult := mapreduce.Reduce(output)\n\n\t// Check result\n\texpected := map[string]int{\n\t\t\"apple\": 2,\n\t\t\"orange\": 1,\n\t\t\"banana\": 2,\n\t}\n\n\tfor k, v := range expected {\n\t\tif result[k] != v {\n\t\t\tt.Errorf(\"%v: expected %v but got %v\", k, v, result[k])\n\t\t}\n\t}\n}"}
{"sample": "package buildnum\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/jenkins-x/jx/pkg/buildnum/mocks/matchers\"\n\t\"github.com/jenkins-x/jx/pkg/kube\"\n\t. \"github.com/petergtz/pegomock\"\n\n\tbuild_num_test \"github.com/jenkins-x/jx/pkg/buildnum/mocks\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestVendGET(t *testing.T) {\n\tmockIssuer := build_num_test.NewMockBuildNumberIssuer()\n\tpID := kube.NewPipelineIDFromString(\"owner1/repo1/branch1\")\n\texpectedBuildNum := \"3\"\n\tWhen(mockIssuer.NextBuildNumber(matchers.EqKubePipelineID(pID))).ThenReturn(expectedBuildNum, nil)\n\n\trespRecord := makeVendRequest(t, http.MethodGet, \"/vend/owner1/repo1/branch1\", mockIssuer)\n\tassert.Equal(t, http.StatusOK, respRecord.Code,\n\t\t\"Expected OK status code for valid /vend GET request.\")\n\tbody := respRecord.Body.String()\n\tassert.Equal(t, expectedBuildNum, body)\n}\n\nfunc TestVendGETMissingPipeline(t *testing.T) {\n\tmockIssuer := build_num_test.NewMockBuildNumberIssuer()\n\tpID := kube.NewPipelineIDFromString(\"\")\n\texpectedBuildNum := \"543\"\n\tWhen(mockIssuer.NextBuildNumber(matchers.EqKubePipelineID(pID))).ThenReturn(expectedBuildNum, nil)\n\n\trespRecord := makeVendRequest(t, http.MethodGet, \"/vend/\", mockIssuer)\n\tassert.Equal(t, http.StatusBadRequest, respRecord.Code,\n\t\t\"Expected Bad Request for /vend GET request with missing pipeline.\")\n}\n\nfunc TestVendUnsupportedMethod(t *testing.T) {\n\tmockIssuer := build_num_test.NewMockBuildNumberIssuer()\n\n\trespRecord := makeVendRequest(t, http.MethodDelete, \"/vend/a/b/c\", mockIssuer)\n\tassert.Equal(t, http.StatusMethodNotAllowed, respRecord.Code,\n\t\t\"Expected Method Not Allowed status code for valid /vend DELETE request.\")\n}\n\nfunc TestVendError(t *testing.T) {\n\tmockIssuer := build_num_test.NewMockBuildNumberIssuer()\n\terr := errors.New(\"something bad getting a build number\")\n\tWhen(mockIssuer.NextBuildNumber(matchers.AnyKubePipelineID())).ThenReturn(\"\", err)\n\n\trespRecord := makeVendRequest(t, http.MethodGet, \"/vend/owner1/repo1/branch1\", mockIssuer)\n\tassert.Equal(t, http.StatusInternalServerError, respRecord.Code,\n\t\t\"Expected Internal Server Error status code for /vend GET request when BuildNumberIssuer fails.\")\n}\n\nfunc makeVendRequest(t *testing.T, method string, path string, mockIssuer BuildNumberIssuer) *httptest.ResponseRecorder {\n\tserver := NewHTTPBuildNumberServer(\"\", 1234, mockIssuer)\n\n\treq, err := http.NewRequest(method, path, nil)\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error setting up fake HTTP request.\", err)\n\t}\n\n\trr := httptest.NewRecorder()\n\n\tserver.vend(rr, req)\n\n\treturn rr\n}\n"}
{"sample": "package main\n\n// ErrorHandler is a function that takes an error and handles it\nfunc ErrorHandler(err error, handler func(error)) {\n\thandler(err)\n}\n"}
{"sample": "// Add a handler function for the specified route pattern\nfunc HandleFunc(mux *http.ServeMux, pattern string, handlerFunc http.HandlerFunc) {\n\tmux.HandleFunc(pattern, handlerFunc)\n}\n"}
{"sample": "file, err := os.Create(\"file.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\n_, err = file.WriteString(\"Hello, World!\")\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "// IfErrorThenLogAndPanic checks if an error exists, if so, logs it and panics\nfunc IfErrorThenLogAndPanic(err error) {\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tpanic(err)\n\t}\n}\n"}
{"sample": "package main\n\n// ThrowError creates an error with a given message\nfunc ThrowError(msg string) error {\n\treturn errors.New(msg)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(IsLeapYear(2020))\n}\n\n// Function to check if a year is leap or not\nfunc IsLeapYear(year int) bool {\n\treturn year%4 == 0 && (year%100 != 0 || year%400 == 0)\n}"}
{"sample": "func ProcessUploadedFile(r *http.Request, fieldName string) (string, error) {\n\tfile, handler, err := r.FormFile(fieldName)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\tfilename := handler.Filename\n\treturn filename, nil\n}"}
{"sample": "package kvstore\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype KeyValue struct {\n\tKey   string `json:\"key\"`\n\tValue string `json:\"value\"`\n}\n\nvar store = make(map[string]string)\n\nfunc SetKey(w http.ResponseWriter, r *http.Request) {\n\tvar kv KeyValue\n\terr := json.NewDecoder(r.Body).Decode(&kv)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tstore[kv.Key] = kv.Value\n\n\tw.WriteHeader(http.StatusCreated)\n}\n\nfunc GetKey(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tkey := vars[\"key\"]\n\n\tval, ok := store[key]\n\tif !ok {\n\t\thttp.Error(w, \"Key not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tkv := KeyValue{Key: key, Value: val}\n\n\tjson.NewEncoder(w).Encode(kv)\n}\n\nfunc GetAllKeys(w http.ResponseWriter, r *http.Request) {\n\tvar keys []string\n\tfor key := range store {\n\t\tkeys = append(keys, key)\n\t}\n\n\tjson.NewEncoder(w).Encode(keys)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\nfunc getEvenNumberList(n int) []int {\n\tnumbers := make([]int, 0)\n\n\tfor i := 0; len(numbers) != n; i++ {\n\t\tif i%2 == 0 {\n\t\t\tnumbers = append(numbers, i)\n\t\t}\n\t}\n\n\treturn numbers\n}\n\nfunc main() {\n\tevenNumbers := getEvenNumberList(10)\n\tfmt.Println(evenNumbers)\n}"}
{"sample": "// Find the index of the last occurrence of a substring in a string\nfunc FindLastSubstringIndex(str, substr string) int {\n\treturn strings.LastIndex(str, substr)\n}\n"}
{"sample": "var j int\nswitch j {\ncase 2:\n\tfmt.Println(\"j is two\")\ncase 3:\n\tfmt.Println(\"j is three\")\ndefault:\n\tfmt.Println(\"j is not two or three\")\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tch := make(chan string)\n\n\tgo sendNotifications(ch)\n\n\tfor {\n\t\tselect {\n\t\tcase msg := <-ch:\n\t\t\tfmt.Println(\"Notification received: \", msg)\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tfmt.Println(\"No new notifications at this time\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc sendNotifications(ch chan string) {\n\tnotifications := []string{\"New message from user 1\", \"Post approved by admin\", \"Payment receipt uploaded\"}\n\tfor _, n := range notifications {\n\t\tch <- n\n\t\ttime.Sleep(time.Second * 2)\n\t}\n\tclose(ch)\n}"}
{"sample": "// Reverse the order of elements in an array\nfunc ReverseArray(arr []int) {\n\tfor i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {\n\t\tarr[i], arr[j] = arr[j], arr[i]\n\t}\n}\n"}
{"sample": "package gamesockets\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\n// Connection is a middleman between the websocket connection and the hub.\ntype Connection struct {\n\thub  *Hub\n\tconn *websocket.Conn\n\tsend chan []byte\n}\n\n// readPump pumps messages from the websocket connection to the hub.\nfunc (c *Connection) readPump() {\n\tdefer func() {\n\t\tc.hub.unregister <- c\n\t\tc.conn.Close()\n\t}()\n\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tmessage = bytes.TrimSpace(bytes.Replace(message, newline, space, -1))\n\t\tc.hub.broadcast <- message\n\t}\n}\n\n// writePump pumps messages from the hub to the websocket connection.\nfunc (c *Connection) writePump() {\n\tticker := time.NewTicker(pingPeriod)\n\tdefer func() {\n\t\tticker.Stop()\n\t\tc.conn.Close()\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase message, ok := <-c.send:\n\t\t\tif !ok {\n\t\t\t\tc.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw, err := c.conn.NextWriter(websocket.TextMessage)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tw.Write(message)\n\n\t\t\t// Add queued chat messages to the current websocket message.\n\t\t\tn := len(c.send)\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\tw.Write(newline)\n\t\t\t\tw.Write(<-c.send)\n\t\t\t}\n\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-ticker.C:\n\t\t\tif err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// serveWs handles websocket requests from the peer.\nfunc serveWs(hub *Hub, w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tclient := &Connection{hub: hub, conn: conn, send: make(chan []byte, 256)}\n\tclient.hub.register <- client\n\n\tgo client.writePump()\n\tgo client.readPump()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Hello, World!\"})\n\t})\n\n\tr.GET(\"/users/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\t\tc.JSON(http.StatusOK, gin.H{\"user_id\": id})\n\t})\n\n\tr.Run(\":8080\")\n}"}
{"sample": "package main\n\nimport (\n\t\"flag'\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10\"\n)\n\ntype Post struct {\n\tId        int\n\tTitle     string\n\tContent   string\n\tCreatedAt time.Time `pg:\"default:now()\"`\n}\n\n// This function will return your Connections options. These can be injected into pg.Connect\n// to configure everything.\nfunc newConnection(codeLatency bool) pg.Options {\n\n\tdefaultOptions := &pg.Options{\n\t\tUser: optCfg.StaticEnvOr(\"PGUSER\", defaultAuth.User),\n\t\tPass: optCfg.StaticEnvOr(\"PGPASSWORD\", \"\"),\n\t\tPort: uint(optCfg.getNumber(\"PGPORT\", defPort)),\n\t}\n\n\tif codeLatency {\n\t\tNStdConfig.EnableORMAnalyzing = 1\n\t\tResultSetTrace.WhereWarn = 2\n\n\t\tHPGTPlugin.LocalMachineNr = \"998\"\n\n\t    // Super sleed nos match this sequence\n\t\tTimeKeeperOption = \"tl-sym=nsw-m8-644876-chownh-zewel1-pirtop-sahav 018831-00005,\\ ntjpx\"\n\t\t\n        return *wcfg.CreateMockWSOptions(1, \"unit-tests/tablecode latency/webAuthTest/web$\", DB_NAME, defaultDSN, RISING_PHOENIX_RATELIMIT_OPTIONS).Bool()\n\t} \n\n\treturn tlsCfg.Setup(Cfg, defaultOptions.ClientURL().Scheme, H, doneChan)\n}\n\n\nfunc main() {\n\tflag.Parse()\n\n\tconnection := newConnection(*isLatencyDevelopment)\n\n\tdb := pg.Connect(connection)\n\tif db == nil {\n\t\tpanic(nil)\n\t}\n\n\tvar posts []Post\n\n\tif err := db.Model(&posts).Select(); err != nil {\n\t\tlog.Fatalln(\"Error massaging posts into Output Buffer,\", err)\n\t}\n\n\tfor _, post := range posts {\n\t\tlog.Printf(\"post: %v\", post)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, wg *sync.WaitGroup, jobs <-chan int, results chan<- int) {\n\tdefer wg.Done()\n\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", id, j)\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Printf(\"Worker %d finished job %d\\n\", id, j)\n\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tvar wg sync.WaitGroup\n\tfor w := 1; w <= 3; w++ {\n\t\twg.Add(1)\n\t\tgo worker(w, &wg, jobs, results)\n\t}\n\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n\n\tclose(results)\n\n\tfor r := range results {\n\t\tfmt.Println(r)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Student struct {\n\tID        int\n\tFirstName string\n\tLastName  string\n\tAge       int\n}\n\nfunc (s Student) FullName() string {\n\treturn fmt.Sprintf(\"%s %s\", s.FirstName, s.LastName)\n}\n\nfunc (s *Student) IncrementAge() {\n\ts.Age++\n}\n\nfunc main() {\n\tstudent := Student{\n\t\tID:        1,\n\t\tFirstName: \"John\",\n\t\tLastName:  \"Doe\",\n\t\tAge:       18,\n\t}\n\n\tfmt.Println(student.FullName())\n\tstudent.IncrementAge()\n\tfmt.Println(student.Age)\n\n\ttime.Sleep(time.Second)\n}"}
{"sample": "package main\n\n// ReturnError returns the error as a string\nfunc ReturnError(err error) string {\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\treturn \"\"\n}\n"}
{"sample": "package main\n\n// IfErrorThenReturnDefault checks if an error exists, if so, returns a default value\nfunc IfErrorThenReturnDefault(err error, defaultValue string) string {\n\tif err != nil {\n\t\treturn defaultValue\n\t}\n\treturn \"\"\n}\n"}
{"sample": "// Send a DELETE request to the specified URL\nfunc Delete(url string) (*http.Response, error) {\n\trequest, _ := http.NewRequest(\"DELETE\", url, nil)\n\treturn http.DefaultClient.Do(request)\n}\n"}
{"sample": "func main() {\n\tresp, err := http.Get(\"https://api.example.com/data\")\n\tif err != nil {\n\t\tfmt.Println(\"Error making HTTP request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "type Server struct {\n\tserver *http.Server\n}\n\nfunc NewServer(addr string, handler http.Handler) *Server {\n\treturn &Server{\n\t\tserver: &http.Server{\n\t\t\tAddr:    addr,\n\t\t\tHandler: handler,\n\t\t}\n\t}\n}\n\nfunc (s *Server) Start() error {\n\treturn s.server.ListenAndServe()\n}\n\nfunc (s *Server) Stop(ctx context.Context) error {\n\treturn s.server.Shutdown(ctx)\n}"}
{"sample": "package users\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n\tID           string    `json:\"id\"`\n\tUsername     string    `json:\"username\"`\n\tEmail        string    `json:\"email\"`\n\tPasswordHash string    `json:\"-\"`\n\tCreatedAt    time.Time `json:\"created_at\"`\n}\n\nfunc (u *User) SetPassword(pass string) error {\n\thash, err := bcrypt.GenerateFromPassword([]byte(pass), bcrypt.MinCost)\n\tif err != nil {\n\t\treturn err\n\t}\n\tu.PasswordHash = string(hash)\n\treturn nil\n}\n\nfunc (u *User) CheckPassword(pass string) bool {\n\tif err := bcrypt.CompareHashAndPassword([]byte(u.PasswordHash), []byte(pass)); err != nil {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc NewUser(username, email, password string) (*User, error) {\n\tuser := &User{\n\t\tID:        uuid.New().String(),\n\t\tUsername:  username,\n\t\tEmail:     email,\n\t\tCreatedAt: time.Now(),\n\t}\n\tif err := user.SetPassword(password); err != nil {\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}"}
{"sample": "// RandomInt returns a random integer between min and max.\nfunc RandomInt(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}\n\n// RandomString returns a random string of length n.\nfunc RandomString(n int) string {\n\tconst letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\trand.Seed(time.Now().UnixNano())\n\tb := make([]byte, n)\n\tfor i := range b {\n\t\tb[i] = letters[rand.Int63()%int64(len(letters))]\n\t}\n\treturn string(b)\n}"}
{"sample": "package main\n\n// IfErrorThenExit checks if an error exists, if so, exits the program\nfunc IfErrorThenExit(err error) {\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}\n"}
{"sample": "// Enable basic authentication for the HTTP server\nfunc EnableBasicAuth(handler http.Handler, username, password string) http.Handler {\n\treturn http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {\n\t\tuser, pass, _ := request.BasicAuth()\n\t\tif user != username || pass != password {\n\t\t\tresponse.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\tresponse.WriteHeader(http.StatusUnauthorized)\n\t\t\tresponse.Write([]byte(\"Unauthorized\"))\n\t\t\treturn\n\t\t}\n\t\thandler.ServeHTTP(response, request)\n\t})\n}\n"}
{"sample": "package firestoreclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\tfirebase \"firebase.google.com/go\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/api/iterator\"\n\t\"google.golang.org/api/option/firestore\"\n)\n\ntype FirestoreClient struct {\n\tclient *firestore.Client\n}\n\nfunc NewFirestoreClient(ctx context.Context, projectID string, credentialsFile string) (*FirestoreClient, error) {\n\topt := option.WithCredentialsFile(credentialsFile)\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initializing app: %v\", err)\n\t}\n\n\tclient, err := app.Firestore(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting Firestore client: %v\", err)\n\t}\n\n\treturn &FirestoreClient{client}, nil\n}\n\nfunc (fc *FirestoreClient) AddDocument(collection string, data map[string]interface{}) error {\n\t_, err := fc.client.Collection(collection).Doc().Set(context.Background(), data)\n\tif err != nil {\n\t\tlog.Printf(\"Error adding document: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (fc *FirestoreClient) GetDocuments(collection string) ([]map[string]interface{}, error) {\n\tvar documents []map[string]interface{}\n\titer := fc.client.Collection(collection).Documents(context.Background())\n\tfor {\n\t\tdoc, err := iter.Next()\n\t\tif err == iterator.Done {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error getting document: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tdocuments = append(documents, doc.Data())\n\t}\n\treturn documents, nil\n}\n\nfunc (fc *FirestoreClient) DeleteDocument(collection string, documentID string) error {\n\t_, err := fc.client.Collection(collection).Doc(documentID).Delete(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error deleting document: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel()\n\n\t// simulate a long-running operation\n\tgo func() {\n\t\ttime.Sleep(3 * time.Second)\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"Operation timed out\")\n\tcase <-time.After(1 * time.Second):\n\t\tfmt.Println(\"Operation complete\")\n\t}\n\n\t// do any necessary cleanup\n\tlog.Println(\"Exiting...\")\n}"}
{"sample": "package xmlparser\n\nimport (\n\t\"encoding/xml\"\n\t\"os\"\n)\n\ntype Person struct {\n\tName      string `xml:\"name\"`\n\tAge       int    `xml:\"age\"`\n\tEmail     string `xml:\"email\"`\n\tCompany   string `xml:\"company\"`\n}\n\nfunc ParseXML() ([]Person, error) {\n\tfile, err := os.Open(\"people.xml\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tvar people []Person\n\n\tdecoder := xml.NewDecoder(file)\n\tfor {\n\t\ttoken, err := decoder.Token()\n\t\tif err != nil {\n\t\t\tif err.Error() == \"EOF\" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif element, ok := token.(xml.StartElement); ok {\n\t\t\tif element.Name.Local == \"person\" {\n\t\t\t\tvar p Person\n\t\t\t\tif err := decoder.DecodeElement(&p, &element); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tpeople = append(people, p)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn people, nil\n}"}
{"sample": "package main\n\nimport \"time\"\n\nfunc main() {\n\tfmt.Println(FormatTime(time.Now()))\n}\n\nfunc FormatTime(t time.Time) string {\n\treturn t.Format(time.RFC3339)\n}"}
{"sample": "package bcryptHash\n\nimport (\n\t\"fmt\"\n\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\nfunc HashPassword(password string) (string, error) {\n\thash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error hashing password: %w\", err)\n\t}\n\n\treturn string(hash), nil\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}"}
{"sample": "package main\n\ntype MyStruct struct {\n\tField1      int\n\tField2      string\n\tSliceField1 []int\n}\n\nfunc (s MyStruct) Method1() string {\n\treturn \"Hello, world!\"\n}\n\nfunc NewMyStruct(field1 int, field2 string, sliceField1 []int) *MyStruct {\n\treturn &MyStruct{Field1: field1, Field2: field2, SliceField1: sliceField1}\n}\n\nfunc main() {\n\tms := NewMyStruct(42, \"answer\", []int{0, 1, 2})\n\tms.Method1()\n}"}
{"sample": "package main\n\n// RecoverAndLog recovers from panic and logs the error\nfunc RecoverAndLog() {\n\tif r := recover(); r != nil {\n\t\tlog.Println(\"Recovered from\", r)\n\t}\n}\n"}
{"sample": "func main() {\n\thttp.HandleFunc(\"/\", handleRoot)\n\thttp.HandleFunc(\"/users\", handleUsers)\n\thttp.HandleFunc(\"/products\", handleProducts)\n\thttp.HandleFunc(\"/items\", handleItems)\n\thttp.HandleFunc(\"/orders\", handleOrders)\n\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc handleRoot(w http.ResponseWriter, r *http.Request) {\n\t// Handle root endpoint\n\tfmt.Fprint(w, \"Hello, World!\")\n}\n\nfunc handleUsers(w http.ResponseWriter, r *http.Request) {\n\t// Handle users endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get users\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create user\")\n\t}\n}\n\nfunc handleProducts(w http.ResponseWriter, r *http.Request) {\n\t// Handle products endpoint\n\tswitch r.Method {\n\tcase \"GET\":\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get products\")\n\tcase \"POST\":\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create product\")\n\t}\n}\n\nfunc handleItems(w http.ResponseWriter, r *http.Request) {\n\t// Handle items endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get items\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create item\")\n\t}\n}\n\nfunc handleOrders(w http.ResponseWriter, r *http.Request) {\n\t// Handle orders endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get orders\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create order\")\n\t}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintOddNumbers prints odd numbers up to a given limit.\nfunc PrintOddNumbers(limit int) {\n\tfor i := 1; i <= limit; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "package main\n\n// This function walks a directory\nfunc WalkDir(dirname string, walkFn filepath.WalkFunc) error {\n\terr := filepath.Walk(dirname, walkFn)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\twalker := func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(path)\n\t\treturn nil\n\t}\n\terr := WalkDir(\".\", walker)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// GenerateRandomNumber generates a random number within the specified range.\nfunc GenerateRandomNumber(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"html/template\"\n)\n\nfunc main() {\n\ttmpl, err := template.ParseFiles(\"template.html\")\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing template:\", err)\n\t\treturn\n\t}\n\n\tdata := struct{\n\t\tName string\n\t\tAge  int\n\t}{\n\t\tName: \"John Doe\",\n\t\tAge:  30,\n\t}\n\n\terr = tmpl.Execute(os.Stdout, data)\n\tif err != nil {\n\t\tfmt.Println(\"Error executing template:\", err)\n\t\treturn\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tEmail  string `json:\"email\"`\n\tGender string `json:\"gender\"`\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path != \"/\" {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tuser := User{\n\t\t\tName:   \"John Doe\",\n\t\t\tAge:    30,\n\t\t\tEmail:  \"johndoe@example.com\",\n\t\t\tGender: \"male\",\n\t\t}\n\n\t\tjsonBytes, err := json.Marshal(user)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tfmt.Fprint(w, string(jsonBytes))\n\t})\n\n\tfmt.Println(\"Server started: http://localhost:8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "// Read the response body as JSON into a struct\nfunc ReadJSON(response *http.Response, data interface{}) error {\n\treturn json.NewDecoder(response.Body).Decode(data)\n}\n"}
{"sample": "func OpenDatabaseConnection(connStr string) (*sql.DB, error) {\n\treturn sql.Open(\"postgres\", connStr)\n}\n\nfunc ExecuteSQLCommand(db *sql.DB, command string) (sql.Result, error) {\n\treturn db.Exec(command)\n}\n\nfunc CloseDatabaseConnection(db *sql.DB) error {\n\treturn db.Close()\n}"}
{"sample": "ch := make(chan string)\ngo func() {\n\tch <- \"Hello, channel!\"\n}()\nmessage := <-ch\nfmt.Printf(\"Received message: %s\\n\", message)\n"}
{"sample": "for i := 10; i > 0; i-- {\n\tfmt.Println(i)\n}\n"}
{"sample": "package router\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Route struct {\n\tMethod  string\n\tPattern string\n\tHandler http.HandlerFunc\n}\n\ntype Router struct {\n\tRoutes []Route\n}\n\nfunc (r *Router) AddRoute(route Route) {\n\tr.Routes = append(r.Routes, route)\n}\n\nfunc (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tfor _, route := range r.Routes {\n\t\tif req.Method == route.Method && req.URL.Path == route.Pattern {\n\t\t\troute.Handler(w, req)\n\t\t\treturn\n\t\t}\n\t}\n\n\thttp.NotFound(w, req)\n}\n\nfunc helloHandler(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"Hello, World!\")\n}\n\nfunc goodbyeHandler(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"Goodbye, World!\")\n}\n\nfunc main() {\n\trouter := Router{}\n\trouter.AddRoute(Route{\n\t\tMethod:  \"GET\",\n\t\tPattern: \"/hello\",\n\t\tHandler: helloHandler,\n\t})\n\trouter.AddRoute(Route{\n\t\tMethod:  \"GET\",\n\t\tPattern: \"/goodbye\",\n\t\tHandler: goodbyeHandler,\n\t})\n\n\thttp.ListenAndServe(\":8080\", &router)\n}"}
{"sample": "// Create a new HTTP request with the specified method, URL, and body\nfunc NewRequest(method, url string, body io.Reader) (*http.Request, error) {\n\treturn http.NewRequest(method, url, body)\n}\n"}
{"sample": "// Stream the response from a GET request\nfunc StreamGet(url string) (*http.Response, error) {\n\trequest, _ := http.NewRequest(\"GET\", url, nil)\n\trequest.Header.Set(\"Accept\", \"application/octet-stream\")\n\treturn http.DefaultClient.Do(request)\n}\n"}
{"sample": "func GetRequestBody(r *http.Request) ([]byte, error) {\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn body, nil\n}\n\nfunc SetResponseBody(w http.ResponseWriter, body []byte) (int, error) {\n\treturn w.Write(body)\n}\n\nfunc RespondWithJSON(w http.ResponseWriter, statusCode int, data interface{}) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(statusCode)\n\tjson.NewEncoder(w).Encode(data)\n}"}
{"sample": "func prepareAndQuery(tx *sql.Tx, query string, args ...interface{}) (*sql.Rows, error) {\n\tstmt, err := tx.Prepare(query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\trows, err := stmt.Query(args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn rows, nil\n}\n"}
{"sample": "package main\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5}\n\tprintSlice(list)\n}\n\nfunc printSlice(s []int) {\n\tfor _, v := range s {\n\t\tfmt.Println(v)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tclient := &http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", \"https://api.example.com/resource\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating HTTP request:\", err)\n\t\treturn\n\t}\n\n\treq.Header.Add(\"Authorization\", \"Bearer <token>\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error making HTTP request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// RandomInt generates a random integer between min and max (inclusive).\nfunc RandomInt(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}\n\n// RandomFloat generates a random float between 0 and 1.\nfunc RandomFloat() float64 {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Float64()\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--config\", argparse.String, \"config.yaml\", \"Config file\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 4, \"Number of threads\")\nparser.AddArgument(\"--max-iter\", argparse.Int, 1000, \"Maximum number of iterations\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--batch-size\", argparse.Int, 16, \"Batch size\")\nparser.AddArgument(\"--mode\", argparse.String, \"default\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\nparser.AddArgument(\"--debug\", argparse.Bool, false, \"Enable debug mode\")\nparser.AddArgument(\"--gpu\", argparse.Bool, true, \"Enable GPU usage\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 8, \"Number of threads\")\nparser.AddArgument(\"--log-file\", argparse.String, \"log.txt\", \"Log file\")\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\tcurrentDir, err := os.Getwd()\n\tif err != nil {\n\t\tfmt.Println(\"Error getting current directory:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Current directory:\", currentDir)\n\n\tfiles, err := filepath.Glob(\"*.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error matching file patterns:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Matching files:\", files)\n}"}
{"sample": "// Generated by github.com/temporalio/temporal-aws-sdk-generator\n// from github.com/aws/aws-sdk-go version 1.35.7\n\npackage route53resolverstub\n\nimport (\n\t\"github.com/aws/aws-sdk-go/service/route53resolver\"\n\t\"go.uber.org/cadence/workflow\"\n\n\t\"github.com/banzaicloud/cadence-aws-sdk/clients\"\n)\n\n// ensure that imports are valid even if not used by the generated code\nvar _ clients.VoidFuture\n\ntype Client interface {\n\tAssociateResolverEndpointIpAddress(ctx workflow.Context, input *route53resolver.AssociateResolverEndpointIpAddressInput) (*route53resolver.AssociateResolverEndpointIpAddressOutput, error)\n\tAssociateResolverEndpointIpAddressAsync(ctx workflow.Context, input *route53resolver.AssociateResolverEndpointIpAddressInput) *AssociateResolverEndpointIpAddressFuture\n\n\tAssociateResolverQueryLogConfig(ctx workflow.Context, input *route53resolver.AssociateResolverQueryLogConfigInput) (*route53resolver.AssociateResolverQueryLogConfigOutput, error)\n\tAssociateResolverQueryLogConfigAsync(ctx workflow.Context, input *route53resolver.AssociateResolverQueryLogConfigInput) *AssociateResolverQueryLogConfigFuture\n\n\tAssociateResolverRule(ctx workflow.Context, input *route53resolver.AssociateResolverRuleInput) (*route53resolver.AssociateResolverRuleOutput, error)\n\tAssociateResolverRuleAsync(ctx workflow.Context, input *route53resolver.AssociateResolverRuleInput) *AssociateResolverRuleFuture\n\n\tCreateResolverEndpoint(ctx workflow.Context, input *route53resolver.CreateResolverEndpointInput) (*route53resolver.CreateResolverEndpointOutput, error)\n\tCreateResolverEndpointAsync(ctx workflow.Context, input *route53resolver.CreateResolverEndpointInput) *CreateResolverEndpointFuture\n\n\tCreateResolverQueryLogConfig(ctx workflow.Context, input *route53resolver.CreateResolverQueryLogConfigInput) (*route53resolver.CreateResolverQueryLogConfigOutput, error)\n\tCreateResolverQueryLogConfigAsync(ctx workflow.Context, input *route53resolver.CreateResolverQueryLogConfigInput) *CreateResolverQueryLogConfigFuture\n\n\tCreateResolverRule(ctx workflow.Context, input *route53resolver.CreateResolverRuleInput) (*route53resolver.CreateResolverRuleOutput, error)\n\tCreateResolverRuleAsync(ctx workflow.Context, input *route53resolver.CreateResolverRuleInput) *CreateResolverRuleFuture\n\n\tDeleteResolverEndpoint(ctx workflow.Context, input *route53resolver.DeleteResolverEndpointInput) (*route53resolver.DeleteResolverEndpointOutput, error)\n\tDeleteResolverEndpointAsync(ctx workflow.Context, input *route53resolver.DeleteResolverEndpointInput) *DeleteResolverEndpointFuture\n\n\tDeleteResolverQueryLogConfig(ctx workflow.Context, input *route53resolver.DeleteResolverQueryLogConfigInput) (*route53resolver.DeleteResolverQueryLogConfigOutput, error)\n\tDeleteResolverQueryLogConfigAsync(ctx workflow.Context, input *route53resolver.DeleteResolverQueryLogConfigInput) *DeleteResolverQueryLogConfigFuture\n\n\tDeleteResolverRule(ctx workflow.Context, input *route53resolver.DeleteResolverRuleInput) (*route53resolver.DeleteResolverRuleOutput, error)\n\tDeleteResolverRuleAsync(ctx workflow.Context, input *route53resolver.DeleteResolverRuleInput) *DeleteResolverRuleFuture\n\n\tDisassociateResolverEndpointIpAddress(ctx workflow.Context, input *route53resolver.DisassociateResolverEndpointIpAddressInput) (*route53resolver.DisassociateResolverEndpointIpAddressOutput, error)\n\tDisassociateResolverEndpointIpAddressAsync(ctx workflow.Context, input *route53resolver.DisassociateResolverEndpointIpAddressInput) *DisassociateResolverEndpointIpAddressFuture\n\n\tDisassociateResolverQueryLogConfig(ctx workflow.Context, input *route53resolver.DisassociateResolverQueryLogConfigInput) (*route53resolver.DisassociateResolverQueryLogConfigOutput, error)\n\tDisassociateResolverQueryLogConfigAsync(ctx workflow.Context, input *route53resolver.DisassociateResolverQueryLogConfigInput) *DisassociateResolverQueryLogConfigFuture\n\n\tDisassociateResolverRule(ctx workflow.Context, input *route53resolver.DisassociateResolverRuleInput) (*route53resolver.DisassociateResolverRuleOutput, error)\n\tDisassociateResolverRuleAsync(ctx workflow.Context, input *route53resolver.DisassociateResolverRuleInput) *DisassociateResolverRuleFuture\n\n\tGetResolverDnssecConfig(ctx workflow.Context, input *route53resolver.GetResolverDnssecConfigInput) (*route53resolver.GetResolverDnssecConfigOutput, error)\n\tGetResolverDnssecConfigAsync(ctx workflow.Context, input *route53resolver.GetResolverDnssecConfigInput) *GetResolverDnssecConfigFuture\n\n\tGetResolverEndpoint(ctx workflow.Context, input *route53resolver.GetResolverEndpointInput) (*route53resolver.GetResolverEndpointOutput, error)\n\tGetResolverEndpointAsync(ctx workflow.Context, input *route53resolver.GetResolverEndpointInput) *GetResolverEndpointFuture\n\n\tGetResolverQueryLogConfig(ctx workflow.Context, input *route53resolver.GetResolverQueryLogConfigInput) (*route53resolver.GetResolverQueryLogConfigOutput, error)\n\tGetResolverQueryLogConfigAsync(ctx workflow.Context, input *route53resolver.GetResolverQueryLogConfigInput) *GetResolverQueryLogConfigFuture\n\n\tGetResolverQueryLogConfigAssociation(ctx workflow.Context, input *route53resolver.GetResolverQueryLogConfigAssociationInput) (*route53resolver.GetResolverQueryLogConfigAssociationOutput, error)\n\tGetResolverQueryLogConfigAssociationAsync(ctx workflow.Context, input *route53resolver.GetResolverQueryLogConfigAssociationInput) *GetResolverQueryLogConfigAssociationFuture\n\n\tGetResolverQueryLogConfigPolicy(ctx workflow.Context, input *route53resolver.GetResolverQueryLogConfigPolicyInput) (*route53resolver.GetResolverQueryLogConfigPolicyOutput, error)\n\tGetResolverQueryLogConfigPolicyAsync(ctx workflow.Context, input *route53resolver.GetResolverQueryLogConfigPolicyInput) *GetResolverQueryLogConfigPolicyFuture\n\n\tGetResolverRule(ctx workflow.Context, input *route53resolver.GetResolverRuleInput) (*route53resolver.GetResolverRuleOutput, error)\n\tGetResolverRuleAsync(ctx workflow.Context, input *route53resolver.GetResolverRuleInput) *GetResolverRuleFuture\n\n\tGetResolverRuleAssociation(ctx workflow.Context, input *route53resolver.GetResolverRuleAssociationInput) (*route53resolver.GetResolverRuleAssociationOutput, error)\n\tGetResolverRuleAssociationAsync(ctx workflow.Context, input *route53resolver.GetResolverRuleAssociationInput) *GetResolverRuleAssociationFuture\n\n\tGetResolverRulePolicy(ctx workflow.Context, input *route53resolver.GetResolverRulePolicyInput) (*route53resolver.GetResolverRulePolicyOutput, error)\n\tGetResolverRulePolicyAsync(ctx workflow.Context, input *route53resolver.GetResolverRulePolicyInput) *GetResolverRulePolicyFuture\n\n\tListResolverDnssecConfigs(ctx workflow.Context, input *route53resolver.ListResolverDnssecConfigsInput) (*route53resolver.ListResolverDnssecConfigsOutput, error)\n\tListResolverDnssecConfigsAsync(ctx workflow.Context, input *route53resolver.ListResolverDnssecConfigsInput) *ListResolverDnssecConfigsFuture\n\n\tListResolverEndpointIpAddresses(ctx workflow.Context, input *route53resolver.ListResolverEndpointIpAddressesInput) (*route53resolver.ListResolverEndpointIpAddressesOutput, error)\n\tListResolverEndpointIpAddressesAsync(ctx workflow.Context, input *route53resolver.ListResolverEndpointIpAddressesInput) *ListResolverEndpointIpAddressesFuture\n\n\tListResolverEndpoints(ctx workflow.Context, input *route53resolver.ListResolverEndpointsInput) (*route53resolver.ListResolverEndpointsOutput, error)\n\tListResolverEndpointsAsync(ctx workflow.Context, input *route53resolver.ListResolverEndpointsInput) *ListResolverEndpointsFuture\n\n\tListResolverQueryLogConfigAssociations(ctx workflow.Context, input *route53resolver.ListResolverQueryLogConfigAssociationsInput) (*route53resolver.ListResolverQueryLogConfigAssociationsOutput, error)\n\tListResolverQueryLogConfigAssociationsAsync(ctx workflow.Context, input *route53resolver.ListResolverQueryLogConfigAssociationsInput) *ListResolverQueryLogConfigAssociationsFuture\n\n\tListResolverQueryLogConfigs(ctx workflow.Context, input *route53resolver.ListResolverQueryLogConfigsInput) (*route53resolver.ListResolverQueryLogConfigsOutput, error)\n\tListResolverQueryLogConfigsAsync(ctx workflow.Context, input *route53resolver.ListResolverQueryLogConfigsInput) *ListResolverQueryLogConfigsFuture\n\n\tListResolverRuleAssociations(ctx workflow.Context, input *route53resolver.ListResolverRuleAssociationsInput) (*route53resolver.ListResolverRuleAssociationsOutput, error)\n\tListResolverRuleAssociationsAsync(ctx workflow.Context, input *route53resolver.ListResolverRuleAssociationsInput) *ListResolverRuleAssociationsFuture\n\n\tListResolverRules(ctx workflow.Context, input *route53resolver.ListResolverRulesInput) (*route53resolver.ListResolverRulesOutput, error)\n\tListResolverRulesAsync(ctx workflow.Context, input *route53resolver.ListResolverRulesInput) *ListResolverRulesFuture\n\n\tListTagsForResource(ctx workflow.Context, input *route53resolver.ListTagsForResourceInput) (*route53resolver.ListTagsForResourceOutput, error)\n\tListTagsForResourceAsync(ctx workflow.Context, input *route53resolver.ListTagsForResourceInput) *ListTagsForResourceFuture\n\n\tPutResolverQueryLogConfigPolicy(ctx workflow.Context, input *route53resolver.PutResolverQueryLogConfigPolicyInput) (*route53resolver.PutResolverQueryLogConfigPolicyOutput, error)\n\tPutResolverQueryLogConfigPolicyAsync(ctx workflow.Context, input *route53resolver.PutResolverQueryLogConfigPolicyInput) *PutResolverQueryLogConfigPolicyFuture\n\n\tPutResolverRulePolicy(ctx workflow.Context, input *route53resolver.PutResolverRulePolicyInput) (*route53resolver.PutResolverRulePolicyOutput, error)\n\tPutResolverRulePolicyAsync(ctx workflow.Context, input *route53resolver.PutResolverRulePolicyInput) *PutResolverRulePolicyFuture\n\n\tTagResource(ctx workflow.Context, input *route53resolver.TagResourceInput) (*route53resolver.TagResourceOutput, error)\n\tTagResourceAsync(ctx workflow.Context, input *route53resolver.TagResourceInput) *TagResourceFuture\n\n\tUntagResource(ctx workflow.Context, input *route53resolver.UntagResourceInput) (*route53resolver.UntagResourceOutput, error)\n\tUntagResourceAsync(ctx workflow.Context, input *route53resolver.UntagResourceInput) *UntagResourceFuture\n\n\tUpdateResolverDnssecConfig(ctx workflow.Context, input *route53resolver.UpdateResolverDnssecConfigInput) (*route53resolver.UpdateResolverDnssecConfigOutput, error)\n\tUpdateResolverDnssecConfigAsync(ctx workflow.Context, input *route53resolver.UpdateResolverDnssecConfigInput) *UpdateResolverDnssecConfigFuture\n\n\tUpdateResolverEndpoint(ctx workflow.Context, input *route53resolver.UpdateResolverEndpointInput) (*route53resolver.UpdateResolverEndpointOutput, error)\n\tUpdateResolverEndpointAsync(ctx workflow.Context, input *route53resolver.UpdateResolverEndpointInput) *UpdateResolverEndpointFuture\n\n\tUpdateResolverRule(ctx workflow.Context, input *route53resolver.UpdateResolverRuleInput) (*route53resolver.UpdateResolverRuleOutput, error)\n\tUpdateResolverRuleAsync(ctx workflow.Context, input *route53resolver.UpdateResolverRuleInput) *UpdateResolverRuleFuture\n}\n\nfunc NewClient() Client {\n\treturn &stub{}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintSquareRoot(25)\n}\n\n// Function to print the square root of a number\nfunc PrintSquareRoot(n float64) {\n\tfmt.Println(math.Sqrt(n))\n}"}
{"sample": "package main\n\nfunc IsPalindrome(str string) bool {\n\tfor i := 0; i < len(str)/2; i++ {\n\t\tif str[i] != str[len(str)-1-i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"sample": "package validation\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/giantswarm/apiextensions-application/api/v1alpha1\"\n\t\"github.com/giantswarm/k8smetadata/pkg/label\"\n\t\"github.com/giantswarm/microerror\"\n\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/fields\"\n\t\"sigs.k8s.io/controller-runtime/pkg/client\"\n\n\t\"github.com/giantswarm/app/v6/pkg/key\"\n)\n\nconst (\n\tcatalogNotFoundTemplate         = \"catalog %#q not found\"\n\tnameTooLongTemplate             = \"name %#q is %d chars and exceeds max length of %d chars\"\n\tnameNotFoundReasonTemplate      = \"name is not specified for %s\"\n\tnamespaceNotFoundReasonTemplate = \"namespace is not specified for %s %#q\"\n\tlabelInvalidValueTemplate       = \"label %#q has invalid value %#q\"\n\tlabelNotFoundTemplate           = \"label %#q not found\"\n\tresourceNotFoundTemplate        = \"%s %#q in namespace %#q not found\"\n\n\tdefaultCatalogName            = \"default\"\n\tnginxIngressControllerAppName = \"nginx-ingress-controller-app\"\n\n\t// nameMaxLength is 53 characters as this is the maximum allowed for Helm\n\t// release names.\n\tnameMaxLength = 53\n)\n\nfunc (v *Validator) ValidateApp(ctx context.Context, app v1alpha1.App) (bool, error) {\n\tvar err error\n\n\terr = v.validateCatalog(ctx, app)\n\tif err != nil {\n\t\treturn false, microerror.Mask(err)\n\t}\n\n\terr = v.validateConfig(ctx, app)\n\tif err != nil {\n\t\treturn false, microerror.Mask(err)\n\t}\n\n\terr = v.validateKubeConfig(ctx, app)\n\tif err != nil {\n\t\treturn false, microerror.Mask(err)\n\t}\n\n\terr = v.validateLabels(ctx, app)\n\tif err != nil {\n\t\treturn false, microerror.Mask(err)\n\t}\n\n\terr = v.validateMetadataConstraints(ctx, app)\n\tif err != nil {\n\t\treturn false, microerror.Mask(err)\n\t}\n\n\terr = v.validateName(ctx, app)\n\tif err != nil {\n\t\treturn false, microerror.Mask(err)\n\t}\n\n\terr = v.validateNamespaceConfig(ctx, app)\n\tif err != nil {\n\t\treturn false, microerror.Mask(err)\n\t}\n\n\terr = v.validateUserConfig(ctx, app)\n\tif err != nil {\n\t\treturn false, microerror.Mask(err)\n\t}\n\n\treturn true, nil\n}\n\nfunc (v *Validator) ValidateAppUpdate(ctx context.Context, app, currentApp v1alpha1.App) (bool, error) {\n\terr := v.validateNamespaceUpdate(ctx, app, currentApp)\n\tif err != nil {\n\t\treturn false, microerror.Mask(err)\n\t}\n\n\treturn true, nil\n}\n\nfunc (v *Validator) validateCatalog(ctx context.Context, cr v1alpha1.App) error {\n\tvar err error\n\n\tif key.CatalogName(cr) == \"\" {\n\t\treturn nil\n\t}\n\n\tvar namespaces []string\n\t{\n\t\tif key.CatalogNamespace(cr) != \"\" {\n\t\t\tnamespaces = []string{key.CatalogNamespace(cr)}\n\t\t} else {\n\t\t\tnamespaces = []string{metav1.NamespaceDefault, \"giantswarm\"}\n\t\t}\n\t}\n\n\tvar matchedCatalog *v1alpha1.Catalog\n\n\tfor _, ns := range namespaces {\n\t\tvar catalog v1alpha1.Catalog\n\t\terr = v.g8sClient.Get(ctx, client.ObjectKey{\n\t\t\tNamespace: ns,\n\t\t\tName:      key.CatalogName(cr),\n\t\t}, &catalog)\n\t\tif apierrors.IsNotFound(err) {\n\t\t\t// no-op\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\treturn microerror.Mask(err)\n\t\t}\n\t\tmatchedCatalog = &catalog\n\t\tbreak\n\t}\n\n\tif matchedCatalog == nil || matchedCatalog.Name == \"\" {\n\t\treturn microerror.Maskf(validationError, catalogNotFoundTemplate, key.CatalogName(cr))\n\t}\n\n\treturn nil\n}\n\nfunc (v *Validator) validateConfig(ctx context.Context, cr v1alpha1.App) error {\n\tif key.IsManagedByFlux(cr, v.projectName) {\n\t\treturn nil\n\t}\n\n\tif key.AppConfigMapName(cr) != \"\" {\n\t\tns := key.AppConfigMapNamespace(cr)\n\t\tif ns == \"\" {\n\t\t\treturn microerror.Maskf(validationError, namespaceNotFoundReasonTemplate, \"configmap\", key.AppConfigMapName(cr))\n\t\t}\n\n\t\t_, err := v.k8sClient.CoreV1().ConfigMaps(ns).Get(ctx, key.AppConfigMapName(cr), metav1.GetOptions{})\n\t\tif apierrors.IsNotFound(err) {\n\t\t\t// appConfigMapNotFoundError is used rather than a validation error because\n\t\t\t// during cluster creation there is a short delay while it is generated.\n\t\t\treturn microerror.Maskf(appConfigMapNotFoundError, resourceNotFoundTemplate, \"configmap\", key.AppConfigMapName(cr), ns)\n\t\t} else if err != nil {\n\t\t\treturn microerror.Mask(err)\n\t\t}\n\t}\n\n\tif key.AppSecretName(cr) != \"\" {\n\t\tns := key.AppSecretNamespace(cr)\n\t\tif ns == \"\" {\n\t\t\treturn microerror.Maskf(validationError, namespaceNotFoundReasonTemplate, \"secret\", key.AppSecretName(cr))\n\t\t}\n\n\t\t_, err := v.k8sClient.CoreV1().Secrets(ns).Get(ctx, key.AppSecretName(cr), metav1.GetOptions{})\n\t\tif apierrors.IsNotFound(err) {\n\t\t\treturn microerror.Maskf(validationError, resourceNotFoundTemplate, \"secret\", key.AppSecretName(cr), ns)\n\t\t} else if err != nil {\n\t\t\treturn microerror.Mask(err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (v *Validator) validateName(ctx context.Context, cr v1alpha1.App) error {\n\tif len(cr.Name) > nameMaxLength {\n\t\treturn microerror.Maskf(validationError, nameTooLongTemplate, cr.Name, len(cr.Name), nameMaxLength)\n\t}\n\n\treturn nil\n}\n\nfunc (v *Validator) validateNamespaceConfig(ctx context.Context, cr v1alpha1.App) error {\n\tannotations := key.AppNamespaceAnnotations(cr)\n\tlabels := key.AppNamespaceLabels(cr)\n\n\tif annotations == nil && labels == nil {\n\t\t// no-op\n\t\treturn nil\n\t}\n\n\tvar apps []v1alpha1.App\n\t{\n\t\tfieldSelector, err := fields.ParseSelector(fmt.Sprintf(\"metadata.name!=%s\", cr.Name))\n\t\tif err != nil {\n\t\t\treturn microerror.Mask(err)\n\t\t}\n\n\t\tlo := client.ListOptions{\n\t\t\tNamespace:     cr.Namespace,\n\t\t\tFieldSelector: fieldSelector,\n\t\t}\n\t\tvar appList v1alpha1.AppList\n\t\terr = v.g8sClient.List(ctx, &appList, &lo)\n\t\tif err != nil {\n\t\t\treturn microerror.Mask(err)\n\t\t}\n\n\t\tapps = appList.Items\n\t}\n\n\tfor _, app := range apps {\n\t\tif key.AppNamespace(cr) != key.AppNamespace(app) {\n\t\t\tcontinue\n\t\t}\n\n\t\ttargetAnnotations := key.AppNamespaceAnnotations(app)\n\t\tif targetAnnotations != nil && annotations != nil {\n\t\t\tfor k, v := range targetAnnotations {\n\t\t\t\toriginalValue, ok := annotations[k]\n\t\t\t\tif ok && originalValue != v {\n\t\t\t\t\treturn microerror.Maskf(validationError, \"app %#q annotation %#q for target namespace %#q collides with value %#q for app %#q\",\n\t\t\t\t\t\tkey.AppName(cr), k, key.AppNamespace(cr), v, app.Name)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttargetLabels := key.AppNamespaceLabels(app)\n\t\tif targetLabels != nil && labels != nil {\n\t\t\tfor k, v := range targetLabels {\n\t\t\t\toriginalValue, ok := labels[k]\n\t\t\t\tif ok && originalValue != v {\n\t\t\t\t\treturn microerror.Maskf(validationError, \"app %#q label %#q for target namespace %#q collides with value %#q for app %#q\",\n\t\t\t\t\t\tkey.AppName(cr), k, key.AppNamespace(cr), v, app.Name)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (v *Validator) validateKubeConfig(ctx context.Context, cr v1alpha1.App) error {\n\tif key.IsManagedByFlux(cr, v.projectName) {\n\t\treturn nil\n\t}\n\n\tif !key.InCluster(cr) {\n\t\tns := key.KubeConfigSecretNamespace(cr)\n\t\tif ns == \"\" {\n\t\t\treturn microerror.Maskf(validationError, namespaceNotFoundReasonTemplate, \"kubeconfig secret\", key.KubeConfigSecretName(cr))\n\t\t}\n\n\t\tsecretName := key.KubeConfigSecretName(cr)\n\t\tif secretName == \"\" {\n\t\t\treturn microerror.Maskf(validationError, nameNotFoundReasonTemplate, \"kubeconfig secret\")\n\t\t}\n\n\t\t_, err := v.k8sClient.CoreV1().Secrets(key.KubeConfigSecretNamespace(cr)).Get(ctx, secretName, metav1.GetOptions{})\n\t\tif apierrors.IsNotFound(err) {\n\t\t\t// kubeConfigNotFoundError is used rather than a validation error because\n\t\t\t// during cluster creation there is a short delay while it is generated.\n\t\t\treturn microerror.Maskf(kubeConfigNotFoundError, resourceNotFoundTemplate, \"kubeconfig secret\", secretName, ns)\n\t\t} else if err != nil {\n\t\t\treturn microerror.Mask(err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (v *Validator) validateLabels(ctx context.Context, cr v1alpha1.App) error {\n\tif key.VersionLabel(cr) == \"\" {\n\t\treturn microerror.Maskf(validationError, labelNotFoundTemplate, label.AppOperatorVersion)\n\t}\n\tif key.VersionLabel(cr) == key.LegacyAppVersionLabel {\n\t\treturn microerror.Maskf(validationError, labelInvalidValueTemplate, label.AppOperatorVersion, key.VersionLabel(cr))\n\t}\n\n\treturn nil\n}\n\nfunc (v *Validator) validateMetadataConstraints(ctx context.Context, cr v1alpha1.App) error {\n\tname := key.AppCatalogEntryName(key.CatalogName(cr), key.AppName(cr), key.Version(cr))\n\n\tvar entry v1alpha1.AppCatalogEntry\n\terr := v.g8sClient.Get(ctx, client.ObjectKey{\n\t\tNamespace: metav1.NamespaceDefault,\n\t\tName:      name,\n\t}, &entry)\n\tif apierrors.IsNotFound(err) {\n\t\tv.logger.Debugf(ctx, \"appcatalogentry %#q not found, skipping metadata validation\", name)\n\t\treturn nil\n\t} else if err != nil {\n\t\treturn microerror.Mask(err)\n\t}\n\n\tif entry.Spec.Restrictions == nil {\n\t\t// no-op\n\t\treturn nil\n\t}\n\n\tif len(entry.Spec.Restrictions.CompatibleProviders) > 0 {\n\t\tif !contains(entry.Spec.Restrictions.CompatibleProviders, v1alpha1.Provider(v.provider)) {\n\t\t\treturn microerror.Maskf(validationError, \"app %#q can only be installed for providers %#q not %#q\",\n\t\t\t\tcr.Spec.Name, entry.Spec.Restrictions.CompatibleProviders, v.provider)\n\t\t}\n\t}\n\n\tif entry.Spec.Restrictions.FixedNamespace != \"\" {\n\t\tif entry.Spec.Restrictions.FixedNamespace != cr.Spec.Namespace {\n\t\t\treturn microerror.Maskf(validationError, \"app %#q can only be installed in namespace %#q only, not %#q\",\n\t\t\t\tcr.Spec.Name, entry.Spec.Restrictions.FixedNamespace, cr.Spec.Namespace)\n\t\t}\n\t}\n\n\tvar apps []v1alpha1.App\n\tif entry.Spec.Restrictions.ClusterSingleton || entry.Spec.Restrictions.NamespaceSingleton {\n\t\tfieldSelector, err := fields.ParseSelector(fmt.Sprintf(\"metadata.name!=%s\", cr.Name))\n\t\tif err != nil {\n\t\t\treturn microerror.Mask(err)\n\t\t}\n\n\t\tlo := client.ListOptions{\n\t\t\tFieldSelector: fieldSelector,\n\t\t\tNamespace:     cr.Namespace,\n\t\t}\n\t\tvar appList v1alpha1.AppList\n\t\terr = v.g8sClient.List(ctx, &appList, &lo)\n\t\tif err != nil {\n\t\t\treturn microerror.Mask(err)\n\t\t}\n\n\t\tapps = appList.Items\n\t}\n\n\tfor _, app := range apps {\n\t\tif app.Spec.Name == cr.Spec.Name {\n\t\t\tif entry.Spec.Restrictions.ClusterSingleton {\n\t\t\t\treturn microerror.Maskf(validationError, \"app %#q can only be installed once in cluster %#q\",\n\t\t\t\t\tcr.Spec.Name, cr.Namespace)\n\t\t\t}\n\t\t\tif entry.Spec.Restrictions.NamespaceSingleton {\n\t\t\t\tif app.Spec.Namespace == cr.Spec.Namespace {\n\t\t\t\t\treturn microerror.Maskf(validationError, \"app %#q can only be installed only once in namespace %#q\",\n\t\t\t\t\t\tcr.Spec.Name, key.Namespace(cr))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (v *Validator) validateNamespaceUpdate(ctx context.Context, app, currentApp v1alpha1.App) error {\n\tif key.Namespace(app) != key.Namespace(currentApp) {\n\t\treturn microerror.Maskf(validationError, \"target namespace for app %#q cannot be changed from %#q to %#q\", app.Name,\n\t\t\tkey.Namespace(currentApp), key.Namespace(app))\n\t}\n\n\treturn nil\n}\n\nfunc (v *Validator) validateUserConfig(ctx context.Context, cr v1alpha1.App) error {\n\tif key.IsManagedByFlux(cr, v.projectName) {\n\t\treturn nil\n\t}\n\n\tif key.UserConfigMapName(cr) != \"\" {\n\t\t// NGINX Ingress Controller is no longer a pre-installed app\n\t\t// managed by cluster-operator. So we don't need to restrict\n\t\t// the name.\n\t\tif key.CatalogName(cr) == defaultCatalogName && key.AppName(cr) != nginxIngressControllerAppName {\n\t\t\tconfigMapName := fmt.Sprintf(\"%s-user-values\", cr.Name)\n\t\t\tif key.UserConfigMapName(cr) != configMapName {\n\t\t\t\treturn microerror.Maskf(validationError, \"user configmap must be named %#q for app in default catalog\", configMapName)\n\t\t\t}\n\t\t}\n\n\t\tns := key.UserConfigMapNamespace(cr)\n\t\tif ns == \"\" {\n\t\t\treturn microerror.Maskf(validationError, namespaceNotFoundReasonTemplate, \"configmap\", key.UserConfigMapName(cr))\n\t\t}\n\n\t\t_, err := v.k8sClient.CoreV1().ConfigMaps(ns).Get(ctx, key.UserConfigMapName(cr), metav1.GetOptions{})\n\t\tif apierrors.IsNotFound(err) {\n\t\t\treturn microerror.Maskf(validationError, resourceNotFoundTemplate, \"configmap\", key.UserConfigMapName(cr), ns)\n\t\t} else if err != nil {\n\t\t\treturn microerror.Mask(err)\n\t\t}\n\t}\n\n\tif key.UserSecretName(cr) != \"\" {\n\t\tif key.CatalogName(cr) == defaultCatalogName {\n\t\t\tsecretName := fmt.Sprintf(\"%s-user-secrets\", cr.Name)\n\t\t\tif key.UserSecretName(cr) != secretName {\n\t\t\t\treturn microerror.Maskf(validationError, \"user secret must be named %#q for app in default catalog\", secretName)\n\t\t\t}\n\t\t}\n\n\t\tns := key.UserSecretNamespace(cr)\n\t\tif ns == \"\" {\n\t\t\treturn microerror.Maskf(validationError, namespaceNotFoundReasonTemplate, \"secret\", key.UserSecretName(cr))\n\t\t}\n\n\t\t_, err := v.k8sClient.CoreV1().Secrets(key.UserSecretNamespace(cr)).Get(ctx, key.UserSecretName(cr), metav1.GetOptions{})\n\t\tif apierrors.IsNotFound(err) {\n\t\t\treturn microerror.Maskf(validationError, resourceNotFoundTemplate, \"secret\", key.UserSecretName(cr), ns)\n\t\t} else if err != nil {\n\t\t\treturn microerror.Mask(err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc contains(s []v1alpha1.Provider, e v1alpha1.Provider) bool {\n\tfor _, a := range s {\n\t\tif a == e {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"}
{"sample": "package golang\n\nimport (\n\t\"github.com/jschaf/pggen/internal/codegen/golang/gotype\"\n\t\"sort\"\n)\n\n// ImportSet contains a set of imports required by one Go file.\ntype ImportSet struct {\n\timports map[string]struct{}\n}\n\nfunc NewImportSet() *ImportSet {\n\treturn &ImportSet{imports: make(map[string]struct{}, 4)}\n}\n\n// AddPackage adds a fully qualified package path to the set, like\n// \"github.com/jschaf/pggen/foo\".\nfunc (s *ImportSet) AddPackage(p string) {\n\ts.imports[p] = struct{}{}\n}\n\n// AddType adds all fully qualified package paths needed for type and any child\n// types.\nfunc (s *ImportSet) AddType(typ gotype.Type) {\n\ts.AddPackage(typ.Import())\n\tcomp, ok := typ.(gotype.CompositeType)\n\tif !ok {\n\t\treturn\n\t}\n\tfor _, childType := range comp.FieldTypes {\n\t\ts.AddType(childType)\n\t}\n}\n\n// SortedPackages returns a new slice containing the sorted packages, suitable\n// for an import statement.\nfunc (s *ImportSet) SortedPackages() []string {\n\timps := make([]string, 0, len(s.imports))\n\tfor pkg := range s.imports {\n\t\tif pkg != \"\" {\n\t\t\timps = append(imps, pkg)\n\t\t}\n\t}\n\tsort.Strings(imps)\n\treturn imps\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://api.example.com/data\")\n\tif err != nil {\n\t\tfmt.Println(\"Error making HTTP request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\tif len(os.Args) != 3 {\n\t\tlog.Fatal(\"expected two arguments; the listen and destination addresses\")\n\t}\n\n\tlistenAddr := os.Args[1]\n\tpeerAddr := os.Args[2]\n\n\tln, err := net.Listen(\"tcp\", listenAddr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error accepting connection: %s\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo proxy(c, peerAddr)\n\t}\n}\n\nfunc proxy(c net.Conn, peerAddr string) {\n\tlog.Printf(\"Incomming connection from %s\", c.RemoteAddr())\n\tlog.Printf(\"Connecting to %s\", peerAddr)\n\n\tr, err := net.Dial(\"tcp\", peerAddr)\n\tif err != nil {\n\t\tlog.Printf(\"Error connecting to peer: %s\", err)\n\t\tc.Close()\n\t\treturn\n\t}\n\n\tlog.Printf(\"Proxying connection...\")\n\tgo func() {\n\t\tio.Copy(c, r)\n\t\tc.Close()\n\t}()\n\n\tgo func() {\n\t\tio.Copy(r, c)\n\t\tr.Close()\n\t}()\n}\n"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\n// Book represents a book\ntype Book struct {\n\tID     string `json:\"id\"`\n\tTitle  string `json:\"title\"`\n\tAuthor string `json:\"author\"`\n}\n\nvar books []Book\n\nfunc main() {\n\trouter := mux.NewRouter()\n\n\t//add some predefined books\n\tbooks = append(books, Book{ID: \"1\", Title: \"Go programming language\", Author: \"Alan A. Donovan and Brian W. Kernighan\"})\n\tbooks = append(books, Book{ID: \"2\", Title: \"Programming in Go: Creating Applications for the 21st Century\", Author: \"Mark Summerfield\"})\n\tbooks = append(books, Book{ID: \"3\", Title: \"Introducing Go: Build Reliable, Scalable Programs\", Author: \"Caleb Doxsey\"})\n\n\t//api endpoint to get all books\n\trouter.HandleFunc(\"/api/books\", getBooks).Methods(\"GET\")\n\n\t//api endpoint to get a single book by id\n\trouter.HandleFunc(\"/api/books/{id}\", getBook).Methods(\"GET\")\n\n\t//start the server\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc getBooks(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(books)\n}\n\nfunc getBook(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", \"application/json\")\n\tparams := mux.Vars(r)\n\tfor _, book := range books {\n\t\tif book.ID == params[\"id\"] {\n\t\t\tjson.NewEncoder(w).Encode(book)\n\t\t\treturn\n\t\t}\n\t}\n\tjson.NewEncoder(w).Encode(&Book{})\n}"}
{"sample": "// HandleErrorWithRecovery handles an error and attempts recovery\nfunc HandleErrorWithRecovery(err *error) {\n\tif r := recover(); r != nil {\n\t\t*err = fmt.Errorf(\"recovered error: %v\", r)\n\t\t// Attempt recovery...\n\t}\n}\n"}
{"sample": "func main() {\n\tusers := []User{\n\t\t{ID: 1, Name: \"John Doe\"}\n\t\t{ID: 2, Name: \"Jane Smith\"}\n\t}\n\n\tjson.NewEncoder(w).Encode(users)\n}"}
{"sample": "package cookiemanage\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/securecookie\"\n)\n\ntype CookieManager struct {\n\thashKey  []byte\n\tblockKey []byte\n\tsc       *securecookie.SecureCookie\n}\n\nfunc NewCookieManager(hashKey, blockKey []byte) *CookieManager {\n\treturn &CookieManager{\n\t\thashKey:  hashKey,\n\t\tblockKey: blockKey,\n\t\tsc:       securecookie.New(hashKey, blockKey),\n\t}\n}\n\nfunc (cm *CookieManager) SetCookie(w http.ResponseWriter, name string, value interface{}, age time.Duration) error {\n\tif encoded, err := cm.sc.Encode(name, value); err == nil {\n\t\tcookie := &http.Cookie{\n\t\t\tName:     name,\n\t\t\tValue:    encoded,\n\t\t\tExpires:  time.Now().Add(age),\n\t\t\tHttpOnly: true,\n\t\t\tPath:     \"/\",\n\t\t\tSecure:   true,\n\t\t\tSameSite: http.SameSiteStrictMode,\n\t\t}\n\t\thttp.SetCookie(w, cookie)\n\t\treturn nil\n\t} else {\n\t\treturn err\n\t}\n}\n\nfunc (cm *CookieManager) GetCookie(r *http.Request, name string, value interface{}) error {\n\tif cookie, err := r.Cookie(name); err == nil {\n\t\tif err = cm.sc.Decode(name, cookie.Value, value); err == nil {\n\t\t\treturn nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n}\n\nfunc (cm *CookieManager) ClearCookie(w http.ResponseWriter, name string) {\n\tcookie := &http.Cookie{\n\t\tName:     name,\n\t\tValue:    \"\",\n\t\tExpires:  time.Unix(0, 0),\n\t\tHttpOnly: true,\n\t\tPath:     \"/\",\n\t\tSecure:   true,\n\t\tSameSite: http.SameSiteStrictMode,\n\t}\n\thttp.SetCookie(w, cookie)\n}"}
{"sample": "select {\ncase <-ch1:\n\tfmt.Println(\"Got data from ch1\")\ncase <-ch2:\n\tfmt.Println(\"Got data from ch2\")\ndefault:\n\tfmt.Println(\"No data received\")\n}\n"}
{"sample": "package gcsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\n\t\"cloud.google.com/go/storage\"\n)\n\ntype GCSClient struct {\n\tclient *storage.Client\n\tbucket *storage.BucketHandle\n}\n\nfunc NewGCSClient(projectID, bucketName string) (*GCSClient, error) {\n\tctx := context.Background()\n\n\tclient, err := storage.NewClient(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create client: %v\", err)\n\t}\n\n\tbucket := client.Bucket(bucketName)\n\n\treturn &GCSClient{\n\t\tclient: client,\n\t\tbucket: bucket,\n\t}, nil\n}\n\nfunc (c *GCSClient) UploadObject(objectName string, r io.Reader) error {\n\tctx := context.Background()\n\n\twc := c.bucket.Object(objectName).NewWriter(ctx)\n\n\tif _, err := io.Copy(wc, r); err != nil {\n\t\treturn fmt.Errorf(\"failed to upload object: %v\", err)\n\t}\n\n\tif err := wc.Close(); err != nil {\n\t\treturn fmt.Errorf(\"failed to close writer: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *GCSClient) DownloadObject(objectName string, w io.Writer) error {\n\tctx := context.Background()\n\n\trc, err := c.bucket.Object(objectName).NewReader(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open object: %v\", err)\n\t}\n\tdefer rc.Close()\n\n\tif _, err := io.Copy(w, rc); err != nil {\n\t\treturn fmt.Errorf(\"failed to download object: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *GCSClient) ListObjects() ([]string, error) {\n\tctx := context.Background()\n\n\tvar objects []string\n\n\tit := c.bucket.Objects(ctx, nil)\n\tfor {\n\t\tobjAttrs, err := it.Next()\n\t\tif err == iterator.Done {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to iterate objects: %v\", err)\n\t\t}\n\t\tobjects = append(objects, objAttrs.Name)\n\t}\n\n\treturn objects, nil\n}\n\nfunc (c *GCSClient) DeleteObject(objectName string) error {\n\tctx := context.Background()\n\n\tif err := c.bucket.Object(objectName).Delete(ctx); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete object: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *GCSClient) Close() {\n\tif err := c.client.Close(); err != nil {\n\t\tlog.Printf(\"failed to close client: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\t// Create a random 2D slice of integers\n\tgrid := make([][]int, 5)\n\tfor i := range grid {\n\t\tgrid[i] = make([]int, 5)\n\t\tfor j := range grid[i] {\n\t\t\tgrid[i][j] = rand.Intn(10)\n\t\t}\n\t}\n\n\t// Print the grid\n\tfmt.Println(\"Grid:\")\n\tfor _, row := range grid {\n\t\tfmt.Println(row)\n\t}\n\n\t// Calculate the sum of each row\n\trowSums := make([]int, len(grid))\n\tfor i, row := range grid {\n\t\tsum := 0\n\t\tfor _, val := range row {\n\t\t\tsum += val\n\t\t}\n\t\trowSums[i] = sum\n\t}\n\n\t// Calculate the sum of each column\n\tcolSums := make([]int, len(grid[0]))\n\tfor j := 0; j < len(grid[0]); j++ {\n\t\tsum := 0\n\t\tfor i := 0; i < len(grid); i++ {\n\t\t\tsum += grid[i][j]\n\t\t}\n\t\tcolSums[j] = sum\n\t}\n\n\t// Print the row and column sums\n\tfmt.Println(\"Row sums:\", rowSums)\n\tfmt.Println(\"Column sums:\", colSums)\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/lib/pq\"\n)\n\nfunc main() {\n\tdb, err := sql.Open(\"postgres\", \"postgres://username:password@localhost/mydb?sslmode=disable\")\n\tif err != nil {\n\t\tfmt.Println(\"Failed to connect to the database:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\t// Perform database operations here\n\t// ...\n}\n"}
{"sample": "func DeleteFile(path string) error {\n\treturn os.Remove(path)\n}\n\nfunc CheckFileExists(path string) bool {\n\t_, err := os.Stat(path)\n\tif os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc RenameFile(oldPath, newPath string) error {\n\treturn os.Rename(oldPath, newPath)\n}"}
{"sample": "// FileHandler provides file related operations.\n// It uses a predefined filePath as the file to manipulate.\ntype FileHandler struct {\n\tfilePath string\n}\n\n// NewFileHandler creates a new FileHandler.\nfunc NewFileHandler(filePath string) *FileHandler {\n\treturn &FileHandler{filePath}\n}\n\n// ReadFile reads and returns the content of the file.\nfunc (fh *FileHandler) ReadFile() ([]byte, error) {\n\treturn ioutil.ReadFile(fh.filePath)\n}"}
{"sample": "// Set a custom timeout for the HTTP client\nfunc SetTimeout(client *http.Client, timeout time.Duration) {\n\tclient.Timeout = timeout\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// GenerateRandomNumber generates a random number within the specified range.\nfunc GenerateRandomNumber(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}"}
{"sample": "package main\n\n// Get the file extension\nfunc main() {\n\tabsPath, _ := filepath.Abs(\"file.txt\")\n\text := filepath.Ext(absPath)\n\tfmt.Println(\"Extension:\", ext)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs chan int, results chan int) {\n\tfor j := range jobs {\n\t\tfmt.Println(\"worker\", id, \"started  job\", j)\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Println(\"worker\", id, \"finished job\", j)\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tconst numJobs = 5\n\tjobs := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\n\tfor w := 1; w <= 3; w++ {\n\t\tgo worker(w, jobs, results)\n\t}\n\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- j\n\t}\n\n\tclose(jobs)\n\n\tvar wg sync.WaitGroup\n\twg.Add(numJobs)\n\n\tgo func() {\n\t\tfor r := range results {\n\t\t\tfmt.Println(\"result:\", r)\n\t\t\twg.Done()\n\t\t}\n\t\t\n\t}()\n\n\twg.Wait()\n}"}
{"sample": "package combsort\n\nfunc CombSort(arr []int) []int {\n\tn := len(arr)\n\tgap := n\n\tshrink := 1.3\n\tswapped := true\n\n\tfor swapped {\n\t\tgap = int(float64(gap) / shrink)\n\t\tif gap < 1 {\n\t\t\tgap = 1\n\t\t}\n\n\t\tswapped = false\n\n\t\tfor i := 0; i+gap < n; i++ {\n\t\t\tif arr[i] > arr[i+gap] {\n\t\t\t\tarr[i], arr[i+gap] = arr[i+gap], arr[i]\n\t\t\t\tswapped = true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn arr\n}"}
{"sample": "package main\n\nfunc ReverseString(str string) string {\n\trunes := []rune(str)\n\tfor i, j := 0, len(runes)-1; i < len(runes)/2; i, j = i+1, j-1 {\n\t\trunes[i], runes[j] = runes[j], runes[i]\n\t}\n\treturn string(runes)\n}\n"}
{"sample": "//  Copyright 2019 Google Inc. All Rights Reserved.\n//\n//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\n\npackage param\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"google.golang.org/api/option\"\n\n\t\"github.com/GoogleCloudPlatform/compute-image-tools/cli_tools/common/domain\"\n\t\"github.com/GoogleCloudPlatform/compute-image-tools/cli_tools/common/utils/paramhelper\"\n\t\"github.com/GoogleCloudPlatform/compute-image-tools/cli_tools/common/utils/storage\"\n\t\"github.com/GoogleCloudPlatform/compute-image-tools/cli_tools/common/utils/validation\"\n\t\"github.com/GoogleCloudPlatform/compute-image-tools/daisy\"\n\t\"github.com/GoogleCloudPlatform/compute-image-tools/daisy/compute\"\n)\n\n// GetProjectID gets project id from flag if exists; otherwise, try to retrieve from GCE metadata.\nfunc GetProjectID(mgce domain.MetadataGCEInterface, projectFlag string) (string, error) {\n\tif projectFlag == \"\" {\n\t\tif !mgce.OnGCE() {\n\t\t\treturn \"\", daisy.Errf(\"project cannot be determined because build is not running on GCE\")\n\t\t}\n\t\taProject, err := mgce.ProjectID()\n\t\tif err != nil || aProject == \"\" {\n\t\t\treturn \"\", daisy.Errf(\"project cannot be determined %v\", err)\n\t\t}\n\t\treturn aProject, nil\n\t}\n\treturn projectFlag, nil\n}\n\n// populateScratchBucketGcsPath validates the scratch bucket, creating a new one if not\n// provided, and returns the region of the scratch bucket. If the scratch bucket is\n// already populated, and the owning project doesn't match `project`, then an error is returned.\n// In that case, if `file` resides in the non-owned scratch bucket and `removeFileWhenScratchNotOwned`\n// is specified, then `file` is deleted from GCS.\nfunc populateScratchBucketGcsPath(scratchBucketGcsPath *string, zone string, mgce domain.MetadataGCEInterface,\n\tscratchBucketCreator domain.ScratchBucketCreatorInterface, file string, project *string,\n\tstorageClient domain.StorageClientInterface, removeFileWhenScratchNotOwned bool) (string, error) {\n\n\tscratchBucketRegion := \"\"\n\tif *scratchBucketGcsPath == \"\" {\n\t\tfallbackZone := zone\n\t\tif fallbackZone == \"\" && mgce.OnGCE() {\n\t\t\tvar err error\n\t\t\tif fallbackZone, err = mgce.Zone(); err != nil {\n\t\t\t\t// reset fallback zone if failed to get zone from running GCE\n\t\t\t\tfallbackZone = \"\"\n\t\t\t}\n\t\t}\n\n\t\tscratchBucketName, sbr, err := scratchBucketCreator.CreateScratchBucket(file, *project, fallbackZone)\n\t\tscratchBucketRegion = sbr\n\t\tif err != nil {\n\t\t\treturn \"\", daisy.Errf(\"failed to create scratch bucket: %v\", err)\n\t\t}\n\n\t\t*scratchBucketGcsPath = fmt.Sprintf(\"gs://%v/\", scratchBucketName)\n\t} else {\n\t\tscratchBucketName, err := storage.GetBucketNameFromGCSPath(*scratchBucketGcsPath)\n\t\tif err != nil {\n\t\t\treturn \"\", daisy.Errf(\"invalid scratch bucket GCS path %v\", scratchBucketGcsPath)\n\t\t}\n\n\t\tif !scratchBucketCreator.IsBucketInProject(*project, scratchBucketName) {\n\t\t\tanonymizedErrorMessage := \"Scratch bucket %q is not in project %q\"\n\n\t\t\tsubstitutions := []interface{}{scratchBucketName, *project}\n\n\t\t\tif removeFileWhenScratchNotOwned && strings.HasPrefix(file, fmt.Sprintf(\"gs://%s/\", scratchBucketName)) {\n\t\t\t\terr := storageClient.DeleteObject(file)\n\t\t\t\tif err == nil {\n\t\t\t\t\tanonymizedErrorMessage += \". Deleted %q\"\n\t\t\t\t\tsubstitutions = append(substitutions, file)\n\t\t\t\t} else {\n\t\t\t\t\tanonymizedErrorMessage += \". Failed to delete %q: %v. \" +\n\t\t\t\t\t\t\"Check with the owner of gs://%q for more information\"\n\t\t\t\t\tsubstitutions = append(substitutions, file, err, scratchBucketName)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"\", daisy.Errf(anonymizedErrorMessage, substitutions...)\n\t\t}\n\n\t\tscratchBucketAttrs, err := storageClient.GetBucketAttrs(scratchBucketName)\n\t\tif err == nil {\n\t\t\tscratchBucketRegion = scratchBucketAttrs.Location\n\t\t}\n\t}\n\treturn scratchBucketRegion, nil\n}\n\n// PopulateProjectIfMissing populates project id for cli tools\nfunc PopulateProjectIfMissing(mgce domain.MetadataGCEInterface, projectFlag *string) error {\n\tvar err error\n\t*projectFlag, err = GetProjectID(mgce, *projectFlag)\n\treturn err\n}\n\n// PopulateRegion populates region based on the value extracted from zone param\nfunc PopulateRegion(region *string, zone string) error {\n\taRegion, err := paramhelper.GetRegion(zone)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*region = aRegion\n\treturn nil\n}\n\n// CreateComputeClient creates a new compute client\nfunc CreateComputeClient(ctx *context.Context, oauth string, ce string) (compute.Client, error) {\n\tcomputeOptions := []option.ClientOption{option.WithCredentialsFile(oauth)}\n\tif ce != \"\" {\n\t\tcomputeOptions = append(computeOptions, option.WithEndpoint(ce))\n\t}\n\n\tcomputeClient, err := compute.NewClient(*ctx, computeOptions...)\n\tif err != nil {\n\t\treturn nil, daisy.Errf(\"failed to create compute client: %v\", err)\n\t}\n\treturn computeClient, nil\n}\n\nvar fullResourceURLPrefix = \"https://www.googleapis.com/compute/[^/]*/\"\nvar fullResourceURLRegex = regexp.MustCompile(fmt.Sprintf(\"^(%s)\", fullResourceURLPrefix))\n\nfunc getResourcePath(scope string, resourceType string, resourceName string) string {\n\t// handle full URL: transform to relative URL\n\tif prefix := fullResourceURLRegex.FindString(resourceName); prefix != \"\" {\n\t\treturn strings.TrimPrefix(resourceName, prefix)\n\t}\n\n\t// handle relative (partial) URL: use it as-is\n\tif strings.Contains(resourceName, \"/\") {\n\t\treturn resourceName\n\t}\n\n\t// handle pure name: treat it as current project\n\treturn fmt.Sprintf(\"%v/%v/%v\", scope, resourceType, resourceName)\n}\n\n// GetImageResourcePath gets the resource path for an image. It will panic if either\n// projectID or imageName is invalid. To avoid panic, pre-validate using the\n// functions in the `validation` package.\nfunc GetImageResourcePath(projectID, imageName string) string {\n\tif err := validation.ValidateImageName(imageName); err != nil {\n\t\tpanic(fmt.Sprintf(\"Invalid image name %q: %v\", imageName, err))\n\t}\n\tif err := validation.ValidateProjectID(projectID); err != nil {\n\t\tpanic(fmt.Sprintf(\"Invalid projectID %q: %v\", projectID, err))\n\t}\n\treturn fmt.Sprintf(\"projects/%s/global/images/%s\", projectID, imageName)\n}\n\n// GetGlobalResourcePath gets global resource path based on either a local resource name or a path\nfunc GetGlobalResourcePath(resourceType string, resourceName string) string {\n\treturn getResourcePath(\"global\", resourceType, resourceName)\n}\n\n// GetRegionalResourcePath gets regional resource path based on either a local resource name or a path\nfunc GetRegionalResourcePath(region string, resourceType string, resourceName string) string {\n\treturn getResourcePath(fmt.Sprintf(\"regions/%v\", region), resourceType, resourceName)\n}\n\n// GetZonalResourcePath gets zonal resource path based on either a local resource name or a path\nfunc GetZonalResourcePath(zone string, resourceType string, resourceName string) string {\n\treturn getResourcePath(fmt.Sprintf(\"zones/%v\", zone), resourceType, resourceName)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tPrintSquare(5)\n}\n\nfunc PrintSquare(n int) {\n\tfmt.Println(n * n)\n}"}
{"sample": "func IsPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tif n <= 3 {\n\t\treturn true\n\t}\n\tif n%2 == 0 || n%3 == 0 {\n\t\treturn false\n\t}\n\ti := 5\n\tfor i*i <= n {\n\t\tif n%i == 0 || n%(i+2) == 0 {\n\t\t\treturn false\n\t\t}\n\t\ti += 6\n\t}\n\treturn true\n}"}
{"sample": "/*\n * Adyen for Platforms: Notifications\n *\n * The Notification API sends notifications to the endpoints specified in a given subscription. Subscriptions are managed through the Notification Configuration API. The API specifications listed here detail the format of each notification.  For more information, refer to our [documentation](https://docs.adyen.com/platforms/notifications).\n *\n * API version: 6\n * Contact: support@adyen.com\n */\n\n// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.\n\npackage platformsnotificationevents\n\nimport (\n\t\"encoding/json\"\n)\n\n// PayoutMethod struct for PayoutMethod\ntype PayoutMethod struct {\n\tMerchantAccount string `json:\"merchantAccount\"`\n\tPayoutMethodCode *string `json:\"payoutMethodCode,omitempty\"`\n\tPayoutMethodType *string `json:\"payoutMethodType,omitempty\"`\n\tRecurringDetailReference string `json:\"recurringDetailReference\"`\n\tShopperReference string `json:\"shopperReference\"`\n}\n\n// NewPayoutMethod instantiates a new PayoutMethod object\n// This constructor will assign default values to properties that have it defined,\n// and makes sure properties required by API are set, but the set of arguments\n// will change when the set of required properties is changed\nfunc NewPayoutMethod(merchantAccount string, recurringDetailReference string, shopperReference string, ) *PayoutMethod {\n\tthis := PayoutMethod{}\n\tthis.MerchantAccount = merchantAccount\n\tthis.RecurringDetailReference = recurringDetailReference\n\tthis.ShopperReference = shopperReference\n\treturn &this\n}\n\n// NewPayoutMethodWithDefaults instantiates a new PayoutMethod object\n// This constructor will only assign default values to properties that have it defined,\n// but it doesn't guarantee that properties required by API are set\nfunc NewPayoutMethodWithDefaults() *PayoutMethod {\n\tthis := PayoutMethod{}\n\treturn &this\n}\n\n// GetMerchantAccount returns the MerchantAccount field value\nfunc (o *PayoutMethod) GetMerchantAccount() string {\n\tif o == nil  {\n\t\tvar ret string\n\t\treturn ret\n\t}\n\n\treturn o.MerchantAccount\n}\n\n// GetMerchantAccountOk returns a tuple with the MerchantAccount field value\n// and a boolean to check if the value has been set.\nfunc (o *PayoutMethod) GetMerchantAccountOk() (*string, bool) {\n\tif o == nil  {\n\t\treturn nil, false\n\t}\n\treturn &o.MerchantAccount, true\n}\n\n// SetMerchantAccount sets field value\nfunc (o *PayoutMethod) SetMerchantAccount(v string) {\n\to.MerchantAccount = v\n}\n\n// GetPayoutMethodCode returns the PayoutMethodCode field value if set, zero value otherwise.\nfunc (o *PayoutMethod) GetPayoutMethodCode() string {\n\tif o == nil || o.PayoutMethodCode == nil {\n\t\tvar ret string\n\t\treturn ret\n\t}\n\treturn *o.PayoutMethodCode\n}\n\n// GetPayoutMethodCodeOk returns a tuple with the PayoutMethodCode field value if set, nil otherwise\n// and a boolean to check if the value has been set.\nfunc (o *PayoutMethod) GetPayoutMethodCodeOk() (*string, bool) {\n\tif o == nil || o.PayoutMethodCode == nil {\n\t\treturn nil, false\n\t}\n\treturn o.PayoutMethodCode, true\n}\n\n// HasPayoutMethodCode returns a boolean if a field has been set.\nfunc (o *PayoutMethod) HasPayoutMethodCode() bool {\n\tif o != nil && o.PayoutMethodCode != nil {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// SetPayoutMethodCode gets a reference to the given string and assigns it to the PayoutMethodCode field.\nfunc (o *PayoutMethod) SetPayoutMethodCode(v string) {\n\to.PayoutMethodCode = &v\n}\n\n// GetPayoutMethodType returns the PayoutMethodType field value if set, zero value otherwise.\nfunc (o *PayoutMethod) GetPayoutMethodType() string {\n\tif o == nil || o.PayoutMethodType == nil {\n\t\tvar ret string\n\t\treturn ret\n\t}\n\treturn *o.PayoutMethodType\n}\n\n// GetPayoutMethodTypeOk returns a tuple with the PayoutMethodType field value if set, nil otherwise\n// and a boolean to check if the value has been set.\nfunc (o *PayoutMethod) GetPayoutMethodTypeOk() (*string, bool) {\n\tif o == nil || o.PayoutMethodType == nil {\n\t\treturn nil, false\n\t}\n\treturn o.PayoutMethodType, true\n}\n\n// HasPayoutMethodType returns a boolean if a field has been set.\nfunc (o *PayoutMethod) HasPayoutMethodType() bool {\n\tif o != nil && o.PayoutMethodType != nil {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// SetPayoutMethodType gets a reference to the given string and assigns it to the PayoutMethodType field.\nfunc (o *PayoutMethod) SetPayoutMethodType(v string) {\n\to.PayoutMethodType = &v\n}\n\n// GetRecurringDetailReference returns the RecurringDetailReference field value\nfunc (o *PayoutMethod) GetRecurringDetailReference() string {\n\tif o == nil  {\n\t\tvar ret string\n\t\treturn ret\n\t}\n\n\treturn o.RecurringDetailReference\n}\n\n// GetRecurringDetailReferenceOk returns a tuple with the RecurringDetailReference field value\n// and a boolean to check if the value has been set.\nfunc (o *PayoutMethod) GetRecurringDetailReferenceOk() (*string, bool) {\n\tif o == nil  {\n\t\treturn nil, false\n\t}\n\treturn &o.RecurringDetailReference, true\n}\n\n// SetRecurringDetailReference sets field value\nfunc (o *PayoutMethod) SetRecurringDetailReference(v string) {\n\to.RecurringDetailReference = v\n}\n\n// GetShopperReference returns the ShopperReference field value\nfunc (o *PayoutMethod) GetShopperReference() string {\n\tif o == nil  {\n\t\tvar ret string\n\t\treturn ret\n\t}\n\n\treturn o.ShopperReference\n}\n\n// GetShopperReferenceOk returns a tuple with the ShopperReference field value\n// and a boolean to check if the value has been set.\nfunc (o *PayoutMethod) GetShopperReferenceOk() (*string, bool) {\n\tif o == nil  {\n\t\treturn nil, false\n\t}\n\treturn &o.ShopperReference, true\n}\n\n// SetShopperReference sets field value\nfunc (o *PayoutMethod) SetShopperReference(v string) {\n\to.ShopperReference = v\n}\n\nfunc (o PayoutMethod) MarshalJSON() ([]byte, error) {\n\ttoSerialize := map[string]interface{}{}\n\tif true {\n\t\ttoSerialize[\"merchantAccount\"] = o.MerchantAccount\n\t}\n\tif o.PayoutMethodCode != nil {\n\t\ttoSerialize[\"payoutMethodCode\"] = o.PayoutMethodCode\n\t}\n\tif o.PayoutMethodType != nil {\n\t\ttoSerialize[\"payoutMethodType\"] = o.PayoutMethodType\n\t}\n\tif true {\n\t\ttoSerialize[\"recurringDetailReference\"] = o.RecurringDetailReference\n\t}\n\tif true {\n\t\ttoSerialize[\"shopperReference\"] = o.ShopperReference\n\t}\n\treturn json.Marshal(toSerialize)\n}\n\ntype NullablePayoutMethod struct {\n\tvalue *PayoutMethod\n\tisSet bool\n}\n\nfunc (v NullablePayoutMethod) Get() *PayoutMethod {\n\treturn v.value\n}\n\nfunc (v *NullablePayoutMethod) Set(val *PayoutMethod) {\n\tv.value = val\n\tv.isSet = true\n}\n\nfunc (v NullablePayoutMethod) IsSet() bool {\n\treturn v.isSet\n}\n\nfunc (v *NullablePayoutMethod) Unset() {\n\tv.value = nil\n\tv.isSet = false\n}\n\nfunc NewNullablePayoutMethod(val *PayoutMethod) *NullablePayoutMethod {\n\treturn &NullablePayoutMethod{value: val, isSet: true}\n}\n\nfunc (v NullablePayoutMethod) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(v.value)\n}\n\nfunc (v *NullablePayoutMethod) UnmarshalJSON(src []byte) error {\n\tv.isSet = true\n\treturn json.Unmarshal(src, &v.value)\n}\n\n\n"}
{"sample": "package main\n\n// IgnoreError ignores an error\nfunc IgnoreError(err error) {\n\t_ = err\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tjob := func(num int) {\n\t\tfmt.Printf(\"Starting job %d\\n\", num)\n\t\ttime.Sleep(time.Second * 3)\n\t\tfmt.Printf(\"Job %d finished\\n\", num)\n\t}\n\n\tfor i := 1; i <= 5; i++ {\n\t\tgo job(i)\n\t}\n\n\tfmt.Println(\"All jobs started\")\n\n\ttime.Sleep(time.Second * 5)\n\tfmt.Println(\"Main finished\")\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintCubeOfNumber(3)\n}\n\n// Function to print the cube of a number\nfunc PrintCubeOfNumber(n int) {\n\tfmt.Println(n * n * n)\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--num-epochs\", argparse.Int, 10, \"Number of training epochs\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\n"}
{"sample": "// EncodeJSON encodes an interface into a JSON string.\nfunc EncodeJSON(v interface{}) (string, error) {\n\tbytes, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(bytes), nil\n}\n\n// DecodeJSON decodes a JSON string into an interface.\nfunc DecodeJSON(s string, v interface{}) error {\n\treturn json.Unmarshal([]byte(s), v)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadJSONFile reads and parses a JSON file into a struct.\nfunc ReadJSONFile(filePath string, v interface{}) error {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tdata, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn json.Unmarshal(data, v)\n}\n\n// WriteJSONFile writes a struct as JSON to a file.\nfunc WriteJSONFile(filePath string, v interface{}) error {\n\tdata, err := json.MarshalIndent(v, \"\", \"  \")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ioutil.WriteFile(filePath, data, 0644)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintEvenNumbers prints even numbers up to a given limit.\nfunc PrintEvenNumbers(limit int) {\n\tfor i := 0; i <= limit; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "package aws\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/awserr\"\n\t\"github.com/aws/aws-sdk-go/service/ec2\"\n\t\"github.com/hashicorp/terraform/helper/hashcode\"\n\t\"github.com/hashicorp/terraform/helper/resource\"\n\t\"github.com/hashicorp/terraform/helper/schema\"\n)\n\n// How long to sleep if a limit-exceeded event happens\nvar routeTargetValidationError = errors.New(\"Error: more than 1 target specified. Only 1 of gateway_id, \" +\n\t\"egress_only_gateway_id, nat_gateway_id, instance_id, network_interface_id or \" +\n\t\"vpc_peering_connection_id is allowed.\")\n\n// AWS Route resource Schema declaration\nfunc resourceAwsRoute() *schema.Resource {\n\treturn &schema.Resource{\n\t\tCreate: resourceAwsRouteCreate,\n\t\tRead:   resourceAwsRouteRead,\n\t\tUpdate: resourceAwsRouteUpdate,\n\t\tDelete: resourceAwsRouteDelete,\n\t\tExists: resourceAwsRouteExists,\n\n\t\tSchema: map[string]*schema.Schema{\n\t\t\t\"destination_cidr_block\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tOptional: true,\n\t\t\t\tForceNew: true,\n\t\t\t},\n\t\t\t\"destination_ipv6_cidr_block\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tOptional: true,\n\t\t\t\tForceNew: true,\n\t\t\t},\n\n\t\t\t\"destination_prefix_list_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tComputed: true,\n\t\t\t},\n\n\t\t\t\"gateway_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tOptional: true,\n\t\t\t\tComputed: true,\n\t\t\t},\n\n\t\t\t\"egress_only_gateway_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tOptional: true,\n\t\t\t\tComputed: true,\n\t\t\t},\n\n\t\t\t\"nat_gateway_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tOptional: true,\n\t\t\t\tComputed: true,\n\t\t\t},\n\n\t\t\t\"instance_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tOptional: true,\n\t\t\t\tComputed: true,\n\t\t\t},\n\n\t\t\t\"instance_owner_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tComputed: true,\n\t\t\t},\n\n\t\t\t\"network_interface_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tOptional: true,\n\t\t\t\tComputed: true,\n\t\t\t},\n\n\t\t\t\"origin\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tComputed: true,\n\t\t\t},\n\n\t\t\t\"state\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tComputed: true,\n\t\t\t},\n\n\t\t\t\"route_table_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tRequired: true,\n\t\t\t},\n\n\t\t\t\"vpc_peering_connection_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tOptional: true,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc resourceAwsRouteCreate(d *schema.ResourceData, meta interface{}) error {\n\tconn := meta.(*AWSClient).ec2conn\n\tvar numTargets int\n\tvar setTarget string\n\tallowedTargets := []string{\n\t\t\"egress_only_gateway_id\",\n\t\t\"gateway_id\",\n\t\t\"nat_gateway_id\",\n\t\t\"instance_id\",\n\t\t\"network_interface_id\",\n\t\t\"vpc_peering_connection_id\",\n\t}\n\n\t// Check if more than 1 target is specified\n\tfor _, target := range allowedTargets {\n\t\tif len(d.Get(target).(string)) > 0 {\n\t\t\tnumTargets++\n\t\t\tsetTarget = target\n\t\t}\n\t}\n\n\tif numTargets > 1 {\n\t\treturn routeTargetValidationError\n\t}\n\n\tcreateOpts := &ec2.CreateRouteInput{}\n\t// Formulate CreateRouteInput based on the target type\n\tswitch setTarget {\n\tcase \"gateway_id\":\n\t\tcreateOpts = &ec2.CreateRouteInput{\n\t\t\tRouteTableId: aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tGatewayId:    aws.String(d.Get(\"gateway_id\").(string)),\n\t\t}\n\n\t\tif v, ok := d.GetOk(\"destination_cidr_block\"); ok {\n\t\t\tcreateOpts.DestinationCidrBlock = aws.String(v.(string))\n\t\t}\n\n\t\tif v, ok := d.GetOk(\"destination_ipv6_cidr_block\"); ok {\n\t\t\tcreateOpts.DestinationIpv6CidrBlock = aws.String(v.(string))\n\t\t}\n\n\tcase \"egress_only_gateway_id\":\n\t\tcreateOpts = &ec2.CreateRouteInput{\n\t\t\tRouteTableId:                aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tDestinationIpv6CidrBlock:    aws.String(d.Get(\"destination_ipv6_cidr_block\").(string)),\n\t\t\tEgressOnlyInternetGatewayId: aws.String(d.Get(\"egress_only_gateway_id\").(string)),\n\t\t}\n\tcase \"nat_gateway_id\":\n\t\tcreateOpts = &ec2.CreateRouteInput{\n\t\t\tRouteTableId:         aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tDestinationCidrBlock: aws.String(d.Get(\"destination_cidr_block\").(string)),\n\t\t\tNatGatewayId:         aws.String(d.Get(\"nat_gateway_id\").(string)),\n\t\t}\n\tcase \"instance_id\":\n\t\tcreateOpts = &ec2.CreateRouteInput{\n\t\t\tRouteTableId: aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tInstanceId:   aws.String(d.Get(\"instance_id\").(string)),\n\t\t}\n\n\t\tif v, ok := d.GetOk(\"destination_cidr_block\"); ok {\n\t\t\tcreateOpts.DestinationCidrBlock = aws.String(v.(string))\n\t\t}\n\n\t\tif v, ok := d.GetOk(\"destination_ipv6_cidr_block\"); ok {\n\t\t\tcreateOpts.DestinationIpv6CidrBlock = aws.String(v.(string))\n\t\t}\n\n\tcase \"network_interface_id\":\n\t\tcreateOpts = &ec2.CreateRouteInput{\n\t\t\tRouteTableId:       aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tNetworkInterfaceId: aws.String(d.Get(\"network_interface_id\").(string)),\n\t\t}\n\n\t\tif v, ok := d.GetOk(\"destination_cidr_block\"); ok {\n\t\t\tcreateOpts.DestinationCidrBlock = aws.String(v.(string))\n\t\t}\n\n\t\tif v, ok := d.GetOk(\"destination_ipv6_cidr_block\"); ok {\n\t\t\tcreateOpts.DestinationIpv6CidrBlock = aws.String(v.(string))\n\t\t}\n\n\tcase \"vpc_peering_connection_id\":\n\t\tcreateOpts = &ec2.CreateRouteInput{\n\t\t\tRouteTableId:           aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tVpcPeeringConnectionId: aws.String(d.Get(\"vpc_peering_connection_id\").(string)),\n\t\t}\n\n\t\tif v, ok := d.GetOk(\"destination_cidr_block\"); ok {\n\t\t\tcreateOpts.DestinationCidrBlock = aws.String(v.(string))\n\t\t}\n\n\t\tif v, ok := d.GetOk(\"destination_ipv6_cidr_block\"); ok {\n\t\t\tcreateOpts.DestinationIpv6CidrBlock = aws.String(v.(string))\n\t\t}\n\n\tdefault:\n\t\treturn fmt.Errorf(\"An invalid target type specified: %s\", setTarget)\n\t}\n\tlog.Printf(\"[DEBUG] Route create config: %s\", createOpts)\n\n\t// Create the route\n\tvar err error\n\n\terr = resource.Retry(2*time.Minute, func() *resource.RetryError {\n\t\t_, err = conn.CreateRoute(createOpts)\n\n\t\tif err != nil {\n\t\t\tec2err, ok := err.(awserr.Error)\n\t\t\tif !ok {\n\t\t\t\treturn resource.NonRetryableError(err)\n\t\t\t}\n\t\t\tif ec2err.Code() == \"InvalidParameterException\" {\n\t\t\t\tlog.Printf(\"[DEBUG] Trying to create route again: %q\", ec2err.Message())\n\t\t\t\treturn resource.RetryableError(err)\n\t\t\t}\n\n\t\t\treturn resource.NonRetryableError(err)\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error creating route: %s\", err)\n\t}\n\n\tvar route *ec2.Route\n\n\tif v, ok := d.GetOk(\"destination_cidr_block\"); ok {\n\t\terr = resource.Retry(2*time.Minute, func() *resource.RetryError {\n\t\t\troute, err = findResourceRoute(conn, d.Get(\"route_table_id\").(string), v.(string), \"\")\n\t\t\treturn resource.RetryableError(err)\n\t\t})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Error finding route after creating it: %s\", err)\n\t\t}\n\t}\n\n\tif v, ok := d.GetOk(\"destination_ipv6_cidr_block\"); ok {\n\t\terr = resource.Retry(2*time.Minute, func() *resource.RetryError {\n\t\t\troute, err = findResourceRoute(conn, d.Get(\"route_table_id\").(string), \"\", v.(string))\n\t\t\treturn resource.RetryableError(err)\n\t\t})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Error finding route after creating it: %s\", err)\n\t\t}\n\t}\n\n\td.SetId(routeIDHash(d, route))\n\tresourceAwsRouteSetResourceData(d, route)\n\treturn nil\n}\n\nfunc resourceAwsRouteRead(d *schema.ResourceData, meta interface{}) error {\n\tconn := meta.(*AWSClient).ec2conn\n\trouteTableId := d.Get(\"route_table_id\").(string)\n\n\tdestinationCidrBlock := d.Get(\"destination_cidr_block\").(string)\n\tdestinationIpv6CidrBlock := d.Get(\"destination_ipv6_cidr_block\").(string)\n\n\troute, err := findResourceRoute(conn, routeTableId, destinationCidrBlock, destinationIpv6CidrBlock)\n\tif err != nil {\n\t\tif ec2err, ok := err.(awserr.Error); ok && ec2err.Code() == \"InvalidRouteTableID.NotFound\" {\n\t\t\tlog.Printf(\"[WARN] Route Table %q could not be found. Removing Route from state.\",\n\t\t\t\trouteTableId)\n\t\t\td.SetId(\"\")\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\tresourceAwsRouteSetResourceData(d, route)\n\treturn nil\n}\n\nfunc resourceAwsRouteSetResourceData(d *schema.ResourceData, route *ec2.Route) {\n\td.Set(\"destination_prefix_list_id\", route.DestinationPrefixListId)\n\td.Set(\"gateway_id\", route.GatewayId)\n\td.Set(\"egress_only_gateway_id\", route.EgressOnlyInternetGatewayId)\n\td.Set(\"nat_gateway_id\", route.NatGatewayId)\n\td.Set(\"instance_id\", route.InstanceId)\n\td.Set(\"instance_owner_id\", route.InstanceOwnerId)\n\td.Set(\"network_interface_id\", route.NetworkInterfaceId)\n\td.Set(\"origin\", route.Origin)\n\td.Set(\"state\", route.State)\n\td.Set(\"vpc_peering_connection_id\", route.VpcPeeringConnectionId)\n}\n\nfunc resourceAwsRouteUpdate(d *schema.ResourceData, meta interface{}) error {\n\tconn := meta.(*AWSClient).ec2conn\n\tvar numTargets int\n\tvar setTarget string\n\n\tallowedTargets := []string{\n\t\t\"egress_only_gateway_id\",\n\t\t\"gateway_id\",\n\t\t\"nat_gateway_id\",\n\t\t\"network_interface_id\",\n\t\t\"instance_id\",\n\t\t\"vpc_peering_connection_id\",\n\t}\n\treplaceOpts := &ec2.ReplaceRouteInput{}\n\n\t// Check if more than 1 target is specified\n\tfor _, target := range allowedTargets {\n\t\tif len(d.Get(target).(string)) > 0 {\n\t\t\tnumTargets++\n\t\t\tsetTarget = target\n\t\t}\n\t}\n\n\tswitch setTarget {\n\t//instance_id is a special case due to the fact that AWS will \"discover\" the network_interace_id\n\t//when it creates the route and return that data.  In the case of an update, we should ignore the\n\t//existing network_interface_id\n\tcase \"instance_id\":\n\t\tif numTargets > 2 || (numTargets == 2 && len(d.Get(\"network_interface_id\").(string)) == 0) {\n\t\t\treturn routeTargetValidationError\n\t\t}\n\tdefault:\n\t\tif numTargets > 1 {\n\t\t\treturn routeTargetValidationError\n\t\t}\n\t}\n\n\t// Formulate ReplaceRouteInput based on the target type\n\tswitch setTarget {\n\tcase \"gateway_id\":\n\t\treplaceOpts = &ec2.ReplaceRouteInput{\n\t\t\tRouteTableId:         aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tDestinationCidrBlock: aws.String(d.Get(\"destination_cidr_block\").(string)),\n\t\t\tGatewayId:            aws.String(d.Get(\"gateway_id\").(string)),\n\t\t}\n\tcase \"egress_only_gateway_id\":\n\t\treplaceOpts = &ec2.ReplaceRouteInput{\n\t\t\tRouteTableId:                aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tDestinationIpv6CidrBlock:    aws.String(d.Get(\"destination_ipv6_cidr_block\").(string)),\n\t\t\tEgressOnlyInternetGatewayId: aws.String(d.Get(\"egress_only_gateway_id\").(string)),\n\t\t}\n\tcase \"nat_gateway_id\":\n\t\treplaceOpts = &ec2.ReplaceRouteInput{\n\t\t\tRouteTableId:         aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tDestinationCidrBlock: aws.String(d.Get(\"destination_cidr_block\").(string)),\n\t\t\tNatGatewayId:         aws.String(d.Get(\"nat_gateway_id\").(string)),\n\t\t}\n\tcase \"instance_id\":\n\t\treplaceOpts = &ec2.ReplaceRouteInput{\n\t\t\tRouteTableId:         aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tDestinationCidrBlock: aws.String(d.Get(\"destination_cidr_block\").(string)),\n\t\t\tInstanceId:           aws.String(d.Get(\"instance_id\").(string)),\n\t\t}\n\tcase \"network_interface_id\":\n\t\treplaceOpts = &ec2.ReplaceRouteInput{\n\t\t\tRouteTableId:         aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tDestinationCidrBlock: aws.String(d.Get(\"destination_cidr_block\").(string)),\n\t\t\tNetworkInterfaceId:   aws.String(d.Get(\"network_interface_id\").(string)),\n\t\t}\n\tcase \"vpc_peering_connection_id\":\n\t\treplaceOpts = &ec2.ReplaceRouteInput{\n\t\t\tRouteTableId:           aws.String(d.Get(\"route_table_id\").(string)),\n\t\t\tDestinationCidrBlock:   aws.String(d.Get(\"destination_cidr_block\").(string)),\n\t\t\tVpcPeeringConnectionId: aws.String(d.Get(\"vpc_peering_connection_id\").(string)),\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"An invalid target type specified: %s\", setTarget)\n\t}\n\tlog.Printf(\"[DEBUG] Route replace config: %s\", replaceOpts)\n\n\t// Replace the route\n\t_, err := conn.ReplaceRoute(replaceOpts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc resourceAwsRouteDelete(d *schema.ResourceData, meta interface{}) error {\n\tconn := meta.(*AWSClient).ec2conn\n\n\tdeleteOpts := &ec2.DeleteRouteInput{\n\t\tRouteTableId: aws.String(d.Get(\"route_table_id\").(string)),\n\t}\n\tif v, ok := d.GetOk(\"destination_cidr_block\"); ok {\n\t\tdeleteOpts.DestinationCidrBlock = aws.String(v.(string))\n\t}\n\tif v, ok := d.GetOk(\"destination_ipv6_cidr_block\"); ok {\n\t\tdeleteOpts.DestinationIpv6CidrBlock = aws.String(v.(string))\n\t}\n\tlog.Printf(\"[DEBUG] Route delete opts: %s\", deleteOpts)\n\n\tvar err error\n\terr = resource.Retry(5*time.Minute, func() *resource.RetryError {\n\t\tlog.Printf(\"[DEBUG] Trying to delete route with opts %s\", deleteOpts)\n\t\tresp, err := conn.DeleteRoute(deleteOpts)\n\t\tlog.Printf(\"[DEBUG] Route delete result: %s\", resp)\n\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tec2err, ok := err.(awserr.Error)\n\t\tif !ok {\n\t\t\treturn resource.NonRetryableError(err)\n\t\t}\n\t\tif ec2err.Code() == \"InvalidParameterException\" {\n\t\t\tlog.Printf(\"[DEBUG] Trying to delete route again: %q\",\n\t\t\t\tec2err.Message())\n\t\t\treturn resource.RetryableError(err)\n\t\t}\n\n\t\treturn resource.NonRetryableError(err)\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td.SetId(\"\")\n\treturn nil\n}\n\nfunc resourceAwsRouteExists(d *schema.ResourceData, meta interface{}) (bool, error) {\n\tconn := meta.(*AWSClient).ec2conn\n\trouteTableId := d.Get(\"route_table_id\").(string)\n\n\tfindOpts := &ec2.DescribeRouteTablesInput{\n\t\tRouteTableIds: []*string{&routeTableId},\n\t}\n\n\tres, err := conn.DescribeRouteTables(findOpts)\n\tif err != nil {\n\t\tif ec2err, ok := err.(awserr.Error); ok && ec2err.Code() == \"InvalidRouteTableID.NotFound\" {\n\t\t\tlog.Printf(\"[WARN] Route Table %q could not be found.\", routeTableId)\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, fmt.Errorf(\"Error while checking if route exists: %s\", err)\n\t}\n\n\tif len(res.RouteTables) < 1 || res.RouteTables[0] == nil {\n\t\tlog.Printf(\"[WARN] Route Table %q is gone, or route does not exist.\",\n\t\t\trouteTableId)\n\t\treturn false, nil\n\t}\n\n\tif v, ok := d.GetOk(\"destination_cidr_block\"); ok {\n\t\tfor _, route := range (*res.RouteTables[0]).Routes {\n\t\t\tif route.DestinationCidrBlock != nil && *route.DestinationCidrBlock == v.(string) {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tif v, ok := d.GetOk(\"destination_ipv6_cidr_block\"); ok {\n\t\tfor _, route := range (*res.RouteTables[0]).Routes {\n\t\t\tif route.DestinationIpv6CidrBlock != nil && *route.DestinationIpv6CidrBlock == v.(string) {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// Create an ID for a route\nfunc routeIDHash(d *schema.ResourceData, r *ec2.Route) string {\n\n\tif r.DestinationIpv6CidrBlock != nil && *r.DestinationIpv6CidrBlock != \"\" {\n\t\treturn fmt.Sprintf(\"r-%s%d\", d.Get(\"route_table_id\").(string), hashcode.String(*r.DestinationIpv6CidrBlock))\n\t}\n\n\treturn fmt.Sprintf(\"r-%s%d\", d.Get(\"route_table_id\").(string), hashcode.String(*r.DestinationCidrBlock))\n}\n\n// Helper: retrieve a route\nfunc findResourceRoute(conn *ec2.EC2, rtbid string, cidr string, ipv6cidr string) (*ec2.Route, error) {\n\trouteTableID := rtbid\n\n\tfindOpts := &ec2.DescribeRouteTablesInput{\n\t\tRouteTableIds: []*string{&routeTableID},\n\t}\n\n\tresp, err := conn.DescribeRouteTables(findOpts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(resp.RouteTables) < 1 || resp.RouteTables[0] == nil {\n\t\treturn nil, fmt.Errorf(\"Route Table %q is gone, or route does not exist.\",\n\t\t\trouteTableID)\n\t}\n\n\tif cidr != \"\" {\n\t\tfor _, route := range (*resp.RouteTables[0]).Routes {\n\t\t\tif route.DestinationCidrBlock != nil && *route.DestinationCidrBlock == cidr {\n\t\t\t\treturn route, nil\n\t\t\t}\n\t\t}\n\n\t\treturn nil, fmt.Errorf(\"Unable to find matching route for Route Table (%s) \"+\n\t\t\t\"and destination CIDR block (%s).\", rtbid, cidr)\n\t}\n\n\tif ipv6cidr != \"\" {\n\t\tfor _, route := range (*resp.RouteTables[0]).Routes {\n\t\t\tif route.DestinationIpv6CidrBlock != nil && *route.DestinationIpv6CidrBlock == ipv6cidr {\n\t\t\t\treturn route, nil\n\t\t\t}\n\t\t}\n\n\t\treturn nil, fmt.Errorf(\"Unable to find matching route for Route Table (%s) \"+\n\t\t\t\"and destination IPv6 CIDR block (%s).\", rtbid, ipv6cidr)\n\t}\n\n\treturn nil, fmt.Errorf(\"When trying to find a matching route for Route Table %q \"+\n\t\t\"you need to specify a CIDR block of IPv6 CIDR Block\", rtbid)\n\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tselect {\n\tcase <-time.After(2 * time.Second):\n\t\tfmt.Println(\"Timeout\")\n\tcase <-time.After(3 * time.Second):\n\t\tfmt.Println(\"Another timeout\")\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// GetCurrentTime returns the current time in the specified time zone.\nfunc GetCurrentTime(timezone string) (time.Time, error) {\n\tloc, err := time.LoadLocation(timezone)\n\tif err != nil {\n\t\treturn time.Time{} err\n\t}\n\treturn time.Now().In(loc), nil\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype User struct {\n\tId    int64\n\tName  string\n\tEmail string\n}\n\ntype UserService struct {\n\tusers []*User\n}\n\nfunc (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error) {\n\tuser := &User{\n\t\tId:    int64(len(s.users) + 1),\n\t\tName:  req.Name,\n\t\tEmail: req.Email,\n\t}\n\ts.users = append(s.users, user)\n\treturn &CreateUserResponse{\n\t\tId: user.Id,\n\t}, nil\n}\n\nfunc (s *UserService) GetUser(ctx context.Context, req *GetUserRequest) (*GetUserResponse, error) {\n\tfor _, user := range s.users {\n\t\tif user.Id == req.Id {\n\t\t\treturn &GetUserResponse{\n\t\t\t\tUser: user,\n\t\t\t}, nil\n\t\t}\n\t}\n\treturn nil, status.Error(codes.NotFound, \"User not found\")\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tcreds, err := credentials.NewServerTLSFromFile(\"cert.pem\", \"key.pem\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to load credentials: %v\", err)\n\t}\n\n\ts := grpc.NewServer(grpc.Creds(creds))\n\tRegisterUserServiceServer(s, &UserService{})\n\tfmt.Println(\"Server listening on port :8080\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype Book struct {\n\tID     string `json:\"id,omitempty\"`\n\tTitle  string `json:\"title,omitempty\"`\n\tAuthor string `json:\"author,omitempty\"`\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/books\", GetBooks).Methods(\"GET\")\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc GetBooks(w http.ResponseWriter, r *http.Request) {\n\tbooks := []Book{{ID: \"1\", Title: \"Book1\", Author: \"Author1\"}}\n\tjson.NewEncoder(w).Encode(books)\n}"}
{"sample": "func main() {\n\tfileNames, err := ioutil.ReadDir(\".\")\n\tif err != nil {\n\t\tfmt.Println(\"Error reading directory:\", err)\n\t\treturn\n\t}\n\n\tfor _, file := range fileNames {\n\t\tfmt.Println(file.Name())\n\t}\n}"}
{"sample": "package bintreesearch\n\ntype node struct {\n\tvalue int\n\tleft  *node\n\tright *node\n}\n\ntype Tree struct {\n\troot *node\n}\n\nfunc (t *Tree) Insert(value int) {\n\tif t.root == nil {\n\t\tt.root = &node{value: value}\n\t\treturn\n\t}\n\n\tcurrent := t.root\n\tfor {\n\t\tif value < current.value {\n\t\t\tif current.left == nil {\n\t\t\t\tcurrent.left = &node{value: value}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent = current.left\n\t\t} else {\n\t\t\tif current.right == nil {\n\t\t\t\tcurrent.right = &node{value: value}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent = current.right\n\t\t}\n\t}\n}\n\nfunc (t *Tree) Search(value int) bool {\n\tcurrent := t.root\n\tfor current != nil {\n\t\tif value == current.value {\n\t\t\treturn true\n\t\t} else if value < current.value {\n\t\t\tcurrent = current.left\n\t\t} else {\n\t\t\tcurrent = current.right\n\t\t}\n\t}\n\treturn false\n}"}
{"sample": "package leadservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"leadservice/database\"\n\t\"leadservice/models\"\n)\n\ntype LeadService struct {\n\tdb *database.DB\n}\n\nfunc NewLeadService(db *database.DB) *LeadService {\n\treturn &LeadService{\n\t\tdb: db,\n\t}\n}\n\nfunc (s *LeadService) CreateLead(ctx context.Context, lead *models.Lead) error {\n\tif lead == nil {\n\t\treturn errors.New(\"lead cannot be nil\")\n\t}\n\n\treturn s.db.CreateLead(ctx, lead)\n}\n\nfunc (s *LeadService) GetLead(ctx context.Context, id string) (*models.Lead, error) {\n\tif id == \"\" {\n\t\treturn nil, errors.New(\"id cannot be empty\")\n\t}\n\n\treturn s.db.GetLead(ctx, id)\n}\n\nfunc (s *LeadService) UpdateLead(ctx context.Context, lead *models.Lead) error {\n\tif lead == nil {\n\t\treturn errors.New(\"lead cannot be nil\")\n\t}\n\n\treturn s.db.UpdateLead(ctx, lead)\n}\n\nfunc (s *LeadService) DeleteLead(ctx context.Context, id string) error {\n\tif id == \"\" {\n\t\treturn errors.New(\"id cannot be empty\")\n\t}\n\n\treturn s.db.DeleteLead(ctx, id)\n}\n\nfunc (s *LeadService) ListLeads(ctx context.Context, limit, offset int) ([]*models.Lead, error) {\n\treturn s.db.ListLeads(ctx, limit, offset)\n}"}
{"sample": "type Node struct {\n\tValue int\n\tNext  *Node\n}\n\ntype LinkedList struct {\n\tHead *Node\n}\n\nfunc (l *LinkedList) Insert(value int) {\n\tif l.Head == nil {\n\t\tl.Head = &Node{Value: value}\n\t\treturn\n\t}\n\tcurrent := l.Head\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t}\n\tcurrent.Next = &Node{Value: value}\n}"}
{"sample": "// PanicIfError panics if the error is not nil\nfunc PanicIfError(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintFactors prints the factors of a given number.\nfunc PrintFactors(num int) {\n\tfmt.Print(\"Factors of \", num, \":\")\n\tfor i := 1; i <= num; i++ {\n\t\tif num%i == 0 {\n\t\t\tfmt.Print(\" \", i)\n\t\t}\n\t}\n\tfmt.Println()\n}"}
{"sample": "// Enable HTTP basic authentication for the server\nfunc EnableHTTPBasicAuth(handler http.Handler, username, password string) http.Handler {\n\treturn auth.BasicAuth(username, password)(handler)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Factorial calculates the factorial of a given non-negative integer.\nfunc Factorial(n int) int {\n\tif n <= 1 {\n\t\treturn 1\n\t}\n\treturn n * Factorial(n-1)\n}"}
{"sample": "// Using a channel\n\nch := make(chan int)\ngo func() {\n\tch <- doSomething()\n}()\nresult := <-ch\n"}
{"sample": "// Code generated by the Pulumi SDK Generator DO NOT EDIT.\n// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***\n\npackage events\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\n// Resource Type definition for AWS::Events::Connection.\nfunc LookupConnection(ctx *pulumi.Context, args *LookupConnectionArgs, opts ...pulumi.InvokeOption) (*LookupConnectionResult, error) {\n\tvar rv LookupConnectionResult\n\terr := ctx.Invoke(\"aws-native:events:getConnection\", args, &rv, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &rv, nil\n}\n\ntype LookupConnectionArgs struct {\n\t// Name of the connection.\n\tName string `pulumi:\"name\"`\n}\n\ntype LookupConnectionResult struct {\n\t// The arn of the connection resource.\n\tArn               *string                      `pulumi:\"arn\"`\n\tAuthorizationType *ConnectionAuthorizationType `pulumi:\"authorizationType\"`\n\t// Description of the connection.\n\tDescription *string `pulumi:\"description\"`\n\t// The arn of the secrets manager secret created in the customer account.\n\tSecretArn *string `pulumi:\"secretArn\"`\n}\n\nfunc LookupConnectionOutput(ctx *pulumi.Context, args LookupConnectionOutputArgs, opts ...pulumi.InvokeOption) LookupConnectionResultOutput {\n\treturn pulumi.ToOutputWithContext(context.Background(), args).\n\t\tApplyT(func(v interface{}) (LookupConnectionResult, error) {\n\t\t\targs := v.(LookupConnectionArgs)\n\t\t\tr, err := LookupConnection(ctx, &args, opts...)\n\t\t\tvar s LookupConnectionResult\n\t\t\tif r != nil {\n\t\t\t\ts = *r\n\t\t\t}\n\t\t\treturn s, err\n\t\t}).(LookupConnectionResultOutput)\n}\n\ntype LookupConnectionOutputArgs struct {\n\t// Name of the connection.\n\tName pulumi.StringInput `pulumi:\"name\"`\n}\n\nfunc (LookupConnectionOutputArgs) ElementType() reflect.Type {\n\treturn reflect.TypeOf((*LookupConnectionArgs)(nil)).Elem()\n}\n\ntype LookupConnectionResultOutput struct{ *pulumi.OutputState }\n\nfunc (LookupConnectionResultOutput) ElementType() reflect.Type {\n\treturn reflect.TypeOf((*LookupConnectionResult)(nil)).Elem()\n}\n\nfunc (o LookupConnectionResultOutput) ToLookupConnectionResultOutput() LookupConnectionResultOutput {\n\treturn o\n}\n\nfunc (o LookupConnectionResultOutput) ToLookupConnectionResultOutputWithContext(ctx context.Context) LookupConnectionResultOutput {\n\treturn o\n}\n\n// The arn of the connection resource.\nfunc (o LookupConnectionResultOutput) Arn() pulumi.StringPtrOutput {\n\treturn o.ApplyT(func(v LookupConnectionResult) *string { return v.Arn }).(pulumi.StringPtrOutput)\n}\n\nfunc (o LookupConnectionResultOutput) AuthorizationType() ConnectionAuthorizationTypePtrOutput {\n\treturn o.ApplyT(func(v LookupConnectionResult) *ConnectionAuthorizationType { return v.AuthorizationType }).(ConnectionAuthorizationTypePtrOutput)\n}\n\n// Description of the connection.\nfunc (o LookupConnectionResultOutput) Description() pulumi.StringPtrOutput {\n\treturn o.ApplyT(func(v LookupConnectionResult) *string { return v.Description }).(pulumi.StringPtrOutput)\n}\n\n// The arn of the secrets manager secret created in the customer account.\nfunc (o LookupConnectionResultOutput) SecretArn() pulumi.StringPtrOutput {\n\treturn o.ApplyT(func(v LookupConnectionResult) *string { return v.SecretArn }).(pulumi.StringPtrOutput)\n}\n\nfunc init() {\n\tpulumi.RegisterOutputType(LookupConnectionResultOutput{})\n}\n"}
{"sample": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"runtime\"\n\n\t\"github.com/cloud66-oss/habitus/api\"\n\t\"github.com/cloud66-oss/habitus/build\"\n\t\"github.com/cloud66-oss/habitus/configuration\"\n\t\"github.com/getsentry/raven-go\"\n\t\"github.com/op/go-logging\"\n)\n\nvar prettyFormat = logging.MustStringFormatter(\n\t\"%{color}\u25b6 %{message} %{color:reset}\",\n)\nvar plainFormat = logging.MustStringFormatter(\n\t\"[%{level}] - %{message}\",\n)\n\nvar (\n\tflagLevel       string\n\tflagShowHelp    bool\n\tflagShowVersion bool\n\tflagPrettyLog   bool\n\tVERSION         string = \"dev\"\n\tBUILD_DATE      string = \"\"\n)\n\nfunc init() {\n\t//sentry DSN setup\n\traven.SetDSN(\"https://c5b047b41b3f4de38fc93cb3df75fd43:c94164f03aba4ded84de1fa5894e6544@sentry.io/187936\")\n}\n\nconst DEFAULT_DOCKER_HOST = \"unix:///var/run/docker.sock\"\n\nfunc main() {\n\targs := os.Args[1:]\n\tdefer recoverPanic()\n\n\tvar log = logging.MustGetLogger(\"habitus\")\n\tlogging.SetFormatter(plainFormat)\n\n\tconfig := configuration.CreateConfig()\n\tflag.StringVar(&config.Buildfile, \"f\", \"build.yml\", \"Build file path. Defaults to build.yml in the workdir\")\n\tflag.StringVar(&config.Workdir, \"d\", \"\", \"Work directory for this build. Defaults to the current directory\")\n\tflag.BoolVar(&config.NoCache, \"no-cache\", false, \"Don't use cache in build\")\n\tflag.BoolVar(&config.SuppressOutput, \"suppress\", false, \"Suppress build output\")\n\tflag.BoolVar(&config.RmTmpContainers, \"rm\", true, \"Remove intermediate containers\")\n\tflag.BoolVar(&config.ForceRmTmpContainer, \"force-rm\", false, \"Force remove intermediate containers\")\n\tflag.StringVar(&config.UniqueID, \"uid\", \"\", \"Unique ID for the build. Used only for multi-tenanted build environments\")\n\tflag.StringVar(&flagLevel, \"level\", \"debug\", \"Log level: debug, info, notice, warning, error and critical\")\n\tflag.BoolVar(&flagPrettyLog, \"pretty\", true, \"Display logs with color and formatting\")\n\n\tdockerhost, ok := os.LookupEnv(\"DOCKER_HOST\")\n\tif !ok {\n\t\tdockerhost = DEFAULT_DOCKER_HOST\n\t}\n\n\tflag.StringVar(&config.DockerHost, \"host\", dockerhost, \"Docker host link. Uses DOCKER_HOST if missing.\")\n\tflag.StringVar(&config.DockerCert, \"certs\", os.Getenv(\"DOCKER_CERT_PATH\"), \"Docker cert folder. Uses DOCKER_CERT_PATH if missing\")\n\tflag.Var(&config.EnvVars, \"env\", \"Environment variables to be used in the build.yml. Uses parent process environment variables if empty\")\n\tflag.Var(&config.BuildArgs, \"build\", \"Build arguments to be used during each Dockerfile build step.\")\n\tflag.StringVar(&config.Network, \"network\", \"\", \"Set the networking mode for the RUN instructions during build. See `networkmode` in https://docs.docker.com/engine/api/v1.25/#operation/ImageBuild for available values. If omitted, the \\\"default\\\" bridge network is used, which is the same behavior as `docker build`.\")\n\tflag.BoolVar(&config.KeepSteps, \"keep-all\", false, \"Overrides the keep flag for all steps. Used for debugging\")\n\tflag.BoolVar(&config.KeepArtifacts, \"keep-artifacts\", false, \"Keep the temporary artifacts created on the host during build. Used for debugging\")\n\tflag.BoolVar(&config.UseTLS, \"use-tls\", os.Getenv(\"DOCKER_TLS_VERIFY\") == \"1\", \"Establish TLS connection with Docker daemon. Uses DOCKER_TLS_VERIFY if missing\")\n\tflag.BoolVar(&config.UseStatForPermissions, \"use-stat\", true, \"Uses the stat command inside your container to get the arfifact permissions\")\n\n\tflag.BoolVar(&config.NoSquash, \"no-cleanup\", false, \"Skip cleanup commands for this run. Used for debugging\")\n\tflag.BoolVar(&config.FroceRmImages, \"force-rmi\", false, \"Force remove of unwanted images\")\n\tflag.BoolVar(&config.NoPruneRmImages, \"noprune-rmi\", false, \"No pruning of unwanted images\")\n\tflag.StringVar(&config.OsType, \"os\", \"debian\", \"Specify the OS that the build occurs in\")\n\tflag.BoolVar(&flagShowHelp, \"help\", false, \"Display the help\")\n\tflag.BoolVar(&flagShowVersion, \"version\", false, \"Display version information\")\n\tflag.IntVar(&config.ApiPort, \"port\", 8080, \"Port to server the API\")\n\tflag.StringVar(&config.ApiBinding, \"binding\", \"192.168.99.1\", \"Network address to bind the API to. (see documentation for more info)\")\n\tflag.BoolVar(&config.SecretService, \"secrets\", false, \"Turn Secrets Service on or off\")\n\tflag.BoolVar(&config.AllowAfterBuildCommands, \"after-build-commands\", false, \"Allow to run arbitrary commands on the host after build\")\n\tflag.StringVar(&config.SecretProviders, \"sec-providers\", \"file,env\", \"All available secret providers. Comma separated\")\n\tflag.StringVar(&config.DockerMemory, \"docker-memory\", \"\", \"Memory limits to apply to Docker build operations. More: https://docs.docker.com/engine/reference/commandline/build\")\n\tflag.StringVar(&config.DockerCPUSetCPUs, \"docker-cpuset-cpus\", \"\", \"CPU binding limits to apply to Docker build operations. More: https://docs.docker.com/engine/reference/commandline/build\")\n\tflag.IntVar(&config.DockerCPUShares, \"docker-cpu-shares\", 1024, \"CPU share weighting to apply to Docker build operations. More: https://docs.docker.com/engine/reference/commandline/build\")\n\n\tflag.BoolVar(&config.UseAuthenticatedSecretServer, \"authentication-secret-server\", false, \"Enable basic authentication for secret server\")\n\tflag.StringVar(&config.AuthenticatedSecretServerPassword, \"password-secret-server\", \"admin\", \"The password for basic authentication.\")\n\tflag.StringVar(&config.AuthenticatedSecretServerUser, \"user-secret-server\", \"habitus\", \"The user for basic authentication.\")\n\n\tconfig.Logger = *log\n\tflag.Parse()\n\n\tif flagPrettyLog {\n\t\tlogging.SetFormatter(prettyFormat)\n\t}\n\n\tif flagShowHelp || (len(args) > 0 && args[0] == \"help\") {\n\t\tfmt.Println(\"Habitus - (c) 2016 Cloud 66 Inc.\")\n\t\tflag.PrintDefaults()\n\t\treturn\n\t}\n\n\tif flagShowVersion || (len(args) > 0 && args[0] == \"version\") {\n\t\tif BUILD_DATE == \"\" {\n\t\t\tfmt.Printf(\"Habitus - v%s (c) 2017 Cloud 66 Inc.\\n\", VERSION)\n\t\t} else {\n\t\t\tfmt.Printf(\"Habitus - v%s (%s) (c) 2017 Cloud 66 Inc.\\n\", VERSION, BUILD_DATE)\n\t\t}\n\t\treturn\n\t}\n\n\t// The -os flag allows free form text. Validate what was specified\n\tif !config.ValidateOsType() {\n\t\tfmt.Println(\"Invalid OS name\")\n\t\tfmt.Println(\"Please choose from \", configuration.OsTypes)\n\t\treturn\n\t}\n\n\tlevel, err := logging.LogLevel(flagLevel)\n\tif err != nil {\n\t\tfmt.Println(\"Invalid log level value. Falling back to debug\")\n\t\tlevel = logging.DEBUG\n\t}\n\tlogging.SetLevel(level, \"habitus\")\n\n\tif config.Workdir == \"\" {\n\t\tif curr, err := os.Getwd(); err != nil {\n\t\t\tlog.Fatal(\"Failed to get the current directory\")\n\t\t\tos.Exit(1)\n\t\t} else {\n\t\t\tconfig.Workdir = curr\n\t\t}\n\t}\n\n\tif config.Buildfile == \"build.yml\" {\n\t\tconfig.Buildfile = filepath.Join(config.Workdir, \"build.yml\")\n\t}\n\n\tc, err := build.LoadBuildFromFile(&config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed: %s\", err.Error())\n\t}\n\n\tif c.IsPrivileged && os.Getenv(\"SUDO_USER\") == \"\" {\n\t\tlog.Fatal(\"Some of the build steps require admin privileges (sudo). Please run with sudo\\nYou might want to use --certs=$DOCKER_CERT_PATH --host=$DOCKER_HOST params to make sure all environment variables are available to the process\")\n\t\tos.Exit(1)\n\t}\n\n\tb := build.NewBuilder(c, &config)\n\n\tif config.SecretService {\n\t\t// start the API\n\t\tsecret_service := &api.Server{Builder: b}\n\t\terr = secret_service.StartServer(VERSION)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Cannot start API server due to %s\", err.Error())\n\t\t\tos.Exit(2)\n\t\t}\n\t}\n\n\terr = b.StartBuild()\n\tif err != nil {\n\t\tlog.Errorf(\"Error during build %s\", err.Error())\n\t}\n}\n\nfunc recoverPanic() {\n\tif VERSION != \"dev\" {\n\t\traven.CapturePanicAndWait(func() {\n\t\t\tif rec := recover(); rec != nil {\n\t\t\t\tpanic(rec)\n\t\t\t}\n\t\t}, map[string]string{\n\t\t\t\"Version\":      VERSION,\n\t\t\t\"Platform\":     runtime.GOOS,\n\t\t\t\"Architecture\": runtime.GOARCH,\n\t\t\t\"goversion\":    runtime.Version()})\n\t}\n}\n"}
{"sample": "// LogErrorAndContinue logs the error and continues execution\nfunc LogErrorAndContinue(err error) {\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\t// Continue execution...\n}\n"}
{"sample": "func main() {\n\tch := make(chan string)\n\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tch <- \"Hello from goroutine\"\n\t}()\n\n\tfmt.Println(<-ch)\n}"}
{"sample": "type Database struct {\n\tDB *sql.DB\n}\n\nfunc ConnectToDB(driverName, dataSourceName string) (*Database, error) {\n\tDB, err := sql.Open(driverName, dataSourceName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Database{DB: DB} nil\n}\n\nfunc (db *Database) Query(query string, args ...interface{}) (*sql.Rows, error) {\n\trows, err := db.DB.Query(query, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn rows, nil\n}"}
{"sample": "package main\n\n// Write to a gzip file\nfunc main() {\n\tfile, err := os.Create(\"file.gz\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\tgzWriter := gzip.NewWriter(file)\n\tdefer gzWriter.Close()\n\t_, err = gzWriter.Write([]byte(\"Gzip compression\\n\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package abbotgopb\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/gogo/protobuf/proto\"\n)\n\nfunc NewResponse(resp proto.Marshaler) (*Response, error) {\n\tif resp == nil {\n\t\treturn &Response{Kind: RESP_DONE, Body: nil}, nil\n\t}\n\n\tvar kind ResponseType\n\tswitch resp.(type) {\n\tcase *ContainerNetworkConfigResponse:\n\t\tkind = RESP_CTR_NETWORK_CONFIG\n\tcase *ContainerNetworkStatusResponse:\n\t\tkind = RESP_CTR_NETWORK_STATUS\n\tcase *ContainerNetworkStatusListResponse:\n\t\tkind = RESP_CTR_NETWORK_STATUS_LIST\n\tcase *HostNetworkConfigResponse:\n\t\tkind = RESP_HOST_NETWORK_CONFIG\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unkonw response type\")\n\t}\n\n\tdata, err := resp.Marshal()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal response body: %w\", err)\n\t}\n\n\treturn &Response{\n\t\tKind: kind,\n\t\tBody: data,\n\t}, nil\n}\n\nfunc NewContainerNetworkConfigResponse(\n\tipv4Subnet, ipv6Subnet string,\n) *ContainerNetworkConfigResponse {\n\treturn &ContainerNetworkConfigResponse{\n\t\tIpv4Subnet: ipv4Subnet,\n\t\tIpv6Subnet: ipv6Subnet,\n\t}\n}\n\nfunc NewContainerNetworkStatusResponse(\n\tpid uint32,\n\tinterfaces []*NetworkInterface,\n) *ContainerNetworkStatusResponse {\n\treturn &ContainerNetworkStatusResponse{Interfaces: interfaces}\n}\n\nfunc NewContainerNetworkStatusListResponse(\n\tnets map[string]*ContainerNetworkStatusResponse,\n) *ContainerNetworkStatusListResponse {\n\treturn &ContainerNetworkStatusListResponse{\n\t\tContainerNetworks: nets,\n\t}\n}\n\nfunc NewHostNetworkConfigResponse(\n\tinterfaces ...*HostNetworkInterface,\n) *HostNetworkConfigResponse {\n\treturn &HostNetworkConfigResponse{\n\t\tActual: interfaces,\n\t}\n}\n"}
{"sample": "package priqueue\n\nimport (\n\t\"container/heap\"\n\t\"errors\"\n)\n\ntype Item struct {\n\tvalue    interface{}\n\tpriority int\n\tindex    int\n}\n\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n\treturn pq[i].priority < pq[j].priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n\tpq[i].index = i\n\tpq[j].index = j\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n\tn := len(*pq)\n\titem := x.(*Item)\n\titem.index = n\n\t*pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\titem.index = -1\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\nfunc (pq *PriorityQueue) Update(item *Item, value interface{}, priority int) error {\n\tif item == nil {\n\t\treturn errors.New(\"item cannot be nil\")\n\t}\n\n\titem.value = value\n\titem.priority = priority\n\theap.Fix(pq, item.index)\n\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tpath, err := os.Executable()\n\tif err != nil {\n\t\tfmt.Println(\"Error getting executable path:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Executable path:\", path)\n}"}
{"sample": "package saltstack\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/saltstack/salt-golang/api\"\n\t\"github.com/saltstack/salt-golang/handlers\"\n)\n\nfunc runCommand() {\n\tclient, err := api.NewClient(&api.Config{\n\t\tTransport: \"tcp\",\n\t\tAddress:   \"localhost:4506\",\n\t\tUsername:  \"admin\",\n\t\tPassword:  \"password\",\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tctx := context.Background()\n\tcmd := \"ls -la /tmp\"\n\ttarget := \"webserver*\"\n\n\tresp, err := client.Run(ctx, handlers.RemoteExecutionRequest{\n\t\tTarget: target,\n\t\tArgs:   []string{cmd},\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, r := range resp.Results {\n\t\tfmt.Printf(\"%s: %s\\n\", r.Target, r.Stdout)\n\t}\n}\n\nfunc runState() {\n\tclient, err := api.NewClient(&api.Config{\n\t\tTransport: \"tcp\",\n\t\tAddress:   \"localhost:4506\",\n\t\tUsername:  \"admin\",\n\t\tPassword:  \"password\",\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tctx := context.Background()\n\tstate := \"nginx\"\n\ttarget := \"webserver*\"\n\n\tresp, err := client.Run(ctx, handlers.StateExecutionRequest{\n\t\tTarget: target,\n\t\tArgs:   []string{state},\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, r := range resp.Results {\n\t\tfmt.Printf(\"%s: %s\\n\", r.Target, r.Stdout)\n\t}\n}"}
{"sample": "package main\n\nimport \"os\"\n\nfunc main() {\n\tos.Exit(1)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Power raises a number to the specified exponent and returns the result.\nfunc Power(base, exponent float64) float64 {\n\treturn math.Pow(base, exponent)\n}"}
{"sample": "// Reverse reverses a string.\nfunc Reverse(s string) string {\n\trunes := []rune(s)\n\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n\t\trunes[i], runes[j] = runes[j], runes[i]\n\t}\n\treturn string(runes)\n}\n\n// IsPalindrome checks whether a string is a palindrome.\nfunc IsPalindrome(s string) bool {\n\treturn s == Reverse(s)\n}"}
{"sample": "// Sum adds all the integers in the slice and returns the sum.\nfunc Sum(nums []int) int {\n\tsum := 0\n\tfor _, num := range nums {\n\t\tsum += num\n\t}\n\treturn sum\n}\n\n// Max returns the largest integer in the slice.\nfunc Max(nums []int) int {\n\tmax := nums[0]\n\tfor _, num := range nums {\n\t\tif num > max {\n\t\t\tmax = num\n\t\t}\n\t}\n\treturn max\n}"}
{"sample": "writer := bufio.NewWriter(file)\n_, err = writer.WriteString(\"Writing with bufio\\n\")\nif err != nil {\n\tlog.Fatal(err)\n}\nwriter.Flush()\n"}
{"sample": "package main\n\nfunc SplitString(str, sep string) []string {\n\treturn strings.Split(str, sep)\n}\n"}
{"sample": "student := Student{\n\tName:   \"Alice\",\n\tAge:   20,\n\tGrades: []float64{85.5, 90.3, 88.4}\n}\n"}
{"sample": "func main() {\n\tto := []string{\"recipient@example.com\"}\n\tsubject := \"Hello\"\n\tbody := \"Hello, World!\"\n\n\tmsg := fmt.Sprintf(\"To: %s\\r\\nSubject: %s\\r\\n\\r\\n%s\", strings.Join(to, \", \"), subject, body)\n\n\terr := smtp.SendMail(\"smtp.example.com:587\", smtp.PlainAuth(\"\", \"sender@example.com\", \"password\", \"smtp.example.com\"), \"sender@example.com\", to, []byte(msg))\n\tif err != nil {\n\t\tfmt.Println(\"Error sending email:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Email sent\")\n}"}
{"sample": "package main\n\nfunc CountVowels(str string) int {\n\tcount := 0\n\tvowels := []rune{'a', 'e', 'i', 'o', 'u'}\n\tfor _, char := range str {\n\t\tfor _, vowel := range vowels {\n\t\t\tif char == vowel {\n\t\t\t\tcount++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n"}
{"sample": "scores := map[string]int{\"Alice\": 90, \"Bob\": 85}\nfor name, score := range scores {\n\tfmt.Printf(\"Score of %s: %d\\n\", name, score)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ReadFile reads and returns the content of a file.\nfunc ReadFile(filePath string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// WriteFile writes the content to a file.\nfunc WriteFile(filePath string, content []byte) error {\n\treturn ioutil.WriteFile(filePath, content, 0644)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintCharacterCount(\"Hello, World!\")\n}\n\n// Function to print the count of each character in a string\nfunc PrintCharacterCount(s string) {\n\tcount := make(map[rune]int)\n\tfor _, char := range s {\n\t\tcount[char]++\n\t}\n\tfor char, count := range count {\n\t\tfmt.Printf(\"%c: %d\\n\", char, count)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintEvenNumbers prints even numbers up to a given limit.\nfunc PrintEvenNumbers(limit int) {\n\tfor i := 0; i <= limit; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\n\t// Simulate a long running operation\n\ttime.Sleep(5 * time.Second)\n\n\telapsed := time.Since(start)\n\n\tfmt.Printf(\"Operation took %v\", elapsed)\n}"}
{"sample": "package websocket_test\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc TestWebsocket(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tupgrader := websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error upgrading connection: %v\", err)\n\t\t}\n\n\t\tdefer conn.Close()\n\n\t\tfor {\n\t\t\tmessageType, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error reading message: %v\", err)\n\t\t\t}\n\n\t\t\tif string(message) != \"ping\" {\n\t\t\t\tt.Fatalf(\"Expected 'ping', got '%s'\", string(message))\n\t\t\t}\n\n\t\t\tif err := conn.WriteMessage(messageType, []byte(\"pong\")); err != nil {\n\t\t\t\tt.Fatalf(\"Error writing message: %v\", err)\n\t\t\t}\n\t\t}\n\t}))\n\n\tdefer server.Close()\n\n\turl := \"ws\" + server.URL[4:]\n\tconn, _, err := websocket.DefaultDialer.Dial(url, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Error dialing connection: %v\", err)\n\t}\n\n\tdefer conn.Close()\n\n\tif err := conn.WriteMessage(websocket.TextMessage, []byte(\"ping\")); err != nil {\n\t\tt.Fatalf(\"Error writing message: %v\", err)\n\t}\n\n\t_, message, err := conn.ReadMessage()\n\tif err != nil {\n\t\tt.Fatalf(\"Error reading message: %v\", err)\n\t}\n\n\tif string(message) != \"pong\" {\n\t\tt.Fatalf(\"Expected 'pong', got '%s'\", string(message))\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"os\"\n\n\t\"cloud.google.com/go/storage\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Creates a client.\n\tclient, err := storage.NewClient(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\tdefer client.Close()\n\n\t// Creates a bucket and object.\n\tbucketName := \"my-bucket\"\n\tobjectName := \"my-object\"\n\tbucket := client.Bucket(bucketName)\n\n\t// Creates the new bucket with storage class `STANDARD`.\n\tif err := bucket.Create(ctx, projectID, &storage.BucketAttrs{StorageClass: \"STANDARD\"}); err != nil {\n\t\tlog.Fatalf(\"Failed to create bucket: %v\", err)\n\t}\n\tlog.Printf(\"Bucket %s created.\", bucketName)\n\n\t// Creates a new object with the content of a local file.\n\tfile, err := os.Open(\"local-file\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open file: %v\", err)\n\t}\n\tdefer file.Close()\n\n\twc := bucket.Object(objectName).NewWriter(ctx)\n\tif _, err = io.Copy(wc, file); err != nil {\n\t\tlog.Fatalf(\"Failed to write to object: %v\", err)\n\t}\n\tif err := wc.Close(); err != nil {\n\t\tlog.Fatalf(\"Failed to close writer: %v\", err)\n\t}\n\tlog.Printf(\"Object %v created in bucket %v.\", objectName, bucketName)\n}"}
{"sample": "package dhencdec\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"fmt\"\n)\n\nfunc GenerateKeyPair() (*rsa.PrivateKey, error) {\n\treturn rsa.GenerateKey(rand.Reader, 2048)\n}\n\nfunc EncryptMessage(message []byte, publicKey *rsa.PublicKey) ([]byte, error) {\n\treturn rsa.EncryptOAEP(\n\t\tsha256.New(),\n\t\trand.Reader,\n\t\tpublicKey,\n\t\tmessage,\n\t\tnil,\n\t)\n}\n\nfunc DecryptMessage(ciphertext []byte, privateKey *rsa.PrivateKey) ([]byte, error) {\n\treturn rsa.DecryptOAEP(\n\t\tsha256.New(),\n\t\trand.Reader,\n\t\tprivateKey,\n\t\tciphertext,\n\t\tnil,\n\t)\n}\n\nfunc Example() {\n\talicePrivateKey, err := GenerateKeyPair()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tbobPrivateKey, err := GenerateKeyPair()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\talicePublicKey := &alicePrivateKey.PublicKey\n\tbobPublicKey := &bobPrivateKey.PublicKey\n\n\tmessage := []byte(\"Hello, Bob!\")\n\n\t// Alice encrypts the message using Bob's public key\n\tciphertext, err := EncryptMessage(message, bobPublicKey)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Bob decrypts the message using his own private key\n\tplaintext, err := DecryptMessage(ciphertext, bobPrivateKey)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Plaintext: %s\\n\", plaintext)\n}"}
{"sample": "var mutex sync.Mutex\nmutex.Lock()\n// do something critical\nmutex.Unlock()\n"}
{"sample": "// Using delete to remove from a map\n\nm := map[string]int{\"a\": 1}\ndelete(m, \"a\")\n"}
{"sample": "// Marshaling JSON\n\ndata := struct {\n\tField string `json:\"field\"`\n}{\"value\"}\njsonData, err := json.Marshal(data)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"database/sql\"\n\t_ \"github.com/lib/pq\"\n)\n\nfunc main() {\n\tdb, err := sql.Open(\"postgres\", \"postgres://username:password@localhost/mydb?sslmode=disable\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to PostgreSQL:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE IF NOT EXISTS users (id SERIAL PRIMARY KEY, name TEXT)\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating table:\", err)\n\t\treturn\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (name) VALUES ('John Doe')\")\n\tif err != nil {\n\t\tfmt.Println(\"Error inserting into table:\", err)\n\t\treturn\n\t}\n\n\trows, err := db.Query(\"SELECT id, name FROM users\")\n\tif err != nil {\n\t\tfmt.Println(\"Error querying table:\", err)\n\t\treturn\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\terr = rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error scanning row:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Println(id, name)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc reverse(word string) string {\n\tvar reversed strings.Builder\n\n\t// Iterate backwards through word using a for loop.\n\t// Append each character to the strings.Builder object.\n\tfor i := len(word) - 1; i >= 0; i-- {\n\t\treversed.WriteByte(word[i])\n\t}\n\n\treturn reversed.String()\n}\n\nfunc findPangram(sentence string) bool {\n\t// Pre-populate seen map with all alphabets.\n\tseen := make(map[rune]bool)\n\tfor ch := 'a'; ch <= 'z'; ch++ {\n\t\tseen[ch] = false\n\t}\n\n\t// Loop through each character in the sentence\n\t// Mark each character found as \"true\" in seen map.\n\tfor _, ch := range sentence {\n\t\tlch := strings.ToLower(string(ch))\n\t\tif _, ok := seen[rune(lch[0])]; ok {\n\t\t\tseen[rune(lch[0])] = true\n\t\t}\n\t}\n\n\t// Check all characters if they have been seen (excluding \" \")\n\tfor _, exist := range seen {\n\t\tif !exist {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// If we did not get out early, it exists.\n\treturn true\n}\n\nfunc checkPassword(password string) error {\n\t//If the password satisfies these checks, We return nil as Error.\n\tif len(password) < 6 {\n\t\treturn fmt.Errorf(\"password too short\")\n\t}\n\tif len(password) > 15 {\n\t\treturn fmt.Errorf(\"password too long\")\n\t}\n\tif findPangram(strings.ToLower(password)) {\n\t\treturn fmt.Errorf(\"password is a Pangram\")\n\t}\n\tif password == strings.ToLower(password) {\n\t\treturn fmt.Errorf(\"password needs one uppercase character\")\n\t}\n\tif password == strings.ToUpper(password) {\n\t\treturn fmt.Errorf(\"password needs one lowercase character\")\n\t}\n\tif _, err := fmt.Scanf(password, \"%d\"); err == nil { //It was able to scan for integer in password.\tSo we don't want it(passwd) numeric word like ilkulus1 for sure.\n\t\treturn fmt.Errorf(\"password should not have a known digit\")\n\t}\n\tif password == reverse(password) {\n\t\treturn fmt.Errorf(\"password should not chat backward\")\n\t}\n\n\t//PASSWORD PASS SURVEILANCE SUCCESS\n\treturn nil\n}\n\nfunc main() {\n\terr := checkPassword(\"ImpRestitutedLua27klFi\") // Good Password :) you have this merit :)\n\tif err != nil {\n\t   \n\t   \n\t\tfmt.Println(\"Checking your attempted password hath conjured the error as shown: \",err.Error())\n    return\n\tfmt.Println(\" Passed our Utility Check, Life may have it checks haha heck!\")\n  }\n  }\n\n}\n\n \n}\n```\n\nIt provides the supporting functionality:\n\n-reverse function:convert a string(worden/sentence) available \"ordered left-to-right\"\tto strings written right to left(RtoLverse). Obviously to fine opposites , palimdromics or alike utilities.\n\n-findPangram fuction:\n\n---checks uses a hash map to retrieve all twenty rone newly array viz a BCell like iteratives needed\n \n-checkPassword function : called to micro-observe the singular strings at molecular\nlevels against restrictable/greenlight rules.\nPrimary input_param(switch Parameter Combo Required for Qualification, MrDamisi @ SpecialIST, has done us justice ).\n\nRef :: learned & applied : strings _PKG\tsrc/BaiscAPI with Struct\tcontainer\tmaps._\n\n```"}
{"sample": "package envhandler\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc GetString(key string, defaultValue string) string {\n\tval, ok := os.LookupEnv(key)\n\tif !ok {\n\t\treturn defaultValue\n\t}\n\n\treturn val\n}\n\nfunc GetInt(key string, defaultValue int) int {\n\tval, ok := os.LookupEnv(key)\n\tif !ok {\n\t\treturn defaultValue\n\t}\n\n\ti, err := strconv.Atoi(val)\n\tif err != nil {\n\t\tfmt.Printf(\"Warning: Environment variable '%s' not an integer. Using default value.\\n\", key)\n\t\treturn defaultValue\n\t}\n\n\treturn i\n}\n\nfunc GetBool(key string, defaultValue bool) bool {\n\tval, ok := os.LookupEnv(key)\n\tif !ok {\n\t\treturn defaultValue\n\t}\n\n\tb, err := strconv.ParseBool(val)\n\tif err != nil {\n\t\tfmt.Printf(\"Warning: Environment variable '%s' not a boolean. Using default value.\\n\", key)\n\t\treturn defaultValue\n\t}\n\n\treturn b\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Multiply multiplies two integers and returns the result.\nfunc Multiply(a, b int) int {\n\treturn a * b\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"html/template\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttmpl, err := template.ParseFiles(\"index.html\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error parsing template:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tdata := struct{\n\t\t\tTitle string\n\t\t\tBody  string\n\t\t}{\n\t\t\tTitle: \"Hello\",\n\t\t\tBody:  \"Welcome to the home page\",\n\t\t}\n\n\t\ttmpl.Execute(w, data)\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "file, err := os.Create(\"hello.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer file.Close()\n_, err = file.WriteString(\"Hello, Golang!\")\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"html/template\"\n)\n\nfunc RenderTemplate() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttemplateData := struct {\n\t\t\tTitle   string\n\t\t\tMessage string\n\t\t}{\n\t\t\tTitle:   \"Welcome\",\n\t\t\tMessage: \"Hello, World!\",\n\t\t}\n\n\t\tt, _ := template.ParseFiles(\"template.html\")\n\t\tt.Execute(w, templateData)\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n"}
{"sample": "http.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle users endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get users\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create user\")\n\t} else if r.Method == \"PUT\" {\n\t\t// Handle PUT request\n\t\tfmt.Fprint(w, \"Update user\")\n\t} else if r.Method == \"DELETE\" {\n\t\t// Handle DELETE request\n\t\tfmt.Fprint(w, \"Delete user\")\n\t}\n})\n"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/protobuf\"\n)\n\ntype server struct {\n\tpb.UnimplementedServiceServer\n}\n\nfunc (s *server) GetTask(ctx context.Context, in *pb.TaskRequest) (*pb.TaskResponse, error) {\n\t// Code to fetch task from MySQL\n\t// ...\n\t// Code to create response\n\tresp := &pb.TaskResponse{\n\t\tId:          in.Id,\n\t\tTitle:       \"Task Title\",\n\t\tDescription: \"Task Description\",\n\t\tStatus:      \"In Progress\",\n\t}\n\treturn resp, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterServiceServer(s, &server{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tnumStr := \"42\"\n\tnum, err := strconv.Atoi(numStr)\n\tif err != nil {\n\t\tfmt.Println(\"Error converting string to int:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(num)\n}"}
{"sample": "package mapsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"googlemaps.github.io/maps\"\n)\n\ntype MapsClient struct {\n\tclient *maps.Client\n}\n\nfunc NewMapsClient(apiKey string) (*MapsClient, error) {\n\tc, err := maps.NewClient(maps.WithAPIKey(apiKey))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &MapsClient{\n\t\tclient: c,\n\t}, nil\n}\n\nfunc (mc *MapsClient) GetDirections(origin, destination string) ([]maps.Route, error) {\n\tr := &maps.DirectionsRequest{\n\t\tOrigin:      origin,\n\t\tDestination: destination,\n\t}\n\n\troutes, _, err := mc.client.Directions(context.Background(), r)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\treturn routes, nil\n}\n\nfunc (mc *MapsClient) GetPlaceDetails(placeID string) (*maps.PlaceDetailsResult, error) {\n\tr := &maps.PlaceDetailsRequest{\n\t\tPlaceID: placeID,\n\t}\n\n\tdetails, err := mc.client.PlaceDetails(context.Background(), r)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\treturn details, nil\n}\n\nfunc (mc *MapsClient) Geocode(address string) (*maps.GeocodingResult, error) {\n\tr := &maps.GeocodingRequest{\n\t\tAddress: address,\n\t}\n\n\tresults, err := mc.client.Geocode(context.Background(), r)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no results found for address: %s\", address)\n\t}\n\n\treturn &results[0], nil\n}"}
{"sample": "func main() {\n\tvar num float64 = 4.5\n\n\tfmt.Println(\"Floor:\", math.Floor(num))\n\tfmt.Println(\"Ceil:\", math.Ceil(num))\n\tfmt.Println(\"Round:\", math.Round(num))\n\tfmt.Println(\"Sqrt:\", math.Sqrt(num))\n}"}
{"sample": "func ListFilesInBucket(svc *s3.S3, bucketName string) ([]string, error) {\n\tinput := &s3.ListObjectsV2Input{\n\t\tBucket:  aws.String(bucketName),\n\t}\n\n\tresult, err := svc.ListObjectsV2(input)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar filenames []string\n\tfor _, item := range result.Contents {\n\t\tfilenames = append(filenames, *item.Key)\n\t}\n\n\treturn filenames, nil\n}\n\nfunc DeleteFileFromBucket(svc *s3.S3, bucketName, itemName string) error {\n\tinput := &s3.DeleteObjectInput{\n\t\tBucket: aws.String(bucketName),\n\t\tKey:    aws.String(itemName),\n\t}\n\n\t_, err := svc.DeleteObject(input)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "// Concatenate two strings\nfunc ConcatenateStrings(str1, str2 string) string {\n\treturn str1 + str2\n}\n"}
{"sample": "func multiply(nums []int) int {\n\tresult := 1\n\tfor _, num := range nums {\n\t\tresult *= num\n\t}\n\treturn result\n}\n"}
{"sample": "// Copyright GoFrame Author(https://goframe.org). All Rights Reserved.\n//\n// This Source Code Form is subject to the terms of the MIT License.\n// If a copy of the MIT was not distributed with this file,\n// You can obtain one at https://github.com/gogf/gf.\n\npackage glog_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/gogf/gf/v2/container/garray\"\n\t\"github.com/gogf/gf/v2/os/glog\"\n\t\"github.com/gogf/gf/v2/test/gtest\"\n\t\"github.com/gogf/gf/v2/text/gstr\"\n)\n\nvar arrayForHandlerTest1 = garray.NewStrArray()\n\nfunc customHandler1(ctx context.Context, input *glog.HandlerInput) {\n\tarrayForHandlerTest1.Append(input.String(false))\n\tinput.Next(ctx)\n}\n\nfunc TestLogger_SetHandlers1(t *testing.T) {\n\tgtest.C(t, func(t *gtest.T) {\n\t\tw := bytes.NewBuffer(nil)\n\t\tl := glog.NewWithWriter(w)\n\t\tl.SetHandlers(customHandler1)\n\t\tl.SetCtxKeys(\"Trace-Id\", \"Span-Id\", \"Test\")\n\t\tctx := context.WithValue(context.Background(), \"Trace-Id\", \"1234567890\")\n\t\tctx = context.WithValue(ctx, \"Span-Id\", \"abcdefg\")\n\n\t\tl.Print(ctx, 1, 2, 3)\n\t\tt.Assert(gstr.Count(w.String(), \"1234567890\"), 1)\n\t\tt.Assert(gstr.Count(w.String(), \"abcdefg\"), 1)\n\t\tt.Assert(gstr.Count(w.String(), \"1 2 3\"), 1)\n\n\t\tt.Assert(arrayForHandlerTest1.Len(), 1)\n\t\tt.Assert(gstr.Count(arrayForHandlerTest1.At(0), \"1234567890\"), 1)\n\t\tt.Assert(gstr.Count(arrayForHandlerTest1.At(0), \"abcdefg\"), 1)\n\t\tt.Assert(gstr.Count(arrayForHandlerTest1.At(0), \"1 2 3\"), 1)\n\t})\n}\n\nvar arrayForHandlerTest2 = garray.NewStrArray()\n\nfunc customHandler2(ctx context.Context, input *glog.HandlerInput) {\n\tarrayForHandlerTest2.Append(input.String(false))\n}\n\nfunc TestLogger_SetHandlers2(t *testing.T) {\n\tgtest.C(t, func(t *gtest.T) {\n\t\tw := bytes.NewBuffer(nil)\n\t\tl := glog.NewWithWriter(w)\n\t\tl.SetHandlers(customHandler2)\n\t\tl.SetCtxKeys(\"Trace-Id\", \"Span-Id\", \"Test\")\n\t\tctx := context.WithValue(context.Background(), \"Trace-Id\", \"1234567890\")\n\t\tctx = context.WithValue(ctx, \"Span-Id\", \"abcdefg\")\n\n\t\tl.Print(ctx, 1, 2, 3)\n\t\tt.Assert(gstr.Count(w.String(), \"1234567890\"), 0)\n\t\tt.Assert(gstr.Count(w.String(), \"abcdefg\"), 0)\n\t\tt.Assert(gstr.Count(w.String(), \"1 2 3\"), 0)\n\n\t\tt.Assert(arrayForHandlerTest2.Len(), 1)\n\t\tt.Assert(gstr.Count(arrayForHandlerTest2.At(0), \"1234567890\"), 1)\n\t\tt.Assert(gstr.Count(arrayForHandlerTest2.At(0), \"abcdefg\"), 1)\n\t\tt.Assert(gstr.Count(arrayForHandlerTest2.At(0), \"1 2 3\"), 1)\n\t})\n}\n\nfunc TestLogger_SetHandlers_HandlerJson(t *testing.T) {\n\tgtest.C(t, func(t *gtest.T) {\n\t\tw := bytes.NewBuffer(nil)\n\t\tl := glog.NewWithWriter(w)\n\t\tl.SetHandlers(glog.HandlerJson)\n\t\tl.SetCtxKeys(\"Trace-Id\", \"Span-Id\", \"Test\")\n\t\tctx := context.WithValue(context.Background(), \"Trace-Id\", \"1234567890\")\n\t\tctx = context.WithValue(ctx, \"Span-Id\", \"abcdefg\")\n\n\t\tl.Debug(ctx, 1, 2, 3)\n\t\tt.Assert(gstr.Count(w.String(), \"1234567890\"), 1)\n\t\tt.Assert(gstr.Count(w.String(), \"abcdefg\"), 1)\n\t\tt.Assert(gstr.Count(w.String(), `\"1 2 3\"`), 1)\n\t\tt.Assert(gstr.Count(w.String(), `\"DEBU\"`), 1)\n\t})\n}\n\nfunc Test_SetDefaultHandler(t *testing.T) {\n\tgtest.C(t, func(t *gtest.T) {\n\t\toldHandler := glog.GetDefaultHandler()\n\t\tglog.SetDefaultHandler(func(ctx context.Context, in *glog.HandlerInput) {\n\t\t\tglog.HandlerJson(ctx, in)\n\t\t})\n\t\tdefer glog.SetDefaultHandler(oldHandler)\n\n\t\tw := bytes.NewBuffer(nil)\n\t\tl := glog.NewWithWriter(w)\n\t\tl.SetCtxKeys(\"Trace-Id\", \"Span-Id\", \"Test\")\n\t\tctx := context.WithValue(context.Background(), \"Trace-Id\", \"1234567890\")\n\t\tctx = context.WithValue(ctx, \"Span-Id\", \"abcdefg\")\n\n\t\tl.Debug(ctx, 1, 2, 3)\n\t\tt.Assert(gstr.Count(w.String(), \"1234567890\"), 1)\n\t\tt.Assert(gstr.Count(w.String(), \"abcdefg\"), 1)\n\t\tt.Assert(gstr.Count(w.String(), `\"1 2 3\"`), 1)\n\t\tt.Assert(gstr.Count(w.String(), `\"DEBU\"`), 1)\n\t})\n}\n"}
{"sample": "// Check if a string is uppercase\nfunc IsUppercase(str string) bool {\n\treturn str == strings.ToUpper(str)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "/***\nCopyright 2014 Cisco Systems Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage objdb\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/net/context\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"github.com/coreos/etcd/client\"\n)\n\n// Service state\ntype etcdServiceState struct {\n\tServiceName string        // Name of the service\n\tKeyName     string        // Service key name\n\tTTL         time.Duration // TTL for the service\n\tHostAddr    string        // Host name or IP address where its running\n\tPort        int           // Port number where its listening\n\tHostname    string        // Host name where its running\n\n\t// Channel to stop ttl refresh\n\tstopChan chan bool\n}\n\n// RegisterService Register a service\n// Service is registered with a ttl for 60sec and a goroutine is created\n// to refresh the ttl.\nfunc (ep *EtcdClient) RegisterService(serviceInfo ServiceInfo) error {\n\tkeyName := \"/contiv.io/service/\" + serviceInfo.ServiceName + \"/\" +\n\t\tserviceInfo.HostAddr + \":\" + strconv.Itoa(serviceInfo.Port)\n\tttl := time.Duration(serviceInfo.TTL) * time.Second\n\n\tlog.Infof(\"Registering service key: %s, value: %+v\", keyName, serviceInfo)\n\n\t// if there is a previously registered service, stop refreshing it\n\tif ep.serviceDb[keyName] != nil {\n\t\tep.serviceDb[keyName].stopChan <- true\n\t}\n\n\t// JSON format the object\n\tjsonVal, err := json.Marshal(serviceInfo)\n\tif err != nil {\n\t\tlog.Errorf(\"Json conversion error. Err %v\", err)\n\t\treturn err\n\t}\n\n\t// create service state\n\tsrvState := etcdServiceState{\n\t\tServiceName: serviceInfo.ServiceName,\n\t\tKeyName:     keyName,\n\t\tTTL:         ttl,\n\t\tHostAddr:    serviceInfo.HostAddr,\n\t\tPort:        serviceInfo.Port,\n\t\tstopChan:    make(chan bool, 1),\n\t\tHostname:    serviceInfo.Hostname,\n\t}\n\n\t// Run refresh in background\n\tgo ep.refreshService(&srvState, string(jsonVal[:]))\n\n\t// Store it in DB\n\tep.serviceDb[keyName] = &srvState\n\n\treturn nil\n}\n\n// GetService lists all end points for a service\nfunc (ep *EtcdClient) GetService(name string) ([]ServiceInfo, error) {\n\tkeyName := \"/contiv.io/service/\" + name + \"/\"\n\n\t_, srvcList, err := ep.getServiceState(keyName)\n\treturn srvcList, err\n}\n\nfunc (ep *EtcdClient) getServiceState(key string) (uint64, []ServiceInfo, error) {\n\tvar srvcList []ServiceInfo\n\tretryCount := 0\n\n\t// Get the object from etcd client\n\tresp, err := ep.kapi.Get(context.Background(), key, &client.GetOptions{Recursive: true, Sort: true})\n\tfor err != nil && err.Error() == client.ErrClusterUnavailable.Error() {\n\t\t// Retry after a delay\n\t\tretryCount++\n\t\tif retryCount%16 == 0 {\n\t\t\tlog.Warnf(\"%v -- Retrying...\", err)\n\t\t}\n\n\t\ttime.Sleep(time.Second)\n\t\tresp, err = ep.kapi.Get(context.Background(), key,\n\t\t\t&client.GetOptions{Recursive: true, Sort: true})\n\t}\n\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), \"Key not found\") {\n\t\t\treturn 0, nil, nil\n\t\t}\n\n\t\tlog.Errorf(\"Error getting key %s. Err: %v\", key, err)\n\t\treturn 0, nil, err\n\t}\n\n\tif !resp.Node.Dir {\n\t\tlog.Errorf(\"Err. Response is not a directory: %+v\", resp.Node)\n\t\treturn 0, nil, errors.New(\"Invalid Response from etcd\")\n\t}\n\n\t// Parse each node in the directory\n\tfor _, node := range resp.Node.Nodes {\n\t\tvar respSrvc ServiceInfo\n\t\t// Parse JSON response\n\t\terr = json.Unmarshal([]byte(node.Value), &respSrvc)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error parsing object %s, Err %v\", node.Value, err)\n\t\t\treturn 0, nil, err\n\t\t}\n\n\t\tsrvcList = append(srvcList, respSrvc)\n\t}\n\n\twatchIndex := resp.Index\n\treturn watchIndex, srvcList, nil\n}\n\n// initServiceState reads the current state and injects it to the channel\n// additionally, it returns the next index to watch\nfunc (ep *EtcdClient) initServiceState(key string, eventCh chan WatchServiceEvent) (uint64, error) {\n\tmIndex, srvcList, err := ep.getServiceState(key)\n\tif err != nil {\n\t\treturn mIndex, err\n\t}\n\n\t// walk each service and inject it as an add event\n\tfor _, srvInfo := range srvcList {\n\t\tlog.Debugf(\"Sending service add event: %+v\", srvInfo)\n\t\t// Send Add event\n\t\teventCh <- WatchServiceEvent{\n\t\t\tEventType:   WatchServiceEventAdd,\n\t\t\tServiceInfo: srvInfo,\n\t\t}\n\t}\n\n\treturn mIndex, nil\n}\n\n// WatchService Watch for a service\nfunc (ep *EtcdClient) WatchService(name string, eventCh chan WatchServiceEvent, stopCh chan bool) error {\n\tkeyName := \"/contiv.io/service/\" + name + \"/\"\n\n\t// Create channels\n\twatchCh := make(chan *client.Response, 1)\n\n\t// Create watch context\n\twatchCtx, watchCancel := context.WithCancel(context.Background())\n\n\t// Start the watch thread\n\tgo func() {\n\t\t// Get current state and etcd index to watch\n\t\twatchIndex, err := ep.initServiceState(keyName, eventCh)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Unable to watch service key: %s - %v\", keyName,\n\t\t\t\terr)\n\t\t}\n\n\t\tlog.Infof(\"Watching for service: %s at index %v\", keyName, watchIndex)\n\t\t// Start the watch\n\t\twatcher := ep.kapi.Watcher(keyName, &client.WatcherOptions{AfterIndex: watchIndex, Recursive: true})\n\t\tif watcher == nil {\n\t\t\tlog.Errorf(\"Error watching service %s. Etcd returned invalid watcher\", keyName)\n\n\t\t\t// Emit the event\n\t\t\teventCh <- WatchServiceEvent{EventType: WatchServiceEventError}\n\t\t}\n\n\t\t// Keep getting next event\n\t\tfor {\n\t\t\t// Block till next watch event\n\t\t\tetcdRsp, err := watcher.Next(watchCtx)\n\t\t\tif err != nil && err.Error() == client.ErrClusterUnavailable.Error() {\n\t\t\t\tlog.Infof(\"Stopping watch on key %s\", keyName)\n\t\t\t\treturn\n\t\t\t} else if err != nil {\n\t\t\t\tlog.Errorf(\"Error %v during watch. Watch thread exiting\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Send it to watch channel\n\t\t\twatchCh <- etcdRsp\n\t\t}\n\t}()\n\n\t// handle messages from watch service\n\tgo func() {\n\t\tvar srvMap = make(map[string]ServiceInfo)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase watchResp := <-watchCh:\n\t\t\t\tvar srvInfo ServiceInfo\n\n\t\t\t\tlog.Debugf(\"Received event {%#v}\\n Node: {%#v}\\n PrevNade: {%#v}\", watchResp, watchResp.Node, watchResp.PrevNode)\n\n\t\t\t\t// derive service info from key\n\t\t\t\tsrvKey := strings.TrimPrefix(watchResp.Node.Key, \"/contiv.io/service/\")\n\n\t\t\t\t// We ignore all events except Set/Delete/Expire\n\t\t\t\t// Note that Set event doesnt exactly mean new service end point.\n\t\t\t\t// If a service restarts and re-registers before it expired, we'll\n\t\t\t\t// receive set again. receivers need to handle this case\n\t\t\t\tif _, ok := srvMap[srvKey]; !ok && watchResp.Action == \"set\" {\n\t\t\t\t\t// Parse JSON response\n\t\t\t\t\terr := json.Unmarshal([]byte(watchResp.Node.Value), &srvInfo)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Errorf(\"Error parsing object %s, Err %v\", watchResp.Node.Value, err)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\tlog.Infof(\"Sending service add event: %+v\", srvInfo)\n\t\t\t\t\t// Send Add event\n\t\t\t\t\teventCh <- WatchServiceEvent{\n\t\t\t\t\t\tEventType:   WatchServiceEventAdd,\n\t\t\t\t\t\tServiceInfo: srvInfo,\n\t\t\t\t\t}\n\n\t\t\t\t\t// save it in cache\n\t\t\t\t\tsrvMap[srvKey] = srvInfo\n\t\t\t\t} else if (watchResp.Action == \"delete\") || (watchResp.Action == \"expire\") {\n\t\t\t\t\t// Parse JSON response\n\t\t\t\t\terr := json.Unmarshal([]byte(watchResp.PrevNode.Value), &srvInfo)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Errorf(\"Error parsing object %s, Err %v\", watchResp.Node.Value, err)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\tlog.Infof(\"Sending service del event: %+v\", srvInfo)\n\n\t\t\t\t\t// Send Delete event\n\t\t\t\t\teventCh <- WatchServiceEvent{\n\t\t\t\t\t\tEventType:   WatchServiceEventDel,\n\t\t\t\t\t\tServiceInfo: srvInfo,\n\t\t\t\t\t}\n\n\t\t\t\t\t// remove it from cache\n\t\t\t\t\tdelete(srvMap, srvKey)\n\t\t\t\t}\n\t\t\tcase stopReq := <-stopCh:\n\t\t\t\tif stopReq {\n\t\t\t\t\t// Stop watch and return\n\t\t\t\t\tlog.Infof(\"Stopping watch on %s\", keyName)\n\t\t\t\t\twatchCancel()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\n// DeregisterService Deregister a service\n// This removes the service from the registry and stops the refresh groutine\nfunc (ep *EtcdClient) DeregisterService(serviceInfo ServiceInfo) error {\n\tkeyName := \"/contiv.io/service/\" + serviceInfo.ServiceName + \"/\" +\n\t\tserviceInfo.HostAddr + \":\" + strconv.Itoa(serviceInfo.Port)\n\n\t// Find it in the database\n\tsrvState := ep.serviceDb[keyName]\n\tif srvState == nil {\n\t\tlog.Errorf(\"Could not find the service in db %s\", keyName)\n\t\treturn errors.New(\"Service not found\")\n\t}\n\n\t// stop the refresh thread and delete service\n\tsrvState.stopChan <- true\n\tdelete(ep.serviceDb, keyName)\n\n\t// Delete the service instance\n\t_, err := ep.kapi.Delete(context.Background(), keyName, nil)\n\tif err != nil {\n\t\tlog.Errorf(\"Error deleting key %s. Err: %v\", keyName, err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Keep refreshing the service every 30sec\nfunc (ep *EtcdClient) refreshService(srvState *etcdServiceState, keyVal string) {\n\t// Set it via etcd client\n\t_, err := ep.kapi.Set(context.Background(), srvState.KeyName, keyVal, &client.SetOptions{TTL: srvState.TTL})\n\tif err != nil {\n\t\tlog.Errorf(\"Error setting key %s, Err: %v\", srvState.KeyName, err)\n\t}\n\n\t// Loop forever\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(srvState.TTL / 3):\n\t\t\tlog.Debugf(\"Refreshing key: %s\", srvState.KeyName)\n\n\t\t\t_, err := ep.kapi.Set(context.Background(), srvState.KeyName, keyVal, &client.SetOptions{TTL: srvState.TTL})\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Error setting key %s, Err: %v\", srvState.KeyName, err)\n\t\t\t}\n\n\t\tcase <-srvState.stopChan:\n\t\t\tlog.Infof(\"Stop refreshing key: %s\", srvState.KeyName)\n\t\t\treturn\n\t\t}\n\t}\n}\n"}
{"sample": "package csvmanip\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype Entry struct {\n\tID    int\n\tName  string\n\tEmail string\n}\n\nfunc readCSV() ([]Entry, error) {\n\tfile, err := os.Open(\"data.csv\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\n\trecords, err := reader.ReadAll()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tentries := []Entry{}\n\tfor _, record := range records {\n\t\tentry := Entry{\n\t\t\tID:    record[0],\n\t\t\tName:  record[1],\n\t\t\tEmail: record[2],\n\t\t}\n\t\tentries = append(entries, entry)\n\t}\n\n\treturn entries, nil\n}\n\nfunc writeCSV(entries []Entry) error {\n\tfile, err := os.Create(\"data.csv\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\n\tfor _, entry := range entries {\n\t\trecord := []string{entry.ID, entry.Name, entry.Email}\n\t\tif err := writer.Write(record); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\twriter.Flush()\n\n\treturn nil\n}\n\nfunc updateEntry(id int, name string, email string) error {\n\tentries, err := readCSV()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i, entry := range entries {\n\t\tif entry.ID == id {\n\t\t\tentry.Name = name\n\t\t\tentry.Email = email\n\t\t\tentries[i] = entry\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err := writeCSV(entries); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tentries, err := readCSV()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(entries)\n\n\tentry := Entry{\n\t\tID:    \"4\",\n\t\tName:  \"John\",\n\t\tEmail: \"john@example.com\",\n\t}\n\n\tentries = append(entries, entry)\n\n\tif err := writeCSV(entries); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := updateEntry(2, \"Jane\", \"jane@example.com\"); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "type MongoDB struct {\n\tclient *mongo.Client\n}\n\nfunc ConnectToMongoDB(uri string) (*MongoDB, error) {\n\tclient, err := mongo.NewClient(options.Client().ApplyURI(uri))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &MongoDB{client: client} nil\n}\n\nfunc (db *MongoDB) GetCollection(database, collection string) *mongo.Collection {\n\treturn db.client.Database(database).Collection(collection)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype Task struct {\n\tID   string `json:\"id,omitempty\"`\n\tName string `json:\"name,omitempty\"`\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/tasks\", GetTasks).Methods(\"GET\")\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc GetTasks(w http.ResponseWriter, r *http.Request) {\n\ttasks := []Task{{ID: \"1\", Name: \"Task1\"}}\n\tjson.NewEncoder(w).Encode(tasks)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/go-redis/redis\"\n)\n\nfunc main() {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // No password\n\t\tDB:       0,  // use default DB\n\t})\n\n\tpong, err := client.Ping().Result()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tfmt.Println(pong)\n\n\terr = client.Set(\"key\", \"value\", 0).Err()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tval, err := client.Get(\"key\").Result()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\tfmt.Println(val)\n\n}"}
{"sample": "package rssplugin\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"time\"\n\n\t\"github.com/torlenor/redseligg/model\"\n\t\"github.com/torlenor/redseligg/storage\"\n\t\"github.com/torlenor/redseligg/storagemodels\"\n)\n\nvar now = time.Now\n\nvar errNotExist = errors.New(\"RSS subscription does not exist\")\n\nfunc (p *RssPlugin) getRssSubscriptions() (storagemodels.RssPluginSubscriptions, error) {\n\ts := p.getStorage()\n\tif s == nil {\n\t\treturn storagemodels.RssPluginSubscriptions{}, ErrNoValidStorage\n\t}\n\n\treturn s.GetRssPluginSubscriptions(p.BotID, p.PluginID)\n}\n\nfunc (p *RssPlugin) storeRssPluginSubscription(data storagemodels.RssPluginSubscription) error {\n\ts := p.getStorage()\n\tif s == nil {\n\t\tp.API.LogError(ErrNoValidStorage.Error())\n\t\treturn ErrNoValidStorage\n\t}\n\n\terr := s.StoreRssPluginSubscription(p.BotID, p.PluginID, generateIdentifier(), data)\n\tif err != nil {\n\t\tp.API.LogError(fmt.Sprintf(\"Error storing RSS subscription: %s\", err))\n\t\treturn fmt.Errorf(\"Error storing RSS subscription: %s\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (p *RssPlugin) updateRssPluginSubscription(data storagemodels.RssPluginSubscription) error {\n\ts := p.getStorage()\n\tif s == nil {\n\t\tp.API.LogError(ErrNoValidStorage.Error())\n\t\treturn ErrNoValidStorage\n\t}\n\n\terr := s.UpdateRssPluginSubscription(p.BotID, p.PluginID, data.Identifier, data)\n\tif err != nil {\n\t\tp.API.LogError(fmt.Sprintf(\"Error updating RSS subscription: %s\", err))\n\t\treturn fmt.Errorf(\"Error updating RSS subscription: %s\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (p *RssPlugin) addRssSubscription(channelID, link string) error {\n\terr := p.storeRssPluginSubscription(storagemodels.RssPluginSubscription{\n\t\tLink:              link,\n\t\tChannelID:         channelID,\n\t\tLastPostedPubDate: time.Now(),\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Could not add RSS subscription for link '%s' in channel '%s': %s\", link, channelID, err)\n\t}\n\n\tp.API.LogTrace(fmt.Sprintf(\"Added RSS subscription for link '%s' for channel %s\", link, channelID))\n\n\treturn nil\n}\n\nfunc (p *RssPlugin) removeRssSubscription(channelID, link string) error {\n\tsubscriptions, err := p.getRssSubscriptions()\n\tif err != nil && err != storage.ErrNotFound {\n\t\treturn fmt.Errorf(\"Could not remove RSS subscription: %s\", err)\n\t}\n\n\ts := p.getStorage()\n\tif s == nil {\n\t\tp.API.LogError(ErrNoValidStorage.Error())\n\t\treturn ErrNoValidStorage\n\t}\n\n\tvar wasRemoved bool\n\tfor _, x := range subscriptions.Subscriptions {\n\t\tif x.ChannelID == channelID && x.Link == link {\n\t\t\tp.API.LogTrace(fmt.Sprintf(\"Removed RSS subscription for link '%s' for channel %s\", link, channelID))\n\t\t\ts.DeleteRssPluginSubscription(p.BotID, p.PluginID, x.Identifier)\n\t\t\twasRemoved = true\n\t\t}\n\t}\n\n\tif !wasRemoved {\n\t\treturn errNotExist\n\t}\n\n\treturn nil\n}\n\nfunc splitRssCommand(text string) (c string, link string, err error) {\n\tvar re = regexp.MustCompile(`(?m)^+(add|remove) +(.*)$`)\n\n\tconst cgCommand = 1\n\tconst cgLink = 2\n\n\tmatches := re.FindAllStringSubmatch(text, -1)\n\n\tif matches == nil || len(matches) < 1 {\n\t\terr = errors.New(\"Not a valid command\")\n\t\treturn\n\t}\n\n\tif len(matches[0]) > cgLink {\n\t\tc = matches[0][cgCommand]\n\t\tlink = matches[0][cgLink]\n\t} else {\n\t\terr = errors.New(\"Not a valid command\")\n\t}\n\n\t_, err = url.ParseRequestURI(link)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"Not a valid url: %s\", err)\n\t}\n\n\treturn\n}\n\nfunc (p *RssPlugin) returnSubscriptionsList(channelID string) {\n\tsubscriptions, err := p.getRssSubscriptions()\n\tif err != nil {\n\t\tp.API.LogError(fmt.Sprintf(\"Error getting RSS subscriptions list: %s\", err))\n\t\tp.returnMessage(channelID, fmt.Sprintf(\"Error getting RSS subscriptions list: %s\", err))\n\t}\n\n\tsubscriptionsText := \"RSS subscriptions for this channel:\\n\"\n\tcnt := 0\n\tlines := []string{}\n\tfor _, s := range subscriptions.Subscriptions {\n\t\tif s.ChannelID == channelID {\n\t\t\tcnt++\n\t\t\t// subscriptionsText += fmt.Sprintf(\"%d. %s\\n\", cnt, s.Link)\n\t\t\tlines = append(lines, fmt.Sprintf(\"%d. %s\", cnt, s.Link))\n\t\t}\n\t}\n\n\tfor i, line := range lines {\n\t\tsubscriptionsText += line\n\t\tif i < (len(lines) - 1) {\n\t\t\tsubscriptionsText += \"\\n\"\n\t\t}\n\t}\n\n\tp.returnMessage(channelID, subscriptionsText)\n}\n\n// onCommand handles a !rss command.\nfunc (p *RssPlugin) onCommand(content string, post model.Post) {\n\tif content == \"add\" {\n\t\tp.returnHelpAdd(post.ChannelID)\n\t\treturn\n\t} else if content == \"remove\" {\n\t\tp.returnHelpRemove(post.ChannelID)\n\t\treturn\n\t}\n\n\tif content == \"list\" {\n\t\tp.returnSubscriptionsList(post.ChannelID)\n\t\treturn\n\t}\n\n\tc, link, err := splitRssCommand(content)\n\tif err != nil {\n\t\tp.API.LogError(fmt.Sprintf(\"Error parsing command '%s': %s\", content, err))\n\t\tp.returnHelp(post.ChannelID)\n\t\treturn\n\t}\n\n\tswitch c {\n\tcase \"add\":\n\t\terr = p.addRssSubscription(post.ChannelID, link)\n\tcase \"remove\":\n\t\terr = p.removeRssSubscription(post.ChannelID, link)\n\t}\n\n\tif err == errNotExist {\n\t\tp.returnMessage(post.ChannelID, \"RSS subscription to remove does not exist.\")\n\t\treturn\n\t} else if err != nil {\n\t\tp.API.LogError(fmt.Sprintf(\"Could not %s RSS subscription: %s\", c, err))\n\t\tp.returnMessage(post.ChannelID, fmt.Sprintf(\"Could not %s RSS subscription. Please try again later.\", c))\n\t\treturn\n\t}\n\n\tswitch c {\n\tcase \"add\":\n\t\tp.returnMessage(post.ChannelID, fmt.Sprintf(\"RSS subscription for link '%s' added.\", link))\n\tcase \"remove\":\n\t\tp.returnMessage(post.ChannelID, fmt.Sprintf(\"RSS subscription for link '%s' removed.\", link))\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\tctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\tdefer cancel()\n\n\tch := make(chan string, 1)\n\tgo func() {\n\t\ttime.Sleep(4 * time.Second)\n\t\tch <- \"Done\"\n\t}()\n\n\tselect {\n\tcase res := <-ch:\n\t\tfmt.Println(res)\n\tcase <-ctx.Done():\n\t\tlog.Println(ctx.Err())\n\t}\n}"}
{"sample": "// AppendToFile appends data to a file.\nfunc AppendToFile(filePath string, data []byte) error {\n\tf, err := os.OpenFile(filePath, os.O_APPEND|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\t_, err = f.Write(data)\n\treturn err\n}\n\n// PrependToFile prepends data to a file.\nfunc PrependToFile(filePath string, data []byte) error {\n\toriginal, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(filePath, append(data, original...), 0644)\n}"}
{"sample": "package ssh\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc connect(user, password, host string, port int) (*ssh.Session, error) {\n\tvar (\n\t\tauth   []ssh.AuthMethod\n\t\taddr   string\n\t\tclientConfig *ssh.ClientConfig\n\t\tclient *ssh.Client\n\t\tsession *ssh.Session\n\t\terr error\n\t)\n\n\tauth = []ssh.AuthMethod{ssh.Password(password)}\n\tclientConfig = &ssh.ClientConfig{\n\t\tUser: user,\n\t\tAuth: auth,\n\t\tTimeout: 30 * time.Second,\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n\n\taddr = fmt.Sprintf(\"%s:%d\", host, port)\n\n\tif client, err = ssh.Dial(\"tcp\", addr, clientConfig); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif session, err = client.NewSession(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session, nil\n}\n\nfunc RunCommand(user, password, host string, port int, command string) (string, error) {\n\tsession, err := connect(user, password, host, port)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer session.Close()\n\n\toutput, err := session.CombinedOutput(command)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(output), nil\n}\n\nfunc UploadFile(user, password, host string, port int, localPath, remotePath string) error {\n\tsession, err := connect(user, password, host, port)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer session.Close()\n\n\tsrc, err := os.Open(localPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer src.Close()\n\n\tstat, err := src.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif stat.IsDir() {\n\t\treturn fmt.Errorf(\"%s is a directory\", localPath)\n\t}\n\n\tdst, err := session.OpenFile(remotePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, stat.Mode())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dst.Close()\n\n\tif _, err = io.Copy(dst, src); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc DownloadFile(user, password, host string, port int, remotePath, localPath string) error {\n\tsession, err := connect(user, password, host, port)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer session.Close()\n\n\tsrc, err := session.Open(remotePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer src.Close()\n\n\tstat, err := src.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif stat.IsDir() {\n\t\treturn fmt.Errorf(\"%s is a directory\", remotePath)\n\t}\n\n\tdst, err := os.OpenFile(localPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, stat.Mode())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dst.Close()\n\n\tif _, err = io.Copy(dst, src); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\n// Get the absolute path of a file\nfunc main() {\n\tabsPath, err := filepath.Abs(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"Absolute path:\", absPath)\n}\n"}
{"sample": "// Convert a string to uppercase\nfunc ToUppercase(str string) string {\n\treturn strings.ToUpper(str)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype Product struct {\n\tID    string `json:\"id,omitempty\"`\n\tName  string `json:\"name,omitempty\"`\n\tPrice float64 `json:\"price,omitempty\"`\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/products\", GetProducts).Methods(\"GET\")\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc GetProducts(w http.ResponseWriter, r *http.Request) {\n\tproducts := []Product{{ID: \"1\", Name: \"Product1\", Price: 19.99}}\n\tjson.NewEncoder(w).Encode(products)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gomodule/redigo/redis\"\n)\n\nfunc main() {\n\tconn, err := redis.Dial(\"tcp\", \"localhost:6379\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to Redis:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Do(\"SET\", \"key\", \"value\")\n\tif err != nil {\n\t\tfmt.Println(\"Error setting Redis key:\", err)\n\t\treturn\n\t}\n\n\tvalue, err := redis.String(conn.Do(\"GET\", \"key\"))\n\tif err != nil {\n\t\tfmt.Println(\"Error getting Redis key:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Redis value:\", value)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"encoding/json\"\n)\n\n// User represents a user entity\n\ntype User struct {\n\tID   int    `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tusers := []User{\n\t\t\t{ID: 1, Name: \"John Doe\"}\n\t\t\t{ID: 2, Name: \"Jane Smith\"}\n\t\t}\n\n\t\tjson.NewEncoder(w).Encode(users)\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package sysresmon\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/shirou/gopsutil/cpu\"\n\t\"github.com/shirou/gopsutil/disk\"\n\t\"github.com/shirou/gopsutil/mem\"\n)\n\nfunc monitorResources() {\n\tfor {\n\t\tcpuUsage, err := cpu.Percent(time.Second, false)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\n\t\tmemUsage, err := mem.VirtualMemory()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\n\t\tdiskUsage, err := disk.Usage(\"/\")\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\n\t\tfmt.Printf(\"CPU Usage: %.2f%%\\n\", cpuUsage[0])\n\t\tfmt.Printf(\"Memory Usage: %.2f%%\\n\", memUsage.UsedPercent)\n\t\tfmt.Printf(\"Disk Usage: %.2f%%\\n\", diskUsage.UsedPercent)\n\n\t\ttime.Sleep(10 * time.Second)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc main() {\n\troot := \".\"\n\tif len(os.Args) > 1 {\n\t\troot = os.Args[1]\n\t}\n\n\tfileCount := 0\n\tdirCount := 0\n\n\tfilepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error accessing path %q: %v\\n\", path, err)\n\t\t\treturn nil\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\tdirCount++\n\t\t} else {\n\t\t\tif strings.HasSuffix(info.Name(), \".txt\") {\n\t\t\t\tfileCount++\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tfmt.Printf(\"Counted %d files and %d directories.\\n\", fileCount, dirCount)\n}"}
{"sample": "// Get the remote IP address from the request\nfunc GetRemoteIP(request *http.Request) string {\n\tip, _, _ := net.SplitHostPort(request.RemoteAddr)\n\treturn ip\n}\n"}
{"sample": "package main\n\nfunc FindMedian(arr []int) float64 {\n\tsorted := make([]int, len(arr))\n\tcopy(sorted, arr)\n\tsort.Ints(sorted)\n\tmid := len(sorted) / 2\n\tif len(sorted)%2 == 0 {\n\t\treturn float64(sorted[mid-1]+sorted[mid]) / 2.0\n\t} else {\n\t\treturn float64(sorted[mid])\n\t}\n}\n"}
{"sample": "// PrintAndReturnError prints an error message and returns an error\nfunc PrintAndReturnError(message string) error {\n\tfmt.Println(message)\n\treturn errors.New(message)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintFibonacci prints the Fibonacci sequence up to a specified limit.\nfunc PrintFibonacci(limit int) {\n\ta, b := 0, 1\n\tfmt.Println(a)\n\tfor b <= limit {\n\t\tfmt.Println(b)\n\t\ta, b = b, a+b\n\t}\n}"}
{"sample": "package main\n\n// This function reads a line from a bufio.Reader\nfunc ReadLine(reader *bufio.Reader) (string, error) {\n\tline, err := reader.ReadString('\\n')\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn line, nil\n}\n\n// This function reads lines from a file\nfunc ReadLines(filename string) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\treader := bufio.NewReader(file)\n\tfor {\n\t\tline, err := ReadLine(reader)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t\t}\n\t\tfmt.Println(line)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\terr := ReadLines(\"file.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tPrintSquareOfNumber(5)\n}\n\n// Function to print the square of a number\nfunc PrintSquareOfNumber(n int) {\n\tfmt.Println(n * n)\n}"}
{"sample": "// Using a switch statement\n\nswitch variable {\n\tcase value1:\n\t\t// do something\n\tcase value2:\n\t\t// do something else\n\tdefault:\n\t\t// default case\n}\n"}
{"sample": "type WorkerPool struct {\n\tjobs chan Job\n\twg   sync.WaitGroup\n}\n\ntype Job func()\n\nfunc NewWorkerPool(concurrency int) *WorkerPool {\n\twp := &WorkerPool{\n\t\tjobs: make(chan Job),\n\t}\n\n\twp.wg.Add(concurrency)\n\tfor i := 0; i < concurrency; i++ {\n\t\tgo wp.worker()\n\t}\n\n\treturn wp\n}\n\nfunc (wp *WorkerPool) worker() {\n\tdefer wp.wg.Done()\n\tfor job := range wp.jobs {\n\t\tjob()\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"github.com/go-chi/chi\"\n)\n\nfunc main() {\n\tr := chi.NewRouter()\n\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Welcome to the home page\")\n\t})\n\n\tr.Get(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"List of users\")\n\t})\n\n\tr.Post(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Create user\")\n\t})\n\n\tr.Put(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := chi.URLParam(r, \"id\")\n\t\tfmt.Fprintf(w, \"Update user with ID %s\", id)\n\t})\n\n\tr.Delete(\"/users/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := chi.URLParam(r, \"id\")\n\t\tfmt.Fprintf(w, \"Delete user with ID %s\", id)\n\t})\n\n\thttp.ListenAndServe(\":8080\", r)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\tdefer cancel()\n\n\tch := make(chan string, 1)\n\n\tgo slowProcess(ctx, ch)\n\n\tselect {\n\tcase result := <-ch:\n\t\tfmt.Println(result)\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"Process timed out\")\n\t}\n}\n\nfunc slowProcess(ctx context.Context, ch chan<- string) {\n\tselect {\n\tcase <-time.After(5 * time.Second):\n\t\tch <- \"Process completed\"\n\tcase <-ctx.Done():\n\t\treturn\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar wg sync.WaitGroup\n\nfunc main() {\n\tfor i := 1; i <= 5; i++ {\n\t\twg.Add(1)\n\t\tgo processJob(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All jobs are done!\")\n}\n\nfunc processJob(id int) {\n\tfmt.Printf(\"Job %d has started\\n\", id)\n\ttime.Sleep(time.Second * time.Duration(id))\n\tfmt.Printf(\"Job %d has finished\\n\", id)\n\twg.Done()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// SortInts sorts a slice of integers in ascending order.\nfunc SortInts(nums []int) {\n\tsort.Ints(nums)\n}"}
{"sample": "base := filepath.Base(absPath)\nfmt.Println(\"Base name:\", base)\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar numbers []int\n\n\tfor i := 0; i < 10; i++ {\n\t\tnumber := rand.Intn(100)\n\t\tnumbers = append(numbers, number)\n\t}\n\n\tfmt.Println(\"Original numbers:\", numbers)\n\n\tfor i := 0; i < len(numbers); i++ {\n\t\tfor j := i + 1; j < len(numbers); j++ {\n\t\t\tif numbers[i] > numbers[j] {\n\t\t\t\ttemp := numbers[i]\n\t\t\t\tnumbers[i] = numbers[j]\n\t\t\t\tnumbers[j] = temp\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Println(\"Sorted numbers:\", numbers)\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\n// Database represents a connection to a database.\ntype Database struct {\n\tconn *sql.DB\n}\n\n// ConnectToDatabase connects to a database using the given connection string.\nfunc ConnectToDatabase(connectionString string) (*Database, error) {\n\tconn, err := sql.Open(\"postgres\", connectionString)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Database{conn} nil\n}\n\n// ExecuteQuery executes the given SQL query and returns the result.\nfunc (db *Database) ExecuteQuery(query string) (*sql.Rows, error) {\n\treturn db.conn.Query(query)\n}\n\n// CloseDatabaseConnection closes the connection to the database.\nfunc (db *Database) CloseDatabaseConnection() error {\n\treturn db.conn.Close()\n}"}
{"sample": "package dbs\n\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n// Code generated by Alibaba Cloud SDK Code Generator.\n// Changes may cause incorrect behavior and will be lost if the code is regenerated.\n\nimport (\n\t\"github.com/CRORCR/alibaba-cloud-sdk-go/sdk/requests\"\n\t\"github.com/CRORCR/alibaba-cloud-sdk-go/sdk/responses\"\n)\n\n// DescribeJobErrorCode invokes the dbs.DescribeJobErrorCode API synchronously\nfunc (client *Client) DescribeJobErrorCode(request *DescribeJobErrorCodeRequest) (response *DescribeJobErrorCodeResponse, err error) {\n\tresponse = CreateDescribeJobErrorCodeResponse()\n\terr = client.DoAction(request, response)\n\treturn\n}\n\n// DescribeJobErrorCodeWithChan invokes the dbs.DescribeJobErrorCode API asynchronously\nfunc (client *Client) DescribeJobErrorCodeWithChan(request *DescribeJobErrorCodeRequest) (<-chan *DescribeJobErrorCodeResponse, <-chan error) {\n\tresponseChan := make(chan *DescribeJobErrorCodeResponse, 1)\n\terrChan := make(chan error, 1)\n\terr := client.AddAsyncTask(func() {\n\t\tdefer close(responseChan)\n\t\tdefer close(errChan)\n\t\tresponse, err := client.DescribeJobErrorCode(request)\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t} else {\n\t\t\tresponseChan <- response\n\t\t}\n\t})\n\tif err != nil {\n\t\terrChan <- err\n\t\tclose(responseChan)\n\t\tclose(errChan)\n\t}\n\treturn responseChan, errChan\n}\n\n// DescribeJobErrorCodeWithCallback invokes the dbs.DescribeJobErrorCode API asynchronously\nfunc (client *Client) DescribeJobErrorCodeWithCallback(request *DescribeJobErrorCodeRequest, callback func(response *DescribeJobErrorCodeResponse, err error)) <-chan int {\n\tresult := make(chan int, 1)\n\terr := client.AddAsyncTask(func() {\n\t\tvar response *DescribeJobErrorCodeResponse\n\t\tvar err error\n\t\tdefer close(result)\n\t\tresponse, err = client.DescribeJobErrorCode(request)\n\t\tcallback(response, err)\n\t\tresult <- 1\n\t})\n\tif err != nil {\n\t\tdefer close(result)\n\t\tcallback(nil, err)\n\t\tresult <- 0\n\t}\n\treturn result\n}\n\n// DescribeJobErrorCodeRequest is the request struct for api DescribeJobErrorCode\ntype DescribeJobErrorCodeRequest struct {\n\t*requests.RpcRequest\n\tClientToken string `position:\"Query\" name:\"ClientToken\"`\n\tLanguage    string `position:\"Query\" name:\"Language\"`\n\tOwnerId     string `position:\"Query\" name:\"OwnerId\"`\n\tTaskId      string `position:\"Query\" name:\"TaskId\"`\n}\n\n// DescribeJobErrorCodeResponse is the response struct for api DescribeJobErrorCode\ntype DescribeJobErrorCodeResponse struct {\n\t*responses.BaseResponse\n\tSuccess        bool   `json:\"Success\" xml:\"Success\"`\n\tErrCode        string `json:\"ErrCode\" xml:\"ErrCode\"`\n\tErrMessage     string `json:\"ErrMessage\" xml:\"ErrMessage\"`\n\tHttpStatusCode int    `json:\"HttpStatusCode\" xml:\"HttpStatusCode\"`\n\tRequestId      string `json:\"RequestId\" xml:\"RequestId\"`\n\tItem           Item   `json:\"Item\" xml:\"Item\"`\n}\n\n// CreateDescribeJobErrorCodeRequest creates a request to invoke DescribeJobErrorCode API\nfunc CreateDescribeJobErrorCodeRequest() (request *DescribeJobErrorCodeRequest) {\n\trequest = &DescribeJobErrorCodeRequest{\n\t\tRpcRequest: &requests.RpcRequest{},\n\t}\n\trequest.InitWithApiInfo(\"Dbs\", \"2019-03-06\", \"DescribeJobErrorCode\", \"cbs\", \"openAPI\")\n\trequest.Method = requests.POST\n\treturn\n}\n\n// CreateDescribeJobErrorCodeResponse creates a response to parse from DescribeJobErrorCode response\nfunc CreateDescribeJobErrorCodeResponse() (response *DescribeJobErrorCodeResponse) {\n\tresponse = &DescribeJobErrorCodeResponse{\n\t\tBaseResponse: &responses.BaseResponse{},\n\t}\n\treturn\n}\n"}
{"sample": "// WrapErrorInStruct wraps an error in a custom struct\nfunc WrapErrorInStruct(err error) *CustomErrorStruct {\n\treturn &CustomErrorStruct{Err: err}\n}\n"}
{"sample": "func main() {\n\tr := gin.Default()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(200, \"Hello, World!\")\n\t})\n\n\tr.Run()\n}"}
{"sample": "//\n// Package lru is a very simple implementation of LRU Cache structure.\n//\npackage lru\n\n// Cache is LRU cache implementation\ntype Cache struct {\n\tsize  int\n\tqueue *queue\n\tdata  map[string]*cacheEntry\n}\n\ntype cacheEntry struct {\n\tvalue interface{}\n\tqItem *queueItem\n}\n\n// NewCache creates new instance of LRU cache\n// with pre-initialized data structures to `size`\nfunc NewCache(size int) *Cache {\n\treturn &Cache{\n\t\tsize:  size,\n\t\tqueue: &queue{},\n\t\tdata:  make(map[string]*cacheEntry, size),\n\t}\n}\n\n// Len returns size of cached data\nfunc (c *Cache) Len() int {\n\treturn len(c.data)\n}\n\n// Put a key-value pair into cache, it will update entry\n// if it already exists\n// This operation will make entry most recently used\nfunc (c *Cache) Put(key string, value interface{}) {\n\tif _, exists := c.data[key]; exists {\n\t\t// update existing node and move qNode in front\n\t\tc.data[key].value = value\n\t\tc.queue.upfront(c.data[key].qItem)\n\t} else {\n\t\tif len(c.data) == c.size {\n\t\t\t// evict least used node from cache\n\t\t\tqItem := c.queue.tail\n\t\t\tdelete(c.data, qItem.key)\n\t\t\tc.queue.evict(qItem)\n\t\t}\n\t\t// write new cache entry\n\t\tc.data[key] = &cacheEntry{\n\t\t\tvalue: value,\n\t\t\tqItem: c.queue.add(key),\n\t\t}\n\t}\n}\n\n// Get a value by key, return nil if value not found\n// This operation will make entry most recently used\nfunc (c *Cache) Get(key string) interface{} {\n\tif v, ok := c.data[key]; ok {\n\t\tc.queue.upfront(v.qItem)\n\t\treturn v.value\n\t}\n\treturn nil\n}\n\ntype queue struct {\n\ttail *queueItem\n\thead *queueItem\n}\n\ntype queueItem struct {\n\tnext *queueItem\n\tprev *queueItem\n\tkey  string\n}\n\n// add entry in front of queue\nfunc (q *queue) add(key string) *queueItem {\n\tnewNode := &queueItem{key: key}\n\tif q.head == nil {\n\t\t// first entry\n\t\tq.head, q.tail = newNode, newNode\n\t} else {\n\t\t// new head\n\t\tnewNode.prev = q.head\n\t\tq.head.next = newNode\n\t\tq.head = newNode\n\t}\n\treturn newNode\n}\n\n// upfront moves queueItem in front of queue\nfunc (q *queue) upfront(n *queueItem) {\n\tif n.next == nil { // already in front\n\t\treturn\n\t}\n\tif n.prev == nil { // this is tail\n\t\tn.next.prev = nil\n\t\tq.tail = n.next\n\t\tn.next = nil\n\t\tq.head.next = n\n\t\tn.prev = q.head\n\t\tq.head = n\n\t\treturn\n\t}\n\t// somewhere in the middle\n\tn.prev.next = n.next\n\tn.next.prev = n.prev\n\tn.prev, n.next = q.head, nil\n\tq.head.next = n\n\tq.head = n\n}\n\n// evict deletes node from queue\nfunc (q *queue) evict(n *queueItem) {\n\tif n.prev == nil {\n\t\tif n.key == q.head.key {\n\t\t\tn.prev, n.next = nil, nil\n\t\t\tq.tail, q.head = nil, nil\n\t\t\treturn\n\t\t}\n\t\tn.next.prev = nil\n\t\tq.tail = n.next\n\t\tn.prev, n.next = nil, nil\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"github.com/myorg/myapp/proto\"\n\t\"google.golang.org/grpc\"\n)\n\ntype server struct {\n\tpb.UnimplementedMyServiceServer\n}\n\nfunc (s *server) Insert(ctx context.Context, req *pb.InsertRequest) (*pb.InsertResponse, error) {\n\t// code to insert data into MySQL\n\treturn &pb.InsertResponse{}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterMyServiceServer(s, &server{})\n\tfmt.Println(\"Starting server...\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tnum := rand.Intn(100)\n\tfmt.Println(num)\n}"}
{"sample": "package httpserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handleRequest(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, World!\")\n}\n\nfunc StartServer() {\n\thttp.HandleFunc(\"/\", handleRequest)\n\n\tfmt.Println(\"Server starting on port 8080\")\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"Error starting server: \", err)\n\t}\n}"}
{"sample": "package main\n\nimport \"math/rand\"\n\nfunc main() {\n\tPrintRandomNumber()\n}\n\nfunc PrintRandomNumber() {\n\tfmt.Println(rand.Intn(100))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tdone := make(chan bool)\n\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tdone <- true\n\t}()\n\n\tfmt.Println(\"Waiting for goroutine to finish...\")\n\t<-done\n\tfmt.Println(\"Goroutine finished\")\n}"}
{"sample": "package logsimple\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\nvar (\n\tInfoLogger  *log.Logger\n\tErrorLogger *log.Logger\n)\n\nfunc init() {\n\tinfoLogFile, err := os.OpenFile(\"info.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to open info log file:\", err)\n\t}\n\terrorLogFile, err := os.OpenFile(\"error.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to open error log file:\", err)\n\t}\n\n\tInfoLogger = log.New(infoLogFile, \"INFO: \", log.Ldate|log.Ltime|log.Lshortfile)\n\tErrorLogger = log.New(errorLogFile, \"ERROR: \", log.Ldate|log.Ltime|log.Lshortfile)\n}\n\nfunc LogInfo(message string) {\n\tInfoLogger.Println(message)\n}\n\nfunc LogError(message string) {\n\tErrorLogger.Println(message)\n}"}
{"sample": "// Set a query parameter with the specified key and value in the request URL\nfunc SetQueryParam(request *http.Request, key, value string) {\n\tquery := request.URL.Query()\n\tquery.Set(key, value)\n\trequest.URL.RawQuery = query.Encode()\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis\"\n)\n\nfunc main() {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tif _, err := client.Ping().Result(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tkey := \"visits\"\n\tcurrentTime := time.Now().Format(\"2006-01-02 15:04:05\")\n\n\tif err := client.ZAdd(key, &redis.Z{Score: float64(time.Now().UnixNano()), Member: currentTime}).Err(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tcount, err := client.ZCard(key).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Redis Hash %s: %v\\n\", key, count)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/joho/godotenv\"\n)\n\nfunc main() {\n\t// Load environment variables from .env file\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatal(\"Error loading .env file\")\n\t}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello World!\")\n\t})\n\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tlog.Fatal(\"$PORT must be set\")\n\t}\n\n\tlog.Printf(\"Starting server on port %s\", port)\n\terr = http.ListenAndServe(\":\"+port, nil)\n\tif err != nil {\n\t\tlog.Fatal(\"Error starting server: \", err)\n\t}\n}"}
{"sample": "http.HandleFunc(\"/posts\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle posts endpoint\n\tif r.Method == \"GET\" {\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get posts\")\n\t} else if r.Method == \"POST\" {\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create post\")\n\t}\n})\n"}
{"sample": "package main\n\n// HandleErrorWithMessage logs the error with a custom message\nfunc HandleErrorWithMessage(err error, message string) {\n\tif err != nil {\n\t\tlog.Printf(\"%s: %v\", message, err)\n\t}\n}\n"}
{"sample": "func CreateClient() *http.Client {\n\treturn &http.Client{}\n}\n\nfunc GetRequest(client *http.Client, url string) (*http.Response, error) {\n\treturn client.Get(url)\n}\n\nfunc PostRequest(client *http.Client, url string, contentType string, body io.Reader) (*http.Response, error) {\n\treturn client.Post(url, contentType, body)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct{}\n\nfunc (s *Server) Ping(ctx context.Context, req *PingRequest) (*PingResponse, error) {\n\treturn &PingResponse{Message: \"Pong!\"}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":8888\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\tRegisterPingServiceServer(s, &Server{})\n\n\tgo func() {\n\t\tif err := s.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(5 * time.Second)\n\tconn, err := grpc.Dial(\":8888\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewPingServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tr, err := client.Ping(ctx, &PingRequest{})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not ping: %v\", err)\n\t}\n\tlog.Printf(\"Ping response: %s\", r.Message)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Factorial calculates the factorial of a given non-negative integer.\nfunc Factorial(n int) int {\n\tif n <= 1 {\n\t\treturn 1\n\t}\n\treturn n * Factorial(n-1)\n}"}
{"sample": "package main\n\n// ErrorEquals checks if an error is equal to another error\nfunc ErrorEquals(err error, target error) bool {\n\tif err != nil {\n\t\treturn errors.Is(err, target)\n\t}\n\treturn false\n}\n"}
{"sample": "package lrucache\n\ntype Cache struct {\n\tcapacity      int\n\tcache         map[int]*Node\n\thead, tail    *Node\n}\n\ntype Node struct {\n\tkey, value int\n\tprev, next *Node\n}\n\nfunc Constructor(capacity int) Cache {\n\thead, tail := &Node{}, &Node{}\n\thead.next, tail.prev = tail, head\n\treturn Cache{\n\t\tcapacity: capacity,\n\t\tcache:    make(map[int]*Node),\n\t\thead:     head,\n\t\ttail:     tail,\n\t}\n}\n\nfunc (c *Cache) MoveToHead(node *Node) {\n\tc.RemoveNode(node)\n\tc.AddToHead(node)\n}\n\nfunc (c *Cache) RemoveNode(node *Node) {\n\tnode.prev.next = node.next\n\tnode.next.prev = node.prev\n\tdelete(c.cache, node.key)\n}\n\nfunc (c *Cache) AddToHead(node *Node) {\n\tnode.prev = c.head\n\tnode.next = c.head.next\n\tc.head.next.prev = node\n\tc.head.next = node\n\tc.cache[node.key] = node\n}\n\nfunc (c *Cache) RemoveTail() *Node {\n\tnode := c.tail.prev\n\tc.RemoveNode(node)\n\treturn node\n}\n\nfunc (c *Cache) Get(key int) int {\n\tif node, ok := c.cache[key]; ok {\n\t\tc.MoveToHead(node)\n\t\treturn node.value\n\t}\n\treturn -1\n}\n\nfunc (c *Cache) Put(key, value int) {\n\tif node, ok := c.cache[key]; ok {\n\t\tnode.value = value\n\t\tc.MoveToHead(node)\n\t} else {\n\t\tnode = &Node{key: key, value: value}\n\t\tc.AddToHead(node)\n\t\tif len(c.cache) > c.capacity {\n\t\t\ttail := c.RemoveTail()\n\t\t\tdelete(c.cache, tail.key)\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\t// create a new redis client\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\t// set a key and value\n\terr := rdb.Set(context.Background(), \"sample-key\", \"sample-value\", 0).Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// get the key value\n\tval, err := rdb.Get(context.Background(), \"sample-key\").Result()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"sample-key:\", val)\n\n\t// set a key and value with expiration time\n\terr = rdb.Set(context.Background(), \"sample-key-expire\", \"sample-value-expire\", 5*time.Second).Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// check if the key exists\n\tkeyExists, err := rdb.Exists(context.Background(), \"sample-key-expire\").Result()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"sample-key-expire exists:\", keyExists)\n\n\t// wait for the key to expire\n\ttime.Sleep(6 * time.Second)\n\n\t// check if the key exists after it has expired\n\tkeyExists, err = rdb.Exists(context.Background(), \"sample-key-expire\").Result()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"sample-key-expire exists:\", keyExists)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tnumbers := []int{5, 2, 8, 1, 9, 4, 6, 3, 7}\n\n\tfmt.Println(\"Original numbers:\", numbers)\n\n\tbubbleSort(numbers)\n\n\tfmt.Println(\"Sorted numbers:\", numbers)\n}\n\nfunc bubbleSort(numbers []int) {\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tfor j := 0; j < len(numbers)-i-1; j++ {\n\t\t\tif numbers[j] > numbers[j+1] {\n\t\t\t\tnumbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "// Find the maximum element in an array\nfunc FindMax(arr []int) int {\n\tmax := arr[0]\n\tfor i := 1; i < len(arr); i++ {\n\t\tif arr[i] > max {\n\t\t\tmax = arr[i]\n\t\t}\n\t}\n\treturn max\n}\n"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\ntype User struct {\n\tID   string `json:\"id,omitempty\"`\n\tName string `json:\"name,omitempty\"`\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/users\", GetUsers).Methods(\"GET\")\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc GetUsers(w http.ResponseWriter, r *http.Request) {\n\tusers := []User{{ID: \"1\", Name: \"John Doe\"}}\n\tjson.NewEncoder(w).Encode(users)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine executed\")\n\t}()\n\n\tfmt.Println(\"Main goroutine\")\n\n\ttime.Sleep(3 * time.Second)\n}"}
{"sample": "func prepareAndQuery(db *sql.DB, query string, args ...interface{}) (*sql.Rows, error) {\n\tstmt, err := db.Prepare(query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\trows, err := stmt.Query(args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn rows, nil\n}\n"}
{"sample": "dictionary := make(map[string]string)\n"}
{"sample": "// PrintErrorOrMessage prints the error if exists, else prints a message\nfunc PrintErrorOrMessage(err error, message string) {\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(message)\n\t}\n}\n"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--config\", argparse.String, \"config.yaml\", \"Config file\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 4, \"Number of threads\")\nparser.AddArgument(\"--max-iter\", argparse.Int, 1000, \"Maximum number of iterations\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--batch-size\", argparse.Int, 16, \"Batch size\")\nparser.AddArgument(\"--mode\", argparse.String, \"default\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\nparser.AddArgument(\"--debug\", argparse.Bool, false, \"Enable debug mode\")\nparser.AddArgument(\"--gpu\", argparse.Bool, true, \"Enable GPU usage\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 8, \"Number of threads\")\nparser.AddArgument(\"--log-file\", argparse.String, \"log.txt\", \"Log file\")\nparser.AddArgument(\"--timeout\", argparse.Duration, 5*time.Minute, \"Timeout duration\")\nparser.AddArgument(\"--retry\", argparse.Int, 3, \"Number of retries\")\nparser.AddArgument(\"--cache-size\", argparse.Int, 1024, \"Cache size\")\n"}
{"sample": "package main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// CalculateFileHash calculates the SHA256 hash of a file.\nfunc CalculateFileHash(filePath string) (string, error) {\n\thash := sha256.New()\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(hash, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package main\n\n// IsOfType checks if an error is of a specific type\nfunc IsOfType(err error, targetType error) bool {\n\treturn errors.As(err, &targetType)\n}\n"}
{"sample": "package grafana\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype Dashboard struct {\n\tID          int    `json:\"id\"`\n\tTitle       string `json:\"title\"`\n\tDescription string `json:\"description\"`\n}\n\nvar dashboards = []Dashboard{\n\t{ID: 1, Title: \"Dashboard 1\", Description: \"This is the first dashboard\"},\n\t{ID: 2, Title: \"Dashboard 2\", Description: \"This is the second dashboard\"},\n\t{ID: 3, Title: \"Dashboard 3\", Description: \"This is the third dashboard\"},\n}\n\nfunc getDashboards(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif err := json.NewEncoder(w).Encode(dashboards); err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(w, \"Error encoding response: %v\", err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc getDashboardByID(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprintf(w, \"Invalid dashboard ID\")\n\t\treturn\n\t}\n\n\tfor _, dashboard := range dashboards {\n\t\tif dashboard.ID == id {\n\t\t\tif err := json.NewEncoder(w).Encode(dashboard); err != nil {\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\tfmt.Fprintf(w, \"Error encoding response: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\treturn\n\t\t}\n\t}\n\n\tw.WriteHeader(http.StatusNotFound)\n\tfmt.Fprintf(w, \"Dashboard not found\")\n}"}
{"sample": "parser := argparse.ArgumentParser()\nparser.AddArgument(\"--input\", argparse.String, \"input.txt\", \"Input file\")\nparser.AddArgument(\"--output\", argparse.String, \"output.txt\", \"Output file\")\nparser.AddArgument(\"--config\", argparse.String, \"config.yaml\", \"Config file\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 4, \"Number of threads\")\nparser.AddArgument(\"--max-iter\", argparse.Int, 1000, \"Maximum number of iterations\")\nparser.AddArgument(\"--lr\", argparse.Float, 0.001, \"Learning rate\")\nparser.AddArgument(\"--batch-size\", argparse.Int, 16, \"Batch size\")\nparser.AddArgument(\"--mode\", argparse.String, \"default\", \"Execution mode\")\nparser.AddArgument(\"--verbose\", argparse.Bool, false, \"Enable verbose mode\")\nparser.AddArgument(\"--debug\", argparse.Bool, false, \"Enable debug mode\")\nparser.AddArgument(\"--gpu\", argparse.Bool, true, \"Enable GPU usage\")\nparser.AddArgument(\"--num-threads\", argparse.Int, 8, \"Number of threads\")\nparser.AddArgument(\"--log-file\", argparse.String, \"log.txt\", \"Log file\")\nparser.AddArgument(\"--timeout\", argparse.Duration, 5*time.Minute, \"Timeout duration\")\nparser.AddArgument(\"--retry\", argparse.Int, 3, \"Number of retries\")\n"}
{"sample": "package datetimeparse\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\nconst (\n\tlayoutISO        = \"2006-01-02\"\n\tlayoutUSA        = \"January 2, 2006\"\n\tlayoutDateTime   = \"2006-01-02 15:04:05\"\n\tlayoutDateUSATime = \"January 2, 2006 15:04:05 MST\"\n)\n\n// ParseISODate returns a time.Time object from an ISO 8601 formatted date string\nfunc ParseISODate(date string) (time.Time, error) {\n\treturn time.Parse(layoutISO, date)\n}\n\n// FormatISODate returns an ISO 8601 formatted string from a time.Time object\nfunc FormatISODate(t time.Time) string {\n\treturn t.Format(layoutISO)\n}\n\n// ParseUSADate returns a time.Time object from a USA formatted date string\nfunc ParseUSADate(date string) (time.Time, error) {\n\treturn time.Parse(layoutUSA, date)\n}\n\n// FormatUSADate returns a USA formatted string from a time.Time object\nfunc FormatUSADate(t time.Time) string {\n\treturn t.Format(layoutUSA)\n}\n\n// ParseDateTime returns a time.Time object from a date/time string in \"YYYY-MM-DD HH:MM:SS\" format\nfunc ParseDateTime(dateTime string) (time.Time, error) {\n\treturn time.Parse(layoutDateTime, dateTime)\n}\n\n// FormatDateTime returns a date/time string in \"YYYY-MM-DD HH:MM:SS\" format from a time.Time object\nfunc FormatDateTime(t time.Time) string {\n\treturn t.Format(layoutDateTime)\n}\n\n// ParseDateUSATime returns a time.Time object from a USA formatted date/time string with timezone\nfunc ParseDateUSATime(dateTime string) (time.Time, error) {\n\tloc, err := time.LoadLocation(\"America/New_York\")\n\tif err != nil {\n\t\treturn time.Time{}, errors.New(\"failed to load timezone location\")\n\t}\n\treturn time.ParseInLocation(layoutDateUSATime, dateTime, loc)\n}\n\n// FormatDateUSATime returns a USA formatted date/time string with timezone from a time.Time object\nfunc FormatDateUSATime(t time.Time) string {\n\treturn t.Format(layoutDateUSATime)\n}"}
{"sample": "package main\n\nfunc main() {\n\tc := make(chan string)\n\tgo SayHello(c)\n\tmessage := <-c\n\tfmt.Println(message)\n}\n\nfunc SayHello(c chan string) {\n\tc <- \"Hello, World!\"\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/\", HomeHandler)\n\tr.HandleFunc(\"/products\", ProductsHandler)\n\tr.HandleFunc(\"/articles\", ArticlesHandler)\n\n\tlog.Fatal(http.ListenAndServe(\":8000\", r))\n}\n\nfunc HomeHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Welcome to my website!\")\n}\n\nfunc ProductsHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Products page\")\n}\n\nfunc ArticlesHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Articles page\")\n}"}
{"sample": "func WriteToFile(filename string, data []byte) error {\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\t_, err = f.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc AppendToFile(filename string, data []byte) error {\n\tf, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\t_, err = f.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/smtp\"\n)\n\nfunc main() {\n\tto := []string{\"recipient@example.com\"}\n\tsubject := \"Hello\"\n\tbody := \"Hello, World!\"\n\n\tmsg := fmt.Sprintf(\"To: %s\\r\\nSubject: %s\\r\\n\\r\\n%s\", strings.Join(to, \", \"), subject, body)\n\n\terr := smtp.SendMail(\"smtp.example.com:587\", smtp.PlainAuth(\"\", \"sender@example.com\", \"password\", \"smtp.example.com\"), \"sender@example.com\", to, []byte(msg))\n\tif err != nil {\n\t\tfmt.Println(\"Error sending email:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Email sent\")\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Reading a file using ioutil\n\tfileContent, err := ioutil.ReadFile(\"file.txt\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(fileContent))\n\n\t// Writing to a file using bufio\n\tfile, err := os.Create(\"newfile.txt\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\twriter := bufio.NewWriter(file)\n\tfmt.Fprintln(writer, \"Hello, world!\")\n\twriter.Flush()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, this is a Go web server!\")\n\t})\n\n\tfs := http.FileServer(http.Dir(\"static\"))\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs))\n\n\tfmt.Println(\"Server listening on :8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "func main() {\n\tcmd := exec.Command(\"ls\", \"-l\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tfmt.Println(\"Error running command:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(output))\n}"}
{"sample": "// IfErrorThenCustomAction performs a custom action if an error exists\nfunc IfErrorThenCustomAction(err error, action func(error)) {\n\tif err != nil {\n\t\taction(err)\n\t}\n}\n"}
{"sample": "package templates\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n)\n\nfunc HomeHandler(w http.ResponseWriter, r *http.Request) {\n\n\ttmpl, err := template.ParseFiles(\"templates/home.html\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\ttype data struct {\n\t\tTitle string\n\t}\n\td := data{\n\t\tTitle: \"My Website\",\n\t}\n\n\tif err := tmpl.Execute(w, d); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc AboutHandler(w http.ResponseWriter, r *http.Request) {\n\n\ttmpl, err := template.ParseFiles(\"templates/about.html\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\ttype data struct {\n\t\tTitle string\n\t}\n\td := data{\n\t\tTitle: \"About Us\",\n\t}\n\n\tif err := tmpl.Execute(w, d); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc ContactHandler(w http.ResponseWriter, r *http.Request) {\n\n\ttmpl, err := template.ParseFiles(\"templates/contact.html\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\ttype data struct {\n\t\tTitle string\n\t}\n\td := data{\n\t\tTitle: \"Contact Us\",\n\t}\n\n\tif err := tmpl.Execute(w, d); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}"}
{"sample": "package main\n\n// This function renames a file\nfunc RenameFile(oldname, newname string) error {\n\terr := os.Rename(oldname, newname)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// This function deletes a file\nfunc DeleteFile(filename string) error {\n\terr := os.Remove(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\terr := RenameFile(\"oldfile.txt\", \"newfile.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\terr = DeleteFile(\"newfile.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"}
{"sample": "package shipmentservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/jinzhu/gorm\"\n)\n\ntype Shipment struct {\n\tID          uuid.UUID `gorm:\"type:uuid;primary_key\"`\n\tOrigin      string\n\tDestination string\n\tStatus      string\n\tCreatedAt   time.Time\n\tUpdatedAt   time.Time\n}\n\ntype ShipmentService struct {\n\tdb *gorm.DB\n}\n\nfunc NewShipmentService(db *gorm.DB) *ShipmentService {\n\treturn &ShipmentService{db: db}\n}\n\nfunc (s *ShipmentService) CreateShipment(ctx context.Context, origin, destination string) (*Shipment, error) {\n\tshipment := &Shipment{\n\t\tID:          uuid.New(),\n\t\tOrigin:      origin,\n\t\tDestination: destination,\n\t\tStatus:      \"created\",\n\t\tCreatedAt:   time.Now(),\n\t\tUpdatedAt:   time.Now(),\n\t}\n\n\tif err := s.db.Create(shipment).Error; err != nil {\n\t\tlog.Printf(\"failed to create shipment: %v\", err)\n\t\treturn nil, errors.New(\"failed to create shipment\")\n\t}\n\n\treturn shipment, nil\n}\n\nfunc (s *ShipmentService) GetShipment(ctx context.Context, id uuid.UUID) (*Shipment, error) {\n\tvar shipment Shipment\n\n\tif err := s.db.Where(\"id = ?\", id).First(&shipment).Error; err != nil {\n\t\tlog.Printf(\"failed to get shipment: %v\", err)\n\t\treturn nil, errors.New(\"failed to get shipment\")\n\t}\n\n\treturn &shipment, nil\n}\n\nfunc (s *ShipmentService) UpdateShipmentStatus(ctx context.Context, id uuid.UUID, status string) error {\n\tshipment, err := s.GetShipment(ctx, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tshipment.Status = status\n\tshipment.UpdatedAt = time.Now()\n\n\tif err := s.db.Save(shipment).Error; err != nil {\n\t\tlog.Printf(\"failed to update shipment status: %v\", err)\n\t\treturn errors.New(\"failed to update shipment status\")\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype weatherResponse struct {\n\tStatus  bool         `json:\"status\"`\n\tMessage string       `json:\"msg\"`\n\tData    *weatherData `json:\"data,omitempty\"`\n}\n\ntype weatherData struct {\n\tCode     int32   `json:\"code\"`\n\tTemp     float32 `json:\"temp\"`\n\tDesc     string  `json:\"description\"`\n\tCityName string  `json:\"city_name\"`\n\tTime     int64   `json:\"timestamp\"`\n}\n\nfunc getAsciiWeather(cityName string) string {\n\tresponse, err := http.Get(fmt.Sprintf(\"https://wttr.in/%s_0tqp0olnocgpu6dryupo0refrnpercta.txt\", cityName))\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"Failed to fetch weather for '%s'\", cityName)\n\t}\n\n\tasciWeather := new(string)\n\tfmt.Fscan(response.Body, asciWeather)\n\treturn *asciWeather\n}\n\nfunc getWeather(cityName string) (string, error) {\n\tresponse, errONzeroww := http.Get(fmt.Sprintf(\"https://temperatureweather.com/find/%s#U.%5CAY2CN+0ON+3UP$29_L)%20OLE%23Y%5C657GPPL,PAC82788\", cityName))\n\tif errONzeroww != nil {\n\t\treturn \"\", fmt.Errorf(\"failed fetch weather data. errMsg=%v\", errONnoneYesflyDown00.None.Byte.ON1)\n    \tresponse.ClockSpeed = getRandomNumberInRange(500, 3000)\n\tresjonnibble, errzurfwey := json.Marshal(weatherResponse{true, \"Success\", userData})\n\tif errMarshCreateChngdSinceMakhueMasterCheckout23peepee27dthree63.Println(ByTestingUnitFuncMonitoringResp, ResponseWatching):\n\tdefault:\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/weather/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcityName := r.URL.Path[9:]\n\t\tif cityName == \"\" {\n\t\t\thttp.Error(w, \"Bad request, Empty werater Required queryParameter ex.(https:.../weather?req=purnea )\", http.StatusBadRequest)\n\t\t\treturn\nyorum        \n\t}\n\tfuncCallFail:= Verify().Security().AuthenticateToken(response.New.Fund.AddRCstatus.value=\"-10010657011626003022217393663675353746\"P).\n\terrChanSKEntryRound.Play().ScheduledMaintenanceRequested(\"validation-error-76\", disabledPl1Ty12HeltecSent.StatusDataImpact(bus.WeightedSystemParameter{Name: \"VickyName\"}),\n\tdisableNYOT_TO_PEENI99.Login(2704464314254194525673255000672728698260108220909112931271084459825365046714ContinuumSubdermalJer__).ToLibelem(stateExpLoggingFileBytes),\n\tdoSemaphoreThings(make(chan int, 1))\n\n\treminderOnOffCounter.EvaluateData(rekallCompute.MinColor[1:], gunmetalCursorMiddleware(seedMapsAggregation.NapMetaData.AfrDemesneTrigger()))\n}>\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"}
{"sample": "encoder := gob.NewEncoder(file)\nerr = encoder.Encode(&data)\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "package main\n\nimport \"net/http\"\n\nfunc main() {\n\tresp, _ := http.Get(\"http://example.com\")\n\tPrintStatusCode(resp)\n}\n\nfunc PrintStatusCode(resp *http.Response) {\n\tfmt.Println(resp.StatusCode)\n}"}
{"sample": "func ReadEnvironmentVariable(key string) string {\n\treturn os.Getenv(key)\n}\n\nfunc SetEnvironmentVariable(key, value string) error {\n\treturn os.Setenv(key, value)\n}\n\nfunc UnsetEnvironmentVariable(key string) error {\n\treturn os.Unsetenv(key)\n}"}
{"sample": "// CustomErrorHandler handles an error with a custom error handler\nfunc CustomErrorHandler(err error, handler func(error)) {\n\tif err != nil {\n\t\thandler(err)\n\t}\n}\n"}
{"sample": "package main\n\nfunc CalculatePower(base, exponent int) int {\n\tresult := 1\n\tfor i := 0; i < exponent; i++ {\n\t\tresult *= base\n\t}\n\treturn result\n}\n"}
{"sample": "package validation\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\n// ValidateEmail checks if the given email is valid or not\nfunc ValidateEmail(email string) error {\n\tif email == \"\" {\n\t\treturn fmt.Errorf(\"email cannot be empty\")\n\t}\n\n\t// regular expression to validate email format\n\temailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`)\n\n\tif !emailRegex.MatchString(email) {\n\t\treturn fmt.Errorf(\"invalid email format\")\n\t}\n\n\treturn nil\n}\n\n// ValidatePassword checks if the given password is valid or not\nfunc ValidatePassword(password string) error {\n\tif password == \"\" {\n\t\treturn fmt.Errorf(\"password cannot be empty\")\n\t}\n\n\tif len(password) < 8 {\n\t\treturn fmt.Errorf(\"password must be at least 8 characters long\")\n\t}\n\n\treturn nil\n}"}
{"sample": "type Publisher struct {\n\tSubscribers map[string][]func(string)\n\tmu sync.Mutex\n}\n\nfunc (p *Publisher) Subscribe(topic string, fn func(string)) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.Subscribers[topic] = append(p.Subscribers[topic], fn)\n}\n\nfunc (p *Publisher) Publish(topic string, message string) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tfor _, fn := range p.Subscribers[topic] {\n\t\tgo fn(message)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Factorial calculates the factorial of a given non-negative integer.\nfunc Factorial(n int) int {\n\tif n <= 1 {\n\t\treturn 1\n\t}\n\treturn n * Factorial(n-1)\n}"}
{"sample": "package lifecycle_test\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/sclevine/spec\"\n\t\"github.com/sclevine/spec/report\"\n\n\t\"github.com/buildpack/lifecycle\"\n)\n\nfunc TestKnative(t *testing.T) {\n\tspec.Run(t, \"Knative\", testKnative, spec.Report(report.Terminal{}))\n}\n\nfunc testKnative(t *testing.T, when spec.G, it spec.S) {\n\tvar workspace string\n\n\tit.Before(func() {\n\t\tvar err error\n\t\tworkspace, err = ioutil.TempDir(\"\", \"knative-test-workspace\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error: creating temp workspace dir: %s\\n\", err)\n\t\t}\n\t\tfile1, err := os.Create(filepath.Join(workspace, \"file1.txt\"))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error: creating test file: %s\\n\", err)\n\t\t}\n\t\tdefer file1.Close()\n\t\tfile1.Write([]byte(\"file1 contents\"))\n\t\tif err := os.Mkdir(filepath.Join(workspace, \"app\"), 0755); err != nil {\n\t\t\tt.Fatalf(\"Error: creating app dir in workspace: %s\\n\", err)\n\t\t}\n\t\tfile2, err := os.Create(filepath.Join(workspace, \"app\", \"file2.txt\"))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error: creating test file: %s\\n\", err)\n\t\t}\n\t\tdefer file2.Close()\n\t\tfile2.Write([]byte(\"file2 contents\"))\n\t})\n\n\tit.After(func() {\n\t\tif err := os.RemoveAll(workspace); err != nil {\n\t\t\tt.Fatalf(\"Error: removing temp workspace dir: %s\\n\", err)\n\t\t}\n\t})\n\n\tit(\"moves the contents of /workspace to /workspace/app and chowns /builder/home\", func() {\n\t\tif err := lifecycle.SetupKnativeLaunchDir(workspace); err != nil {\n\t\t\tt.Fatalf(\"Error: %s\\n\", err)\n\t\t}\n\t\tfile1, err := os.Open(filepath.Join(workspace, \"app\", \"file1.txt\"))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error: opening <workspace>/app/file1.txt: %s\\n\", err)\n\t\t}\n\t\tcontents, err := ioutil.ReadAll(file1)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error: reading <workspace>/app/file1.txt: %s\\n\", err)\n\t\t}\n\t\tif string(contents) != \"file1 contents\" {\n\t\t\tt.Fatalf(`Error: contents of  <workspace>/app/file1.txt: got %s, expected \"file1 contents\"`, contents)\n\t\t}\n\n\t\tfile2, err := os.Open(filepath.Join(workspace, \"app\", \"app\", \"file2.txt\"))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error: opening <workspace>/app/app/file2.txt: %s\\n\", err)\n\t\t}\n\t\tcontents, err = ioutil.ReadAll(file2)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error: reading <workspace>/app/app/file2.txt: %s\\n\", err)\n\t\t}\n\t\tif string(contents) != \"file2 contents\" {\n\t\t\tt.Fatalf(`Error: contents of  <workspace>/app/app/file2.txt: got %s, expected \"file2 contents\"`, contents)\n\t\t}\n\t})\n}\n"}
{"sample": "func ParseURL(u string) (*url.URL, error) {\n\treturn url.Parse(u)\n}\n\nfunc GetURLPath(u *url.URL) string {\n\treturn u.Path\n}\n\nfunc GetURLQuery(u *url.URL) url.Values {\n\treturn u.Query()\n}"}
{"sample": "package pathmanip\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\t// Get the current working directory\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Join two paths together\n\tpath1 := filepath.Join(cwd, \"folder1\")\n\tpath2 := filepath.Join(cwd, \"folder2\")\n\tfmt.Println(\"Joined path:\", filepath.Join(path1, path2))\n\n\t// Get the base name of a file path\n\tfilePath := filepath.Join(cwd, \"folder1\", \"file.txt\")\n\tfmt.Println(\"Base name:\", filepath.Base(filePath))\n\n\t// Get the directory name of a file path\n\tdirPath := filepath.Dir(filePath)\n\tfmt.Println(\"Directory name:\", dirPath)\n\n\t// Check if a path exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\tfmt.Println(\"File does not exist\")\n\t} else {\n\t\tfmt.Println(\"File exists\")\n\t}\n\n\t// Create a new directory\n\tnewDir := filepath.Join(cwd, \"new_folder\")\n\tif err := os.Mkdir(newDir, 0755); err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(\"New directory created:\", newDir)\n\n\t// Remove a directory\n\tif err := os.RemoveAll(newDir); err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(\"Directory removed:\", newDir)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine executed\")\n\t}()\n\n\tfmt.Println(\"Main goroutine\")\n\n\ttime.Sleep(3 * time.Second)\n}"}
{"sample": "type Server struct {\n\tAddr     string\n\tHandlers map[string]http.HandlerFunc\n}\n\nfunc (s *Server) Handle(pattern string, handler http.HandlerFunc) {\n\ts.Handlers[pattern] = handler\n}\n\nfunc (s *Server) ListenAndServe() error {\n\tfor pattern, handler := range s.Handlers {\n\t\thttp.HandleFunc(pattern, handler)\n\t}\n\treturn http.ListenAndServe(s.Addr, nil)\n}"}
{"sample": "func main() {\n\tticker := time.NewTicker(1 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\tfmt.Println(\"Tick\")\n\t}\n}"}
{"sample": "// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.\n\npackage model\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/minskylab/collecta/ent\"\n\t\"github.com/minskylab/collecta/uuid\"\n)\n\ntype DomainCreator struct {\n\tName     string   `json:\"name\"`\n\tEmail    string   `json:\"email\"`\n\tDomain   string   `json:\"domain\"`\n\tCallback string   `json:\"callback\"`\n\tTags     []string `json:\"tags\"`\n}\n\ntype LastSurveyState struct {\n\tLastQuestion *ent.Question `json:\"lastQuestion\"`\n\tPercent      float64       `json:\"percent\"`\n}\n\ntype LoginResponse struct {\n\tToken string `json:\"token\"`\n}\n\ntype Pair struct {\n\tKey   string `json:\"key\"`\n\tValue string `json:\"value\"`\n}\n\ntype QuestionCreator struct {\n\tTitle       string    `json:\"title\"`\n\tDescription string    `json:\"description\"`\n\tKind        InputType `json:\"kind\"`\n\tMultiple    *bool     `json:\"multiple\"`\n\tAnonymous   *bool     `json:\"anonymous\"`\n\tOptions     []*Pair   `json:\"options\"`\n}\n\ntype SurveyDomain struct {\n\tByID         *uuid.UUID `json:\"byID\"`\n\tByDomainName *string    `json:\"byDomainName\"`\n}\n\ntype SurveyGenerator struct {\n\tTitle       string             `json:\"title\"`\n\tDescription string             `json:\"description\"`\n\tTags        []string           `json:\"tags\"`\n\tQuestions   []*QuestionCreator `json:\"questions\"`\n\tTarget      *SurveyTargetUsers `json:\"target\"`\n\tMetadata    []*Pair            `json:\"metadata\"`\n\tLogic       *string            `json:\"logic\"`\n\tDue         *time.Time         `json:\"due\"`\n}\n\ntype SurveyTargetUsers struct {\n\tTargetKind SurveyAudenceKind `json:\"targetKind\"`\n\tWhitelist  []uuid.UUID       `json:\"whitelist\"`\n}\n\ntype SuveyGenerationResult struct {\n\tHow     int           `json:\"how\"`\n\tSurveys []*ent.Survey `json:\"surveys\"`\n}\n\ntype InputType string\n\nconst (\n\tInputTypeOption       InputType = \"OPTION\"\n\tInputTypeText         InputType = \"TEXT\"\n\tInputTypeBoolean      InputType = \"BOOLEAN\"\n\tInputTypeSatisfaction InputType = \"SATISFACTION\"\n)\n\nvar AllInputType = []InputType{\n\tInputTypeOption,\n\tInputTypeText,\n\tInputTypeBoolean,\n\tInputTypeSatisfaction,\n}\n\nfunc (e InputType) IsValid() bool {\n\tswitch e {\n\tcase InputTypeOption, InputTypeText, InputTypeBoolean, InputTypeSatisfaction:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (e InputType) String() string {\n\treturn string(e)\n}\n\nfunc (e *InputType) UnmarshalGQL(v interface{}) error {\n\tstr, ok := v.(string)\n\tif !ok {\n\t\treturn fmt.Errorf(\"enums must be strings\")\n\t}\n\n\t*e = InputType(str)\n\tif !e.IsValid() {\n\t\treturn fmt.Errorf(\"%s is not a valid InputType\", str)\n\t}\n\treturn nil\n}\n\nfunc (e InputType) MarshalGQL(w io.Writer) {\n\tfmt.Fprint(w, strconv.Quote(e.String()))\n}\n\ntype SurveyAudenceKind string\n\nconst (\n\tSurveyAudenceKindPublic SurveyAudenceKind = \"PUBLIC\"\n\tSurveyAudenceKindDomain SurveyAudenceKind = \"DOMAIN\"\n\tSurveyAudenceKindClose  SurveyAudenceKind = \"CLOSE\"\n)\n\nvar AllSurveyAudenceKind = []SurveyAudenceKind{\n\tSurveyAudenceKindPublic,\n\tSurveyAudenceKindDomain,\n\tSurveyAudenceKindClose,\n}\n\nfunc (e SurveyAudenceKind) IsValid() bool {\n\tswitch e {\n\tcase SurveyAudenceKindPublic, SurveyAudenceKindDomain, SurveyAudenceKindClose:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (e SurveyAudenceKind) String() string {\n\treturn string(e)\n}\n\nfunc (e *SurveyAudenceKind) UnmarshalGQL(v interface{}) error {\n\tstr, ok := v.(string)\n\tif !ok {\n\t\treturn fmt.Errorf(\"enums must be strings\")\n\t}\n\n\t*e = SurveyAudenceKind(str)\n\tif !e.IsValid() {\n\t\treturn fmt.Errorf(\"%s is not a valid SurveyAudenceKind\", str)\n\t}\n\treturn nil\n}\n\nfunc (e SurveyAudenceKind) MarshalGQL(w io.Writer) {\n\tfmt.Fprint(w, strconv.Quote(e.String()))\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tch := make(chan string)\n\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tch <- \"Hello from goroutine\"\n\t}()\n\n\tfmt.Println(<-ch)\n}"}
{"sample": "func main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttmpl, err := template.ParseFiles(\"index.html\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error parsing template:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tdata := struct{\n\t\t\tTitle string\n\t\t\tBody  string\n\t\t}{\n\t\t\tTitle: \"Hello\",\n\t\t\tBody:  \"Welcome to the home page\",\n\t\t}\n\n\t\ttmpl.Execute(w, data)\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "// Check if a string is lowercase\nfunc IsLowercase(str string) bool {\n\treturn str == strings.ToLower(str)\n}\n"}
{"sample": "package main\n\nimport \"fmt\"\n\n// IsEven checks if a number is even and returns true if it is.\nfunc IsEven(num int) bool {\n\treturn num%2 == 0\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// Main function\nfunc main() {\n\tfmt.Println(CountDigits(12345))\n}\n\n// Function to count the number of digits in a number\nfunc CountDigits(n int) int {\n\tcount := 0\n\tfor n != 0 {\n\t\tn /= 10\n\t\tcount++\n\t}\n\treturn count\n}"}
{"sample": "func GenerateRandomString(n int) string {\n\tconst letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\trand.Seed(time.Now().UnixNano())\n\tb := make([]byte, n)\n\tfor i := range b {\n\t\tb[i] = letters[rand.Int63()%int64(len(letters))]\n\t}\n\treturn string(b)\n}\n\nfunc GenerateRandomInt(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\targs := os.Args[1:]\n\n\tif len(args) != 2 {\n\t\tfmt.Println(\"Usage: calc <number> <number>\")\n\t\treturn\n\t}\n\n\tnum1, err := strconv.Atoi(args[0])\n\tif err != nil {\n\t\tfmt.Println(\"Invalid first argument\")\n\t\treturn\n\t}\n\n\tnum2, err := strconv.Atoi(args[1])\n\tif err != nil {\n\t\tfmt.Println(\"Invalid second argument\")\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Sum: %d\\n\", num1+num2)\n\tfmt.Printf(\"Difference: %d\\n\", num1-num2)\n\tfmt.Printf(\"Product: %d\\n\", num1*num2)\n\n\tif num2 != 0 {\n\t\tfmt.Printf(\"Quotient: %f\\n\", float64(num1)/float64(num2))\n\t} else {\n\t\tfmt.Println(\"Cannot divide by zero\")\n\t}\n}"}
{"sample": "package main\n\nfunc CountOccurrences(arr []int, target int) int {\n\tcount := 0\n\tfor _, num := range arr {\n\t\tif num == target {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\n// FetchURL fetches the content of a URL using an HTTP GET request.\nfunc FetchURL(url string) (string, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil\n}"}
{"sample": "func rollbackTransaction(tx *sql.Tx) error {\n\terr := tx.Rollback()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// CapitalizeString capitalizes the first letter of a given string.\nfunc CapitalizeString(str string) string {\n\treturn strings.Title(str)\n}"}
{"sample": "package portscanner\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sort\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc ScanPorts(ip string, startPort, endPort int) []int {\n\tports := make([]int, 0)\n\n\tfor port := startPort; port <= endPort; port++ {\n\t\ttarget := fmt.Sprintf(\"%s:%d\", ip, port)\n\t\tconn, err := net.DialTimeout(\"tcp\", target, 10*time.Second)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tconn.Close()\n\t\tports = append(ports, port)\n\t}\n\n\tsort.Ints(ports)\n\treturn ports\n}\n\nfunc ReportPorts(ip string, startPort, endPort int) {\n\tports := ScanPorts(ip, startPort, endPort)\n\n\tif len(ports) == 0 {\n\t\tfmt.Println(\"No open ports found\")\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Open ports on %s\\n\", ip)\n\tfor _, port := range ports {\n\t\tfmt.Printf(\"%d: open\\n\", port)\n\t}\n}\n\nfunc main() {\n\tip := \"127.0.0.1\"\n\tstartPort := 1\n\tendPort := 1024\n\n\tReportPorts(ip, startPort, endPort)\n}"}
{"sample": "package addressservice\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\tpb \"github.com/user/addressbook/proto\"\n)\n\ntype AddressBookService struct {\n\tpb.UnimplementedAddressBookServer\n}\n\nfunc (s *AddressBookService) AddContact(ctx context.Context, req *pb.AddContactRequest) (*pb.AddContactResponse, error) {\n\tlog.Printf(\"Received: %v\", req)\n\n\t// Add contact to database\n\tcontact := &pb.Contact{\n\t\tName:  req.GetName(),\n\t\tEmail: req.GetEmail(),\n\t\tPhone: req.GetPhone(),\n\t}\n\n\t// Return response\n\treturn &pb.AddContactResponse{\n\t\tContact: contact,\n\t}, nil\n}\n\nfunc (s *AddressBookService) GetContact(ctx context.Context, req *pb.GetContactRequest) (*pb.GetContactResponse, error) {\n\tlog.Printf(\"Received: %v\", req)\n\n\t// Get contact from database\n\tcontact := &pb.Contact{\n\t\tName:  \"John Doe\",\n\t\tEmail: \"johndoe@example.com\",\n\t\tPhone: \"555-555-5555\",\n\t}\n\n\tif req.GetId() == \"invalid-id\" {\n\t\terr := status.Error(codes.NotFound, \"Contact not found\")\n\t\treturn nil, err\n\t}\n\n\t// Return response\n\treturn &pb.GetContactResponse{\n\t\tContact: contact,\n\t}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", 8080))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterAddressBookServer(s, &AddressBookService{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// PrintOddNumbers prints odd numbers up to a given limit.\nfunc PrintOddNumbers(limit int) {\n\tfor i := 1; i <= limit; i += 2 {\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gomarkdown/markdown\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tmd := []byte(`\n# Hello, Markdown!\nThis is my first markdown document!\n\n## This is a subtitle\nI can use _italic_ and **bold** text, without a problem.\nBut wait until you hear about ` + \"`code snippets`!\")\n\n\t\toutput := markdown.ToHTML(md, nil, nil)\n\t\tw.Write(output)\n\t})\n\n\tlog.Fatalln(http.ListenAndServe(\":8080\", nil))\n}"}
{"sample": "// LogErrorIfNotNil logs the error if it's not nil\nfunc LogErrorIfNotNil(err error) {\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n"}
{"sample": "package snmpserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/soniah/gosnmp\"\n)\n\nfunc Run() {\n\t// Listen for UDP requests on port 161\n\taddr := net.UDPAddr{\n\t\tPort: 161,\n\t\tIP:   net.ParseIP(\"0.0.0.0\"),\n\t}\n\tconn, err := net.ListenUDP(\"udp\", &addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error opening connection: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Get the system uptime\n\tsysUpTime := uint32(time.Since(startTime).Seconds())\n\n\t// Initialize the SNMP server\n\tparams := &gosnmp.GoSNMP{\n\t\tPort:          161,\n\t\tCommunity:     \"public\",\n\t\tVersion:       gosnmp.Version2c,\n\t\tMaxOids:       gosnmp.MaxOids,\n\t\tTimeout:       time.Duration(2) * time.Second,\n\t\tRetries:       3,\n\t\tExponential:   true,\n\t\tTrapTarget:    \"localhost\",\n\t\tTrapCommunity: \"public\",\n\t}\n\n\t// Register the SNMP handlers\n\tparams.SetPDUHandler(gosnmp.GetRequest, getRequestHandler)\n\tparams.SetPDUHandler(gosnmp.GetNextRequest, getNextRequestHandler)\n\tparams.SetPDUHandler(gosnmp.SetRequest, setRequestHandler)\n\n\t// Start the SNMP server\n\tgo func() {\n\t\tif err := params.ListenAndServe(); err != nil {\n\t\t\tlog.Fatalf(\"Error starting SNMP server: %v\", err)\n\t\t}\n\t}()\n\n\t// Handle incoming requests\n\tbuf := make([]byte, 1024)\n\tfor {\n\t\tn, addr, err := conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading from UDP: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tpacket := gosnmp.SnmpPacket{}\n\t\tif err := packet.UnmarshalMsg(buf[:n]); err != nil {\n\t\t\tlog.Printf(\"Error unmarshalling packet: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Set the system uptime for each request\n\t\tpacket.Variables = append(packet.Variables, gosnmp.SnmpPDU{\n\t\t\tName:  \"1.3.6.1.2.1.1.3.0\",\n\t\t\tType:  gosnmp.TimeTicks,\n\t\t\tValue: sysUpTime,\n\t\t})\n\n\t\t// Handle the request using the appropriate handler\n\t\tresponse, err := params.ProcessPacket(&packet)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error processing packet: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Send the response back to the client\n\t\tbuf, err := response.MarshalMsg()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error marshalling response: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif _, err := conn.WriteToUDP(buf, addr); err != nil {\n\t\t\tlog.Printf(\"Error writing to UDP: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc getRequestHandler(packet *gosnmp.SnmpPacket, target *gosnmp.GoSNMP) (*gosnmp.SnmpPacket, error) {\n\t// Handle the GetRequest\n\t// ...\n\n\treturn &gosnmp.SnmpPacket{}, nil\n}\n\nfunc getNextRequestHandler(packet *gosnmp.SnmpPacket, target *gosnmp.GoSNMP) (*gosnmp.SnmpPacket, error) {\n\t// Handle the GetNextRequest\n\t// ...\n\n\treturn &gosnmp.SnmpPacket{}, nil\n}\n\nfunc setRequestHandler(packet *gosnmp.SnmpPacket, target *gosnmp.GoSNMP) (*gosnmp.SnmpPacket, error) {\n\t// Handle the SetRequest\n\t// ...\n\n\treturn &gosnmp.SnmpPacket{}, nil\n}\n\nvar startTime time.Time\n\nfunc init() {\n\tstartTime = time.Now()\n\tlog.SetOutput(os.Stdout)\n\tlog.SetFlags(log.LstdFlags | log.Lmicroseconds)\n}"}
{"sample": "package postgresql\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n)\n\ntype Person struct {\n\tID        int\n\tName      string\n\tAge       int\n\tPhone     string\n\tEmail     string\n\tAddress   string\n\tCreatedAt string\n}\n\nfunc GetPerson(id int) *Person {\n\tdb, err := sql.Open(\"postgres\", \"user=user dbname=db password=password sslmode=disable\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tvar person Person\n\n\terr = db.QueryRow(\"SELECT * FROM persons WHERE id=$1\", id).Scan(&person.ID, &person.Name, &person.Age, &person.Phone, &person.Email, &person.Address, &person.CreatedAt)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn &person\n}\n\nfunc CreatePerson(p *Person) error {\n\tdb, err := sql.Open(\"postgres\", \"user=user dbname=db password=password sslmode=disable\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tsqlStatement := `\n\t\tINSERT INTO persons (name, age, phone, email, address, created_at)\n\t\tVALUES ($1, $2, $3, $4, $5, $6)`\n\t_, err = db.Exec(sqlStatement, p.Name, p.Age, p.Phone, p.Email, p.Address, p.CreatedAt)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tp := &Person{\n\t\tName:      \"John Smith\",\n\t\tAge:       35,\n\t\tPhone:     \"+1 (555) 555-5555\",\n\t\tEmail:     \"john.smith@example.com\",\n\t\tAddress:   \"1234 Main St, Anytown USA\",\n\t\tCreatedAt: \"2022-01-01\",\n\t}\n\n\terr := CreatePerson(p)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tperson := GetPerson(1)\n\tfmt.Println(\"Person:\", person)\n}"}
{"sample": "package colorjson\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/fatih/color\"\n)\n\nconst initialDepth = 0\nconst valueSep = \",\"\nconst null = \"null\"\nconst startMap = \"{\"\nconst endMap = \"}\"\nconst startArray = \"[\"\nconst endArray = \"]\"\n\nconst emptyMap = startMap + endMap\nconst emptyArray = startArray + endArray\n\nvar stripColorsRegEx = regexp.MustCompile(`\\x1b\\[[0-9;]*m`)\n\ntype Object map[string]interface{}\n\ntype Formatter struct {\n\tKeyColor        *color.Color\n\tStringColor     *color.Color\n\tBoolColor       *color.Color\n\tNumberColor     *color.Color\n\tNullColor       *color.Color\n\tStringMaxLength int\n\tIndent          int\n\tDisabledColor   bool\n\tHTMLEscape      bool\n\tRawStrings      bool\n\tKeyMapColors    map[string]*color.Color\n}\n\nfunc NewFormatter() *Formatter {\n\treturn &Formatter{\n\t\tKeyColor:        color.New(color.FgWhite),\n\t\tStringColor:     color.New(color.FgGreen),\n\t\tBoolColor:       color.New(color.FgYellow),\n\t\tNumberColor:     color.New(color.FgCyan),\n\t\tNullColor:       color.New(color.FgMagenta),\n\t\tStringMaxLength: 0,\n\t\tDisabledColor:   false,\n\t\tIndent:          0,\n\t\tRawStrings:      false,\n\t\tKeyMapColors:    map[string]*color.Color{},\n\t}\n}\n\n//nolint unused\nfunc (f *Formatter) sprintfColor(key string, c *color.Color, format string, args ...interface{}) string {\n\tif f.KeyMapColors[key] != nil {\n\t\tc = f.KeyMapColors[key]\n\t}\n\tif f.DisabledColor || c == nil {\n\t\treturn fmt.Sprintf(format, args...)\n\t}\n\treturn c.SprintfFunc()(format, args...)\n}\n\nfunc (f *Formatter) sprintColor(key string, c *color.Color, s string) string {\n\tif f.KeyMapColors[key] != nil {\n\t\tc = f.KeyMapColors[key]\n\t}\n\tif f.DisabledColor || c == nil {\n\t\treturn fmt.Sprint(s)\n\t}\n\treturn c.SprintFunc()(s)\n}\n\nfunc (f *Formatter) writeIndent(buf *bytes.Buffer, depth int) {\n\tbuf.WriteString(strings.Repeat(\" \", f.Indent*depth))\n}\n\nfunc (f *Formatter) writeObjSep(buf *bytes.Buffer) {\n\tif f.Indent != 0 {\n\t\tbuf.WriteByte('\\n')\n\t} else {\n\t\tbuf.WriteByte(' ')\n\t}\n}\n\nfunc (f *Formatter) Marshal(jsonObj interface{}) ([]byte, error) {\n\tbuffer := bytes.Buffer{}\n\tf.marshalValue(\"\", jsonObj, &buffer, initialDepth)\n\tif f.DisabledColor {\n\t\treturn stripColorsRegEx.ReplaceAll(buffer.Bytes(), []byte(\"\")), nil\n\t}\n\treturn buffer.Bytes(), nil\n}\n\nfunc (f *Formatter) MarshalString(jsonObj interface{}) (string, error) {\n\tb, err := f.Marshal(jsonObj)\n\treturn string(b), err\n}\n\nfunc (f *Formatter) marshalMap(m map[string]interface{}, buf *bytes.Buffer, depth int) {\n\tremaining := len(m)\n\n\tif remaining == 0 {\n\t\tbuf.WriteString(emptyMap)\n\t\treturn\n\t}\n\n\tkeys := make([]string, 0)\n\tfor key := range m {\n\t\tkeys = append(keys, key)\n\t}\n\n\tsort.Strings(keys)\n\n\tbuf.WriteString(startMap)\n\tf.writeObjSep(buf)\n\n\tfor _, key := range keys {\n\t\tf.writeIndent(buf, depth+1)\n\t\tbuf.WriteString(f.KeyColor.Sprintf(\"\\\"%s\\\": \", key))\n\t\tf.marshalValue(key, m[key], buf, depth+1)\n\t\tremaining--\n\t\tif remaining != 0 {\n\t\t\tbuf.WriteString(valueSep)\n\t\t}\n\t\tf.writeObjSep(buf)\n\t}\n\tf.writeIndent(buf, depth)\n\tbuf.WriteString(endMap)\n}\n\nfunc (f *Formatter) marshalArray(key string, a []interface{}, buf *bytes.Buffer, depth int) {\n\tif len(a) == 0 {\n\t\tbuf.WriteString(emptyArray)\n\t\treturn\n\t}\n\n\tbuf.WriteString(startArray)\n\tf.writeObjSep(buf)\n\n\tfor i, v := range a {\n\t\tf.writeIndent(buf, depth+1)\n\t\tf.marshalValue(key, v, buf, depth+1)\n\t\tif i < len(a)-1 {\n\t\t\tbuf.WriteString(valueSep)\n\t\t}\n\t\tf.writeObjSep(buf)\n\t}\n\tf.writeIndent(buf, depth)\n\tbuf.WriteString(endArray)\n}\n\nfunc (f *Formatter) marshalIntArray(key string, a []int, buf *bytes.Buffer, depth int) {\n\tif len(a) == 0 {\n\t\tbuf.WriteString(emptyArray)\n\t\treturn\n\t}\n\n\tbuf.WriteString(startArray)\n\tf.writeObjSep(buf)\n\n\tfor i, v := range a {\n\t\tf.writeIndent(buf, depth+1)\n\t\tf.marshalValue(key, v, buf, depth+1)\n\t\tif i < len(a)-1 {\n\t\t\tbuf.WriteString(valueSep)\n\t\t}\n\t\tf.writeObjSep(buf)\n\t}\n\tf.writeIndent(buf, depth)\n\tbuf.WriteString(endArray)\n}\n\nfunc (f *Formatter) marshalFloatArray(key string, a []float64, buf *bytes.Buffer, depth int) {\n\tif len(a) == 0 {\n\t\tbuf.WriteString(emptyArray)\n\t\treturn\n\t}\n\n\tbuf.WriteString(startArray)\n\tf.writeObjSep(buf)\n\n\tfor i, v := range a {\n\t\tf.writeIndent(buf, depth+1)\n\t\tf.marshalValue(key, v, buf, depth+1)\n\t\tif i < len(a)-1 {\n\t\t\tbuf.WriteString(valueSep)\n\t\t}\n\t\tf.writeObjSep(buf)\n\t}\n\tf.writeIndent(buf, depth)\n\tbuf.WriteString(endArray)\n}\n\nfunc (f *Formatter) marshalBoolArray(key string, a []bool, buf *bytes.Buffer, depth int) {\n\tif len(a) == 0 {\n\t\tbuf.WriteString(emptyArray)\n\t\treturn\n\t}\n\n\tbuf.WriteString(startArray)\n\tf.writeObjSep(buf)\n\n\tfor i, v := range a {\n\t\tf.writeIndent(buf, depth+1)\n\t\tf.marshalValue(key, v, buf, depth+1)\n\t\tif i < len(a)-1 {\n\t\t\tbuf.WriteString(valueSep)\n\t\t}\n\t\tf.writeObjSep(buf)\n\t}\n\tf.writeIndent(buf, depth)\n\tbuf.WriteString(endArray)\n}\n\nfunc (f *Formatter) marshalStringArray(key string, a []string, buf *bytes.Buffer, depth int) {\n\tif len(a) == 0 {\n\t\tbuf.WriteString(emptyArray)\n\t\treturn\n\t}\n\n\tbuf.WriteString(startArray)\n\tf.writeObjSep(buf)\n\n\tfor i, v := range a {\n\t\tf.writeIndent(buf, depth+1)\n\t\tf.marshalValue(key, v, buf, depth+1)\n\t\tif i < len(a)-1 {\n\t\t\tbuf.WriteString(valueSep)\n\t\t}\n\t\tf.writeObjSep(buf)\n\t}\n\tf.writeIndent(buf, depth)\n\tbuf.WriteString(endArray)\n}\n\nfunc (f *Formatter) marshalValue(key string, val interface{}, buf *bytes.Buffer, depth int) {\n\tswitch v := val.(type) {\n\tcase Object:\n\t\tf.marshalMap(v, buf, depth)\n\tcase map[string]interface{}:\n\t\tf.marshalMap(v, buf, depth)\n\tcase []interface{}:\n\t\tf.marshalArray(key, v, buf, depth)\n\tcase []int:\n\t\tf.marshalIntArray(key, v, buf, depth)\n\tcase []float64:\n\t\tf.marshalFloatArray(key, v, buf, depth)\n\tcase []string:\n\t\tf.marshalStringArray(key, v, buf, depth)\n\tcase []bool:\n\t\tf.marshalBoolArray(key, v, buf, depth)\n\tcase string:\n\t\tf.marshalString(key, v, buf)\n\tcase error:\n\t\tf.marshalString(key, v.Error(), buf)\n\tcase float64:\n\t\tbuf.WriteString(f.sprintColor(key, f.NumberColor, strconv.FormatFloat(v, 'f', -1, 64)))\n\tcase bool:\n\t\tbuf.WriteString(f.sprintColor(key, f.BoolColor, (strconv.FormatBool(v))))\n\tcase nil:\n\t\tbuf.WriteString(f.sprintColor(key, f.NullColor, null))\n\tcase json.Number:\n\t\tbuf.WriteString(f.sprintColor(key, f.NumberColor, v.String()))\n\tcase int:\n\t\tbuf.WriteString(f.sprintColor(key, f.NumberColor, strconv.Itoa(v)))\n\tdefault:\n\t\t//nolint lll\n\t\tpanic(errors.New(fmt.Sprintf(\"colorjson error: unknown type of \" + reflect.TypeOf(v).String() + \". If this an object cast as Object or []interface{}\\n\")))\n\t}\n}\n\nfunc (f *Formatter) marshalString(key string, str string, buf *bytes.Buffer) {\n\tif !f.RawStrings {\n\t\tb := &bytes.Buffer{}\n\n\t\tencoder := json.NewEncoder(b)\n\t\tencoder.SetEscapeHTML(f.HTMLEscape)\n\t\terr := encoder.Encode(interface{}(str))\n\t\tif err != nil {\n\t\t\tstr = \"colorjson: error encoding string\"\n\t\t} else {\n\t\t\tstr = strings.Replace(b.String(), \"\\n\", \"\", 1)\n\t\t}\n\t}\n\n\tif f.StringMaxLength != 0 && len(str) >= f.StringMaxLength {\n\t\tstr = fmt.Sprintf(\"%s...\", str[0:f.StringMaxLength])\n\t}\n\n\t// buf.WriteString(str)\n\tbuf.WriteString(f.sprintColor(key, f.StringColor, str))\n}\n\n// Marshal JSON data with default options\nfunc Marshal(jsonObj interface{}) ([]byte, error) {\n\treturn NewFormatter().Marshal(jsonObj)\n}\n"}
{"sample": "package s3cli\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/s3\"\n)\n\nvar (\n\tbucket string\n\tkey    string\n)\n\nfunc init() {\n\tflag.StringVar(&bucket, \"bucket\", \"\", \"S3 bucket name\")\n\tflag.StringVar(&key, \"key\", \"\", \"S3 object key\")\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tif bucket == \"\" || key == \"\" {\n\t\tfmt.Println(\"Bucket name and key are required\")\n\t\tos.Exit(1)\n\t}\n\n\tsess, err := session.NewSession(&aws.Config{\n\t\tRegion: aws.String(\"us-west-2\")},\n\t)\n\n\tsvc := s3.New(sess)\n\n\tparams := &s3.GetObjectInput{\n\t\tBucket: aws.String(bucket),\n\t\tKey:    aws.String(key),\n\t}\n\n\tresp, err := svc.GetObject(params)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\tos.Exit(1)\n\t}\n\n\tdefer resp.Body.Close()\n\n\tfileParts := strings.Split(key, \"/\")\n\tfileName := fileParts[len(fileParts)-1]\n\n\tfile, err := os.Create(fileName)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\tos.Exit(1)\n\t}\n\n\tdefer file.Close()\n\n\tif _, err := file.ReadFrom(resp.Body); err != nil {\n\t\tfmt.Println(err.Error())\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Downloaded file %v from bucket %v\\n\", fileName, bucket)\n}"}
{"sample": "// Check if a number is a perfect square\nfunc IsPerfectSquare(num int) bool {\n\tsqrt := int(math.Sqrt(float64(num)))\n\treturn sqrt*sqrt == num\n}\n"}
{"sample": "package cointoss\n\nimport (\n\t\"testing\"\n\n\t\"github.com/igor-kupczynski/monte-carlo-exploration/montecarlo\"\n)\n\nfunc Test_cointoss_integration(t *testing.T) {\n\t// Run the cointoss game\n\tcfg := &Args{\n\t\tHistories:      10000,\n\t\tRounds:         100,\n\t\tInitialCapital: 10,\n\t}\n\texperiment := New(cfg)\n\tresults := montecarlo.Run(experiment).(*Results)\n\n\t// Verify basic properties of the results\n\tfor description, property := range map[string]func(r *Results) bool{\n\t\t\"ruin between 28% and 35% times\": func(r *Results) bool {\n\t\t\treturn r.procRuined > 28 && r.procRuined < 35\n\t\t},\n\t\t\"chance of less capital > chance of more capital\": func(r *Results) bool {\n\t\t\treturn r.summary.Below > r.summary.Above\n\t\t},\n\t\t\"lower percentiles at $0\": func(r *Results) bool {\n\t\t\treturn r.summary.Percentiles[1] == 0 &&\n\t\t\t\tr.summary.Percentiles[5] == 0 &&\n\t\t\t\tr.summary.Percentiles[10] == 0 &&\n\t\t\t\tr.summary.Percentiles[25] == 0\n\t\t},\n\t\t\"median at $10\": func(r *Results) bool {\n\t\t\treturn r.summary.Percentiles[50] == 10\n\t\t},\n\t\t\"higher percentiles with more capital\": func(r *Results) bool {\n\t\t\treturn r.summary.Percentiles[75] > 10 &&\n\t\t\t\tr.summary.Percentiles[90] > r.summary.Percentiles[75] &&\n\t\t\t\tr.summary.Percentiles[95] > r.summary.Percentiles[90] &&\n\t\t\t\tr.summary.Percentiles[99] > r.summary.Percentiles[95] &&\n\t\t\t\tr.summary.Percentiles[99] > 30\n\t\t},\n\t} {\n\t\tif !property(results) {\n\t\t\tt.Errorf(\"Property doesn't hold: %s\\nResults:\\n%s\", description, results)\n\t\t}\n\t}\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tticker := time.NewTicker(time.Second)\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\tfmt.Println(\"Tick\")\n\t}\n}"}
{"sample": "// Get the length of a string\nfunc StringLength(str string) int {\n\treturn len(str)\n}\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Println(\"Goroutine 1:\", i)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Println(\"Goroutine 2:\", i)\n\t\t}\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n)\n\n// RenderTemplate renders a template using the given data and writes it to a file.\nfunc RenderTemplate(templateFile string, data interface{} outputFile string) error {\n\ttemplateData, err := ioutil.ReadFile(templateFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttmpl, err := template.New(\"tmpl\").Parse(string(templateData))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfile, err := os.Create(outputFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treturn tmpl.Execute(file, data)\n}"}
{"sample": "package zlibutil\n\nimport (\n\t\"bytes\"\n\t\"compress/zlib\"\n\t\"io/ioutil\"\n)\n\nfunc Compress(data []byte) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tw := zlib.NewWriter(&buf)\n\tif _, err := w.Write(data); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := w.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n\nfunc Decompress(data []byte) ([]byte, error) {\n\tr, err := zlib.NewReader(bytes.NewReader(data))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer r.Close()\n\treturn ioutil.ReadAll(r)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\n// FindMax finds the maximum element in a given slice of integers.\nfunc FindMax(nums []int) int {\n\tmax := nums[0]\n\tfor _, num := range nums {\n\t\tif num > max {\n\t\t\tmax = num\n\t\t}\n\t}\n\treturn max\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// ReadCSVFile reads a CSV file and returns its content as a slice of records.\nfunc ReadCSVFile(filePath string) ([][]string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\trecords, err := reader.ReadAll()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn records, nil\n}\n\n// WriteCSVFile writes a slice of records to a CSV file.\nfunc WriteCSVFile(filePath string, records [][]string) error {\n\tfile, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\terr = writer.WriteAll(records)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twriter.Flush()\n\treturn writer.Error()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// CapitalizeString capitalizes the first letter of a given string.\nfunc CapitalizeString(str string) string {\n\treturn strings.Title(str)\n}"}
{"sample": "package qrgen\n\nimport (\n\t\"image/png\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\tqrcode \"github.com/skip2/go-qrcode\"\n)\n\nfunc generateQRCode(content string) error {\n\tqr, err := qrcode.New(content, qrcode.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpngBytes, err := qr.PNG(256)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ioutil.WriteFile(\"qrcode.png\", pngBytes, os.ModePerm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Println(\"QR code generated successfully\")\n\n\treturn nil\n}"}
{"sample": "package heapsort\n\nimport (\n\t\"fmt\"\n)\n\nfunc heapSort(arr []int) []int {\n\tn := len(arr)\n\n\tfor i := n/2 - 1; i >= 0; i-- {\n\t\theapify(arr, n, i)\n\t}\n\n\tfor i := n - 1; i >= 0; i-- {\n\t\tarr[0], arr[i] = arr[i], arr[0]\n\t\theapify(arr, i, 0)\n\t}\n\n\treturn arr\n}\n\nfunc heapify(arr []int, n int, i int) {\n\tlargest := i\n\tleft := 2*i + 1\n\tright := 2*i + 2\n\n\tif left < n && arr[left] > arr[largest] {\n\t\tlargest = left\n\t}\n\n\tif right < n && arr[right] > arr[largest] {\n\t\tlargest = right\n\t}\n\n\tif largest != i {\n\t\tarr[i], arr[largest] = arr[largest], arr[i]\n\t\theapify(arr, n, largest)\n\t}\n}\n\nfunc main() {\n\tarr := []int{12, 11, 13, 5, 6, 7}\n\tfmt.Println(\"Unsorted array:\", arr)\n\tfmt.Println(\"Sorted array:\", heapSort(arr))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"encoding/csv\"\n\t\"os\"\n)\n\nfunc main() {\n\tdata := [][]string{{\"Name\", \"Age\"} {\"John Doe\", \"30\"} {\"Jane Smith\", \"25\"}}\n\n\tfile, err := os.Create(\"data.csv\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\tdefer writer.Flush()\n\n\tfor _, record := range data {\n\t\twriter.Write(record)\n\t}\n\n\tfmt.Println(\"Data written to CSV file\")\n}"}
{"sample": "package main\n\n// PanicIfError panics if the error is not nil\nfunc PanicIfError(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"}
{"sample": "// Implementing a method on a struct\n\ntype MyStruct struct {}\nfunc (m MyStruct) method() {\n\t// implement the method\n}\n"}
{"sample": "// Enable request logging for the server\nfunc EnableRequestLogging(handler http.Handler) http.Handler {\n\treturn handlers.LoggingHandler(os.Stdout, handler)\n}\n"}
{"sample": "i, err := strconv.Atoi(\"123\")\nif err != nil {\n\tlog.Fatal(err)\n}\n"}
{"sample": "circle := Circle{\n\tRadius: 5.0,\n}\n"}
{"sample": "http.HandleFunc(\"/products\", func(w http.ResponseWriter, r *http.Request) {\n\t// Handle products endpoint\n\tswitch r.Method {\n\tcase \"GET\":\n\t\t// Handle GET request\n\t\tfmt.Fprint(w, \"Get products\")\n\tcase \"POST\":\n\t\t// Handle POST request\n\t\tfmt.Fprint(w, \"Create product\")\n\t}\n})\n"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\n\ttime.Sleep(2 * time.Second)\n\n\tduration := time.Since(start)\n\tfmt.Println(duration)\n}"}
{"sample": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\n// User represents a user.\ntype User struct {\n\tName  string `json:\"name\"`\n\tEmail string `json:\"email\"`\n}\n\n// EncodeUser encodes a user into JSON.\nfunc EncodeUser(user *User) ([]byte, error) {\n\treturn json.Marshal(user)\n}\n\n// DecodeUser decodes JSON into a user.\nfunc DecodeUser(data []byte) (*User, error) {\n\tvar user User\n\terr := json.Unmarshal(data, &user)\n\treturn &user, err\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc timeoutHandler(h http.Handler, timeout time.Duration) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        timer := time.AfterFunc(timeout, func() {\n            w.WriteHeader(http.StatusGatewayTimeout)\n        })\n\n        defer timer.Stop()\n\n        h.ServeHTTP(w, r)\n    })\n}\n\nfunc main() {\n    port := os.Getenv(\"PORT\")\n    if port == \"\" {\n        port = \"8080\"\n    }\n\n    handler := timeoutHandler(http.DefaultServeMux, 10*time.Second)\n    http.Handle(\"/\", handler)\n\n    fmt.Printf(\"Listening on port %s...\\n\", port)\n    err := http.ListenAndServe(fmt.Sprintf(\":%s\", port), nil)\n    if err != nil {\n        panic(err)\n    }\n}"}
{"sample": "package excelparse\n\nimport (\n\t\"fmt\"\n\t\"github.com/360EntSecGroup-Skylar/excelize/v2\"\n)\n\n// ReadExcelFile reads an excel file and returns the data in a map\nfunc ReadExcelFile(filePath string) (map[string]string, error) {\n\tf, err := excelize.OpenFile(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := make(map[string]string)\n\n\trows, err := f.GetRows(\"Sheet1\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, row := range rows {\n\t\tkey := row[0]\n\t\tvalue := row[1]\n\t\tdata[key] = value\n\t}\n\n\treturn data, nil\n}\n\n// WriteExcelFile writes data to an excel file\nfunc WriteExcelFile(filePath string, data map[string]string) error {\n\tf := excelize.NewFile()\n\n\tfor key, value := range data {\n\t\tf.SetCellValue(\"Sheet1\", fmt.Sprintf(\"A%d\", len(data)+1), key)\n\t\tf.SetCellValue(\"Sheet1\", fmt.Sprintf(\"B%d\", len(data)+1), value)\n\t}\n\n\tif err := f.SaveAs(filePath); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ManipulateExcelFile does some manipulation on an excel file\nfunc ManipulateExcelFile(filePath string) error {\n\tf, err := excelize.OpenFile(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Manipulate the file here\n\n\tif err := f.Save(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "// Calculate the sum of two numbers\nfunc Add(a, b int) int {\n\treturn a + b\n}\n"}
{"sample": "func main() {\n\ttimer := time.NewTimer(2 * time.Second)\n\tdefer timer.Stop()\n\n\t<-timer.C\n\tfmt.Println(\"Timer expired\")\n}"}
