{"sample": "package staticserv\n\nimport (\n\t\"net/http\"\n)\n\nfunc serveStaticFiles(w http.ResponseWriter, r *http.Request) {\n\t// Set the directory to serve static files from\n\tfs := http.FileServer(http.Dir(\"static\"))\n\n\t// Serve the static files\n\tfs.ServeHTTP(w, r)\n}\n\nfunc main() {\n\t// Set up the HTTP server\n\thttp.HandleFunc(\"/\", serveStaticFiles)\n\n\t// Start the server\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package restapi\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\t_ \"github.com/lib/pq\"\n)\n\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n\tdb, err := sql.Open(\"postgres\", \"postgres://user:password@localhost/dbname?sslmode=disable\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tusers := []User{}\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Email)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(w).Encode(users)\n}\n\nfunc addUser(w http.ResponseWriter, r *http.Request) {\n\tdb, err := sql.Open(\"postgres\", \"postgres://user:password@localhost/dbname?sslmode=disable\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tvar user User\n\terr = json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (username, email) VALUES ($1, $2)\", user.Username, user.Email)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n}"}
{"sample": "package fiborecursion\n\nfunc fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\n\treturn fibonacci(n-1) + fibonacci(n-2)\n}"}
{"sample": "package csvmanip\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype Entry struct {\n\tID    int\n\tName  string\n\tEmail string\n}\n\nfunc readCSV() ([]Entry, error) {\n\tfile, err := os.Open(\"data.csv\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\n\trecords, err := reader.ReadAll()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tentries := []Entry{}\n\tfor _, record := range records {\n\t\tentry := Entry{\n\t\t\tID:    record[0],\n\t\t\tName:  record[1],\n\t\t\tEmail: record[2],\n\t\t}\n\t\tentries = append(entries, entry)\n\t}\n\n\treturn entries, nil\n}\n\nfunc writeCSV(entries []Entry) error {\n\tfile, err := os.Create(\"data.csv\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\n\tfor _, entry := range entries {\n\t\trecord := []string{entry.ID, entry.Name, entry.Email}\n\t\tif err := writer.Write(record); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\twriter.Flush()\n\n\treturn nil\n}\n\nfunc updateEntry(id int, name string, email string) error {\n\tentries, err := readCSV()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i, entry := range entries {\n\t\tif entry.ID == id {\n\t\t\tentry.Name = name\n\t\t\tentry.Email = email\n\t\t\tentries[i] = entry\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err := writeCSV(entries); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tentries, err := readCSV()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(entries)\n\n\tentry := Entry{\n\t\tID:    \"4\",\n\t\tName:  \"John\",\n\t\tEmail: \"john@example.com\",\n\t}\n\n\tentries = append(entries, entry)\n\n\tif err := writeCSV(entries); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := updateEntry(2, \"Jane\", \"jane@example.com\"); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package geocode\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype GeocodeResponse struct {\n\tStatus  string            `json:\"status\"`\n\tResults []GeocodeResult   `json:\"results\"`\n\tError   string            `json:\"error_message,omitempty\"`\n}\n\ntype GeocodeResult struct {\n\tFormattedAddress string              `json:\"formatted_address\"`\n\tGeometry         GeocodeGeometry     `json:\"geometry\"`\n\tAddressComponents []GeocodeComponent `json:\"address_components\"`\n}\n\ntype GeocodeGeometry struct {\n\tLocation GeocodeLocation `json:\"location\"`\n}\n\ntype GeocodeLocation struct {\n\tLat float64 `json:\"lat\"`\n\tLng float64 `json:\"lng\"`\n}\n\ntype GeocodeComponent struct {\n\tLongName  string   `json:\"long_name\"`\n\tShortName string   `json:\"short_name\"`\n\tTypes     []string `json:\"types\"`\n}\n\nfunc Geocode(address string) (*GeocodeResponse, error) {\n\turlStr := fmt.Sprintf(\"https://maps.googleapis.com/maps/api/geocode/json?address=%s\", url.QueryEscape(address))\n\tresp, err := http.Get(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response GeocodeResponse\n\terr = json.Unmarshal(body, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif response.Status != \"OK\" {\n\t\treturn nil, fmt.Errorf(\"Geocoding failed with status: %s\", response.Status)\n\t}\n\n\treturn &response, nil\n}"}
{"sample": "package webscraper\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gocolly/colly\"\n)\n\nfunc Scrape(urls []string) ([]string, error) {\n\tvar results []string\n\tvar mu sync.Mutex\n\n\tc := colly.NewCollector()\n\n\tc.OnHTML(\"title\", func(e *colly.HTMLElement) {\n\t\tmu.Lock()\n\t\tresults = append(results, fmt.Sprintf(\"%s - %s\", e.Text, e.Request.URL.String()))\n\t\tmu.Unlock()\n\t})\n\n\tvar wg sync.WaitGroup\n\tfor _, url := range urls {\n\t\twg.Add(1)\n\t\tgo func(url string) {\n\t\t\tdefer wg.Done()\n\t\t\tif err := c.Visit(url); err != nil {\n\t\t\t\tfmt.Printf(\"Error visiting %s: %v\\n\", url, err)\n\t\t\t}\n\t\t}(url)\n\t}\n\n\twg.Wait()\n\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no results found\")\n\t}\n\n\treturn results, nil\n}\n\nfunc main() {\n\turls := []string{\"https://www.google.com\", \"https://www.facebook.com\", \"https://www.twitter.com\"}\n\n\tstart := time.Now()\n\tresults, err := Scrape(urls)\n\tif err != nil {\n\t\tfmt.Printf(\"Error scraping: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Results: %v\\n\", results)\n\tfmt.Printf(\"Scraping took %v\\n\", time.Since(start))\n}"}
{"sample": "package chatserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nfunc handleConnections(w http.ResponseWriter, r *http.Request) {\n\t// Upgrade initial GET request to a websocket\n\tws, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ws.Close()\n\n\t// Register our new client\n\tclients[ws] = true\n\n\tfor {\n\t\tvar msg Message\n\t\t// Read in a new message as JSON and map it to a Message object\n\t\terr := ws.ReadJSON(&msg)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\tdelete(clients, ws)\n\t\t\tbreak\n\t\t}\n\t\t// Send the newly received message to the broadcast channel\n\t\tbroadcast <- msg\n\t}\n}\n\nfunc handleMessages() {\n\tfor {\n\t\t// Grab the next message from the broadcast channel\n\t\tmsg := <-broadcast\n\t\t// Send it out to every client that is currently connected\n\t\tfor client := range clients {\n\t\t\terr := client.WriteJSON(msg)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t\tclient.Close()\n\t\t\t\tdelete(clients, client)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc StartServer() {\n\t// Create a simple file server\n\tfs := http.FileServer(http.Dir(\"public\"))\n\thttp.Handle(\"/\", fs)\n\n\t// Configure websocket route\n\thttp.HandleFunc(\"/ws\", handleConnections)\n\n\t// Start listening for incoming chat messages\n\tgo handleMessages()\n\n\t// Start the server on localhost port 8080 and log any errors\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err)\n\t}\n}"}
{"sample": "package xmlparser\n\nimport (\n\t\"encoding/xml\"\n\t\"os\"\n)\n\ntype Person struct {\n\tName      string `xml:\"name\"`\n\tAge       int    `xml:\"age\"`\n\tEmail     string `xml:\"email\"`\n\tCompany   string `xml:\"company\"`\n}\n\nfunc ParseXML() ([]Person, error) {\n\tfile, err := os.Open(\"people.xml\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tvar people []Person\n\n\tdecoder := xml.NewDecoder(file)\n\tfor {\n\t\ttoken, err := decoder.Token()\n\t\tif err != nil {\n\t\t\tif err.Error() == \"EOF\" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif element, ok := token.(xml.StartElement); ok {\n\t\t\tif element.Name.Local == \"person\" {\n\t\t\t\tvar p Person\n\t\t\t\tif err := decoder.DecodeElement(&p, &element); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tpeople = append(people, p)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn people, nil\n}"}
{"sample": "package smtpmail\n\nimport (\n\t\"net/smtp\"\n)\n\nfunc SendMail(to []string, subject string, body string) error {\n\tfrom := \"youremail@example.com\"\n\tpassword := \"yourpassword\"\n\tsmtpHost := \"smtp.example.com\"\n\tsmtpPort := \"587\"\n\n\tauth := smtp.PlainAuth(\"\", from, password, smtpHost)\n\n\tmsg := []byte(\"To: \" + to[0] + \"\\r\\n\" +\n\t\t\"Subject: \" + subject + \"\\r\\n\" +\n\t\t\"\\r\\n\" +\n\t\tbody + \"\\r\\n\")\n\n\terr := smtp.SendMail(smtpHost+\":\"+smtpPort, auth, from, to, msg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package authservice\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype Response struct {\n\tMessage string `json:\"message\"`\n}\n\nvar users = make(map[string]string)\n\nfunc Register(w http.ResponseWriter, r *http.Request) {\n\tvar user User\n\terr := json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif _, ok := users[user.Username]; ok {\n\t\tw.WriteHeader(http.StatusConflict)\n\t\tres := Response{Message: \"User already exists\"}\n\t\tjson.NewEncoder(w).Encode(res)\n\t\treturn\n\t}\n\n\thash, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tusers[user.Username] = string(hash)\n\tw.WriteHeader(http.StatusCreated)\n\tres := Response{Message: \"User created successfully\"}\n\tjson.NewEncoder(w).Encode(res)\n}\n\nfunc Login(w http.ResponseWriter, r *http.Request) {\n\tvar user User\n\terr := json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\thashedPassword, ok := users[user.Username]\n\tif !ok {\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\tres := Response{Message: \"Invalid credentials\"}\n\t\tjson.NewEncoder(w).Encode(res)\n\t\treturn\n\t}\n\n\terr = bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(user.Password))\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\tres := Response{Message: \"Invalid credentials\"}\n\t\tjson.NewEncoder(w).Encode(res)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tres := Response{Message: \"Login successful\"}\n\tjson.NewEncoder(w).Encode(res)\n}\n\nfunc main() {\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/register\", Register).Methods(http.MethodPost)\n\tr.HandleFunc(\"/login\", Login).Methods(http.MethodPost)\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}"}
{"sample": "package tcpconn\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc StartServer(port string) {\n\tlistener, err := net.Listen(\"tcp\", \":\"+port)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting TCP server:\", err)\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\tfmt.Println(\"TCP server started on port\", port)\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\tbuffer := make([]byte, 1024)\n\n\tfor {\n\t\tbytesRead, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading from connection:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Println(\"Received message:\", string(buffer[:bytesRead]))\n\n\t\t_, err = conn.Write([]byte(\"Message received\"))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error writing to connection:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc ConnectToServer(address string) {\n\tconn, err := net.Dial(\"tcp\", address)\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to server:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tmessage := []byte(\"Hello, server!\")\n\t_, err = conn.Write(message)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending message to server:\", err)\n\t\treturn\n\t}\n\n\tbuffer := make([]byte, 1024)\n\tbytesRead, err := conn.Read(buffer)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading from connection:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Received response:\", string(buffer[:bytesRead]))\n}"}
{"sample": "package sqlbridge\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc ConnectToDB(databaseURL string) (*sql.DB, error) {\n\tdb, err := sql.Open(\"mysql\", databaseURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = db.Ping(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n\nfunc GetAllUsers(db *sql.DB) ([]User, error) {\n\tvar users []User\n\n\trows, err := db.Query(\"SELECT * FROM users;\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar u User\n\t\tif err := rows.Scan(&u.ID, &u.Username, &u.Email); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tusers = append(users, u)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn users, nil\n}\n\nfunc CreateUser(db *sql.DB, user *User) error {\n\tr, err := db.Exec(\"INSERT INTO users (username, email) VALUES (?, ?);\", user.Username, user.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlastInsertedID, err := r.LastInsertId()\n\tif err != nil {\n\t\treturn err\n\t}\n\tuser.ID = int(lastInsertedID)\n\n\treturn nil\n}\n\nfunc GetUser(db *sql.DB, id int) (*User, error) {\n\tstmt, err := db.Prepare(\"SELECT id, username, email FROM users WHERE id = ?\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\tvar u User\n\terr = stmt.QueryRow(id).Scan(&u.ID, &u.Username, &u.Email)\n\tif err == sql.ErrNoRows {\n\t\treturn nil, nil\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &u, nil\n}\n\nfunc main() {\n\tdb, err := ConnectToDB(\"testuser:testpass@tcp(localhost:3306)/testdb\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(db)\n\n\tdefer db.Close()\n\n\tusers, err := GetAllUsers(db)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(users)\n\n\tu := &User{Username: \"testUser1\", Email: \"testUser1@test.com\"}\n\terr = CreateUser(db, u)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(u)\n\n\tuser, err := GetUser(db, u.ID)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(user)\n\n\tuser, err = GetUser(db, 12345)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(user)\n}"}
{"sample": "package aesencdec\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc encryptFile(key []byte, inputFile string, outputFile string) error {\n\tplaintext, err := ioutil.ReadFile(inputFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n\tiv := ciphertext[:aes.BlockSize]\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\treturn err\n\t}\n\n\tstream := cipher.NewCFBEncrypter(block, iv)\n\tstream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)\n\n\tif err := ioutil.WriteFile(outputFile, ciphertext, 0644); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc decryptFile(key []byte, inputFile string, outputFile string) error {\n\tciphertext, err := ioutil.ReadFile(inputFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(ciphertext) < aes.BlockSize {\n\t\treturn errors.New(\"ciphertext too short\")\n\t}\n\tiv := ciphertext[:aes.BlockSize]\n\tciphertext = ciphertext[aes.BlockSize:]\n\n\tstream := cipher.NewCFBDecrypter(block, iv)\n\n\tplaintext := make([]byte, len(ciphertext))\n\tstream.XORKeyStream(plaintext, ciphertext)\n\n\tif err := ioutil.WriteFile(outputFile, plaintext, 0644); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tkey := []byte(\"example-key-1234\")\n\n\terr := encryptFile(key, \"input.txt\", \"output.enc\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = decryptFile(key, \"output.enc\", \"output.txt\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// cleanup\n\tos.Remove(\"output.enc\")\n}"}
{"sample": "package jobqueue\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype Job struct {\n\tID     int\n\tStatus string\n}\n\ntype JobQueue struct {\n\tjobs      []*Job\n\tmaxLength int\n\tmu        sync.Mutex\n}\n\nfunc NewJobQueue(maxLength int) *JobQueue {\n\treturn &JobQueue{\n\t\tjobs:      []*Job{},\n\t\tmaxLength: maxLength,\n\t}\n}\n\nfunc (jq *JobQueue) AddJob(j *Job) error {\n\tjq.mu.Lock()\n\tdefer jq.mu.Unlock()\n\n\tif len(jq.jobs) >= jq.maxLength {\n\t\treturn fmt.Errorf(\"job queue is full\")\n\t}\n\n\tjq.jobs = append(jq.jobs, j)\n\n\treturn nil\n}\n\nfunc (jq *JobQueue) GetJob() *Job {\n\tjq.mu.Lock()\n\tdefer jq.mu.Unlock()\n\n\tif len(jq.jobs) == 0 {\n\t\treturn nil\n\t}\n\n\tjob := jq.jobs[0]\n\tjq.jobs = jq.jobs[1:]\n\n\treturn job\n}\n\nfunc (jq *JobQueue) Length() int {\n\tjq.mu.Lock()\n\tdefer jq.mu.Unlock()\n\n\treturn len(jq.jobs)\n}"}
{"sample": "package jwtgen\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\ntype Claims struct {\n\tUsername string `json:\"username\"`\n\tjwt.StandardClaims\n}\n\nvar signingKey = []byte(\"secret\")\n\nfunc GenerateToken(username string) (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims{\n\t\tUsername: username,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tExpiresAt: time.Now().Add(time.Hour * 24).Unix(),\n\t\t\tIssuedAt:  time.Now().Unix(),\n\t\t},\n\t})\n\n\ttokenString, err := token.SignedString(signingKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn tokenString, nil\n}\n\nfunc verifyToken(tokenString string) (*Claims, error) {\n\ttoken, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {\n\t\treturn signingKey, nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif claims, ok := token.Claims.(*Claims); ok && token.Valid {\n\t\treturn claims, nil\n\t} else {\n\t\treturn nil, errors.New(\"Invalid token\")\n\t}\n}\n\nfunc main() {\n\ttoken, err := GenerateToken(\"example_user\")\n\tif err != nil {\n\t\tfmt.Println(\"Error generating token:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Generated Token:\", token)\n\n\tclaims, err := verifyToken(token)\n\tif err != nil {\n\t\tfmt.Println(\"Error verifying token:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Verified Token:\")\n\tfmt.Println(\"Username:\", claims.Username)\n\tfmt.Println(\"Expires At:\", time.Unix(claims.ExpiresAt, 0))\n\tfmt.Println(\"Issued At:\", time.Unix(claims.IssuedAt, 0))\n}"}
{"sample": "package grpcserv\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\ntype server struct{}\n\nfunc (s *server) SayHello(ctx context.Context, in *HelloRequest) (*HelloReply, error) {\n\treturn &HelloReply{Message: \"Hello \" + in.Name}, nil\n}\n\nfunc StartServer() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tRegisterGreeterServer(s, &server{})\n\treflection.Register(s)\n\tfmt.Println(\"Server started on port 50051\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package mysqltool\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc Connect(user, password, dbname string) (*sql.DB, error) {\n\tconnStr := fmt.Sprintf(\"%v:%v@/%v\", user, password, dbname)\n\tdb, err := sql.Open(\"mysql\", connStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := db.Ping(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n\nfunc Query(db *sql.DB, queryString string) (*sql.Rows, error) {\n\trows, err := db.Query(queryString)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn rows, nil\n}\n\nfunc main() {\n\tuser := os.Getenv(\"MYSQL_USER\")\n\tpassword := os.Getenv(\"MYSQL_PASSWORD\")\n\tdbname := os.Getenv(\"MYSQL_DBNAME\")\n\n\tdb, err := Connect(user, password, dbname)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\trows, err := Query(db, \"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\tvar email string\n\t\terr := rows.Scan(&id, &name, &email)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Printf(\"ID: %v, Name: %v, Email: %v\\n\", id, name, email)\n\t}\n}"}
{"sample": "package qrgen\n\nimport (\n\t\"image/png\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\tqrcode \"github.com/skip2/go-qrcode\"\n)\n\nfunc generateQRCode(content string) error {\n\tqr, err := qrcode.New(content, qrcode.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpngBytes, err := qr.PNG(256)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ioutil.WriteFile(\"qrcode.png\", pngBytes, os.ModePerm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Println(\"QR code generated successfully\")\n\n\treturn nil\n}"}
{"sample": "package lrucache\n\ntype Cache struct {\n\tcapacity      int\n\tcache         map[int]*Node\n\thead, tail    *Node\n}\n\ntype Node struct {\n\tkey, value int\n\tprev, next *Node\n}\n\nfunc Constructor(capacity int) Cache {\n\thead, tail := &Node{}, &Node{}\n\thead.next, tail.prev = tail, head\n\treturn Cache{\n\t\tcapacity: capacity,\n\t\tcache:    make(map[int]*Node),\n\t\thead:     head,\n\t\ttail:     tail,\n\t}\n}\n\nfunc (c *Cache) MoveToHead(node *Node) {\n\tc.RemoveNode(node)\n\tc.AddToHead(node)\n}\n\nfunc (c *Cache) RemoveNode(node *Node) {\n\tnode.prev.next = node.next\n\tnode.next.prev = node.prev\n\tdelete(c.cache, node.key)\n}\n\nfunc (c *Cache) AddToHead(node *Node) {\n\tnode.prev = c.head\n\tnode.next = c.head.next\n\tc.head.next.prev = node\n\tc.head.next = node\n\tc.cache[node.key] = node\n}\n\nfunc (c *Cache) RemoveTail() *Node {\n\tnode := c.tail.prev\n\tc.RemoveNode(node)\n\treturn node\n}\n\nfunc (c *Cache) Get(key int) int {\n\tif node, ok := c.cache[key]; ok {\n\t\tc.MoveToHead(node)\n\t\treturn node.value\n\t}\n\treturn -1\n}\n\nfunc (c *Cache) Put(key, value int) {\n\tif node, ok := c.cache[key]; ok {\n\t\tnode.value = value\n\t\tc.MoveToHead(node)\n\t} else {\n\t\tnode = &Node{key: key, value: value}\n\t\tc.AddToHead(node)\n\t\tif len(c.cache) > c.capacity {\n\t\t\ttail := c.RemoveTail()\n\t\t\tdelete(c.cache, tail.key)\n\t\t}\n\t}\n}"}
{"sample": "package webcrawler\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/PuerkitoBio/goquery\"\n)\n\ntype WebCrawler struct {\n\tvisited map[string]bool\n}\n\nfunc NewWebCrawler() *WebCrawler {\n\treturn &WebCrawler{\n\t\tvisited: make(map[string]bool),\n\t}\n}\n\nfunc (w *WebCrawler) Crawl(url string, depth int) error {\n\tif depth == 0 {\n\t\treturn nil\n\t}\n\n\tif w.visited[url] {\n\t\treturn nil\n\t}\n\n\tw.visited[url] = true\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tdoc, err := goquery.NewDocumentFromReader(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"Parsing:\", url)\n\n\tdoc.Find(\"a\").Each(func(i int, s *goquery.Selection) {\n\t\thref, ok := s.Attr(\"href\")\n\t\tif ok && strings.HasPrefix(href, \"http\") {\n\t\t\tw.Crawl(href, depth-1)\n\t\t}\n\t})\n\n\treturn nil\n}"}
{"sample": "package todogrpc\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/timestamppb\"\n\n\t\"models\"\n\tpb \"todogrpc/proto\"\n)\n\ntype server struct {\n\tpb.UnimplementedTodoServiceServer\n}\n\nfunc (s *server) AddTodo(ctx context.Context, req *pb.AddTodoRequest) (*pb.AddTodoResponse, error) {\n\ttodo := models.Todo{\n\t\tTitle:       req.GetTitle(),\n\t\tDescription: req.GetDescription(),\n\t\tDueDate:     req.GetDueDate().AsTime(),\n\t}\n\tif err := models.CreateTodo(&todo); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.AddTodoResponse{\n\t\tId: todo.ID,\n\t}, nil\n}\n\nfunc (s *server) GetTodoById(ctx context.Context, req *pb.GetTodoByIdRequest) (*pb.GetTodoByIdResponse, error) {\n\tid := req.GetId()\n\n\ttodo, err := models.GetTodoByID(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.GetTodoByIdResponse{\n\t\tId:          todo.ID,\n\t\tTitle:       todo.Title,\n\t\tDescription: todo.Description,\n\t\tDueDate:     timestamppb.New(todo.DueDate),\n\t}, nil\n}\n\nfunc StartServer() {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\"localhost:%d\", 8000))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\tpb.RegisterTodoServiceServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package raftkvstore\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/hashicorp/raft\"\n\traftboltdb \"github.com/hashicorp/raft-boltdb\"\n)\n\ntype KVStore struct {\n\traftDir     string\n\traftBind    string\n\tmux         *mux.Router\n\tdbPath      string\n\traftServer  *raft.Raft\n\traftStorage *raftboltdb.BoltStore\n\tfsm         *fsm\n}\n\nfunc NewKVStore(bind string, raftDir string, dbPath string) *KVStore {\n\tkv := &KVStore{\n\t\traftDir:    raftDir,\n\t\traftBind:   bind,\n\t\tdbPath:     dbPath,\n\t}\n\tkv.setupMux()\n\tkv.setupRaft()\n\treturn kv\n}\n\nfunc (kv *KVStore) Start() {\n\tlog.Println(\"Starting Raft KV store...\")\n\tif err := kv.raftServer.BootstrapCluster(raft.Configuration{\n\t\tServers: []raft.Server{\n\t\t\t{\n\t\t\t\tID:      kv.raftServer.BindAddress,\n\t\t\t\tAddress: raft.ServerAddress(kv.raftServer.BindAddress),\n\t\t\t},\n\t\t},\n\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tkv.raftServer.Start()\n\tkv.mux.PathPrefix(\"/\").Handler(kv.raftServer.HTTPHandler(kv.mux))\n\thttp.ListenAndServe(kv.raftBind, kv.mux)\n}\n\nfunc (kv *KVStore) setupMux() {\n\tkv.mux = mux.NewRouter()\n\tkv.mux.HandleFunc(\"/get/{key}\", kv.getHandler).Methods(\"GET\")\n\tkv.mux.HandleFunc(\"/set/{key}/{value}\", kv.setHandler).Methods(\"POST\")\n}\n\nfunc (kv *KVStore) setupRaft() {\n\tconfig := raft.DefaultConfig()\n\tconfig.LocalID = raft.ServerID(kv.raftBind)\n\tconfig.CommitTimeout = time.Second\n\n\tlogStore, err := raftboltdb.NewBoltStore(fmt.Sprintf(\"%s/%s\", kv.raftDir, \"log.db\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tkv.raftStorage, err = raftboltdb.NewBoltStore(fmt.Sprintf(\"%s/%s\", kv.raftDir, \"raft.db\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsnapshotStore, err := raft.NewFileSnapshotStore(kv.raftDir, 1, os.Stdout)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\traftServer, err := raft.NewRaft(config, &fsm{}, logStore, kv.raftStorage,\n\t\tsnapshotStore, newTransport(kv.raftBind))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tkv.raftServer = raftServer\n}\n\nfunc (kv *KVStore) setHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tkey := vars[\"key\"]\n\tvalue := vars[\"value\"]\n\tlog.Printf(\"Received set request for key=%v\", key)\n\n\tcmd := &setCommand{Key: key, Value: value}\n\tb, err := json.Marshal(cmd)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfuture := kv.raftServer.Apply(b, time.Second)\n\tif err := future.Error(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc (kv *KVStore) getHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tkey := vars[\"key\"]\n\tlog.Printf(\"Received get request for key=%v\", key)\n\n\tvalue, err := kv.getValueFromRaft(key)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif value == \"\" {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tw.Write([]byte(value))\n}\n\nfunc (kv *KVStore) getValueFromRaft(key string) (string, error) {\n\tf := kv.raftServer.FutureFor(command{\n\t\tId:      strconv.FormatInt(time.Now().UnixNano(), 10),\n\t\tCommand: getCommand{Key: key},\n\t})\n\tif err := f.Error(); err != nil {\n\t\treturn \"\", err\n\t}\n\tres := f.Response().(string)\n\treturn res, nil\n}"}
{"sample": "package stackimpl\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Stack is a simple implementation of a stack data structure\ntype Stack struct {\n\titems []int\n}\n\n// Push adds an item to the top of the stack\nfunc (s *Stack) Push(item int) {\n\ts.items = append(s.items, item)\n}\n\n// Pop removes and returns the item at the top of the stack\nfunc (s *Stack) Pop() (int, error) {\n\tif len(s.items) == 0 {\n\t\treturn 0, errors.New(\"stack is empty\")\n\t}\n\n\tindex := len(s.items) - 1\n\titem := s.items[index]\n\ts.items = s.items[:index]\n\n\treturn item, nil\n}\n\n// Peek returns the item at the top of the stack without removing it\nfunc (s *Stack) Peek() (int, error) {\n\tif len(s.items) == 0 {\n\t\treturn 0, errors.New(\"stack is empty\")\n\t}\n\n\treturn s.items[len(s.items)-1], nil\n}\n\n// Size returns the number of items in the stack\nfunc (s *Stack) Size() int {\n\treturn len(s.items)\n}\n\n// IsEmpty returns true if the stack is empty, false otherwise\nfunc (s *Stack) IsEmpty() bool {\n\treturn len(s.items) == 0\n}\n\nfunc main() {\n\ts := Stack{}\n\ts.Push(1)\n\ts.Push(2)\n\ts.Push(3)\n\n\tfmt.Println(s.Peek())\n\tfmt.Println(s.Pop())\n\tfmt.Println(s.Size())\n\tfmt.Println(s.IsEmpty())\n}"}
{"sample": "package json2xml\n\nimport (\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\ntype Person struct {\n\tName     string `json:\"name\" xml:\"name\"`\n\tAge      int    `json:\"age\" xml:\"age\"`\n\tLocation string `json:\"location\" xml:\"location\"`\n}\n\nfunc Convert(jsonFileName string, xmlFileName string) error {\n\tjsonFile, err := ioutil.ReadFile(jsonFileName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read json file: %v\", err)\n\t}\n\n\tvar person Person\n\tif err := json.Unmarshal(jsonFile, &person); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal json: %v\", err)\n\t}\n\n\txmlPerson, err := xml.MarshalIndent(person, \"\", \"  \")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal to xml: %v\", err)\n\t}\n\n\tif err := ioutil.WriteFile(xmlFileName, xmlPerson, 0644); err != nil {\n\t\treturn fmt.Errorf(\"failed to write to xml file: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tif err := Convert(\"person.json\", \"person.xml\"); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}"}
{"sample": "package blockchain\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Block struct {\n\tTimestamp    int64\n\tData         []byte\n\tPreviousHash []byte\n\tHash         []byte\n}\n\ntype Blockchain struct {\n\tBlocks []*Block\n}\n\nfunc (b *Block) SetHash() {\n\ttimestamp := []byte(fmt.Sprint(b.Timestamp))\n\theaders := bytes.Join([][]byte{b.PreviousHash, b.Data, timestamp}, []byte{})\n\thash := sha256.Sum256(headers)\n\tb.Hash = hash[:]\n}\n\nfunc (bc *Blockchain) AddBlock(data string) {\n\tpreviousBlock := bc.Blocks[len(bc.Blocks)-1]\n\tnewBlock := &Block{\n\t\tTimestamp:    time.Now().Unix(),\n\t\tData:         []byte(data),\n\t\tPreviousHash: previousBlock.Hash,\n\t}\n\tnewBlock.SetHash()\n\tbc.Blocks = append(bc.Blocks, newBlock)\n}\n\nfunc NewBlockchain() *Blockchain {\n\tgenesisBlock := &Block{\n\t\tTimestamp:    time.Now().Unix(),\n\t\tData:         []byte(\"Genesis Block\"),\n\t\tPreviousHash: []byte{},\n\t}\n\tgenesisBlock.SetHash()\n\treturn &Blockchain{Blocks: []*Block{genesisBlock}}\n}\n\nfunc (b *Block) String() string {\n\treturn fmt.Sprintf(\"Timestamp: %d\\nData: %s\\nPrevious Hash: %x\\nHash: %x\\n\", b.Timestamp, b.Data, b.PreviousHash, b.Hash)\n}\n\nfunc (bc *Blockchain) String() string {\n\tvar blocks string\n\tfor _, b := range bc.Blocks {\n\t\tblocks += b.String() + \"\\n\"\n\t}\n\treturn blocks\n}"}
{"sample": "package sysmon\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/shirou/gopsutil/cpu\"\n\t\"github.com/shirou/gopsutil/disk\"\n\t\"github.com/shirou/gopsutil/mem\"\n)\n\nfunc MonitorSystemMetrics() {\n\tfor {\n\t\tcpuPercent, err := cpu.Percent(time.Second, false)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error getting CPU usage:\", err)\n\t\t} else {\n\t\t\tlog.Println(\"CPU usage:\", cpuPercent)\n\t\t}\n\n\t\tvirtualMem, err := mem.VirtualMemory()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error getting memory usage:\", err)\n\t\t} else {\n\t\t\tlog.Println(\"Memory usage:\", virtualMem.UsedPercent)\n\t\t}\n\n\t\tpartitions, err := disk.Partitions(false)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error getting disk partitions:\", err)\n\t\t}\n\n\t\tfor _, partition := range partitions {\n\t\t\tdiskUsage, err := disk.Usage(partition.Mountpoint)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Error getting disk usage:\", err)\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"Disk usage for %s: %f%%\\n\", partition.Mountpoint, diskUsage.UsedPercent)\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(time.Minute)\n\t}\n}"}
{"sample": "package gziputil\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\n// Compress takes a filename, reads its contents, compresses them, and returns the resulting gzip file contents as a []byte.\nfunc Compress(filename string) ([]byte, error) {\n\tcontents, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf bytes.Buffer\n\tzw := gzip.NewWriter(&buf)\n\tdefer zw.Close()\n\n\tif _, err := zw.Write(contents); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buf.Bytes(), nil\n}\n\n// Decompress takes a gzip file name, reads its contents and decompresses them, and returns the resulting file contents as a []byte.\nfunc Decompress(gzipfile string) ([]byte, error) {\n\tfd, err := os.Open(gzipfile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer fd.Close()\n\n\tzr, err := gzip.NewReader(fd)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tvar buf bytes.Buffer\n\tif _, err := io.Copy(&buf, zr); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := zr.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buf.Bytes(), nil\n}"}
{"sample": "package dockercli\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/docker/pkg/stdcopy\"\n\t\"github.com/spf13/cobra\"\n)\n\nfunc runContainer(cmd *cobra.Command, args []string) {\n\tctx := context.Background()\n\n\tcli, err := client.NewEnvClient()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error connecting to Docker daemon: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tconfig := &container.Config{\n\t\tImage:        \"alpine:latest\",\n\t\tTty:          true,\n\t\tAttachStdin:  false,\n\t\tAttachStdout: true,\n\t\tAttachStderr: true,\n\t\tCmd:          []string{\"echo\", \"Hello World!\"},\n\t}\n\n\tresp, err := cli.ContainerCreate(ctx, config, nil, nil, \"\")\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error creating container: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{}); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error starting container: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tstatusCh, errCh := cli.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)\n\tgo func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Error waiting for container: %v\\n\", err)\n\t\t\t}\n\t\tcase <-statusCh:\n\t\t}\n\t}()\n\n\tout, err := cli.ContainerLogs(ctx, resp.ID, types.ContainerLogsOptions{ShowStdout: true, ShowStderr: true, Follow: true})\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error getting container logs: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tgo func() {\n\t\tsigCh := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigCh, syscall.SIGTERM, syscall.SIGINT)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-sigCh:\n\t\t\t\tif err := cli.ContainerStop(ctx, resp.ID, nil); err != nil {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"Error stopping container: %v\\n\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tif _, err := stdcopy.StdCopy(os.Stdout, os.Stderr, out); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error copying container logs: %v\\n\", err)\n\t}\n\ttime.Sleep(5 * time.Second)\n}"}
{"sample": "package httpclient\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tBaseUrl string\n\tClient  http.Client\n}\n\nfunc New(baseUrl string) *Client {\n\treturn &Client{\n\t\tBaseUrl: baseUrl,\n\t\tClient:  http.Client{},\n\t}\n}\n\nfunc (c *Client) DoGet(endpoint string) ([]byte, error) {\n\turl := fmt.Sprintf(\"%s%s\", c.BaseUrl, endpoint)\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, err := c.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n\nfunc (c *Client) DoPost(endpoint string, data interface{}) ([]byte, error) {\n\turl := fmt.Sprintf(\"%s%s\", c.BaseUrl, endpoint)\n\n\tjsonBody, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, _ := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonBody))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tres, err := c.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"}
{"sample": "package radxtree\n\ntype RadixTree struct {\n\troot *node\n}\n\ntype node struct {\n\tkey      string\n\tvalue    interface{}\n\tchildren []*node\n}\n\nfunc NewRadixTree() *RadixTree {\n\treturn &RadixTree{root: &node{}}\n}\n\nfunc (t *RadixTree) Insert(key string, value interface{}) {\n\tcurrent := t.root\n\tfor {\n\t\tif len(key) == 0 {\n\t\t\tcurrent.value = value\n\t\t\treturn\n\t\t}\n\n\t\tvar next *node\n\t\tfor _, child := range current.children {\n\t\t\tif child.key[0] == key[0] {\n\t\t\t\tnext = child\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif next == nil {\n\t\t\tnext = &node{key: key, value: value}\n\t\t\tcurrent.children = append(current.children, next)\n\t\t\treturn\n\t\t}\n\n\t\tcommonPrefix := longestCommonPrefix(key, next.key)\n\t\tif commonPrefix == len(next.key) {\n\t\t\tkey = key[commonPrefix:]\n\t\t\tcurrent = next\n\t\t\tcontinue\n\t\t}\n\n\t\tif commonPrefix == 0 {\n\t\t\tnewNode := &node{key: key, value: value}\n\t\t\tnewNode.children = append(newNode.children, next)\n\t\t\tcurrent.children = append(current.children, newNode)\n\t\t\treturn\n\t\t}\n\n\t\tnewNode := &node{key: next.key[0:commonPrefix]}\n\t\tnewNode.children = append(newNode.children, next)\n\t\tnext.key = next.key[commonPrefix:]\n\t\tcurrent.children = append(current.children, newNode)\n\n\t\tkey = key[commonPrefix:]\n\t\tcurrent = newNode\n\t}\n}\n\nfunc (t *RadixTree) Search(key string) interface{} {\n\tcurrent := t.root\n\tfor {\n\t\tif len(key) == 0 {\n\t\t\treturn current.value\n\t\t}\n\n\t\tvar next *node\n\t\tfor _, child := range current.children {\n\t\t\tif child.key[0] == key[0] {\n\t\t\t\tnext = child\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif next == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tcommonPrefix := longestCommonPrefix(key, next.key)\n\t\tif commonPrefix != len(next.key) {\n\t\t\treturn nil\n\t\t}\n\n\t\tkey = key[commonPrefix:]\n\t\tcurrent = next\n\t}\n}\n\nfunc longestCommonPrefix(a, b string) int {\n\ti := 0\n\tfor ; i < len(a) && i < len(b); i++ {\n\t\tif a[i] != b[i] {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn i\n}"}
{"sample": "package rabbitmqimpl\n\nimport (\n\t\"log\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype RabbitMQ struct {\n\tconn *amqp.Connection\n\tch   *amqp.Channel\n\tq    amqp.Queue\n}\n\nfunc NewRabbitMQ(url, queueName string) (*RabbitMQ, error) {\n\tconn, err := amqp.Dial(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq, err := ch.QueueDeclare(\n\t\tqueueName, // name\n\t\tfalse,     // durable\n\t\tfalse,     // delete when unused\n\t\tfalse,     // exclusive\n\t\tfalse,     // no-wait\n\t\tnil,       // arguments\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &RabbitMQ{\n\t\tconn: conn,\n\t\tch:   ch,\n\t\tq:    q,\n\t}, nil\n}\n\nfunc (r *RabbitMQ) Publish(message []byte) error {\n\terr := r.ch.Publish(\n\t\t\"\",         // exchange\n\t\tr.q.Name,   // routing key\n\t\tfalse,      // mandatory\n\t\tfalse,      // immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        message,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (r *RabbitMQ) Consume() (<-chan amqp.Delivery, error) {\n\tmsgs, err := r.ch.Consume(\n\t\tr.q.Name, // queue\n\t\t\"\",       // consumer\n\t\ttrue,     // auto-ack\n\t\tfalse,    // exclusive\n\t\tfalse,    // no-local\n\t\tfalse,    // no-wait\n\t\tnil,      // args\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn msgs, nil\n}\n\nfunc (r *RabbitMQ) Close() error {\n\tif err := r.ch.Close(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := r.conn.Close(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc ExampleUsage() {\n\tr, err := NewRabbitMQ(\"amqp://guest:guest@localhost:5672/\", \"my_queue\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = r.Publish([]byte(\"Hello World!\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tmsgs, err := r.Consume()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor msg := range msgs {\n\t\tlog.Printf(\"Received message: %s\", msg.Body)\n\t}\n\n\terr = r.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package primegen\n\nfunc GeneratePrimes(n int) []int {\n\tif n < 2 {\n\t\treturn nil\n\t}\n\n\tprimes := []int{2}\n\tfor i := 3; i <= n; i += 2 {\n\t\tisPrime := true\n\t\tfor _, prime := range primes {\n\t\t\tif prime*prime > i {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif i%prime == 0 {\n\t\t\t\tisPrime = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif isPrime {\n\t\t\tprimes = append(primes, i)\n\t\t}\n\t}\n\n\treturn primes\n}"}
{"sample": "package http2push\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"golang.org/x/net/http2\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif pusher, ok := w.(http.Pusher); ok {\n\t\t\tif err := pusher.Push(\"/style.css\", nil); err != nil {\n\t\t\t\tlog.Printf(\"Failed to push: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\tfmt.Fprintf(w, `\n\t\t\t<!DOCTYPE html>\n\t\t\t<html>\n\t\t\t\t<head>\n\t\t\t\t\t<title>HTTP/2 Server Push Example</title>\n\t\t\t\t\t<link rel=\"stylesheet\" href=\"/style.css\">\n\t\t\t\t</head>\n\t\t\t\t<body>\n\t\t\t\t\t<h1>HTTP/2 Server Push Example</h1>\n\t\t\t\t\t<p>Welcome to the world of HTTP/2 server push!</p>\n\t\t\t\t</body>\n\t\t\t</html>\n\t\t`)\n\t})\n\n\thttp.HandleFunc(\"/style.css\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprint(w, `\n\t\t\tbody {\n\t\t\t\tbackground-color: #f2f2f2;\n\t\t\t}\n\n\t\t\th1 {\n\t\t\t\tcolor: #333;\n\t\t\t\tfont-size: 2.5em;\n\t\t\t\ttext-align: center;\n\t\t\t}\n\n\t\t\tp {\n\t\t\t\tcolor: #666;\n\t\t\t\tfont-size: 1.2em;\n\t\t\t\ttext-align: center;\n\t\t\t}\n\t\t`)\n\t})\n\n\thttp2Server := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: http.DefaultServeMux,\n\t}\n\n\thttp2.ConfigureServer(http2Server, nil)\n\n\tlog.Fatal(http2Server.ListenAndServeTLS(\"server.crt\", \"server.key\"))\n}"}
{"sample": "package gamesockets\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\n// Connection is a middleman between the websocket connection and the hub.\ntype Connection struct {\n\thub  *Hub\n\tconn *websocket.Conn\n\tsend chan []byte\n}\n\n// readPump pumps messages from the websocket connection to the hub.\nfunc (c *Connection) readPump() {\n\tdefer func() {\n\t\tc.hub.unregister <- c\n\t\tc.conn.Close()\n\t}()\n\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tmessage = bytes.TrimSpace(bytes.Replace(message, newline, space, -1))\n\t\tc.hub.broadcast <- message\n\t}\n}\n\n// writePump pumps messages from the hub to the websocket connection.\nfunc (c *Connection) writePump() {\n\tticker := time.NewTicker(pingPeriod)\n\tdefer func() {\n\t\tticker.Stop()\n\t\tc.conn.Close()\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase message, ok := <-c.send:\n\t\t\tif !ok {\n\t\t\t\tc.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw, err := c.conn.NextWriter(websocket.TextMessage)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tw.Write(message)\n\n\t\t\t// Add queued chat messages to the current websocket message.\n\t\t\tn := len(c.send)\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\tw.Write(newline)\n\t\t\t\tw.Write(<-c.send)\n\t\t\t}\n\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-ticker.C:\n\t\t\tif err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// serveWs handles websocket requests from the peer.\nfunc serveWs(hub *Hub, w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tclient := &Connection{hub: hub, conn: conn, send: make(chan []byte, 256)}\n\tclient.hub.register <- client\n\n\tgo client.writePump()\n\tgo client.readPump()\n}"}
{"sample": "package kubeclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/tools/clientcmd\"\n)\n\nfunc getClient() (*kubernetes.Clientset, error) {\n\tvar config *rest.Config\n\tvar err error\n\n\tif os.Getenv(\"KUBERNETES_SERVICE_HOST\") != \"\" && os.Getenv(\"KUBERNETES_SERVICE_PORT\") != \"\" {\n\t\tconfig, err = rest.InClusterConfig()\n\t} else {\n\t\tkubeconfig := os.Getenv(\"KUBECONFIG\")\n\t\tconfig, err = clientcmd.BuildConfigFromFlags(\"\", kubeconfig)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclientset, err := kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn clientset, nil\n}\n\nfunc getPods(namespace string) error {\n\tclientset, err := getClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpods, err := clientset.CoreV1().Pods(namespace).List(context.Background(), metav1.ListOptions{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"There are %d pods in the cluster\\n\", len(pods.Items))\n\n\treturn nil\n}"}
{"sample": "package mongocrud\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\ntype Person struct {\n\tName string\n\tAge  int\n\tCity string\n}\n\nfunc CreatePerson(client *mongo.Client, person Person) error {\n\tcollection := client.Database(\"testdb\").Collection(\"people\")\n\n\t_, err := collection.InsertOne(context.TODO(), person)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc GetPerson(client *mongo.Client, name string) (Person, error) {\n\tvar person Person\n\n\tcollection := client.Database(\"testdb\").Collection(\"people\")\n\n\tfilter := bson.M{\"name\": name}\n\n\terr := collection.FindOne(context.Background(), filter).Decode(&person)\n\tif err != nil {\n\t\treturn Person{}, err\n\t}\n\n\treturn person, nil\n}\n\nfunc UpdatePerson(client *mongo.Client, name string, person Person) error {\n\tcollection := client.Database(\"testdb\").Collection(\"people\")\n\n\tfilter := bson.M{\"name\": name}\n\n\tupdate := bson.M{\n\t\t\"$set\": bson.M{\n\t\t\t\"age\":  person.Age,\n\t\t\t\"city\": person.City,\n\t\t},\n\t}\n\n\t_, err := collection.UpdateOne(context.Background(), filter, update)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc DeletePerson(client *mongo.Client, name string) error {\n\tcollection := client.Database(\"testdb\").Collection(\"people\")\n\n\tfilter := bson.M{\"name\": name}\n\n\t_, err := collection.DeleteOne(context.Background(), filter)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tclientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n\n\tclient, err := mongo.Connect(context.Background(), clientOptions)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = client.Ping(context.Background(), nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tperson := Person{\n\t\tName: \"John Doe\",\n\t\tAge:  30,\n\t\tCity: \"New York\",\n\t}\n\n\terr = CreatePerson(client, person)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tperson, err = GetPerson(client, \"John Doe\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(person)\n\n\tperson.Age = 31\n\tperson.City = \"Los Angeles\"\n\n\terr = UpdatePerson(client, \"John Doe\", person)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = DeletePerson(client, \"John Doe\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package ssestream\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Message struct {\n\tID        int       `json:\"id\"`\n\tTimestamp time.Time `json:\"timestamp\"`\n\tText      string    `json:\"text\"`\n}\n\nfunc streamHandler(w http.ResponseWriter, r *http.Request) {\n\tflusher, ok := w.(http.Flusher)\n\tif !ok {\n\t\thttp.Error(w, \"Streaming unsupported\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n\tw.Header().Set(\"Cache-Control\", \"no-cache\")\n\tw.Header().Set(\"Connection\", \"keep-alive\")\n\n\tenc := json.NewEncoder(w)\n\n\tfor i := 0; ; i++ {\n\t\tmsg := Message{\n\t\t\tID:        i,\n\t\t\tTimestamp: time.Now(),\n\t\t\tText:      fmt.Sprintf(\"Message %d\", i),\n\t\t}\n\n\t\tif err := enc.Encode(msg); err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tflusher.Flush()\n\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n\nfunc StartServer() {\n\thttp.HandleFunc(\"/stream\", streamHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package bigcsv\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n)\n\nfunc processCSV(filename string) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\n\t// Set the number of expected fields\n\treader.FieldsPerRecord = 3\n\n\t// Read the header row\n\theader, err := reader.Read()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create a channel to receive the rows\n\trowChan := make(chan []string)\n\n\t// Create a wait group to wait for all the workers to finish\n\tvar wg sync.WaitGroup\n\n\t// Start 10 workers to process the rows concurrently\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor row := range rowChan {\n\t\t\t\t// Process the row\n\t\t\t\tfmt.Println(row)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Read the rows and send them to the workers\n\tfor {\n\t\trow, err := reader.Read()\n\t\tif err != nil {\n\t\t\tif err.Error() == \"EOF\" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\trowChan <- row\n\t}\n\n\t// Close the channel to signal the workers to finish\n\tclose(rowChan)\n\n\t// Wait for all the workers to finish\n\twg.Wait()\n\n\treturn nil\n}"}
{"sample": "package githubapi\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/google/go-github/v35/github\"\n\t\"golang.org/x/oauth2\"\n)\n\nfunc GetLatestRelease(owner, repo string) (*github.RepositoryRelease, error) {\n\tctx := context.Background()\n\n\tts := oauth2.StaticTokenSource(\n\t\t&oauth2.Token{AccessToken: \"YOUR_ACCESS_TOKEN\"},\n\t)\n\ttc := oauth2.NewClient(ctx, ts)\n\n\tclient := github.NewClient(tc)\n\n\trelease, _, err := client.Repositories.GetLatestRelease(ctx, owner, repo)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get latest release: %v\", err)\n\t}\n\n\treturn release, nil\n}\n\nfunc ListIssues(owner, repo string) ([]*github.Issue, error) {\n\tctx := context.Background()\n\n\tts := oauth2.StaticTokenSource(\n\t\t&oauth2.Token{AccessToken: \"YOUR_ACCESS_TOKEN\"},\n\t)\n\ttc := oauth2.NewClient(ctx, ts)\n\n\tclient := github.NewClient(tc)\n\n\topt := &github.IssueListByRepoOptions{\n\t\tState: \"all\",\n\t}\n\n\tissues, _, err := client.Issues.ListByRepo(ctx, owner, repo, opt)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list issues: %v\", err)\n\t}\n\n\treturn issues, nil\n}"}
{"sample": "package jwtlib\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\n// JWTManager is a struct that holds the JWT secret key and the token duration.\ntype JWTManager struct {\n\tSecretKey    string\n\tTokenDuration time.Duration\n}\n\n// GenerateToken generates a new JWT token with the given claims.\nfunc (manager *JWTManager) GenerateToken(claims jwt.MapClaims) (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString([]byte(manager.SecretKey))\n}\n\n// VerifyToken verifies the given JWT token and returns the claims if the token is valid.\nfunc (manager *JWTManager) VerifyToken(tokenString string) (jwt.MapClaims, error) {\n\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t// Check if the signing method is HMAC\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, errors.New(\"invalid signing method\")\n\t\t}\n\n\t\treturn []byte(manager.SecretKey), nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the token is valid\n\tif !token.Valid {\n\t\treturn nil, errors.New(\"invalid token\")\n\t}\n\n\tclaims, ok := token.Claims.(jwt.MapClaims)\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid claims\")\n\t}\n\n\treturn claims, nil\n}"}
{"sample": "package md2html\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/gomarkdown/markdown\"\n)\n\nfunc Convert(filepath string) (string, error) {\n\tfile, err := ioutil.ReadFile(filepath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read file: %v\", err)\n\t}\n\n\thtml := markdown.ToHTML(file, nil, nil)\n\n\tvar buffer bytes.Buffer\n\tbuffer.Write(html)\n\n\treturn buffer.String(), nil\n}"}
{"sample": "package bcryptHash\n\nimport (\n\t\"fmt\"\n\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\nfunc HashPassword(password string) (string, error) {\n\thash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error hashing password: %w\", err)\n\t}\n\n\treturn string(hash), nil\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}"}
{"sample": "package ratelimiter\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/juju/ratelimit\"\n)\n\nfunc RateLimitMiddleware(next http.Handler) http.Handler {\n\tbucket := ratelimit.NewBucketWithQuantum(time.Second, 10, 1)\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif bucket.Available() < 1 {\n\t\t\tw.WriteHeader(http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}"}
{"sample": "package bookapi\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n\t\"models\"\n)\n\ntype BookAPI struct {\n\trouter *mux.Router\n}\n\nfunc NewBookAPI() *BookAPI {\n\treturn &BookAPI{\n\t\trouter: mux.NewRouter(),\n\t}\n}\n\nfunc (b *BookAPI) Start() {\n\tb.router.HandleFunc(\"/books\", b.getAllBooks).Methods(\"GET\")\n\tb.router.HandleFunc(\"/books/{id}\", b.getBook).Methods(\"GET\")\n\tb.router.HandleFunc(\"/books\", b.createBook).Methods(\"POST\")\n\tb.router.HandleFunc(\"/books/{id}\", b.updateBook).Methods(\"PUT\")\n\tb.router.HandleFunc(\"/books/{id}\", b.deleteBook).Methods(\"DELETE\")\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", b.router))\n}\n\nfunc (b *BookAPI) getAllBooks(w http.ResponseWriter, r *http.Request) {\n\tbooks, err := models.GetAllBooks()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(books)\n}\n\nfunc (b *BookAPI) getBook(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tbook, err := models.GetBook(id)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(book)\n}\n\nfunc (b *BookAPI) createBook(w http.ResponseWriter, r *http.Request) {\n\tvar book models.Book\n\tif err := json.NewDecoder(r.Body).Decode(&book); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif err := book.Create(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(book)\n}\n\nfunc (b *BookAPI) updateBook(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar book models.Book\n\tif err := json.NewDecoder(r.Body).Decode(&book); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif err := book.Update(id); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(book)\n}\n\nfunc (b *BookAPI) deleteBook(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif err := models.DeleteBook(id); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n}"}
{"sample": "package rsaencdec\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\ntype RSA struct {\n\tprivateKey *rsa.PrivateKey\n\tpublicKey  *rsa.PublicKey\n}\n\nfunc GenerateKey(keySize int) (*RSA, error) {\n\tprivateKey, err := rsa.GenerateKey(rand.Reader, keySize)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &RSA{\n\t\tprivateKey: privateKey,\n\t\tpublicKey:  &privateKey.PublicKey,\n\t}, nil\n}\n\nfunc (r *RSA) ExtractPrivateKey(filename string) error {\n\tprivKeyBytes, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tblock, _ := pem.Decode(privKeyBytes)\n\tif block == nil {\n\t\treturn errors.New(\"failed to decode PEM block containing private key\")\n\t}\n\n\tprivKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tr.privateKey = privKey\n\tr.publicKey = &privKey.PublicKey\n\n\treturn nil\n}\n\nfunc (r *RSA) Encrypt(msg []byte) ([]byte, error) {\n\treturn rsa.EncryptPKCS1v15(rand.Reader, r.publicKey, msg)\n}\n\nfunc (r *RSA) Decrypt(cipherText []byte) ([]byte, error) {\n\treturn rsa.DecryptPKCS1v15(rand.Reader, r.privateKey, cipherText)\n}\n\nfunc (r *RSA) SavePrivateKey(filename string) error {\n\tprivKeyBytes := x509.MarshalPKCS1PrivateKey(r.privateKey)\n\tblock := &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: privKeyBytes,\n\t}\n\n\terr := ioutil.WriteFile(filename, pem.EncodeToMemory(block), 0600)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn nil\n}\n"}
{"sample": "package twitterbot\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/dghubble/go-twitter/twitter\"\n\t\"github.com/dghubble/oauth1\"\n)\n\nfunc replyToMentions() error {\n\tconfig := oauth1.NewConfig(os.Getenv(\"TWITTER_CONSUMER_KEY\"), os.Getenv(\"TWITTER_CONSUMER_SECRET\"))\n\ttoken := oauth1.NewToken(os.Getenv(\"TWITTER_ACCESS_TOKEN\"), os.Getenv(\"TWITTER_ACCESS_SECRET\"))\n\thttpClient := config.Client(oauth1.NoContext, token)\n\n\tclient := twitter.NewClient(httpClient)\n\n\tmentionsTimelineParams := &twitter.MentionTimelineParams{\n\t\tCount: 10,\n\t}\n\n\tmentions, _, err := client.Timelines.MentionTimeline(mentionsTimelineParams)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, mention := range mentions {\n\t\tif !mention.InReplyToUserID.Valid {\n\t\t\tcontinue\n\t\t}\n\t\ttweet := fmt.Sprintf(\"@%v Thanks for the mention! \ud83d\ude0a\", mention.User.ScreenName)\n\t\treplyParams := &twitter.StatusUpdateParams{\n\t\t\tInReplyToStatusID: mention.ID,\n\t\t\tStatus:           tweet,\n\t\t}\n\t\t_, _, err = client.Statuses.Update(tweet, replyParams)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tlog.Printf(\"Replied to mention from %v\\n\", mention.User.ScreenName)\n\t}\n\treturn nil\n}"}
{"sample": "package hotreloadserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, world!\")\n\t})\n\n\tgo func() {\n\t\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdefer watcher.Close()\n\n\tdone := make(chan bool)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase event, ok := <-watcher.Events:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif event.Op&fsnotify.Write == fsnotify.Write {\n\t\t\t\t\tlog.Println(\"modified file:\", event.Name)\n\t\t\t\t\tdone <- true\n\t\t\t\t}\n\t\t\tcase err, ok := <-watcher.Errors:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Println(\"error:\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\terr = watcher.Add(\".\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t<-done\n\n\tlog.Println(\"reloading...\")\n\ttime.Sleep(2 * time.Second)\n\tlog.Println(\"reloaded\")\n}"}
{"sample": "package workerpool\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype Job struct {\n\tID        int\n\tTask      func() error\n\tRetries   int\n\tCompleted bool\n}\n\nfunc NewJob(id int, task func() error, retries int) *Job {\n\treturn &Job{\n\t\tID:        id,\n\t\tTask:      task,\n\t\tRetries:   retries,\n\t\tCompleted: false,\n\t}\n}\n\ntype WorkerPool struct {\n\tworkers   []*Worker\n\tjobQueue  chan *Job\n\twaitGroup sync.WaitGroup\n}\n\nfunc NewWorkerPool(numWorkers int, jobQueueSize int) *WorkerPool {\n\tworkers := make([]*Worker, numWorkers)\n\tfor i := 0; i < numWorkers; i++ {\n\t\tworkers[i] = NewWorker(i)\n\t}\n\n\treturn &WorkerPool{\n\t\tworkers:   workers,\n\t\tjobQueue:  make(chan *Job, jobQueueSize),\n\t\twaitGroup: sync.WaitGroup{},\n\t}\n}\n\nfunc (wp *WorkerPool) Start() {\n\tfor _, worker := range wp.workers {\n\t\twp.waitGroup.Add(1)\n\t\tgo worker.start(wp.jobQueue, &wp.waitGroup)\n\t}\n}\n\nfunc (wp *WorkerPool) Stop() {\n\tclose(wp.jobQueue)\n\twp.waitGroup.Wait()\n}\n\nfunc (wp *WorkerPool) AddJob(job *Job) {\n\twp.jobQueue <- job\n}\n\ntype Worker struct {\n\tID int\n}\n\nfunc NewWorker(id int) *Worker {\n\treturn &Worker{\n\t\tID: id,\n\t}\n}\n\nfunc (w *Worker) start(jobQueue chan *Job, waitGroup *sync.WaitGroup) {\n\tfor job := range jobQueue {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", w.ID, job.ID)\n\n\t\terr := job.Task()\n\t\tif err != nil && job.Retries > 0 {\n\t\t\tjob.Retries--\n\t\t\tjobQueue <- job\n\t\t} else {\n\t\t\tjob.Completed = true\n\t\t}\n\n\t\tfmt.Printf(\"Worker %d completed job %d\\n\", w.ID, job.ID)\n\t}\n\n\twaitGroup.Done()\n}"}
{"sample": "package envhandler\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc GetString(key string, defaultValue string) string {\n\tval, ok := os.LookupEnv(key)\n\tif !ok {\n\t\treturn defaultValue\n\t}\n\n\treturn val\n}\n\nfunc GetInt(key string, defaultValue int) int {\n\tval, ok := os.LookupEnv(key)\n\tif !ok {\n\t\treturn defaultValue\n\t}\n\n\ti, err := strconv.Atoi(val)\n\tif err != nil {\n\t\tfmt.Printf(\"Warning: Environment variable '%s' not an integer. Using default value.\\n\", key)\n\t\treturn defaultValue\n\t}\n\n\treturn i\n}\n\nfunc GetBool(key string, defaultValue bool) bool {\n\tval, ok := os.LookupEnv(key)\n\tif !ok {\n\t\treturn defaultValue\n\t}\n\n\tb, err := strconv.ParseBool(val)\n\tif err != nil {\n\t\tfmt.Printf(\"Warning: Environment variable '%s' not a boolean. Using default value.\\n\", key)\n\t\treturn defaultValue\n\t}\n\n\treturn b\n}"}
{"sample": "package wsmanage\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nfunc handleWebSocket(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\t// Register the new connection\n\tclient := NewClient(conn)\n\tclients[client] = true\n\n\t// Listen for messages\n\tgo client.Listen()\n\n\t// Send a welcome message\n\tclient.Send([]byte(\"Welcome to the WebSocket server!\"))\n\n\t// Close the connection when the function returns\n\tdefer func() {\n\t\tclient.Close()\n\t\tdelete(clients, client)\n\t}()\n\n\t// Keep the function running indefinitely\n\tselect {}\n}\n\n// Client represents a WebSocket client connection\ntype Client struct {\n\tconn *websocket.Conn\n}\n\n// NewClient creates a new WebSocket client\nfunc NewClient(conn *websocket.Conn) *Client {\n\treturn &Client{\n\t\tconn: conn,\n\t}\n}\n\n// Listen listens for incoming messages from the client\nfunc (c *Client) Listen() {\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\t// Handle the message\n\t\thandleMessage(c, message)\n\t}\n}\n\n// Send sends a message to the client\nfunc (c *Client) Send(message []byte) {\n\terr := c.conn.WriteMessage(websocket.TextMessage, message)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n\n// Close closes the WebSocket connection\nfunc (c *Client) Close() {\n\terr := c.conn.Close()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n\n// handleMessage handles incoming messages from the client\nfunc handleMessage(c *Client, message []byte) {\n\t// Handle the message\n}"}
{"sample": "package textproc\n\nimport (\n\t\"bufio\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc ProcessFile(fname string) error {\n\tfile, err := os.Open(fname)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\n\t\t// Process the line here\n\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn nil\n}"}
{"sample": "package http2fileserver\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\thttp.ServeFile(w, r, r.URL.Path[1:])\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\n\tconfig := &tls.Config{NextProtos: []string{\"h2\"}}\n\tserver := &http.Server{\n\t\tAddr:      \":8080\",\n\t\tTLSConfig: config,\n\t}\n\n\thttp2Enabled := false // set to true if HTTP/2 is enabled\n\n\tif http2Enabled {\n\t\terr := server.ListenAndServeTLS(\"server.crt\", \"server.key\")\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"ListenAndServeTLS: %s\", err)\n\t\t}\n\t} else {\n\t\thttp2Server := &http2.Server{}\n\t\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.Proto == \"HTTP/2.0\" {\n\t\t\t\thttp2Server.ServeHTTP(w, r)\n\t\t\t} else {\n\t\t\t\thandler(w, r)\n\t\t\t}\n\t\t})\n\t\tfmt.Printf(\"Serving files over HTTP/2 on port %s...\\n\", server.Addr)\n\t\terr := server.ListenAndServeTLS(\"server.crt\", \"server.key\")\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"ListenAndServeTLS: %s\", err)\n\t\t}\n\t}\n}"}
{"sample": "package httpreq\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Request struct {\n\tMethod  string\n\tURL     string\n\tHeaders map[string]string\n\tBody    []byte\n}\n\nfunc Do(req Request) ([]byte, error) {\n\tclient := http.Client{}\n\n\tbody := bytes.NewBuffer(req.Body)\n\n\thttpReq, err := http.NewRequest(req.Method, req.URL, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor key, value := range req.Headers {\n\t\thttpReq.Header.Set(key, value)\n\t}\n\n\tresp, err := client.Do(httpReq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn respBody, nil\n}"}
{"sample": "package pdfgen\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os/exec\"\n\t\"text/template\"\n)\n\ntype Data struct {\n\tName string\n\tAge  int\n}\n\nfunc GeneratePDF(data Data) error {\n\thtmlTemplate, err := template.ParseFiles(\"template.html\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tvar tpl bytes.Buffer\n\tif err := htmlTemplate.Execute(&tpl, data); err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\thtmlBytes := tpl.Bytes()\n\n\tif err := ioutil.WriteFile(\"output.html\", htmlBytes, 0644); err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tcmd := exec.Command(\"wkhtmltopdf\", \"output.html\", \"output.pdf\")\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tfmt.Println(\"PDF generated successfully\")\n\treturn nil\n}"}
{"sample": "package gcsapi\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\n\t\"cloud.google.com/go/storage\"\n)\n\ntype GCSClient struct {\n\tclient *storage.Client\n}\n\nfunc NewClient(ctx context.Context, projectID string) (*GCSClient, error) {\n\tclient, err := storage.NewClient(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create client: %v\", err)\n\t}\n\treturn &GCSClient{client: client}, nil\n}\n\nfunc (c *GCSClient) ReadObject(bucket, object string, w io.Writer) error {\n\trc, err := c.client.Bucket(bucket).Object(object).NewReader(context.Background())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create reader: %v\", err)\n\t}\n\tdefer rc.Close()\n\n\tif _, err := io.Copy(w, rc); err != nil {\n\t\treturn fmt.Errorf(\"failed to copy object contents: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *GCSClient) WriteObject(bucket, object string, r io.Reader) error {\n\twc := c.client.Bucket(bucket).Object(object).NewWriter(context.Background())\n\tif _, err := io.Copy(wc, r); err != nil {\n\t\treturn fmt.Errorf(\"failed to write object contents: %v\", err)\n\t}\n\tif err := wc.Close(); err != nil {\n\t\treturn fmt.Errorf(\"failed to close object writer: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *GCSClient) DeleteObject(bucket, object string) error {\n\tif err := c.client.Bucket(bucket).Object(object).Delete(context.Background()); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete object: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *GCSClient) ListObjects(bucket string) ([]string, error) {\n\tvar objects []string\n\tit := c.client.Bucket(bucket).Objects(context.Background(), nil)\n\tfor {\n\t\tobj, err := it.Next()\n\t\tif err == storage.ErrIteratorDone {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to iterate objects: %v\", err)\n\t\t}\n\t\tobjects = append(objects, obj.Name)\n\t}\n\treturn objects, nil\n}\n\nfunc (c *GCSClient) Close() error {\n\tif err := c.client.Close(); err != nil {\n\t\tlog.Printf(\"failed to close client: %v\", err)\n\t}\n\treturn nil\n}"}
{"sample": "package mqttclient\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\n\tmqtt \"github.com/eclipse/paho.mqtt.golang\"\n)\n\nfunc main() {\n\tch := make(chan os.Signal, 1)\n\tsignal.Notify(ch, os.Interrupt)\n\n\topts := mqtt.NewClientOptions()\n\topts.AddBroker(\"tcp://broker.hivemq.com:1883\")\n\topts.SetClientID(\"go-mqtt-client\")\n\n\tc := mqtt.NewClient(opts)\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tpanic(token.Error())\n\t}\n\tdefer c.Disconnect(250)\n\n\tsubscribe(c)\n\tpublish(c)\n\n\t<-ch\n\tfmt.Println(\"Exiting\")\n}\n\nfunc subscribe(c mqtt.Client) {\n\thandler := func(client mqtt.Client, msg mqtt.Message) {\n\t\tfmt.Printf(\"Received Message: %s from Topic: %s\\n\", msg.Payload(), msg.Topic())\n\t}\n\n\ttoken := c.Subscribe(\"example/topic\", 0, handler)\n\ttoken.Wait()\n\tlog.Printf(\"Subscribed to topic: %s\\n\", \"example/topic\")\n}\n\nfunc publish(c mqtt.Client) {\n\ttoken := c.Publish(\"example/topic\", 0, false, \"Hello World\")\n\ttoken.Wait()\n\tlog.Println(\"Message published\")\n}"}
{"sample": "package excelparse\n\nimport (\n\t\"fmt\"\n\t\"github.com/360EntSecGroup-Skylar/excelize/v2\"\n)\n\n// ReadExcelFile reads an excel file and returns the data in a map\nfunc ReadExcelFile(filePath string) (map[string]string, error) {\n\tf, err := excelize.OpenFile(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := make(map[string]string)\n\n\trows, err := f.GetRows(\"Sheet1\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, row := range rows {\n\t\tkey := row[0]\n\t\tvalue := row[1]\n\t\tdata[key] = value\n\t}\n\n\treturn data, nil\n}\n\n// WriteExcelFile writes data to an excel file\nfunc WriteExcelFile(filePath string, data map[string]string) error {\n\tf := excelize.NewFile()\n\n\tfor key, value := range data {\n\t\tf.SetCellValue(\"Sheet1\", fmt.Sprintf(\"A%d\", len(data)+1), key)\n\t\tf.SetCellValue(\"Sheet1\", fmt.Sprintf(\"B%d\", len(data)+1), value)\n\t}\n\n\tif err := f.SaveAs(filePath); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ManipulateExcelFile does some manipulation on an excel file\nfunc ManipulateExcelFile(filePath string) error {\n\tf, err := excelize.OpenFile(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Manipulate the file here\n\n\tif err := f.Save(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package unixsock\n\nimport (\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype UnixSocket struct {\n\tPath string\n}\n\nfunc (us *UnixSocket) ListenAndServe() error {\n\tif err := os.RemoveAll(us.Path); err != nil {\n\t\treturn err\n\t}\n\n\tl, err := net.Listen(\"unix\", us.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer l.Close()\n\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\t// Handle incoming connection\n}\n\nfunc NewUnixSocket(path string) (*UnixSocket, error) {\n\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &UnixSocket{Path: path}, nil\n}"}
{"sample": "package grpcclient\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/protos\"\n)\n\nfunc CreateOrUpdateUser(user *pb.User) error {\n\tconn, err := grpc.Dial(\"remote-server:9000\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewUsersServiceClient(conn)\n\tctx := context.Background()\n\n\tresp, err := client.CreateOrUpdateUser(ctx, &pb.CreateOrUpdateUserRequest{User: user})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not create or update user: %v\", err)\n\t}\n\tlog.Printf(\"CreateOrUpdateUser Response: %v\", resp)\n\treturn nil\n}\n\nfunc GetUser(userId int) (*pb.User, error) {\n\tconn, err := grpc.Dial(\"remote-server:9000\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewUsersServiceClient(conn)\n\tctx := context.Background()\n\n\tresp, err := client.GetUser(ctx, &pb.GetUserRequest{Id: int32(userId)})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not get user: %v\", err)\n\t}\n\tlog.Printf(\"GetUser Response: %v\", resp)\n\treturn resp.User, nil\n}"}
{"sample": "package rssreader\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Item struct {\n\tXMLName     xml.Name `xml:\"item\"`\n\tTitle       string   `xml:\"title\"`\n\tDescription string   `xml:\"description\"`\n\tLink        string   `xml:\"link\"`\n}\n\ntype Channel struct {\n\tXMLName     xml.Name `xml:\"channel\"`\n\tTitle       string   `xml:\"title\"`\n\tDescription string   `xml:\"description\"`\n\tLink        string   `xml:\"link\"`\n\tItems       []Item   `xml:\"item\"`\n}\n\ntype Rss struct {\n\tXMLName xml.Name `xml:\"rss\"`\n\tChannel Channel  `xml:\"channel\"`\n}\n\nfunc ParseRSS(url string) (*Rss, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\trss := &Rss{}\n\terr = xml.NewDecoder(resp.Body).Decode(rss)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn rss, nil\n}\n\nfunc DisplayRSS(rss *Rss) {\n\tfmt.Printf(\"Title: %s\\n\", rss.Channel.Title)\n\tfmt.Printf(\"Description: %s\\n\", rss.Channel.Description)\n\tfmt.Printf(\"Link: %s\\n\", rss.Channel.Link)\n\tfmt.Println(\"Items:\")\n\tfor _, item := range rss.Channel.Items {\n\t\tfmt.Printf(\"\\tTitle: %s\\n\", item.Title)\n\t\tfmt.Printf(\"\\tDescription: %s\\n\", item.Description)\n\t\tfmt.Printf(\"\\tLink: %s\\n\", item.Link)\n\t\tfmt.Println()\n\t}\n}"}
{"sample": "package formdata\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc processForm(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tname := r.FormValue(\"name\")\n\temail := r.FormValue(\"email\")\n\tmessage := r.FormValue(\"message\")\n\n\tfile, _, err := r.FormFile(\"attachment\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// save file to disk\n\tf, err := os.Create(\"attachments/\" + file.Filename)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer f.Close()\n\tif _, err := file.Seek(0, 0); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif _, err := io.Copy(f, file); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// store form data in database\n\terr = storeFormData(name, email, message, file.Filename)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"Form data processed successfully\")\n}\n\nfunc storeFormData(name, email, message, attachment string) error {\n\t// store data in database\n\treturn nil\n}"}
{"sample": "package httpmiddleware\n\nimport (\n\t\"net/http\"\n)\n\nfunc AuthMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if user is authenticated\n\t\tif !isAuthenticated(r) {\n\t\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\t// Call the next handler\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc RateLimitMiddleware(next http.Handler, limit int) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if user has exceeded the rate limit\n\t\tif !hasExceededRateLimit(r, limit) {\n\t\t\thttp.Error(w, \"Rate limit exceeded\", http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\n\t\t// Call the next handler\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc LoggingMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Log the request\n\t\tlogRequest(r)\n\n\t\t// Call the next handler\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// Helper functions\nfunc isAuthenticated(r *http.Request) bool {\n\t// Check if user is authenticated\n\treturn true\n}\n\nfunc hasExceededRateLimit(r *http.Request, limit int) bool {\n\t// Check if user has exceeded the rate limit\n\treturn false\n}\n\nfunc logRequest(r *http.Request) {\n\t// Log the request\n}"}
{"sample": "package sitemapfetch\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype UrlSet struct {\n\tUrls []Url `xml:\"url\"`\n}\n\ntype Url struct {\n\tLoc string `xml:\"loc\"`\n}\n\nfunc FetchSitemap(url string) ([]string, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tvar set UrlSet\n\tif err := xml.NewDecoder(resp.Body).Decode(&set); err != nil {\n\t\treturn nil, err\n\t}\n\n\turls := []string{}\n\tfor _, s := range set.Urls {\n\t\turls = append(urls, strings.TrimSpace(s.Loc))\n\t}\n\n\treturn urls, nil\n}\n\nfunc main() {\n\turls, err := FetchSitemap(\"https://example.com/sitemap.xml\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfor _, url := range urls {\n\t\tfmt.Println(url)\n\t}\n}"}
{"sample": "package s3cli\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/s3\"\n)\n\nvar (\n\tbucket string\n\tkey    string\n)\n\nfunc init() {\n\tflag.StringVar(&bucket, \"bucket\", \"\", \"S3 bucket name\")\n\tflag.StringVar(&key, \"key\", \"\", \"S3 object key\")\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tif bucket == \"\" || key == \"\" {\n\t\tfmt.Println(\"Bucket name and key are required\")\n\t\tos.Exit(1)\n\t}\n\n\tsess, err := session.NewSession(&aws.Config{\n\t\tRegion: aws.String(\"us-west-2\")},\n\t)\n\n\tsvc := s3.New(sess)\n\n\tparams := &s3.GetObjectInput{\n\t\tBucket: aws.String(bucket),\n\t\tKey:    aws.String(key),\n\t}\n\n\tresp, err := svc.GetObject(params)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\tos.Exit(1)\n\t}\n\n\tdefer resp.Body.Close()\n\n\tfileParts := strings.Split(key, \"/\")\n\tfileName := fileParts[len(fileParts)-1]\n\n\tfile, err := os.Create(fileName)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\tos.Exit(1)\n\t}\n\n\tdefer file.Close()\n\n\tif _, err := file.ReadFrom(resp.Body); err != nil {\n\t\tfmt.Println(err.Error())\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Downloaded file %v from bucket %v\\n\", fileName, bucket)\n}"}
{"sample": "package ldapauth\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/go-ldap/ldap/v3\"\n)\n\ntype LDAPAuth struct {\n\tURL      string\n\tBaseDN   string\n\tBindDN   string\n\tBindPass string\n}\n\nfunc (la *LDAPAuth) Authenticate(username, password string) error {\n\tl, err := ldap.DialURL(la.URL)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error connecting to LDAP server: %v\", err)\n\t}\n\tdefer l.Close()\n\n\tif err := l.Bind(la.BindDN, la.BindPass); err != nil {\n\t\treturn fmt.Errorf(\"error binding to LDAP server: %v\", err)\n\t}\n\n\tsearchRequest := ldap.NewSearchRequest(\n\t\tla.BaseDN,\n\t\tldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,\n\t\tfmt.Sprintf(\"(&(objectClass=person)(uid=%s))\", username),\n\t\t[]string{\"dn\"},\n\t\tnil,\n\t)\n\n\tsr, err := l.Search(searchRequest)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error searching LDAP server: %v\", err)\n\t}\n\n\tif len(sr.Entries) != 1 {\n\t\treturn fmt.Errorf(\"user not found or too many entries returned\")\n\t}\n\n\tuserDN := sr.Entries[0].DN\n\n\tif err := l.Bind(userDN, password); err != nil {\n\t\treturn fmt.Errorf(\"invalid credentials: %v\", err)\n\t}\n\n\tlog.Printf(\"User %s authenticated successfully\", username)\n\n\treturn nil\n}"}
{"sample": "package loadbalancer\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype LoadBalancer struct {\n\tmu       sync.Mutex\n\tservers  []*http.Server\n\tnext     int\n\tmaxTries int\n}\n\nfunc NewLoadBalancer(servers []*http.Server, maxTries int) *LoadBalancer {\n\treturn &LoadBalancer{\n\t\tservers:  servers,\n\t\tmaxTries: maxTries,\n\t}\n}\n\nfunc (lb *LoadBalancer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tlb.mu.Lock()\n\tdefer lb.mu.Unlock()\n\n\tfor i := 0; i < lb.maxTries; i++ {\n\t\tserver := lb.servers[lb.next]\n\t\tlb.next = (lb.next + 1) % len(lb.servers)\n\t\tif server == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tresp, err := http.Get(fmt.Sprintf(\"http://%s%s\", server.Addr, r.URL.Path))\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tfor k, v := range resp.Header {\n\t\t\tw.Header().Set(k, v[0])\n\t\t}\n\n\t\tw.WriteHeader(resp.StatusCode)\n\t\tresp.Write(w)\n\n\t\treturn\n\t}\n\n\thttp.Error(w, \"No available servers\", http.StatusServiceUnavailable)\n}\n\nfunc (lb *LoadBalancer) RandomServer() *http.Server {\n\treturn lb.servers[rand.Intn(len(lb.servers))]\n}"}
{"sample": "package protobuff\n\nimport (\n\t\"github.com/golang/protobuf/proto\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\n// Serialize serializes a given message to bytes using Protocol Buffers\nfunc Serialize(m proto.Message) ([]byte, error) {\n\treturn proto.Marshal(m)\n}\n\n// Deserialize deserializes bytes to a given message using Protocol Buffers\nfunc Deserialize(b []byte, m proto.Message) error {\n\terr := proto.Unmarshal(b, m)\n\tif err != nil {\n\t\tlog.Println(\"error deserializing message:\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// WriteToFile writes the serialized bytes of a given message to a file\nfunc WriteToFile(m proto.Message, filepath string) error {\n\tb, err := Serialize(m)\n\tif err != nil {\n\t\tlog.Println(\"error serializing message:\", err)\n\t\treturn err\n\t}\n\terr = ioutil.WriteFile(filepath, b, 0644)\n\tif err != nil {\n\t\tlog.Println(\"error writing to file:\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// ReadFromFile reads a Protocol Buffers message from a file and deserializes it\nfunc ReadFromFile(filepath string, m proto.Message) error {\n\tb, err := ioutil.ReadFile(filepath)\n\tif err != nil {\n\t\tlog.Println(\"error reading file:\", err)\n\t\treturn err\n\t}\n\terr = Deserialize(b, m)\n\tif err != nil {\n\t\tlog.Println(\"error deserializing message:\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"sample": "package namedpipe\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n// Create creates a named pipe with the given name.\nfunc Create(name string) error {\n\terr := syscall.Mkfifo(name, 0666)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not create named pipe: %v\", err)\n\t}\n\treturn nil\n}\n\n// Open opens a named pipe with the given name for reading.\nfunc Open(name string) (*os.File, error) {\n\tfifo, err := os.OpenFile(name, os.O_RDONLY, os.ModeNamedPipe)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not open named pipe: %v\", err)\n\t}\n\treturn fifo, nil\n}\n\n// Write writes data to a named pipe with the given name for writing.\nfunc Write(name string, data []byte) error {\n\tfifo, err := os.OpenFile(name, os.O_WRONLY, os.ModeNamedPipe)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not write to named pipe: %v\", err)\n\t}\n\tdefer fifo.Close()\n\n\t_, err = fifo.Write(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not write to named pipe: %v\", err)\n\t}\n\treturn nil\n}"}
{"sample": "package flaghandler\n\nimport (\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype flagOptions struct {\n\tverbose bool\n\tinput   string\n}\n\nfunc parseFlags() (*flagOptions, error) {\n\toptions := &flagOptions{}\n\n\tflag.BoolVar(&options.verbose, \"v\", false, \"Verbose output\")\n\tflag.StringVar(&options.input, \"i\", \"\", \"Input file\")\n\tflag.Parse()\n\n\tif options.input == \"\" {\n\t\treturn nil, errors.New(\"Input file not provided\")\n\t}\n\n\treturn options, nil\n}\n\nfunc Run() error {\n\toptions, err := parseFlags()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif options.verbose {\n\t\tfmt.Println(\"Verbose output enabled\")\n\t}\n\n\tfmt.Printf(\"Processing input file: %v\\n\", options.input)\n\n\treturn nil\n}\n\nfunc Usage() {\n\tfmt.Fprintf(os.Stderr, \"Usage of %s:\\n\", os.Args[0])\n\tflag.PrintDefaults()\n}"}
{"sample": "package sqlitehandle\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\ntype Database struct {\n\tPath string\n\tconn *sql.DB\n}\n\nfunc OpenDatabase(path string) (*Database, error) {\n\tdb, err := sql.Open(\"sqlite3\", path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdatabase := &Database{Path: path, conn: db}\n\treturn database, nil\n}\n\nfunc (d *Database) CloseDatabase() error {\n\treturn d.conn.Close()\n}\n\nfunc (d *Database) CreateTable(name string, fields map[string]string) error {\n\tfieldList := \"\"\n\tfor k, v := range fields {\n\t\tfieldList += fmt.Sprintf(\"%s %s,\", k, v)\n\t}\n\n\tcreateStmt := fmt.Sprintf(\"CREATE TABLE IF NOT EXISTS %s (%s)\", name, fieldList[:len(fieldList)-1])\n\n\t_, err := d.conn.Exec(createStmt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (d *Database) InsertRecord(table string, values map[string]interface{}) (int64, error) {\n\tfieldList := \"\"\n\tplaceholderList := \"\"\n\tvalueArgs := []interface{}{}\n\n\tfor k, v := range values {\n\t\tfieldList += fmt.Sprintf(\"%s,\", k)\n\t\tplaceholderList += fmt.Sprintf(\"?,\")\n\t\tvalueArgs = append(valueArgs, v)\n\t}\n\n\tinsertStmt := fmt.Sprintf(\"INSERT INTO %s (%s) VALUES (%s)\", table, fieldList[:len(fieldList)-1], placeholderList[:len(placeholderList)-1])\n\n\tresult, err := d.conn.Exec(insertStmt, valueArgs...)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\trowID, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\treturn rowID, nil\n}\n\nfunc (d *Database) Query(queryStmt string) (*sql.Rows, error) {\n\trows, err := d.conn.Query(queryStmt)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\treturn rows, nil\n}"}
{"sample": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\n\t\"github.com/nats-io/nats.go\"\n)\n\nfunc main() {\n\tnc, err := nats.Connect(nats.DefaultURL)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to NATS: %v\", err)\n\t}\n\tdefer nc.Close()\n\n\tec, _ := nats.NewEncodedConn(nc, nats.JSON_ENCODER)\n\n\t_, err = ec.Subscribe(\"chat.new\", func(msg *Message) {\n\n\t\t// TODO: Save the chat message to database\n\n\t\terr = ec.Publish(\"chat.recv\", msg)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to publish to chat.recv: %v\", err)\n\t\t}\n\t})\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to subscribe to chat.new: %v\", err)\n\t}\n\n\tsigint := make(chan os.Signal, 1)\n\tsignal.Notify(sigint, os.Interrupt)\n\t<-sigint\n\n\tlog.Print(\"NATS chat service stopping\")\n}\n\ntype Message struct {\n\tUserID  string `json:\"userId\"`\n\tRoomID  string `json:\"roomId\"`\n\tMessage string `json:\"message\"`\n}"}
{"sample": "package esclient\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/elastic/go-elasticsearch/v8\"\n\t\"github.com/elastic/go-elasticsearch/v8/esapi\"\n)\n\ntype EsClient struct {\n\tClient *elasticsearch.Client\n}\n\nfunc (c *EsClient) Search(index, query string) ([]byte, error) {\n\treq := esapi.SearchRequest{\n\t\tIndex: []string{index},\n\t\tBody:  strings.NewReader(query),\n\t}\n\n\tres, err := req.Do(context.Background(), c.Client)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\n\tif res.IsError() {\n\t\treturn nil, fmt.Errorf(\"failed to search documents: %s\", res.String())\n\t}\n\n\tvar b bytes.Buffer\n\tif _, err := b.ReadFrom(res.Body); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b.Bytes(), nil\n}\n\nfunc (c *EsClient) Index(index string, doc interface{}, id string) error {\n\tvar buf bytes.Buffer\n\tif err := json.NewEncoder(&buf).Encode(doc); err != nil {\n\t\treturn err\n\t}\n\n\treq := esapi.IndexRequest{\n\t\tIndex:      index,\n\t\tDocumentID: id,\n\t\tBody:       &buf,\n\t\tRefresh:    \"true\",\n\t}\n\n\tres, err := req.Do(context.Background(), c.Client)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer res.Body.Close()\n\n\tif res.IsError() {\n\t\treturn fmt.Errorf(\"failed to index document: %s\", res.String())\n\t}\n\n\treturn nil\n}\n\nfunc NewEsClient(address string) (*EsClient, error) {\n\tcfg := elasticsearch.Config{\n\t\tAddresses: []string{address},\n\t\tTransport: &http.Transport{\n\t\t\tMaxIdleConnsPerHost:   10,\n\t\t\tResponseHeaderTimeout: time.Second,\n\t\t\tDialContext:           (&net.Dialer{Timeout: time.Second}).DialContext,\n\t\t\tTLSHandshakeTimeout:   time.Second,\n\t\t\tExpectContinueTimeout: time.Second,\n\t\t},\n\t}\n\n\tclient, err := elasticsearch.NewClient(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &EsClient{client}, nil\n}"}
{"sample": "package redislock\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\ntype RedisLock struct {\n\tredisClient *redis.Client\n\tkey         string\n\tvalue       string\n\texpiration  time.Duration\n}\n\nfunc New(redisClient *redis.Client, key string, value string, expiration time.Duration) *RedisLock {\n\treturn &RedisLock{\n\t\tredisClient: redisClient,\n\t\tkey:         key,\n\t\tvalue:       value,\n\t\texpiration:  expiration,\n\t}\n}\n\nfunc (lock *RedisLock) Acquire() (bool, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\tok, err := lock.redisClient.SetNX(ctx, lock.key, lock.value, lock.expiration).Result()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif !ok {\n\t\treturn false, errors.New(\"lock already acquired\")\n\t}\n\n\treturn true, nil\n}\n\nfunc (lock *RedisLock) Release() error {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\t_, err := lock.redisClient.Del(ctx, lock.key).Result()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package xpathparser\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"github.com/antchfx/htmlquery\"\n)\n\nfunc extractData() error {\n\turl := \"https://example.com\"\n\tres, err := http.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\thtml, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdoc, err := htmlquery.Parse(bytes.NewReader(html))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnodes, err := htmlquery.QueryAll(doc, \"//div[contains(@class, 'article')]\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, node := range nodes {\n\t\ttitleNode := htmlquery.FindOne(node, \"//h2\")\n\t\ttitle := htmlquery.InnerText(titleNode)\n\t\tfmt.Println(title)\n\n\t\tcontentNode := htmlquery.FindOne(node, \"//div[contains(@class, 'content')]\")\n\t\tcontent := htmlquery.InnerText(contentNode)\n\t\tfmt.Println(content)\n\t}\n\n\treturn nil\n}"}
{"sample": "package httpmonitor\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc monitorTraffic(h http.Handler) http.Handler {\n\tfn := func(w http.ResponseWriter, r *http.Request) {\n\t\tstartTime := time.Now()\n\n\t\tlw := &loggingResponseWriter{ResponseWriter: w}\n\t\th.ServeHTTP(lw, r)\n\n\t\tlog.Printf(\"%s %s %v %s\\n\", r.Method, r.URL.Path, lw.statusCode, time.Since(startTime))\n\t}\n\n\treturn http.HandlerFunc(fn)\n}\n\ntype loggingResponseWriter struct {\n\thttp.ResponseWriter\n\tstatusCode int\n}\n\nfunc (lrw *loggingResponseWriter) WriteHeader(code int) {\n\tlrw.statusCode = code\n\tlrw.ResponseWriter.WriteHeader(code)\n}\n\nfunc startMonitoring() {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello World!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", monitorTraffic(mux))\n}"}
{"sample": "package cronscheduler\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/robfig/cron/v3\"\n)\n\nfunc printTime() {\n\tfmt.Println(time.Now().UTC().String())\n}\n\ntype job struct {\n\tname string\n}\n\nfunc (j job) Run() {\n\tfmt.Printf(\"[%s]: triggering job...\\n\", j.name)\n\tprintTime()\n}\n\nfunc StartScheduler() {\n\tscheduler := cron.New()\n\n\t_, err := scheduler.AddFunc(\"0 30 7-21/3 * * *\", job{name: \"scheduled job\"}.Run)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tscheduler.Start()\n\n\tfmt.Println(\"Scheduler started. Jobs will be executed according to cron syntax.\")\n\ttime.Sleep(2 * time.Minute)\n\tscheduler.Stop()\n\tfmt.Println(\"Scheduler stopped.\")\n}\n\nfunc ScheduleTask(jobName string, cronInterval string) (cron.EntryID, error) {\n\tscheduler := cron.New()\n\n\tentryID, err := scheduler.AddFunc(cronInterval, job{name: jobName}.Run)\n\tif err != nil {\n\t\tscheduler.Stop()\n\t\treturn 0, err\n\t}\n\n\tscheduler.Start()\n\n\tfmt.Println(\"Scheduled job\", jobName, \"will be executed according to cron syntax\", cronInterval)\n\n\ti, err := strconv.Atoi(entryID.String())\n\tif err != nil {\n\t\tscheduler.Stop()\n\t\treturn 0, err\n\t}\n\n\treturn cron.EntryID(i), nil\n}\n\nfunc CancelScheduledTask(entryID cron.EntryID) error {\n\ts, err := scheduler.Entry(entryID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"Job\", s.Job.(job).name, \"with ID\", int64(s.ID), \"cancelled.\")\n\tscheduler.Remove(entryID)\n\n\treturn nil\n}"}
{"sample": "package ccvalidator\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype CreditCard struct {\n\tNumber string\n}\n\nfunc (c *CreditCard) IsValid() bool {\n\treturn len(c.Number) >= 12 && len(c.Number) <= 19\n}\n\nfunc (c *CreditCard) Format() string {\n\treturn fmt.Sprintf(\"**** **** **** %s\", c.Number[len(c.Number)-4:])\n}\n\nfunc (c *CreditCard) GetIssuer() (string, error) {\n\tif len(c.Number) < 13 || len(c.Number) > 19 {\n\t\treturn \"\", errors.New(\"Invalid credit card number\")\n\t}\n\n\tif c.Number[0] == '4' {\n\t\treturn \"Visa\", nil\n\t} else if c.Number[0:2] == \"34\" || c.Number[0:2] == \"37\" {\n\t\treturn \"American Express\", nil\n\t} else if c.Number[0:2] >= \"51\" && c.Number[0:2] <= \"55\" {\n\t\treturn \"Mastercard\", nil\n\t} else if c.Number[0:4] == \"6011\" || (c.Number[0:3] >= \"644\" && c.Number[0:3] <= \"649\") || c.Number[0:2] == \"65\" {\n\t\treturn \"Discover\", nil\n\t} else {\n\t\treturn \"\", errors.New(\"Issuer not found\")\n\t}\n}"}
{"sample": "package securegen\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"math/big\"\n)\n\nfunc GenerateRandomString(length int) (string, error) {\n\tbytes := make([]byte, length)\n\tif _, err := rand.Read(bytes); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.URLEncoding.EncodeToString(bytes), nil\n}\n\nfunc GenerateRandomNumber(min, max int64) (int64, error) {\n\tif min >= max {\n\t\treturn 0, ErrInvalidRange\n\t}\n\tdiff := big.NewInt(max - min)\n\tn, err := rand.Int(rand.Reader, diff)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn n.Int64() + min, nil\n}"}
{"sample": "package pushnotify\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/go-redis/redis\"\n\t\"github.com/nats-io/nats.go\"\n)\n\ntype PushService struct {\n\tnatsConn *nats.Conn\n\tredisCli *redis.Client\n}\n\nfunc NewPushService(natsURL string, redisURL string) (*PushService, error) {\n\tnatsConn, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\treturn nil, errors.New(\"failed to connect to nats\")\n\t}\n\n\tredisCli := redis.NewClient(&redis.Options{\n\t\tAddr: redisURL,\n\t})\n\n\tif _, err := redisCli.Ping().Result(); err != nil {\n\t\treturn nil, errors.New(\"failed to connect to redis\")\n\t}\n\n\treturn &PushService{\n\t\tnatsConn: natsConn,\n\t\tredisCli: redisCli,\n\t}, nil\n}\n\nfunc (ps *PushService) Send(notification Notification) error {\n\terr := ps.natsConn.Publish(notification.Topic(), notification)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to publish message to nats: %v\", err)\n\t}\n\n\tif err := ps.redisCli.Set(notification.Id(), notification.Content, 0).Err(); err != nil {\n\t\tlog.Printf(\"failed to save notification to redis: %v\\n\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (ps *PushService) Close() {\n\tps.natsConn.Close()\n\tps.redisCli.Close()\n\tlog.Println(\"push service closed\")\n}"}
{"sample": "package pathmanip\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\t// Get the current working directory\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Join two paths together\n\tpath1 := filepath.Join(cwd, \"folder1\")\n\tpath2 := filepath.Join(cwd, \"folder2\")\n\tfmt.Println(\"Joined path:\", filepath.Join(path1, path2))\n\n\t// Get the base name of a file path\n\tfilePath := filepath.Join(cwd, \"folder1\", \"file.txt\")\n\tfmt.Println(\"Base name:\", filepath.Base(filePath))\n\n\t// Get the directory name of a file path\n\tdirPath := filepath.Dir(filePath)\n\tfmt.Println(\"Directory name:\", dirPath)\n\n\t// Check if a path exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\tfmt.Println(\"File does not exist\")\n\t} else {\n\t\tfmt.Println(\"File exists\")\n\t}\n\n\t// Create a new directory\n\tnewDir := filepath.Join(cwd, \"new_folder\")\n\tif err := os.Mkdir(newDir, 0755); err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(\"New directory created:\", newDir)\n\n\t// Remove a directory\n\tif err := os.RemoveAll(newDir); err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(\"Directory removed:\", newDir)\n}"}
{"sample": "package batchproc\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/sqs\"\n)\n\ntype Job struct {\n\tID       int\n\tPayload  string\n\tPriority int\n}\n\nfunc processJob(job *Job) error {\n\t// Process the job\n\treturn nil\n}\n\nfunc processBatch(jobs []*Job) {\n\tvar wg sync.WaitGroup\n\n\tfor _, job := range jobs {\n\t\twg.Add(1)\n\n\t\tgo func(job *Job) {\n\t\t\tdefer wg.Done()\n\n\t\t\tif err := processJob(job); err != nil {\n\t\t\t\tlog.Printf(\"Error processing job %d: %v\", job.ID, err)\n\t\t\t}\n\t\t}(job)\n\t}\n\n\twg.Wait()\n}\n\nfunc main() {\n\tsess, err := session.NewSession(&aws.Config{\n\t\tRegion: aws.String(\"us-west-2\")},\n\t)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error creating AWS session: %v\", err)\n\t}\n\n\tsqsSvc := sqs.New(sess)\n\n\tqueueURL := \"https://sqs.us-west-2.amazonaws.com/123456789012/my-queue\"\n\n\tfor {\n\t\tresult, err := sqsSvc.ReceiveMessage(&sqs.ReceiveMessageInput{\n\t\t\tQueueUrl:            aws.String(queueURL),\n\t\t\tMaxNumberOfMessages: aws.Int64(10),\n\t\t\tVisibilityTimeout:   aws.Int64(30),\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error receiving message from SQS: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.Messages) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar jobs []*Job\n\n\t\tfor _, msg := range result.Messages {\n\t\t\tvar job Job\n\n\t\t\tif err := json.Unmarshal([]byte(*msg.Body), &job); err != nil {\n\t\t\t\tlog.Printf(\"Error unmarshalling message body: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tjobs = append(jobs, &job)\n\t\t}\n\n\t\tprocessBatch(jobs)\n\n\t\tfor _, msg := range result.Messages {\n\t\t\t_, err := sqsSvc.DeleteMessage(&sqs.DeleteMessageInput{\n\t\t\t\tQueueUrl:      aws.String(queueURL),\n\t\t\t\tReceiptHandle: msg.ReceiptHandle,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error deleting message from SQS: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "package datetimeparse\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\nconst (\n\tlayoutISO        = \"2006-01-02\"\n\tlayoutUSA        = \"January 2, 2006\"\n\tlayoutDateTime   = \"2006-01-02 15:04:05\"\n\tlayoutDateUSATime = \"January 2, 2006 15:04:05 MST\"\n)\n\n// ParseISODate returns a time.Time object from an ISO 8601 formatted date string\nfunc ParseISODate(date string) (time.Time, error) {\n\treturn time.Parse(layoutISO, date)\n}\n\n// FormatISODate returns an ISO 8601 formatted string from a time.Time object\nfunc FormatISODate(t time.Time) string {\n\treturn t.Format(layoutISO)\n}\n\n// ParseUSADate returns a time.Time object from a USA formatted date string\nfunc ParseUSADate(date string) (time.Time, error) {\n\treturn time.Parse(layoutUSA, date)\n}\n\n// FormatUSADate returns a USA formatted string from a time.Time object\nfunc FormatUSADate(t time.Time) string {\n\treturn t.Format(layoutUSA)\n}\n\n// ParseDateTime returns a time.Time object from a date/time string in \"YYYY-MM-DD HH:MM:SS\" format\nfunc ParseDateTime(dateTime string) (time.Time, error) {\n\treturn time.Parse(layoutDateTime, dateTime)\n}\n\n// FormatDateTime returns a date/time string in \"YYYY-MM-DD HH:MM:SS\" format from a time.Time object\nfunc FormatDateTime(t time.Time) string {\n\treturn t.Format(layoutDateTime)\n}\n\n// ParseDateUSATime returns a time.Time object from a USA formatted date/time string with timezone\nfunc ParseDateUSATime(dateTime string) (time.Time, error) {\n\tloc, err := time.LoadLocation(\"America/New_York\")\n\tif err != nil {\n\t\treturn time.Time{}, errors.New(\"failed to load timezone location\")\n\t}\n\treturn time.ParseInLocation(layoutDateUSATime, dateTime, loc)\n}\n\n// FormatDateUSATime returns a USA formatted date/time string with timezone from a time.Time object\nfunc FormatDateUSATime(t time.Time) string {\n\treturn t.Format(layoutDateUSATime)\n}"}
{"sample": "package concurhttp\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nfunc makeConcurrentRequests(urls []string) ([]string, error) {\n\tvar wg sync.WaitGroup\n\tvar mutex sync.Mutex\n\tvar results []string\n\terrors := make(chan error, len(urls))\n\n\tfor _, url := range urls {\n\t\twg.Add(1)\n\t\tgo func(url string) {\n\t\t\tdefer wg.Done()\n\n\t\t\tresp, err := http.Get(url)\n\t\t\tif err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\terrors <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tmutex.Lock()\n\t\t\tresults = append(results, string(body))\n\t\t\tmutex.Unlock()\n\t\t}(url)\n\t}\n\n\twg.Wait()\n\n\tselect {\n\tcase err := <-errors:\n\t\treturn nil, err\n\tdefault:\n\t\treturn results, nil\n\t}\n}\n\nfunc main() {\n\turls := []string{\"https://www.google.com\", \"https://www.facebook.com\", \"https://www.twitter.com\"}\n\tresults, err := makeConcurrentRequests(urls)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(results)\n}"}
{"sample": "package imagemeta\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/rwcarlsen/goexif/exif\"\n)\n\nfunc getExifMetadata(filename string) (map[string]interface{}, error) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\tx, err := exif.Decode(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := map[string]interface{}{}\n\tif len(x) == 0 {\n\t\treturn result, fmt.Errorf(\"no exif data\")\n\t}\n\n\tcammodel, err := x.Get(exif.Model)\n\tif err == nil {\n\t\tresult[\"Model\"] = cammodel.String()\n\t}\n\n\texptime, err := x.Get(exif.ExposureTime) \n\tif err == nil {\n\t\tresult[\"ExposureTime\"] = exptime.String() \n\t}\n\n   //... Extract additional metadata fields as needed\n\n\treturn result, nil\n}"}
{"sample": "package cookiemanage\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/securecookie\"\n)\n\ntype CookieManager struct {\n\thashKey  []byte\n\tblockKey []byte\n\tsc       *securecookie.SecureCookie\n}\n\nfunc NewCookieManager(hashKey, blockKey []byte) *CookieManager {\n\treturn &CookieManager{\n\t\thashKey:  hashKey,\n\t\tblockKey: blockKey,\n\t\tsc:       securecookie.New(hashKey, blockKey),\n\t}\n}\n\nfunc (cm *CookieManager) SetCookie(w http.ResponseWriter, name string, value interface{}, age time.Duration) error {\n\tif encoded, err := cm.sc.Encode(name, value); err == nil {\n\t\tcookie := &http.Cookie{\n\t\t\tName:     name,\n\t\t\tValue:    encoded,\n\t\t\tExpires:  time.Now().Add(age),\n\t\t\tHttpOnly: true,\n\t\t\tPath:     \"/\",\n\t\t\tSecure:   true,\n\t\t\tSameSite: http.SameSiteStrictMode,\n\t\t}\n\t\thttp.SetCookie(w, cookie)\n\t\treturn nil\n\t} else {\n\t\treturn err\n\t}\n}\n\nfunc (cm *CookieManager) GetCookie(r *http.Request, name string, value interface{}) error {\n\tif cookie, err := r.Cookie(name); err == nil {\n\t\tif err = cm.sc.Decode(name, cookie.Value, value); err == nil {\n\t\t\treturn nil\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\treturn err\n\t}\n}\n\nfunc (cm *CookieManager) ClearCookie(w http.ResponseWriter, name string) {\n\tcookie := &http.Cookie{\n\t\tName:     name,\n\t\tValue:    \"\",\n\t\tExpires:  time.Unix(0, 0),\n\t\tHttpOnly: true,\n\t\tPath:     \"/\",\n\t\tSecure:   true,\n\t\tSameSite: http.SameSiteStrictMode,\n\t}\n\thttp.SetCookie(w, cookie)\n}"}
{"sample": "package logsimple\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\nvar (\n\tInfoLogger  *log.Logger\n\tErrorLogger *log.Logger\n)\n\nfunc init() {\n\tinfoLogFile, err := os.OpenFile(\"info.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to open info log file:\", err)\n\t}\n\terrorLogFile, err := os.OpenFile(\"error.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to open error log file:\", err)\n\t}\n\n\tInfoLogger = log.New(infoLogFile, \"INFO: \", log.Ldate|log.Ltime|log.Lshortfile)\n\tErrorLogger = log.New(errorLogFile, \"ERROR: \", log.Ldate|log.Ltime|log.Lshortfile)\n}\n\nfunc LogInfo(message string) {\n\tInfoLogger.Println(message)\n}\n\nfunc LogError(message string) {\n\tErrorLogger.Println(message)\n}"}
{"sample": "package blogservice\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/grpc-ecosystem/go-grpc-middleware\"\n\t\"github.com/grpc-ecosystem/go-grpc-middleware/logging/zap\"\n\t\"github.com/grpc-ecosystem/go-grpc-middleware/recovery\"\n\t\"github.com/grpc-ecosystem/grpc-gateway/runtime\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc\"\n\n\t\"blogpb\"\n)\n\ntype server struct {\n}\n\nfunc (*server) CreateBlog(ctx context.Context, req *blogpb.CreateBlogRequest) (*blogpb.CreateBlogResponse, error) {\n\tfmt.Printf(\"Create Blog request received: %v\", req)\n\treturn &blogpb.CreateBlogResponse{\n\t\tBlog: &blogpb.Blog{\n\t\t\tId:       \"123\",\n\t\t\tAuthorId: req.GetBlog().GetAuthorId(),\n\t\t\tTitle:    req.GetBlog().GetTitle(),\n\t\t\tContent:  req.GetBlog().GetContent(),\n\t\t},\n\t}, nil\n}\n\nfunc main() {\n\tlogger, _ := zap.NewDevelopment()\n\tdefer logger.Sync()\n\n\tlis, err := net.Listen(\"tcp\", \"0.0.0.0:50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(\n\t\tgrpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(\n\t\t\tgrpc_zap.UnaryServerInterceptor(logger),\n\t\t\tgrpc_recovery.UnaryServerInterceptor(),\n\t\t)),\n\t)\n\n\tblogpb.RegisterBlogServiceServer(s, &server{})\n\n\tgo func() {\n\t\tlog.Println(\"Starting gRPC server...\")\n\t\tif err := s.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\tmux := runtime.NewServeMux()\n\topts := []grpc.DialOption{grpc.WithInsecure()}\n\tif err := blogpb.RegisterBlogServiceHandlerFromEndpoint(context.Background(), mux, \"localhost:50051\", opts); err != nil {\n\t\tlog.Fatalf(\"Failed to register gateway: %v\", err)\n\t}\n\n\tlog.Println(\"Starting gateway server...\")\n\tif err := http.ListenAndServe(\":8080\", mux); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package yaml2json\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\n\t\"gopkg.in/yaml.v2\"\n)\n\ntype Config struct {\n\tName    string `yaml:\"name\"`\n\tVersion string `yaml:\"version\"`\n}\n\nfunc main() {\n\tyamlFile, err := ioutil.ReadFile(\"config.yaml\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading YAML file: %v\", err)\n\t}\n\n\tvar config Config\n\terr = yaml.Unmarshal(yamlFile, &config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error unmarshaling YAML: %v\", err)\n\t}\n\n\tjsonData, err := json.Marshal(config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error marshaling JSON: %v\", err)\n\t}\n\n\tfmt.Println(string(jsonData))\n}"}
{"sample": "package bintree\n\ntype Node struct {\n\tValue int\n\tLeft  *Node\n\tRight *Node\n}\n\ntype BinaryTree struct {\n\tRoot *Node\n}\n\nfunc (bt *BinaryTree) Insert(value int) {\n\tif bt.Root == nil {\n\t\tbt.Root = &Node{Value: value}\n\t\treturn\n\t}\n\n\tcurrent := bt.Root\n\tfor {\n\t\tif value < current.Value {\n\t\t\tif current.Left == nil {\n\t\t\t\tcurrent.Left = &Node{Value: value}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent = current.Left\n\t\t} else {\n\t\t\tif current.Right == nil {\n\t\t\t\tcurrent.Right = &Node{Value: value}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent = current.Right\n\t\t}\n\t}\n}\n\nfunc (bt *BinaryTree) Search(value int) bool {\n\tcurrent := bt.Root\n\tfor current != nil {\n\t\tif value == current.Value {\n\t\t\treturn true\n\t\t}\n\n\t\tif value < current.Value {\n\t\t\tcurrent = current.Left\n\t\t} else {\n\t\t\tcurrent = current.Right\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (bt *BinaryTree) TraverseInOrder(node *Node, f func(int)) {\n\tif node != nil {\n\t\tbt.TraverseInOrder(node.Left, f)\n\t\tf(node.Value)\n\t\tbt.TraverseInOrder(node.Right, f)\n\t}\n}"}
{"sample": "package dhencdec\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"fmt\"\n)\n\nfunc GenerateKeyPair() (*rsa.PrivateKey, error) {\n\treturn rsa.GenerateKey(rand.Reader, 2048)\n}\n\nfunc EncryptMessage(message []byte, publicKey *rsa.PublicKey) ([]byte, error) {\n\treturn rsa.EncryptOAEP(\n\t\tsha256.New(),\n\t\trand.Reader,\n\t\tpublicKey,\n\t\tmessage,\n\t\tnil,\n\t)\n}\n\nfunc DecryptMessage(ciphertext []byte, privateKey *rsa.PrivateKey) ([]byte, error) {\n\treturn rsa.DecryptOAEP(\n\t\tsha256.New(),\n\t\trand.Reader,\n\t\tprivateKey,\n\t\tciphertext,\n\t\tnil,\n\t)\n}\n\nfunc Example() {\n\talicePrivateKey, err := GenerateKeyPair()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tbobPrivateKey, err := GenerateKeyPair()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\talicePublicKey := &alicePrivateKey.PublicKey\n\tbobPublicKey := &bobPrivateKey.PublicKey\n\n\tmessage := []byte(\"Hello, Bob!\")\n\n\t// Alice encrypts the message using Bob's public key\n\tciphertext, err := EncryptMessage(message, bobPublicKey)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Bob decrypts the message using his own private key\n\tplaintext, err := DecryptMessage(ciphertext, bobPrivateKey)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Plaintext: %s\\n\", plaintext)\n}"}
{"sample": "package couchdbclient\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Client struct {\n\tserverURL string\n}\n\nfunc NewClient(serverURL string) *Client {\n\treturn &Client{serverURL: serverURL}\n}\n\nfunc (c *Client) GetDatabaseInfo(dbName string) (map[string]interface{}, error) {\n\tresp, err := http.Get(c.serverURL + \"/\" + dbName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to get database info\")\n\t}\n\n\tvar result map[string]interface{}\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n\nfunc (c *Client) CreateDocument(dbName string, doc interface{}) (string, error) {\n\tdocBytes, err := json.Marshal(doc)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tresp, err := http.Post(c.serverURL+\"/\"+dbName, \"application/json\", bytes.NewReader(docBytes))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusCreated {\n\t\treturn \"\", errors.New(\"failed to create document\")\n\t}\n\n\tlocation := resp.Header.Get(\"Location\")\n\tparts := strings.Split(location, \"/\")\n\tdocID := parts[len(parts)-1]\n\n\treturn docID, nil\n}\n\nfunc (c *Client) GetDocument(dbName, docID string) (map[string]interface{}, error) {\n\tresp, err := http.Get(c.serverURL + \"/\" + dbName + \"/\" + docID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to get document\")\n\t}\n\n\tvar result map[string]interface{}\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n\nfunc (c *Client) DeleteDocument(dbName, docID, rev string) error {\n\treq, err := http.NewRequest(http.MethodDelete, c.serverURL+\"/\"+dbName+\"/\"+docID, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"If-Match\", rev)\n\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(\"failed to delete document\")\n\t}\n\n\treturn nil\n}\n\nfunc (c *Client) QueryView(dbName, designDoc, viewName string, params map[string]string) ([]map[string]interface{}, error) {\n\tquery := fmt.Sprintf(\"_design/%s/_view/%s\", designDoc, viewName)\n\tif len(params) > 0 {\n\t\tquery += \"?\"\n\t\tfor k, v := range params {\n\t\t\tquery += fmt.Sprintf(\"%s=%s&\", k, v)\n\t\t}\n\t\tquery = strings.TrimSuffix(query, \"&\")\n\t}\n\n\tresp, err := http.Get(c.serverURL + \"/\" + dbName + \"/\" + query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to query view\")\n\t}\n\n\tvar result struct {\n\t\tRows []struct {\n\t\t\tID    string                 `json:\"id\"`\n\t\t\tKey   interface{}            `json:\"key\"`\n\t\t\tValue map[string]interface{} `json:\"value\"`\n\t\t} `json:\"rows\"`\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar docs []map[string]interface{}\n\tfor _, row := range result.Rows {\n\t\tdoc := row.Value\n\t\tdoc[\"_id\"] = row.ID\n\t\tdoc[\"_rev\"] = \"\"\n\t\tdocs = append(docs, doc)\n\t}\n\n\treturn docs, nil\n}"}
{"sample": "package sha256hash\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc ComputeSHA256Hash(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := sha256.New()\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}"}
{"sample": "package zlibutil\n\nimport (\n\t\"bytes\"\n\t\"compress/zlib\"\n\t\"io/ioutil\"\n)\n\nfunc Compress(data []byte) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tw := zlib.NewWriter(&buf)\n\tif _, err := w.Write(data); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := w.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n\nfunc Decompress(data []byte) ([]byte, error) {\n\tr, err := zlib.NewReader(bytes.NewReader(data))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer r.Close()\n\treturn ioutil.ReadAll(r)\n}"}
{"sample": "package urlparse\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n)\n\nfunc validateURL(input string) (string, error) {\n\tu, err := url.Parse(input)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"invalid URL: %v\", err)\n\t}\n\n\tif u.Scheme != \"http\" && u.Scheme != \"https\" {\n\t\treturn \"\", fmt.Errorf(\"unsupported URL scheme: %v\", u.Scheme)\n\t}\n\n\treturn u.String(), nil\n}\n\nfunc parseURL(input string) (*url.URL, error) {\n\tu, err := url.Parse(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid URL: %v\", err)\n\t}\n\n\treturn u, nil\n}"}
{"sample": "package redditapi\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype RedditAPI struct {\n\tclient   *http.Client\n\tbaseURL  *url.URL\n\tUser     string\n\tPassword string\n}\n\ntype Post struct {\n\tTitle string `json:\"title\"`\n\tURL   string `json:\"url\"`\n}\n\ntype Subreddit struct {\n\tName  string `json:\"display_name\"`\n\tPosts []Post `json:\"posts\"`\n}\n\nfunc NewRedditAPI(user, password string) (*RedditAPI, error) {\n\tbaseURL, err := url.Parse(\"https://www.reddit.com/\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &RedditAPI{\n\t\tclient:   &http.Client{},\n\t\tbaseURL:  baseURL,\n\t\tUser:     user,\n\t\tPassword: password,\n\t}, nil\n}\n\nfunc (api *RedditAPI) GetSubreddit(name string) (*Subreddit, error) {\n\treq, err := http.NewRequest(\"GET\", api.baseURL.String()+\"/r/\"+name+\".json\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.SetBasicAuth(api.User, api.Password)\n\n\tresp, err := api.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(fmt.Sprintf(\"unexpected status code %d\", resp.StatusCode))\n\t}\n\n\tvar data struct {\n\t\tData struct {\n\t\t\tChildren []struct {\n\t\t\t\tData Post `json:\"data\"`\n\t\t\t} `json:\"children\"`\n\t\t} `json:\"data\"`\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(&data); err != nil {\n\t\treturn nil, err\n\t}\n\n\tsubreddit := &Subreddit{\n\t\tName: name,\n\t}\n\n\tfor _, child := range data.Data.Children {\n\t\tsubreddit.Posts = append(subreddit.Posts, child.Data)\n\t}\n\n\treturn subreddit, nil\n}"}
{"sample": "package uuidgen\n\nimport (\n\t\"fmt\"\n\t\"github.com/google/uuid\"\n)\n\nfunc GenerateUUID() string {\n\tuuid := uuid.New()\n\treturn fmt.Sprintf(\"%s\", uuid)\n}\n\nfunc GenerateUUIDs(n int) []string {\n\tuuids := make([]string, n)\n\tfor i := 0; i < n; i++ {\n\t\tuuids[i] = GenerateUUID()\n\t}\n\treturn uuids\n}"}
{"sample": "package sessions\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/sessions\"\n)\n\nvar (\n\t// ErrSessionNotFound is returned when a session is not found.\n\tErrSessionNotFound = errors.New(\"session not found\")\n)\n\n// SessionManager manages user sessions.\ntype SessionManager struct {\n\tstore     sessions.Store\n\tname      string\n\tmaxAge    int\n\tsecure    bool\n\thttpOnly  bool\n\tsameSite  http.SameSite\n}\n\n// NewSessionManager creates a new SessionManager.\nfunc NewSessionManager(store sessions.Store, name string, maxAge int, secure, httpOnly bool, sameSite http.SameSite) *SessionManager {\n\treturn &SessionManager{\n\t\tstore:     store,\n\t\tname:      name,\n\t\tmaxAge:    maxAge,\n\t\tsecure:    secure,\n\t\thttpOnly:  httpOnly,\n\t\tsameSite:  sameSite,\n\t}\n}\n\n// GetSession retrieves a session by its ID.\nfunc (sm *SessionManager) GetSession(r *http.Request, id string) (*sessions.Session, error) {\n\tsession, err := sm.store.Get(r, sm.name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif session.IsNew {\n\t\treturn nil, ErrSessionNotFound\n\t}\n\n\tif session.ID != id {\n\t\treturn nil, ErrSessionNotFound\n\t}\n\n\treturn session, nil\n}\n\n// CreateSession creates a new session for the given user ID.\nfunc (sm *SessionManager) CreateSession(w http.ResponseWriter, r *http.Request, id string) (*sessions.Session, error) {\n\tsession, err := sm.store.New(r, sm.name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.Values[\"id\"] = id\n\tsession.Options.MaxAge = sm.maxAge\n\tsession.Options.Secure = sm.secure\n\tsession.Options.HttpOnly = sm.httpOnly\n\tsession.Options.SameSite = sm.sameSite\n\n\tif err := session.Save(r, w); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session, nil\n}\n\n// DestroySession destroys the session with the given ID.\nfunc (sm *SessionManager) DestroySession(w http.ResponseWriter, r *http.Request, id string) error {\n\tsession, err := sm.GetSession(r, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsession.Options.MaxAge = -1\n\n\tif err := session.Save(r, w); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// RenewSession renews the session with the given ID.\nfunc (sm *SessionManager) RenewSession(w http.ResponseWriter, r *http.Request, id string) (*sessions.Session, error) {\n\tsession, err := sm.GetSession(r, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.Options.MaxAge = sm.maxAge\n\tsession.Options.Secure = sm.secure\n\tsession.Options.HttpOnly = sm.httpOnly\n\tsession.Options.SameSite = sm.sameSite\n\tsession.Options.Expires = time.Now().Add(time.Duration(sm.maxAge) * time.Second)\n\n\tif err := session.Save(r, w); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session, nil\n}"}
{"sample": "package priqueue\n\nimport (\n\t\"container/heap\"\n\t\"errors\"\n)\n\ntype Item struct {\n\tvalue    interface{}\n\tpriority int\n\tindex    int\n}\n\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n\treturn pq[i].priority < pq[j].priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n\tpq[i].index = i\n\tpq[j].index = j\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n\tn := len(*pq)\n\titem := x.(*Item)\n\titem.index = n\n\t*pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\titem.index = -1\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\nfunc (pq *PriorityQueue) Update(item *Item, value interface{}, priority int) error {\n\tif item == nil {\n\t\treturn errors.New(\"item cannot be nil\")\n\t}\n\n\titem.value = value\n\titem.priority = priority\n\theap.Fix(pq, item.index)\n\n\treturn nil\n}"}
{"sample": "package messagerouter\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n)\n\ntype Message struct {\n\tID      int\n\tContent string\n}\n\ntype MessageRouter struct {\n\tmessages map[int]Message\n\tmutex    sync.RWMutex\n}\n\nfunc NewMessageRouter() *MessageRouter {\n\treturn &MessageRouter{\n\t\tmessages: make(map[int]Message),\n\t}\n}\n\nfunc (mr *MessageRouter) SendMessage(id int, content string) error {\n\tmr.mutex.Lock()\n\tdefer mr.mutex.Unlock()\n\n\tif _, ok := mr.messages[id]; ok {\n\t\treturn errors.New(\"message with that ID already exists\")\n\t}\n\n\tmr.messages[id] = Message{\n\t\tID:      id,\n\t\tContent: content,\n\t}\n\n\treturn nil\n}\n\nfunc (mr *MessageRouter) GetMessage(id int) (Message, error) {\n\tmr.mutex.RLock()\n\tdefer mr.mutex.RUnlock()\n\n\tif message, ok := mr.messages[id]; ok {\n\t\treturn message, nil\n\t}\n\n\treturn Message{}, errors.New(\"message not found\")\n}\n\nfunc (mr *MessageRouter) RouteMessage(id int) error {\n\tmessage, err := mr.GetMessage(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Printf(\"Routing message with ID %d and content %s\", message.ID, message.Content)\n\n\treturn nil\n}\n\nfunc (mr *MessageRouter) PrintMessages() {\n\tmr.mutex.RLock()\n\tdefer mr.mutex.RUnlock()\n\n\tfor _, message := range mr.messages {\n\t\tfmt.Printf(\"Message ID: %d, Content: %s\\n\", message.ID, message.Content)\n\t}\n}"}
{"sample": "package slugify\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\tregSpace = regexp.MustCompile(`\\s+`)\n\tregPunct = regexp.MustCompile(`[^\\w\\d-]+`)\n)\n\n// Slugify converts plain text into slug format for URLs.\nfunc Slugify(text string) string {\n\ttext = strings.ToLower(text)\n\ttext = regSpace.ReplaceAllString(text, \"-\")\n\ttext = regPunct.ReplaceAllString(text, \"\")\n\treturn text\n}"}
{"sample": "package logparser\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n)\n\ntype LogEntry struct {\n\tIP         string\n\tUserID     string\n\tUsername   string\n\tTimestamp  string\n\tMethod     string\n\tEndpoint   string\n\tHTTPStatus int\n}\n\nfunc ParseLog(filePath string) ([]LogEntry, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tvar logEntries []LogEntry\n\treader := bufio.NewReader(file)\n\tfor {\n\t\tline, err := reader.ReadString('\\n')\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tlogEntry, err := parseLine(line)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tlogEntries = append(logEntries, logEntry)\n\t}\n\n\treturn logEntries, nil\n}\n\nfunc parseLine(line string) (LogEntry, error) {\n\tvar logEntry LogEntry\n\n\tre := regexp.MustCompile(`^([\\d\\.]+) (\\S+) (\\S+) \\[([\\w:/]+\\s[+\\-]\\d{4})\\] \"(\\S+) (\\S+) HTTP/\\d\\.\\d\" (\\d+)`)\n\tmatches := re.FindStringSubmatch(line)\n\tif len(matches) < 8 {\n\t\treturn logEntry, nil\n\t}\n\n\tlogEntry.IP = matches[1]\n\tlogEntry.UserID = matches[2]\n\tlogEntry.Username = matches[3]\n\tlogEntry.Timestamp = matches[4]\n\tlogEntry.Method = matches[5]\n\tlogEntry.Endpoint = matches[6]\n\tlogEntry.HTTPStatus = convertToInt(matches[7])\n\n\treturn logEntry, nil\n}\n\nfunc convertToInt(str string) int {\n\tstr = strings.TrimSpace(str)\n\tif str == \"\" {\n\t\treturn 0\n\t}\n\tval := 0\n\tfor _, r := range str {\n\t\tif r < '0' || r > '9' {\n\t\t\treturn 0\n\t\t}\n\t\tval = val*10 + int(r-'0')\n\t}\n\treturn val\n}"}
{"sample": "package dblinkedlist\n\ntype Node struct {\n\tPrev *Node\n\tNext *Node\n\tValue interface{}\n}\n\ntype List struct {\n\tHead *Node\n\tTail *Node\n\tLen  int\n}\n\nfunc (l *List) PushFront(v interface{}) {\n\tn := &Node{nil, nil, v}\n\tif l.Len == 0 {\n\t\tl.Head = n\n\t\tl.Tail = n\n\t} else {\n\t\tl.Head.Prev = n\n\t\tn.Next = l.Head\n\t\tl.Head = n\n\t}\n\tl.Len++\n}\n\nfunc (l *List) PushBack(v interface{}) {\n\tn := &Node{nil, nil, v}\n\tif l.Len == 0 {\n\t\tl.Head = n\n\t\tl.Tail = n\n\t} else {\n\t\tl.Tail.Next = n\n\t\tn.Prev = l.Tail\n\t\tl.Tail = n\n\t}\n\tl.Len++\n}\n\nfunc (l *List) Remove(n *Node) {\n\tif n.Prev == nil {\n\t\tl.Head = n.Next\n\t} else {\n\t\tn.Prev.Next = n.Next\n\t}\n\tif n.Next == nil {\n\t\tl.Tail = n.Prev\n\t} else {\n\t\tn.Next.Prev = n.Prev\n\t}\n\tl.Len--\n}"}
{"sample": "package httpproxy\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n)\n\ntype Proxy struct {\n\tTransport http.RoundTripper\n}\n\nfunc (p *Proxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tlog.Printf(\"Proxying %s %s\", r.Method, r.URL)\n\n\ttransport := p.Transport\n\tif transport == nil {\n\t\ttransport = http.DefaultTransport\n\t}\n\n\tres, err := transport.RoundTrip(r)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadGateway)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tfor k, vv := range res.Header {\n\t\tfor _, v := range vv {\n\t\t\tw.Header().Add(k, v)\n\t\t}\n\t}\n\tw.WriteHeader(res.StatusCode)\n\tio.Copy(w, res.Body)\n}\n\nfunc NewProxy() *Proxy {\n\treturn &Proxy{}\n}\n\nfunc main() {\n\tproxy := NewProxy()\n\n\tserver := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: proxy,\n\t}\n\n\tlog.Fatal(server.ListenAndServe())\n}\n\nfunc ConnectDial(network, addr string) (net.Conn, error) {\n\treturn net.Dial(network, addr)\n}"}
{"sample": "package wsmanage\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\ntype Client struct {\n\tconn *websocket.Conn\n\tsend chan []byte\n}\n\ntype Manager struct {\n\tclients map[*Client]bool\n\tbroadcast chan []byte\n\tregister chan *Client\n\tunregister chan *Client\n}\n\nfunc (m *Manager) Start() {\n\tfor {\n\t\tselect {\n\t\tcase client := <-m.register:\n\t\t\tm.clients[client] = true\n\t\tcase client := <-m.unregister:\n\t\t\tif _, ok := m.clients[client]; ok {\n\t\t\t\tdelete(m.clients, client)\n\t\t\t\tclose(client.send)\n\t\t\t}\n\t\tcase message := <-m.broadcast:\n\t\t\tfor client := range m.clients {\n\t\t\t\tselect {\n\t\t\t\tcase client.send <- message:\n\t\t\t\tdefault:\n\t\t\t\t\tclose(client.send)\n\t\t\t\t\tdelete(m.clients, client)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *Client) Read() {\n\tdefer func() {\n\t\tc.conn.Close()\n\t}()\n\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tmanager.broadcast <- message\n\t}\n}\n\nfunc (c *Client) Write() {\n\tdefer func() {\n\t\tc.conn.Close()\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase message, ok := <-c.send:\n\t\t\tif !ok {\n\t\t\t\tc.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.conn.WriteMessage(websocket.TextMessage, message)\n\t\t}\n\t}\n}\n\nfunc handleWebSocket(manager *Manager, w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tclient := &Client{conn: conn, send: make(chan []byte, 256)}\n\tmanager.register <- client\n\n\tgo client.Read()\n\tgo client.Write()\n}"}
{"sample": "package svgparser\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\ntype SVG struct {\n\tXMLName xml.Name `xml:\"svg\"`\n\tWidth   int      `xml:\"width,attr\"`\n\tHeight  int      `xml:\"height,attr\"`\n\tRects   []Rect   `xml:\"rect\"`\n}\n\ntype Rect struct {\n\tXMLName xml.Name `xml:\"rect\"`\n\tX       int      `xml:\"x,attr\"`\n\tY       int      `xml:\"y,attr\"`\n\tWidth   int      `xml:\"width,attr\"`\n\tHeight  int      `xml:\"height,attr\"`\n}\n\nfunc ParseSVGFile(filename string) (*SVG, error) {\n\txmlFile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer xmlFile.Close()\n\n\tbyteValue, _ := ioutil.ReadAll(xmlFile)\n\n\tvar svg SVG\n\terr = xml.Unmarshal(byteValue, &svg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &svg, nil\n}\n\nfunc ScaleRects(svg *SVG, scale int) {\n\tfor i := range svg.Rects {\n\t\tsvg.Rects[i].X *= scale\n\t\tsvg.Rects[i].Y *= scale\n\t\tsvg.Rects[i].Width *= scale\n\t\tsvg.Rects[i].Height *= scale\n\t}\n}\n\nfunc WriteSVGFile(svg *SVG, filename string) error {\n\txmlData, err := xml.MarshalIndent(svg, \"\", \"  \")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ioutil.WriteFile(filename, xmlData, 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"SVG file written successfully\")\n\treturn nil\n}"}
{"sample": "package graphqlclient\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\turl string\n}\n\nfunc NewClient(url string) *Client {\n\treturn &Client{url: url}\n}\n\nfunc (c *Client) Query(query string, variables map[string]interface{}, response interface{}) error {\n\treqBody, err := json.Marshal(map[string]interface{}{\n\t\t\"query\":     query,\n\t\t\"variables\": variables,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq, err := http.NewRequest(http.MethodPost, c.url, bytes.NewBuffer(reqBody))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"received non-200 status code: %d\", resp.StatusCode)\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(response); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package sha3hash\n\nimport (\n\t\"crypto/sha3\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc ComputeSHA3Hash(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := sha3.New256()\n\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(\"%x\", hash.Sum(nil)), nil\n}"}
{"sample": "package captchagen\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/png\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/dchest/captcha\"\n)\n\nfunc GenerateCaptcha(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"image/png\")\n\n\tvar buf bytes.Buffer\n\timg := captcha.NewImage(\"\", captcha.StdWidth, captcha.StdHeight)\n\tif err := png.Encode(&buf, img); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tid := captcha.New()\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\tcaptcha.SetCustomRescaler(func(width, height int) (int, int) {\n\t\treturn captcha.StdWidth, captcha.StdHeight\n\t})\n\tcaptcha.SetCustomFilter(func(r rune) bool {\n\t\treturn r >= 'a' && r <= 'z'\n\t})\n\tcaptcha.SetCustomFonts([]string{\"comic.ttf\", \"arial.ttf\"})\n\tcaptcha.SetCustomWidth(200)\n\tcaptcha.SetCustomHeight(100)\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif _, err := io.Copy(w, &buf); err != nil {\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n}\n\nfunc ValidateCaptcha(w http.ResponseWriter, r *http.Request) {\n\tid := r.FormValue(\"id\")\n\tdigits := r.FormValue(\"digits\")\n\n\tif captcha.VerifyString(id, digits) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"Captcha verified successfully\"))\n\t} else {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write([]byte(\"Invalid captcha\"))\n\t}\n}\n\nfunc GenerateBase64Captcha() (string, string, error) {\n\timg := captcha.NewImage(\"\", captcha.StdWidth, captcha.StdHeight)\n\tvar buf bytes.Buffer\n\tif err := png.Encode(&buf, img); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tid := captcha.New()\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\tcaptcha.SetCustomRescaler(func(width, height int) (int, int) {\n\t\treturn captcha.StdWidth, captcha.StdHeight\n\t})\n\tcaptcha.SetCustomFilter(func(r rune) bool {\n\t\treturn r >= 'a' && r <= 'z'\n\t})\n\tcaptcha.SetCustomFonts([]string{\"comic.ttf\", \"arial.ttf\"})\n\tcaptcha.SetCustomWidth(200)\n\tcaptcha.SetCustomHeight(100)\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tcaptcha.SetCustomStore(captcha.NewMemoryStore(100, time.Minute*5))\n\n\tif err := captcha.WriteImage(&buf, id, captcha.StdWidth, captcha.StdHeight); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tb64 := base64.StdEncoding.EncodeToString(buf.Bytes())\n\treturn id, b64, nil\n}\n\nfunc ValidateBase64Captcha(id, digits string) bool {\n\treturn captcha.VerifyString(id, digits)\n}\n\nfunc GenerateRandomString(length int) string {\n\tconst letters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-\"\n\tbytes := make([]byte, length)\n\tif _, err := rand.Read(bytes); err != nil {\n\t\treturn \"\"\n\t}\n\tfor i, b := range bytes {\n\t\tbytes[i] = letters[b%byte(len(letters))]\n\t}\n\treturn string(bytes)\n}\n\nfunc GenerateCaptchaURL() string {\n\treturn \"/captcha?r=\" + strconv.FormatInt(time.Now().UnixNano(), 10)\n}"}
{"sample": "package router\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Route struct {\n\tMethod  string\n\tPattern string\n\tHandler http.HandlerFunc\n}\n\ntype Router struct {\n\tRoutes []Route\n}\n\nfunc (r *Router) AddRoute(route Route) {\n\tr.Routes = append(r.Routes, route)\n}\n\nfunc (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tfor _, route := range r.Routes {\n\t\tif req.Method == route.Method && req.URL.Path == route.Pattern {\n\t\t\troute.Handler(w, req)\n\t\t\treturn\n\t\t}\n\t}\n\n\thttp.NotFound(w, req)\n}\n\nfunc helloHandler(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"Hello, World!\")\n}\n\nfunc goodbyeHandler(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"Goodbye, World!\")\n}\n\nfunc main() {\n\trouter := Router{}\n\trouter.AddRoute(Route{\n\t\tMethod:  \"GET\",\n\t\tPattern: \"/hello\",\n\t\tHandler: helloHandler,\n\t})\n\trouter.AddRoute(Route{\n\t\tMethod:  \"GET\",\n\t\tPattern: \"/goodbye\",\n\t\tHandler: goodbyeHandler,\n\t})\n\n\thttp.ListenAndServe(\":8080\", &router)\n}"}
{"sample": "package filewatcher\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n\n// Watcher watches for file changes and reports them\ntype Watcher struct {\n\twatcher *fsnotify.Watcher\n\tdone    chan bool\n}\n\n// NewWatcher creates a new Watcher\nfunc NewWatcher() (*Watcher, error) {\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Watcher{\n\t\twatcher: watcher,\n\t\tdone:    make(chan bool),\n\t}, nil\n}\n\n// Watch watches a given file or directory\nfunc (w *Watcher) Watch(path string) {\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase event := <-w.watcher.Events:\n\t\t\t\tlog.Printf(\"File %s %s\\n\", event.Name, event.Op)\n\t\t\tcase err := <-w.watcher.Errors:\n\t\t\t\tlog.Println(\"error:\", err)\n\t\t\tcase <-w.done:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\terr := w.watcher.Add(path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n// Stop stops watching for file changes\nfunc (w *Watcher) Stop() {\n\tw.done <- true\n\ttime.Sleep(time.Millisecond * 100)\n\tw.watcher.Close()\n}\n\nfunc ExampleUsage() {\n\twatcher, err := NewWatcher()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer watcher.Stop()\n\n\twatcher.Watch(os.Args[1])\n\n\tselect {}\n}"}
{"sample": "package trieimpl\n\ntype TrieNode struct {\n\tchildren map[rune]*TrieNode\n\tisEnd    bool\n}\n\ntype Trie struct {\n\troot *TrieNode\n}\n\nfunc NewTrie() *Trie {\n\treturn &Trie{\n\t\troot: &TrieNode{\n\t\t\tchildren: make(map[rune]*TrieNode),\n\t\t\tisEnd:    false,\n\t\t},\n\t}\n}\n\nfunc (t *Trie) Insert(word string) {\n\tnode := t.root\n\n\tfor _, ch := range word {\n\t\tif _, ok := node.children[ch]; !ok {\n\t\t\tnode.children[ch] = &TrieNode{\n\t\t\t\tchildren: make(map[rune]*TrieNode),\n\t\t\t\tisEnd:    false,\n\t\t\t}\n\t\t}\n\t\tnode = node.children[ch]\n\t}\n\n\tnode.isEnd = true\n}\n\nfunc (t *Trie) Search(word string) bool {\n\tnode := t.root\n\n\tfor _, ch := range word {\n\t\tif _, ok := node.children[ch]; !ok {\n\t\t\treturn false\n\t\t}\n\t\tnode = node.children[ch]\n\t}\n\n\treturn node.isEnd\n}\n\nfunc (t *Trie) Delete(word string) bool {\n\tvar deleteNode func(node *TrieNode, i int) bool\n\n\tdeleteNode = func(node *TrieNode, i int) bool {\n\t\tif i == len(word) {\n\t\t\tif !node.isEnd {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tnode.isEnd = false\n\t\t\treturn len(node.children) == 0\n\t\t}\n\n\t\tch := rune(word[i])\n\t\tif _, ok := node.children[ch]; !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tif deleteNode(node.children[ch], i+1) {\n\t\t\tdelete(node.children, ch)\n\t\t\treturn len(node.children) == 0\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn deleteNode(t.root, 0)\n}"}
{"sample": "package kvstore\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype KeyValue struct {\n\tKey   string `json:\"key\"`\n\tValue string `json:\"value\"`\n}\n\nvar store = make(map[string]string)\n\nfunc SetKey(w http.ResponseWriter, r *http.Request) {\n\tvar kv KeyValue\n\terr := json.NewDecoder(r.Body).Decode(&kv)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tstore[kv.Key] = kv.Value\n\n\tw.WriteHeader(http.StatusCreated)\n}\n\nfunc GetKey(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tkey := vars[\"key\"]\n\n\tval, ok := store[key]\n\tif !ok {\n\t\thttp.Error(w, \"Key not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tkv := KeyValue{Key: key, Value: val}\n\n\tjson.NewEncoder(w).Encode(kv)\n}\n\nfunc GetAllKeys(w http.ResponseWriter, r *http.Request) {\n\tvar keys []string\n\tfor key := range store {\n\t\tkeys = append(keys, key)\n\t}\n\n\tjson.NewEncoder(w).Encode(keys)\n}"}
{"sample": "package kafkaclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/segmentio/kafka-go\"\n)\n\nfunc processMessages(ctx context.Context, r *kafka.Reader) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t\tm, err := r.ReadMessage(ctx)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Printf(\"Received message: %s\\n\", string(m.Value))\n\t\t\t// process message here\n\t\t}\n\t}\n}\n\nfunc startKafkaClient() {\n\tbrokers := []string{\"localhost:9092\"}\n\ttopic := \"my-topic\"\n\tgroupID := \"my-group\"\n\n\tr := kafka.NewReader(kafka.ReaderConfig{\n\t\tBrokers:  brokers,\n\t\tTopic:    topic,\n\t\tGroupID:  groupID,\n\t\tMinBytes: 10e3, // 10KB\n\t\tMaxBytes: 10e6, // 10MB\n\t})\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tgo processMessages(ctx, r)\n\n\tsigterm := make(chan os.Signal, 1)\n\tsignal.Notify(sigterm, os.Interrupt)\n\tselect {\n\tcase <-sigterm:\n\t\tlog.Println(\"Received SIGTERM, shutting down gracefully\")\n\tcase <-ctx.Done():\n\t\tlog.Println(\"Context cancelled, shutting down gracefully\")\n\t}\n\n\tif err := r.Close(); err != nil {\n\t\tlog.Fatalf(\"Error closing reader: %v\", err)\n\t}\n}\n\nfunc main() {\n\tstartKafkaClient()\n\ttime.Sleep(time.Second * 10)\n}"}
{"sample": "package signals\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\nfunc HandleSignals() {\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\tfor {\n\t\tsig := <-sigChan\n\t\tswitch sig {\n\t\tcase syscall.SIGINT:\n\t\t\tfmt.Println(\"Received SIGINT signal\")\n\t\t\t// Handle SIGINT signal\n\t\t\treturn\n\t\tcase syscall.SIGTERM:\n\t\t\tfmt.Println(\"Received SIGTERM signal\")\n\t\t\t// Handle SIGTERM signal\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Received unknown signal\")\n\t\t\t// Handle unknown signal\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"sample": "package ftpclient\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc ftpClient() {\n\tconn, err := net.Dial(\"tcp\", \"ftp.example.com:21\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tmessage, err := bufio.NewReader(conn).ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Print(message)\n\n\treader := bufio.NewReader(os.Stdin)\n\n\tfmt.Print(\"Enter username: \")\n\tusername, _ := reader.ReadString('\\n')\n\tusername = strings.TrimSuffix(username, \"\\n\")\n\n\tfmt.Print(\"Enter password: \")\n\tpassword, _ := reader.ReadString('\\n')\n\tpassword = strings.TrimSuffix(password, \"\\n\")\n\n\tfmt.Fprintf(conn, \"USER %s\\r\\n\", username)\n\tmessage, err = bufio.NewReader(conn).ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Print(message)\n\n\tfmt.Fprintf(conn, \"PASS %s\\r\\n\", password)\n\tmessage, err = bufio.NewReader(conn).ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Print(message)\n\n\tfmt.Fprintf(conn, \"PWD\\r\\n\")\n\tmessage, err = bufio.NewReader(conn).ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Print(message)\n\n\tfmt.Fprintf(conn, \"QUIT\\r\\n\")\n\tmessage, err = bufio.NewReader(conn).ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Print(message)\n}"}
{"sample": "package webhookmgr\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype Webhook struct {\n\tEvent  string      `json:\"event\"`\n\tData   interface{} `json:\"data\"`\n\tTarget string      `json:\"target\"`\n}\n\ntype WebhookHandler struct {\n\thandlers map[string]func(interface{})\n\tmu       sync.RWMutex\n}\n\nfunc (wh *WebhookHandler) RegisterHandler(event string, handler func(interface{})) {\n\twh.mu.Lock()\n\tdefer wh.mu.Unlock()\n\twh.handlers[event] = handler\n}\n\nfunc (wh *WebhookHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPost {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tvar webhook Webhook\n\tif err := json.Unmarshal(body, &webhook); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\twh.mu.RLock()\n\thandler, ok := wh.handlers[webhook.Event]\n\twh.mu.RUnlock()\n\n\tif !ok {\n\t\tlog.Printf(\"No handler found for event: %s\", webhook.Event)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\thandler(webhook.Data)\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"Webhook processed successfully\")\n}"}
{"sample": "package firebasedb\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\tfirebase \"firebase.google.com/go\"\n\t\"firebase.google.com/go/db\"\n\t\"google.golang.org/api/option\"\n)\n\ntype User struct {\n\tName  string `json:\"name\"`\n\tEmail string `json:\"email\"`\n}\n\nfunc CreateUser(ctx context.Context, user *User) error {\n\topt := option.WithCredentialsFile(\"path/to/firebase/credentials.json\")\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tclient, err := app.Database(ctx)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tref := client.NewRef(\"users\")\n\tif err := ref.Push(ctx, user); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc ReadUser(ctx context.Context, userID string) (*User, error) {\n\topt := option.WithCredentialsFile(\"path/to/firebase/credentials.json\")\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tclient, err := app.Database(ctx)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tref := client.NewRef(\"users\")\n\tsnapshot, err := ref.OrderByChild(\"email\").EqualTo(userID).GetOrdered(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(snapshot) == 0 {\n\t\treturn nil, fmt.Errorf(\"user not found\")\n\t}\n\n\tvar user User\n\tif err := snapshot[0].Unmarshal(&user); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &user, nil\n}\n\nfunc UpdateUser(ctx context.Context, userID string, user *User) error {\n\topt := option.WithCredentialsFile(\"path/to/firebase/credentials.json\")\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tclient, err := app.Database(ctx)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tref := client.NewRef(\"users\")\n\tsnapshot, err := ref.OrderByChild(\"email\").EqualTo(userID).GetOrdered(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(snapshot) == 0 {\n\t\treturn fmt.Errorf(\"user not found\")\n\t}\n\n\tif err := snapshot[0].Ref().Update(ctx, map[string]interface{}{\n\t\t\"name\":  user.Name,\n\t\t\"email\": user.Email,\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc DeleteUser(ctx context.Context, userID string) error {\n\topt := option.WithCredentialsFile(\"path/to/firebase/credentials.json\")\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tclient, err := app.Database(ctx)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tref := client.NewRef(\"users\")\n\tsnapshot, err := ref.OrderByChild(\"email\").EqualTo(userID).GetOrdered(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(snapshot) == 0 {\n\t\treturn fmt.Errorf(\"user not found\")\n\t}\n\n\tif err := snapshot[0].Ref().Delete(ctx); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package bloomfilter\n\nimport (\n\t\"hash/fnv\"\n\t\"math\"\n)\n\ntype BloomFilter struct {\n\tbitset []bool\n\tk      uint\n}\n\nfunc New(m uint, k uint) *BloomFilter {\n\treturn &BloomFilter{\n\t\tbitset: make([]bool, m),\n\t\tk:      k,\n\t}\n}\n\nfunc (bf *BloomFilter) Add(item []byte) {\n\thash1, hash2 := bf.getHashes(item)\n\n\tfor i := uint(0); i < bf.k; i++ {\n\t\tindex := (hash1 + i*hash2) % uint(len(bf.bitset))\n\t\tbf.bitset[index] = true\n\t}\n}\n\nfunc (bf *BloomFilter) Contains(item []byte) bool {\n\thash1, hash2 := bf.getHashes(item)\n\n\tfor i := uint(0); i < bf.k; i++ {\n\t\tindex := (hash1 + i*hash2) % uint(len(bf.bitset))\n\t\tif !bf.bitset[index] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (bf *BloomFilter) getHashes(item []byte) (uint, uint) {\n\thasher1 := fnv.New32()\n\thasher2 := fnv.New32a()\n\n\thasher1.Write(item)\n\thasher2.Write(item)\n\n\thash1 := uint(hasher1.Sum32())\n\thash2 := uint(hasher2.Sum32())\n\n\treturn hash1, hash2\n}\n\nfunc (bf *BloomFilter) GetFalsePositiveRate(n uint) float64 {\n\treturn math.Pow(1-math.Exp(-float64(bf.k)*float64(n)/float64(len(bf.bitset))), float64(bf.k))\n}"}
{"sample": "package emailrouter\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/smtp\"\n\t\"strings\"\n)\n\ntype Email struct {\n\tTo      []string\n\tSubject string\n\tBody    string\n}\n\ntype EmailService struct {\n\tSMTPHost string\n\tSMTPPort int\n\tUsername string\n\tPassword string\n}\n\nfunc (es *EmailService) SendEmail(e *Email) error {\n\tauth := smtp.PlainAuth(\"\", es.Username, es.Password, es.SMTPHost)\n\n\tto := strings.Join(e.To, \",\")\n\n\tmsg := fmt.Sprintf(\"To: %s\\r\\nSubject: %s\\r\\n\\r\\n%s\", to, e.Subject, e.Body)\n\n\terr := smtp.SendMail(fmt.Sprintf(\"%s:%d\", es.SMTPHost, es.SMTPPort), auth, es.Username, e.To, []byte(msg))\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\ntype EmailRouter struct {\n\tEmailServices map[string]*EmailService\n}\n\nfunc (er *EmailRouter) RouteEmail(e *Email, service string) error {\n\tes, ok := er.EmailServices[service]\n\tif !ok {\n\t\treturn fmt.Errorf(\"Email service not found\")\n\t}\n\n\treturn es.SendEmail(e)\n}"}
{"sample": "package networkmon\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/google/gopacket\"\n\t\"github.com/google/gopacket/layers\"\n\t\"github.com/google/gopacket/pcap\"\n)\n\nfunc StartMonitoring(device string) error {\n\thandle, err := pcap.OpenLive(device, 65535, true, pcap.BlockForever)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error opening device: %v\", err)\n\t}\n\tdefer handle.Close()\n\n\terr = handle.SetBPFFilter(\"tcp and port 80\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error setting BPF filter: %v\", err)\n\t}\n\n\tpacketSource := gopacket.NewPacketSource(handle, handle.LinkType())\n\n\tfor packet := range packetSource.Packets() {\n\t\t// Extract the TCP layer from the packet\n\t\ttcpLayer := packet.Layer(layers.LayerTypeTCP)\n\t\tif tcpLayer == nil {\n\t\t\tcontinue\n\t\t}\n\t\ttcp, ok := tcpLayer.(*layers.TCP)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Extract the IP layer from the packet\n\t\tipLayer := packet.Layer(layers.LayerTypeIPv4)\n\t\tif ipLayer == nil {\n\t\t\tcontinue\n\t\t}\n\t\tip, ok := ipLayer.(*layers.IPv4)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Print the source and destination IP addresses and ports\n\t\tfmt.Printf(\"%s:%d -> %s:%d\\n\", net.IP(ip.SrcIP), tcp.SrcPort, net.IP(ip.DstIP), tcp.DstPort)\n\t}\n}\n\nfunc ReportTraffic() {\n\t// Generate a report of network traffic every hour\n\tfor {\n\t\ttime.Sleep(time.Hour)\n\n\t\t// TODO: Implement code to generate report\n\t\tlog.Println(\"Generating network traffic report\")\n\t}\n}"}
{"sample": "package binsearch\n\nfunc binarySearch(arr []int, target int) int {\n\tlow := 0\n\thigh := len(arr) - 1\n\n\tfor low <= high {\n\t\tmid := (low + high) / 2\n\n\t\tif arr[mid] == target {\n\t\t\treturn mid\n\t\t} else if arr[mid] < target {\n\t\t\tlow = mid + 1\n\t\t} else {\n\t\t\thigh = mid - 1\n\t\t}\n\t}\n\n\treturn -1\n}"}
{"sample": "package base64coder\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n)\n\n// EncodeBase64 encodes a byte slice to base64\nfunc EncodeBase64(data []byte) string {\n\treturn base64.StdEncoding.EncodeToString(data)\n}\n\n// DecodeBase64 decodes a base64 string to a byte slice\nfunc DecodeBase64(encoded string) ([]byte, error) {\n\tdata, err := base64.StdEncoding.DecodeString(encoded)\n\tif err != nil {\n\t\treturn nil, errors.New(\"failed to decode base64\")\n\t}\n\treturn data, nil\n}"}
{"sample": "package profileservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"models\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype ProfileService struct {\n\tprofileStore models.ProfileStore\n}\n\nfunc NewProfileService(profileStore models.ProfileStore) *ProfileService {\n\treturn &ProfileService{profileStore: profileStore}\n}\n\nfunc (s *ProfileService) CreateProfile(ctx context.Context, profile *models.Profile) error {\n\tif profile.ID != \"\" {\n\t\treturn errors.New(\"profile already has an ID\")\n\t}\n\n\tprofile.ID = uuid.New().String()\n\tprofile.CreatedAt = time.Now()\n\n\treturn s.profileStore.CreateProfile(ctx, profile)\n}\n\nfunc (s *ProfileService) GetProfile(ctx context.Context, id string) (*models.Profile, error) {\n\treturn s.profileStore.GetProfile(ctx, id)\n}\n\nfunc (s *ProfileService) UpdateProfile(ctx context.Context, profile *models.Profile) error {\n\tif profile.ID == \"\" {\n\t\treturn errors.New(\"profile does not have an ID\")\n\t}\n\n\tprofile.UpdatedAt = time.Now()\n\n\treturn s.profileStore.UpdateProfile(ctx, profile)\n}\n\nfunc (s *ProfileService) DeleteProfile(ctx context.Context, id string) error {\n\treturn s.profileStore.DeleteProfile(ctx, id)\n}"}
{"sample": "package checksumgen\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc GenerateMD5Checksum(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := md5.New()\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tchecksum := hex.EncodeToString(hash.Sum(nil))\n\treturn checksum, nil\n}\n\nfunc GenerateSHA256Checksum(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := sha256.New()\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tchecksum := hex.EncodeToString(hash.Sum(nil))\n\treturn checksum, nil\n}\n\nfunc ValidateChecksum(filePath, checksum string) (bool, error) {\n\tfileChecksum, err := GenerateMD5Checksum(filePath)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn fileChecksum == checksum, nil\n}\n\nfunc main() {\n\tchecksum, err := GenerateMD5Checksum(\"file.txt\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Println(checksum)\n\n\tvalid, err := ValidateChecksum(\"file.txt\", checksum)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Println(valid)\n}"}
{"sample": "package hashmap\n\ntype HashMap struct {\n\tdata map[string]interface{}\n}\n\nfunc NewHashMap() *HashMap {\n\treturn &HashMap{\n\t\tdata: make(map[string]interface{}),\n\t}\n}\n\nfunc (h *HashMap) Set(key string, value interface{}) {\n\th.data[key] = value\n}\n\nfunc (h *HashMap) Get(key string) (interface{}, bool) {\n\tvalue, ok := h.data[key]\n\treturn value, ok\n}\n\nfunc (h *HashMap) Delete(key string) {\n\tdelete(h.data, key)\n}\n\nfunc (h *HashMap) Keys() []string {\n\tkeys := make([]string, 0, len(h.data))\n\tfor key := range h.data {\n\t\tkeys = append(keys, key)\n\t}\n\treturn keys\n}\n\nfunc (h *HashMap) Values() []interface{} {\n\tvalues := make([]interface{}, 0, len(h.data))\n\tfor _, value := range h.data {\n\t\tvalues = append(values, value)\n\t}\n\treturn values\n}"}
{"sample": "package dynamodbclient\n\nimport (\n\t\"fmt\"\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/dynamodb\"\n)\n\ntype DynamoDBClient struct {\n\tsvc *dynamodb.DynamoDB\n}\n\nfunc NewDynamoDBClient(region string) (*DynamoDBClient, error) {\n\tsess, err := session.NewSession(&aws.Config{\n\t\tRegion: aws.String(region),\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsvc := dynamodb.New(sess)\n\n\treturn &DynamoDBClient{svc}, nil\n}\n\nfunc (c *DynamoDBClient) CreateTable(tableName string) error {\n\tinput := &dynamodb.CreateTableInput{\n\t\tAttributeDefinitions: []*dynamodb.AttributeDefinition{\n\t\t\t{\n\t\t\t\tAttributeName: aws.String(\"id\"),\n\t\t\t\tAttributeType: aws.String(\"S\"),\n\t\t\t},\n\t\t},\n\t\tKeySchema: []*dynamodb.KeySchemaElement{\n\t\t\t{\n\t\t\t\tAttributeName: aws.String(\"id\"),\n\t\t\t\tKeyType:       aws.String(\"HASH\"),\n\t\t\t},\n\t\t},\n\t\tProvisionedThroughput: &dynamodb.ProvisionedThroughput{\n\t\t\tReadCapacityUnits:  aws.Int64(5),\n\t\t\tWriteCapacityUnits: aws.Int64(5),\n\t\t},\n\t\tTableName: aws.String(tableName),\n\t}\n\n\t_, err := c.svc.CreateTable(input)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Table %s created successfully\", tableName)\n\n\treturn nil\n}\n\nfunc (c *DynamoDBClient) PutItem(tableName string, item map[string]interface{}) error {\n\tinput := &dynamodb.PutItemInput{\n\t\tItem:      aws.DynamoDBMap(item),\n\t\tTableName: aws.String(tableName),\n\t}\n\n\t_, err := c.svc.PutItem(input)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Item added to table %s successfully\", tableName)\n\n\treturn nil\n}\n\nfunc (c *DynamoDBClient) GetItem(tableName string, id string) (map[string]*dynamodb.AttributeValue, error) {\n\tinput := &dynamodb.GetItemInput{\n\t\tKey: map[string]*dynamodb.AttributeValue{\n\t\t\t\"id\": {\n\t\t\t\tS: aws.String(id),\n\t\t\t},\n\t\t},\n\t\tTableName: aws.String(tableName),\n\t}\n\n\tresult, err := c.svc.GetItem(input)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result.Item, nil\n}"}
{"sample": "package restprocessor\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc handleUsers(w http.ResponseWriter, r *http.Request) {\n\tswitch r.Method {\n\tcase \"GET\":\n\t\tgetUsers(w, r)\n\tcase \"POST\":\n\t\tcreateUser(w, r)\n\tdefault:\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n\tusers := []User{\n\t\t{ID: 1, Username: \"user1\", Email: \"user1@example.com\"},\n\t\t{ID: 2, Username: \"user2\", Email: \"user2@example.com\"},\n\t\t{ID: 3, Username: \"user3\", Email: \"user3@example.com\"},\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif err := json.NewEncoder(w).Encode(users); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n\tvar user User\n\tif err := json.NewDecoder(r.Body).Decode(&user); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Save user to database\n\n\tw.WriteHeader(http.StatusCreated)\n}"}
{"sample": "package accountservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype User struct {\n\tID        string\n\tFirstName string\n\tLastName  string\n\tEmail     string\n\tPassword  string\n\tCreatedAt time.Time\n}\n\ntype AccountService struct {\n\tusers []*User\n}\n\nfunc NewAccountService() *AccountService {\n\treturn &AccountService{\n\t\tusers: []*User{},\n\t}\n}\n\nfunc (a *AccountService) CreateUser(ctx context.Context, user *User) error {\n\tif user == nil {\n\t\treturn errors.New(\"user is nil\")\n\t}\n\n\tif user.ID != \"\" {\n\t\treturn errors.New(\"user ID must be empty\")\n\t}\n\n\tuser.ID = uuid.New().String()\n\tuser.CreatedAt = time.Now()\n\n\ta.users = append(a.users, user)\n\n\tlog.Printf(\"User created: %v\", user)\n\n\treturn nil\n}\n\nfunc (a *AccountService) GetUser(ctx context.Context, id string) (*User, error) {\n\tfor _, user := range a.users {\n\t\tif user.ID == id {\n\t\t\treturn user, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"user not found: %s\", id)\n}\n\nfunc (a *AccountService) UpdateUser(ctx context.Context, user *User) error {\n\tif user == nil {\n\t\treturn errors.New(\"user is nil\")\n\t}\n\n\tif user.ID == \"\" {\n\t\treturn errors.New(\"user ID is empty\")\n\t}\n\n\tfor i, u := range a.users {\n\t\tif u.ID == user.ID {\n\t\t\ta.users[i] = user\n\t\t\tlog.Printf(\"User updated: %v\", user)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"user not found: %s\", user.ID)\n}\n\nfunc (a *AccountService) DeleteUser(ctx context.Context, id string) error {\n\tfor i, user := range a.users {\n\t\tif user.ID == id {\n\t\t\ta.users = append(a.users[:i], a.users[i+1:]...)\n\t\t\tlog.Printf(\"User deleted: %s\", id)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"user not found: %s\", id)\n}"}
{"sample": "package hammingdist\n\nimport \"errors\"\n\n// HammingDistance returns the Hamming distance between two strings of equal length.\nfunc HammingDistance(s1, s2 string) (int, error) {\n\tif len(s1) != len(s2) {\n\t\treturn 0, errors.New(\"strings must be of equal length\")\n\t}\n\n\tdistance := 0\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\tdistance++\n\t\t}\n\t}\n\n\treturn distance, nil\n}"}
{"sample": "package quicksort\n\nfunc QuickSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\n\tpivot := arr[0]\n\tvar left []int\n\tvar right []int\n\n\tfor _, v := range arr[1:] {\n\t\tif v <= pivot {\n\t\t\tleft = append(left, v)\n\t\t} else {\n\t\t\tright = append(right, v)\n\t\t}\n\t}\n\n\tleft = QuickSort(left)\n\tright = QuickSort(right)\n\n\treturn append(append(left, pivot), right...)\n}"}
{"sample": "package promclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/api\"\n\t\"github.com/prometheus/client_golang/api/prometheus/v1\"\n\t\"github.com/prometheus/common/model\"\n)\n\nfunc Query(query string, endpoint string) (model.Value, error) {\n\tclient, err := api.NewClient(api.Config{\n\t\tAddress: endpoint,\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating prometheus client: %v\", err)\n\t}\n\n\tv1api := v1.NewAPI(client)\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tresult, warnings, err := v1api.Query(ctx, query, time.Now())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error querying prometheus: %v\", err)\n\t}\n\tif len(warnings) > 0 {\n\t\tfmt.Printf(\"Warnings: %v\\n\", warnings)\n\t}\n\n\treturn result, nil\n}\n\nfunc GetMetrics(endpoint string) ([]byte, error) {\n\tresp, err := http.Get(fmt.Sprintf(\"%s/metrics\", endpoint))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting metrics from prometheus: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %v\", err)\n\t}\n\n\treturn body, nil\n}"}
{"sample": "package filetransferservice\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc uploadFile(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tfile, header, err := r.FormFile(\"file\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tf, err := os.OpenFile(header.Filename, os.O_WRONLY|os.O_CREATE, 0666)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tif _, err := io.Copy(f, file); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"File uploaded successfully\")\n}\n\nfunc downloadFile(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"GET\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tfilename := r.URL.Query().Get(\"filename\")\n\tif filename == \"\" {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tw.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+filename)\n\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tif _, err := io.Copy(w, file); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n}"}
{"sample": "package csvdataanalysis\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc analyzeCSVFile(filePath string) error {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\tvar total int\n\tvar max int\n\tvar min int\n\tvar count int\n\n\tfor {\n\t\trecord, err := reader.Read()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvalue, err := strconv.Atoi(record[0])\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ttotal += value\n\t\tcount++\n\n\t\tif value > max {\n\t\t\tmax = value\n\t\t}\n\n\t\tif value < min || min == 0 {\n\t\t\tmin = value\n\t\t}\n\t}\n\n\taverage := float64(total) / float64(count)\n\n\tfmt.Printf(\"Total: %d\\n\", total)\n\tfmt.Printf(\"Average: %.2f\\n\", average)\n\tfmt.Printf(\"Max: %d\\n\", max)\n\tfmt.Printf(\"Min: %d\\n\", min)\n\n\treturn nil\n}"}
{"sample": "package portscanner\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sort\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc ScanPorts(ip string, startPort, endPort int) []int {\n\tports := make([]int, 0)\n\n\tfor port := startPort; port <= endPort; port++ {\n\t\ttarget := fmt.Sprintf(\"%s:%d\", ip, port)\n\t\tconn, err := net.DialTimeout(\"tcp\", target, 10*time.Second)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tconn.Close()\n\t\tports = append(ports, port)\n\t}\n\n\tsort.Ints(ports)\n\treturn ports\n}\n\nfunc ReportPorts(ip string, startPort, endPort int) {\n\tports := ScanPorts(ip, startPort, endPort)\n\n\tif len(ports) == 0 {\n\t\tfmt.Println(\"No open ports found\")\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Open ports on %s\\n\", ip)\n\tfor _, port := range ports {\n\t\tfmt.Printf(\"%d: open\\n\", port)\n\t}\n}\n\nfunc main() {\n\tip := \"127.0.0.1\"\n\tstartPort := 1\n\tendPort := 1024\n\n\tReportPorts(ip, startPort, endPort)\n}"}
{"sample": "package circbuffer\n\nimport \"errors\"\n\ntype CircularBuffer struct {\n\tbuffer []interface{}\n\tsize   int\n\thead   int\n\ttail   int\n}\n\nfunc NewCircularBuffer(size int) *CircularBuffer {\n\treturn &CircularBuffer{\n\t\tbuffer: make([]interface{}, size),\n\t\tsize:   size,\n\t\thead:   0,\n\t\ttail:   0,\n\t}\n}\n\nfunc (cb *CircularBuffer) Add(item interface{}) error {\n\tif cb.IsFull() {\n\t\treturn errors.New(\"buffer is full\")\n\t}\n\n\tcb.buffer[cb.tail] = item\n\tcb.tail = (cb.tail + 1) % cb.size\n\treturn nil\n}\n\nfunc (cb *CircularBuffer) Remove() (interface{}, error) {\n\tif cb.IsEmpty() {\n\t\treturn nil, errors.New(\"buffer is empty\")\n\t}\n\n\titem := cb.buffer[cb.head]\n\tcb.head = (cb.head + 1) % cb.size\n\treturn item, nil\n}\n\nfunc (cb *CircularBuffer) IsFull() bool {\n\treturn (cb.tail+1)%cb.size == cb.head\n}\n\nfunc (cb *CircularBuffer) IsEmpty() bool {\n\treturn cb.head == cb.tail\n}"}
{"sample": "package gcdcalc\n\nfunc gcd(a, b int) int {\n\tif b == 0 {\n\t\treturn a\n\t}\n\treturn gcd(b, a%b)\n}"}
{"sample": "package inventoryservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"inventory\"\n\t\"log\"\n)\n\ntype InventoryService struct {\n\tinventory inventory.Inventory\n}\n\nfunc NewInventoryService(inv inventory.Inventory) *InventoryService {\n\treturn &InventoryService{inventory: inv}\n}\n\nfunc (is *InventoryService) AddItem(ctx context.Context, item inventory.Item) error {\n\tif item.Name == \"\" || item.Quantity <= 0 {\n\t\treturn errors.New(\"invalid item\")\n\t}\n\n\terr := is.inventory.AddItem(item)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn errors.New(\"failed to add item\")\n\t}\n\n\treturn nil\n}\n\nfunc (is *InventoryService) RemoveItem(ctx context.Context, name string) error {\n\tif name == \"\" {\n\t\treturn errors.New(\"invalid name\")\n\t}\n\n\terr := is.inventory.RemoveItem(name)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn errors.New(\"failed to remove item\")\n\t}\n\n\treturn nil\n}\n\nfunc (is *InventoryService) GetItem(ctx context.Context, name string) (inventory.Item, error) {\n\tif name == \"\" {\n\t\treturn inventory.Item{}, errors.New(\"invalid name\")\n\t}\n\n\titem, err := is.inventory.GetItem(name)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn inventory.Item{}, errors.New(\"failed to get item\")\n\t}\n\n\treturn item, nil\n}"}
{"sample": "package slackapi\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\ntype SlackAPI struct {\n\tToken string\n}\n\ntype Message struct {\n\tText string `json:\"text\"`\n}\n\nfunc (s *SlackAPI) SendMessage(channel, message string) error {\n\tif s.Token == \"\" {\n\t\treturn errors.New(\"missing Slack API token\")\n\t}\n\n\tmsg := Message{\n\t\tText: message,\n\t}\n\n\tpayload, err := json.Marshal(msg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\turl := \"https://slack.com/api/chat.postMessage\"\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(payload))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+s.Token)\n\treq.Header.Set(\"User-Agent\", \"My Slack API Client\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(\"failed to send message\")\n\t}\n\n\treturn nil\n}"}
{"sample": "package argparser\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar name string\n\tvar age int\n\tvar married bool\n\n\tflag.StringVar(&name, \"name\", \"\", \"Name of the person\")\n\tflag.IntVar(&age, \"age\", 0, \"Age of the person\")\n\tflag.BoolVar(&married, \"married\", false, \"Marital status of the person\")\n\n\tflag.Parse()\n\n\tif name == \"\" {\n\t\tfmt.Println(\"Name is required\")\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Name: %s\\n\", name)\n\tfmt.Printf(\"Age: %d\\n\", age)\n\tfmt.Printf(\"Married: %t\\n\", married)\n}"}
{"sample": "package digisign\n\nimport (\n\t\"crypto\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"errors\"\n)\n\n// GenerateKeyPair generates a new RSA key pair.\nfunc GenerateKeyPair() (*rsa.PrivateKey, error) {\n\treturn rsa.GenerateKey(rand.Reader, 2048)\n}\n\n// Sign creates a digital signature of the message using the private key.\nfunc Sign(message []byte, privateKey *rsa.PrivateKey) ([]byte, error) {\n\thashed := sha256.Sum256(message)\n\treturn rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hashed[:])\n}\n\n// Verify checks if the digital signature is valid for the given message and public key.\nfunc Verify(message []byte, signature []byte, publicKey *rsa.PublicKey) error {\n\thashed := sha256.Sum256(message)\n\treturn rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hashed[:], signature)\n}\n\n// PrivateKeyToPEM converts a private key to PEM format.\nfunc PrivateKeyToPEM(privateKey *rsa.PrivateKey) ([]byte, error) {\n\tblock := &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: x509.MarshalPKCS1PrivateKey(privateKey),\n\t}\n\treturn pem.EncodeToMemory(block), nil\n}\n\n// PublicKeyToPEM converts a public key to PEM format.\nfunc PublicKeyToPEM(publicKey *rsa.PublicKey) ([]byte, error) {\n\tbytes, err := x509.MarshalPKIXPublicKey(publicKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tblock := &pem.Block{\n\t\tType:  \"PUBLIC KEY\",\n\t\tBytes: bytes,\n\t}\n\treturn pem.EncodeToMemory(block), nil\n}\n\n// PEMToPrivateKey converts a PEM-encoded private key to an RSA private key.\nfunc PEMToPrivateKey(pemBytes []byte) (*rsa.PrivateKey, error) {\n\tblock, _ := pem.Decode(pemBytes)\n\tif block == nil {\n\t\treturn nil, errors.New(\"failed to decode PEM block containing private key\")\n\t}\n\treturn x509.ParsePKCS1PrivateKey(block.Bytes)\n}\n\n// PEMToPublicKey converts a PEM-encoded public key to an RSA public key.\nfunc PEMToPublicKey(pemBytes []byte) (*rsa.PublicKey, error) {\n\tblock, _ := pem.Decode(pemBytes)\n\tif block == nil {\n\t\treturn nil, errors.New(\"failed to decode PEM block containing public key\")\n\t}\n\tpub, err := x509.ParsePKIXPublicKey(block.Bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trsaPub, ok := pub.(*rsa.PublicKey)\n\tif !ok {\n\t\treturn nil, errors.New(\"failed to parse RSA public key\")\n\t}\n\treturn rsaPub, nil\n}"}
{"sample": "package smsservice\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n)\n\ntype SMS struct {\n\tTo      string\n\tMessage string\n}\n\ntype SMSService interface {\n\tSendSMS(sms SMS) error\n}\n\ntype TwilioSMSService struct {\n\taccountSid string\n\tauthToken  string\n\tfromNumber string\n}\n\nfunc NewTwilioSMSService() *TwilioSMSService {\n\treturn &TwilioSMSService{\n\t\taccountSid: os.Getenv(\"TWILIO_ACCOUNT_SID\"),\n\t\tauthToken:  os.Getenv(\"TWILIO_AUTH_TOKEN\"),\n\t\tfromNumber: os.Getenv(\"TWILIO_FROM_NUMBER\"),\n\t}\n}\n\nfunc (t *TwilioSMSService) SendSMS(sms SMS) error {\n\tif t.accountSid == \"\" || t.authToken == \"\" || t.fromNumber == \"\" {\n\t\treturn errors.New(\"twilio credentials not set\")\n\t}\n\n\turlStr := fmt.Sprintf(\"https://api.twilio.com/2010-04-01/Accounts/%s/Messages.json\", t.accountSid)\n\n\tmsgData := url.Values{}\n\tmsgData.Set(\"To\", sms.To)\n\tmsgData.Set(\"From\", t.fromNumber)\n\tmsgData.Set(\"Body\", sms.Message)\n\tmsgDataReader := *strings.NewReader(msgData.Encode())\n\n\tclient := &http.Client{}\n\treq, _ := http.NewRequest(\"POST\", urlStr, &msgDataReader)\n\treq.SetBasicAuth(t.accountSid, t.authToken)\n\treq.Header.Add(\"Accept\", \"application/json\")\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tif resp.StatusCode >= 200 && resp.StatusCode < 300 {\n\t\tlog.Println(\"SMS sent successfully\")\n\t\treturn nil\n\t} else {\n\t\tlog.Println(\"Failed to send SMS\")\n\t\treturn errors.New(\"failed to send SMS\")\n\t}\n}"}
{"sample": "package sysresmon\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/shirou/gopsutil/cpu\"\n\t\"github.com/shirou/gopsutil/disk\"\n\t\"github.com/shirou/gopsutil/mem\"\n)\n\nfunc monitorResources() {\n\tfor {\n\t\tcpuUsage, err := cpu.Percent(time.Second, false)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\n\t\tmemUsage, err := mem.VirtualMemory()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\n\t\tdiskUsage, err := disk.Usage(\"/\")\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\n\t\tfmt.Printf(\"CPU Usage: %.2f%%\\n\", cpuUsage[0])\n\t\tfmt.Printf(\"Memory Usage: %.2f%%\\n\", memUsage.UsedPercent)\n\t\tfmt.Printf(\"Disk Usage: %.2f%%\\n\", diskUsage.UsedPercent)\n\n\t\ttime.Sleep(10 * time.Second)\n\t}\n}"}
{"sample": "package cassandraclient\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/gocql/gocql\"\n)\n\ntype CassandraClient struct {\n\tsession *gocql.Session\n}\n\nfunc NewCassandraClient(hosts []string, keyspace string) (*CassandraClient, error) {\n\tcluster := gocql.NewCluster(hosts...)\n\tcluster.Keyspace = keyspace\n\tcluster.Consistency = gocql.Quorum\n\tcluster.Timeout = 30 * time.Second\n\n\tsession, err := cluster.CreateSession()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &CassandraClient{session: session}, nil\n}\n\nfunc (c *CassandraClient) Close() {\n\tc.session.Close()\n}\n\nfunc (c *CassandraClient) InsertUser(id int, name string, email string) error {\n\tquery := \"INSERT INTO users (id, name, email) VALUES (?, ?, ?)\"\n\tif err := c.session.Query(query, id, name, email).Exec(); err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *CassandraClient) GetUser(id int) (string, string, error) {\n\tvar name, email string\n\tquery := \"SELECT name, email FROM users WHERE id = ?\"\n\tif err := c.session.Query(query, id).Scan(&name, &email); err != nil {\n\t\tlog.Println(err)\n\t\treturn \"\", \"\", err\n\t}\n\n\treturn name, email, nil\n}\n\nfunc (c *CassandraClient) GetUsers() ([]string, error) {\n\tvar names []string\n\tquery := \"SELECT name FROM users\"\n\titer := c.session.Query(query).Iter()\n\tvar name string\n\tfor iter.Scan(&name) {\n\t\tnames = append(names, name)\n\t}\n\tif err := iter.Close(); err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\treturn names, nil\n}\n\nfunc (c *CassandraClient) CreateSchema() error {\n\tquery := `\n\t\tCREATE TABLE IF NOT EXISTS users (\n\t\t\tid int,\n\t\t\tname text,\n\t\t\temail text,\n\t\t\tPRIMARY KEY (id)\n\t\t)\n\t`\n\tif err := c.session.Query(query).Exec(); err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc ExampleUsage() {\n\thosts := []string{\"127.0.0.1\"}\n\tkeyspace := \"mykeyspace\"\n\n\tclient, err := NewCassandraClient(hosts, keyspace)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer client.Close()\n\n\tif err := client.CreateSchema(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := client.InsertUser(1, \"Alice\", \"alice@example.com\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tname, email, err := client.GetUser(1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"Name: %s, Email: %s\\n\", name, email)\n\n\tusers, err := client.GetUsers()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"Users: %v\\n\", users)\n}"}
{"sample": "package linkedlist\n\ntype Node struct {\n\tValue interface{}\n\tNext  *Node\n}\n\ntype LinkedList struct {\n\tHead *Node\n\tTail *Node\n\tSize int\n}\n\nfunc (l *LinkedList) Append(value interface{}) {\n\tnode := &Node{Value: value}\n\n\tif l.Head == nil {\n\t\tl.Head = node\n\t\tl.Tail = node\n\t} else {\n\t\tl.Tail.Next = node\n\t\tl.Tail = node\n\t}\n\n\tl.Size++\n}\n\nfunc (l *LinkedList) Remove(value interface{}) {\n\tif l.Head == nil {\n\t\treturn\n\t}\n\n\tif l.Head.Value == value {\n\t\tl.Head = l.Head.Next\n\t\tl.Size--\n\t\treturn\n\t}\n\n\tprev := l.Head\n\tcurr := l.Head.Next\n\n\tfor curr != nil {\n\t\tif curr.Value == value {\n\t\t\tprev.Next = curr.Next\n\t\t\tif curr.Next == nil {\n\t\t\t\tl.Tail = prev\n\t\t\t}\n\t\t\tl.Size--\n\t\t\treturn\n\t\t}\n\t\tprev = curr\n\t\tcurr = curr.Next\n\t}\n}\n\nfunc (l *LinkedList) Search(value interface{}) bool {\n\tcurr := l.Head\n\n\tfor curr != nil {\n\t\tif curr.Value == value {\n\t\t\treturn true\n\t\t}\n\t\tcurr = curr.Next\n\t}\n\n\treturn false\n}"}
{"sample": "package commentservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/jackc/pgx/v4/pgxpool\"\n)\n\ntype Comment struct {\n\tID      uuid.UUID\n\tPostID  uuid.UUID\n\tContent string\n}\n\ntype CommentService struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewCommentService(db *pgxpool.Pool) *CommentService {\n\treturn &CommentService{db: db}\n}\n\nfunc (s *CommentService) CreateComment(ctx context.Context, postID uuid.UUID, content string) (uuid.UUID, error) {\n\tcommentID, err := uuid.NewRandom()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn uuid.Nil, errors.New(\"failed to generate comment ID\")\n\t}\n\n\tsql := \"INSERT INTO comments (id, post_id, content) VALUES ($1, $2, $3)\"\n\tif _, err := s.db.Exec(ctx, sql, commentID, postID, content); err != nil {\n\t\tlog.Println(err)\n\t\treturn uuid.Nil, errors.New(\"failed to create comment\")\n\t}\n\n\treturn commentID, nil\n}\n\nfunc (s *CommentService) GetCommentsByPostID(ctx context.Context, postID uuid.UUID) ([]Comment, error) {\n\tsql := \"SELECT id, post_id, content FROM comments WHERE post_id = $1\"\n\trows, err := s.db.Query(ctx, sql, postID)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, errors.New(\"failed to get comments\")\n\t}\n\tdefer rows.Close()\n\n\tcomments := []Comment{}\n\tfor rows.Next() {\n\t\tvar comment Comment\n\t\tif err := rows.Scan(&comment.ID, &comment.PostID, &comment.Content); err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn nil, errors.New(\"failed to scan comment\")\n\t\t}\n\t\tcomments = append(comments, comment)\n\t}\n\n\treturn comments, nil\n}"}
{"sample": "package oracledb\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/godror/godror\"\n)\n\ntype User struct {\n\tID       int\n\tUsername string\n\tEmail    string\n}\n\nfunc Connect() (*sql.DB, error) {\n\tdb, err := sql.Open(\"godror\", \"user/password@host:port/sid\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = db.Ping()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n\nfunc CreateUser(db *sql.DB, user User) error {\n\tquery := `INSERT INTO users (id, username, email) VALUES (:1, :2, :3)`\n\t_, err := db.Exec(query, user.ID, user.Username, user.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc GetUser(db *sql.DB, id int) (User, error) {\n\tquery := `SELECT id, username, email FROM users WHERE id = :1`\n\trow := db.QueryRow(query, id)\n\n\tvar user User\n\terr := row.Scan(&user.ID, &user.Username, &user.Email)\n\tif err != nil {\n\t\treturn User{}, err\n\t}\n\n\treturn user, nil\n}\n\nfunc UpdateUser(db *sql.DB, user User) error {\n\tquery := `UPDATE users SET username = :1, email = :2 WHERE id = :3`\n\t_, err := db.Exec(query, user.Username, user.Email, user.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc DeleteUser(db *sql.DB, id int) error {\n\tquery := `DELETE FROM users WHERE id = :1`\n\t_, err := db.Exec(query, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc ExampleUsage() {\n\tdb, err := Connect()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tuser := User{\n\t\tID:       1,\n\t\tUsername: \"johndoe\",\n\t\tEmail:    \"johndoe@example.com\",\n\t}\n\n\terr = CreateUser(db, user)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tuser, err = GetUser(db, 1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(user)\n\n\tuser.Username = \"janedoe\"\n\tuser.Email = \"janedoe@example.com\"\n\n\terr = UpdateUser(db, user)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = DeleteUser(db, 1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package trelloclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/adlio/trello\"\n)\n\ntype TrelloClient struct {\n\tclient *trello.Client\n\tboard  *trello.Board\n}\n\nfunc NewTrelloClient(boardID string) (*TrelloClient, error) {\n\tappKey := os.Getenv(\"TRELLO_APP_KEY\")\n\ttoken := os.Getenv(\"TRELLO_TOKEN\")\n\n\tclient := trello.NewClient(appKey, token)\n\n\tboard, err := client.GetBoard(boardID, trello.Defaults())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get board: %v\", err)\n\t}\n\n\treturn &TrelloClient{\n\t\tclient: client,\n\t\tboard:  board,\n\t}, nil\n}\n\nfunc (tc *TrelloClient) GetLists() ([]*trello.List, error) {\n\tlists, err := tc.board.GetLists(trello.Defaults())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get lists: %v\", err)\n\t}\n\n\treturn lists, nil\n}\n\nfunc (tc *TrelloClient) CreateCard(listID, name, description string) (*trello.Card, error) {\n\tlist, err := tc.client.GetList(listID, trello.Defaults())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get list: %v\", err)\n\t}\n\n\tcard := trello.Card{\n\t\tName:   name,\n\t\tDesc:   description,\n\t\tIDList: list.ID,\n\t}\n\n\terr = tc.client.CreateCard(&card, trello.Defaults())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create card: %v\", err)\n\t}\n\n\treturn &card, nil\n}\n\nfunc (tc *TrelloClient) MoveCardToList(cardID, listID string) error {\n\tcard, err := tc.client.GetCard(cardID, trello.Defaults())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get card: %v\", err)\n\t}\n\n\tlist, err := tc.client.GetList(listID, trello.Defaults())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get list: %v\", err)\n\t}\n\n\terr = card.MoveToList(list.ID, trello.Defaults())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to move card to list: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (tc *TrelloClient) WatchCard(ctx context.Context, cardID string) (<-chan trello.Card, error) {\n\tcard, err := tc.client.GetCard(cardID, trello.Defaults())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get card: %v\", err)\n\t}\n\n\tcardChan := make(chan trello.Card)\n\n\tgo func() {\n\t\tdefer close(cardChan)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\terr := card.Refresh(trello.Defaults())\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"failed to refresh card: %v\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tcardChan <- *card\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn cardChan, nil\n}"}
{"sample": "package ascii85coder\n\nimport (\n\t\"bytes\"\n\t\"encoding/ascii85\"\n)\n\nfunc Encode(data []byte) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tencoder := ascii85.NewEncoder(&buf)\n\tif _, err := encoder.Write(data); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := encoder.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n\nfunc Decode(data []byte) ([]byte, error) {\n\tdecoder := ascii85.NewDecoder(bytes.NewReader(data))\n\tvar buf bytes.Buffer\n\tif _, err := buf.ReadFrom(decoder); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}"}
{"sample": "package jobservice\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"models\"\n\t\"time\"\n)\n\nfunc createJob(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttitle := r.FormValue(\"title\")\n\tdescription := r.FormValue(\"description\")\n\tlocation := r.FormValue(\"location\")\n\tsalary := r.FormValue(\"salary\")\n\tcompany := r.FormValue(\"company\")\n\n\tjob := models.Job{\n\t\tTitle:       title,\n\t\tDescription: description,\n\t\tLocation:    location,\n\t\tSalary:      salary,\n\t\tCompany:     company,\n\t\tCreatedAt:   time.Now(),\n\t}\n\n\tif err := job.Create(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"Job created successfully\")\n}\n\nfunc applyJob(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tjobID := r.FormValue(\"job_id\")\n\tname := r.FormValue(\"name\")\n\temail := r.FormValue(\"email\")\n\tresume := r.FormValue(\"resume\")\n\n\tapplication := models.Application{\n\t\tJobID:  jobID,\n\t\tName:   name,\n\t\tEmail:  email,\n\t\tResume: resume,\n\t}\n\n\tif err := application.Create(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"Application submitted successfully\")\n}\n\nfunc getJobs(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"GET\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tjobs, err := models.GetJobs()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(jobs)\n}"}
{"sample": "package uptimechecker\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc checkWebsite(url string) bool {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer resp.Body.Close()\n\treturn true\n}\n\nfunc monitorWebsite(url string, interval time.Duration, alerts chan<- string) {\n\tfor {\n\t\tif !checkWebsite(url) {\n\t\t\talerts <- fmt.Sprintf(\"Website %s is down\", url)\n\t\t}\n\t\ttime.Sleep(interval)\n\t}\n}\n\nfunc reportAlerts(alerts <-chan string) {\n\tfor alert := range alerts {\n\t\tfmt.Println(alert)\n\t}\n}\n\nfunc StartMonitoring(url string, interval time.Duration) {\n\talerts := make(chan string)\n\tgo monitorWebsite(url, interval, alerts)\n\treportAlerts(alerts)\n}"}
{"sample": "package azureblobclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/Azure/azure-storage-blob-go/azblob\"\n)\n\ntype BlobClient struct {\n\tcontainerURL azblob.ContainerURL\n}\n\nfunc NewBlobClient(accountName, accountKey, containerName string) (*BlobClient, error) {\n\tcredential, err := azblob.NewSharedKeyCredential(accountName, accountKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpipeline := azblob.NewPipeline(credential, azblob.PipelineOptions{})\n\tURL, _ := url.Parse(fmt.Sprintf(\"https://%s.blob.core.windows.net/%s\", accountName, containerName))\n\tcontainerURL := azblob.NewContainerURL(*URL, pipeline)\n\n\treturn &BlobClient{containerURL}, nil\n}\n\nfunc (c *BlobClient) UploadBlob(ctx context.Context, blobName string, data []byte) error {\n\tblobURL := c.containerURL.NewBlockBlobURL(blobName)\n\n\t_, err := azblob.UploadBufferToBlockBlob(ctx, data, blobURL, azblob.UploadToBlockBlobOptions{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *BlobClient) DownloadBlob(ctx context.Context, blobName string) ([]byte, error) {\n\tblobURL := c.containerURL.NewBlockBlobURL(blobName)\n\n\tresp, err := blobURL.Download(ctx, 0, azblob.CountToEnd, azblob.BlobAccessConditions{}, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Response().Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Response().Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"}
{"sample": "package mergesort\n\nfunc merge(left, right []int) []int {\n\tresult := make([]int, len(left)+len(right))\n\n\ti, j, k := 0, 0, 0\n\n\tfor i < len(left) && j < len(right) {\n\t\tif left[i] <= right[j] {\n\t\t\tresult[k] = left[i]\n\t\t\ti++\n\t\t} else {\n\t\t\tresult[k] = right[j]\n\t\t\tj++\n\t\t}\n\t\tk++\n\t}\n\n\tfor i < len(left) {\n\t\tresult[k] = left[i]\n\t\ti++\n\t\tk++\n\t}\n\n\tfor j < len(right) {\n\t\tresult[k] = right[j]\n\t\tj++\n\t\tk++\n\t}\n\n\treturn result\n}\n\nfunc mergeSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\n\tmid := len(arr) / 2\n\tleft := mergeSort(arr[:mid])\n\tright := mergeSort(arr[mid:])\n\n\treturn merge(left, right)\n}"}
{"sample": "package orderservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Order struct {\n\tID          string\n\tCustomerID  string\n\tProductID   string\n\tQuantity    int\n\tPrice       float64\n\tCreatedTime time.Time\n}\n\ntype OrderService struct {\n}\n\nfunc (os *OrderService) CreateOrder(ctx context.Context, customerID string, productID string, quantity int, price float64) (*Order, error) {\n\tif customerID == \"\" || productID == \"\" || quantity <= 0 || price <= 0 {\n\t\treturn nil, errors.New(\"invalid order parameters\")\n\t}\n\n\torder := &Order{\n\t\tID:          uuid.New().String(),\n\t\tCustomerID:  customerID,\n\t\tProductID:   productID,\n\t\tQuantity:    quantity,\n\t\tPrice:       price,\n\t\tCreatedTime: time.Now(),\n\t}\n\n\t// TODO: Save the order to database\n\n\treturn order, nil\n}\n\nfunc (os *OrderService) GetOrder(ctx context.Context, orderID string) (*Order, error) {\n\tif orderID == \"\" {\n\t\treturn nil, errors.New(\"invalid order ID\")\n\t}\n\n\t// TODO: Get the order from database\n\n\torder := &Order{\n\t\tID:          orderID,\n\t\tCustomerID:  \"customerID\",\n\t\tProductID:   \"productID\",\n\t\tQuantity:    2,\n\t\tPrice:       19.99,\n\t\tCreatedTime: time.Now(),\n\t}\n\n\treturn order, nil\n}\n\nfunc (os *OrderService) CancelOrder(ctx context.Context, orderID string) error {\n\tif orderID == \"\" {\n\t\treturn errors.New(\"invalid order ID\")\n\t}\n\n\t// TODO: Cancel the order in database\n\n\tfmt.Printf(\"Order %s has been cancelled\", orderID)\n\n\treturn nil\n}"}
{"sample": "package mariadbclient\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID       int\n\tUsername string\n\tEmail    string\n}\n\nfunc CreateUser(username, email string) error {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tstmt, err := db.Prepare(\"INSERT INTO users(username, email) VALUES(?, ?)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(username, email)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc GetUser(id int) (*User, error) {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer db.Close()\n\n\trow := db.QueryRow(\"SELECT id, username, email FROM users WHERE id=?\", id)\n\n\tvar user User\n\terr = row.Scan(&user.ID, &user.Username, &user.Email)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn nil, fmt.Errorf(\"User not found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn &user, nil\n}\n\nfunc UpdateUser(id int, username, email string) error {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tstmt, err := db.Prepare(\"UPDATE users SET username=?, email=? WHERE id=?\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(username, email, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc DeleteUser(id int) error {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tstmt, err := db.Prepare(\"DELETE FROM users WHERE id=?\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc GetAllUsers() ([]User, error) {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT id, username, email FROM users\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tusers := []User{}\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Email)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\n\treturn users, nil\n}"}
{"sample": "package jiraclient\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/andygrunwald/go-jira\"\n)\n\ntype JiraClient struct {\n\tclient *jira.Client\n}\n\nfunc NewJiraClient(url, username, password string) (*JiraClient, error) {\n\ttp := jira.BasicAuthTransport{\n\t\tUsername: username,\n\t\tPassword: password,\n\t}\n\n\tjiraClient, err := jira.NewClient(tp.Client(), url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &JiraClient{client: jiraClient}, nil\n}\n\nfunc (jc *JiraClient) GetIssue(issueID string) (*jira.Issue, error) {\n\tissue, _, err := jc.client.Issue.Get(issueID, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn issue, nil\n}\n\nfunc (jc *JiraClient) CreateIssue(projectKey, issueType, summary, description string) (*jira.Issue, error) {\n\tnewIssue := &jira.Issue{\n\t\tFields: &jira.IssueFields{\n\t\t\tProject: jira.Project{\n\t\t\t\tKey: projectKey,\n\t\t\t},\n\t\t\tSummary:     summary,\n\t\t\tDescription: description,\n\t\t\tType: jira.IssueType{\n\t\t\t\tName: issueType,\n\t\t\t},\n\t\t},\n\t}\n\n\tissue, _, err := jc.client.Issue.Create(newIssue)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn issue, nil\n}\n\nfunc (jc *JiraClient) SearchIssues(jql string) ([]jira.Issue, error) {\n\tsearchOptions := &jira.SearchOptions{\n\t\tMaxResults: 100,\n\t}\n\n\tissues, _, err := jc.client.Issue.Search(jql, searchOptions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn issues, nil\n}\n\nfunc (jc *JiraClient) AddComment(issueID, comment string) error {\n\tnewComment := &jira.Comment{\n\t\tBody: comment,\n\t}\n\n\t_, err := jc.client.Issue.AddComment(issueID, newComment)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package bintreesearch\n\ntype node struct {\n\tvalue int\n\tleft  *node\n\tright *node\n}\n\ntype Tree struct {\n\troot *node\n}\n\nfunc (t *Tree) Insert(value int) {\n\tif t.root == nil {\n\t\tt.root = &node{value: value}\n\t\treturn\n\t}\n\n\tcurrent := t.root\n\tfor {\n\t\tif value < current.value {\n\t\t\tif current.left == nil {\n\t\t\t\tcurrent.left = &node{value: value}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent = current.left\n\t\t} else {\n\t\t\tif current.right == nil {\n\t\t\t\tcurrent.right = &node{value: value}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent = current.right\n\t\t}\n\t}\n}\n\nfunc (t *Tree) Search(value int) bool {\n\tcurrent := t.root\n\tfor current != nil {\n\t\tif value == current.value {\n\t\t\treturn true\n\t\t} else if value < current.value {\n\t\t\tcurrent = current.left\n\t\t} else {\n\t\t\tcurrent = current.right\n\t\t}\n\t}\n\treturn false\n}"}
{"sample": "package reviewservice\n\nimport (\n\t\"errors\"\n\t\"log\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Review struct {\n\tID       uuid.UUID\n\tCustomer string\n\tRating   int\n\tComment  string\n}\n\ntype ReviewService struct {\n\tReviews []Review\n}\n\nfunc (rs *ReviewService) AddReview(customer string, rating int, comment string) (uuid.UUID, error) {\n\tif customer == \"\" {\n\t\treturn uuid.Nil, errors.New(\"customer name cannot be empty\")\n\t}\n\tif rating < 1 || rating > 5 {\n\t\treturn uuid.Nil, errors.New(\"rating must be between 1 and 5\")\n\t}\n\n\tid := uuid.New()\n\treview := Review{\n\t\tID:       id,\n\t\tCustomer: customer,\n\t\tRating:   rating,\n\t\tComment:  comment,\n\t}\n\n\trs.Reviews = append(rs.Reviews, review)\n\n\tlog.Printf(\"Added new review: %v\", review)\n\n\treturn id, nil\n}\n\nfunc (rs *ReviewService) GetReviews() []Review {\n\treturn rs.Reviews\n}"}
{"sample": "package postgresclient\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n)\n\ntype PostgresClient struct {\n\tdb *sql.DB\n}\n\nfunc NewPostgresClient(connStr string) (*PostgresClient, error) {\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := db.Ping(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &PostgresClient{db: db}, nil\n}\n\nfunc (p *PostgresClient) Close() error {\n\treturn p.db.Close()\n}\n\nfunc (p *PostgresClient) Create(name string, age int) error {\n\t_, err := p.db.Exec(\"INSERT INTO users (name, age) VALUES ($1, $2)\", name, age)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (p *PostgresClient) Read(id int) (string, int, error) {\n\tvar name string\n\tvar age int\n\n\terr := p.db.QueryRow(\"SELECT name, age FROM users WHERE id = $1\", id).Scan(&name, &age)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn \"\", 0, fmt.Errorf(\"user not found\")\n\t\t}\n\t\treturn \"\", 0, err\n\t}\n\n\treturn name, age, nil\n}\n\nfunc (p *PostgresClient) Update(id int, name string, age int) error {\n\t_, err := p.db.Exec(\"UPDATE users SET name = $1, age = $2 WHERE id = $3\", name, age, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (p *PostgresClient) Delete(id int) error {\n\t_, err := p.db.Exec(\"DELETE FROM users WHERE id = $1\", id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc Example() {\n\tconnStr := \"postgres://user:password@localhost:5432/mydb?sslmode=disable\"\n\tclient, err := NewPostgresClient(connStr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer client.Close()\n\n\tif err := client.Create(\"John Doe\", 30); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tname, age, err := client.Read(1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\n\n\tif err := client.Update(1, \"Jane Doe\", 35); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := client.Delete(1); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package escluster\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/elastic/go-elasticsearch/v8\"\n)\n\ntype Cluster struct {\n\tclient *elasticsearch.Client\n}\n\nfunc NewCluster(addresses []string) (*Cluster, error) {\n\tcfg := elasticsearch.Config{\n\t\tAddresses: addresses,\n\t}\n\n\tclient, err := elasticsearch.NewClient(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Cluster{client: client}, nil\n}\n\nfunc (c *Cluster) GetClusterHealth() (string, error) {\n\tres, err := c.client.Cluster.Health(\n\t\tc.client.Cluster.Health.WithContext(context.Background()),\n\t\tc.client.Cluster.Health.WithPretty(),\n\t)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(\"Cluster status: %s\", res.Status), nil\n}\n\nfunc (c *Cluster) GetIndexMappings(index string) (string, error) {\n\tres, err := c.client.Indices.GetMapping(\n\t\tc.client.Indices.GetMapping.WithContext(context.Background()),\n\t\tc.client.Indices.GetMapping.WithIndex(index),\n\t\tc.client.Indices.GetMapping.WithPretty(),\n\t)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(\"Mappings for index %s: %s\", index, res), nil\n}"}
{"sample": "package radixsort\n\nfunc getMax(arr []int) int {\n\tmax := arr[0]\n\tfor _, val := range arr {\n\t\tif val > max {\n\t\t\tmax = val\n\t\t}\n\t}\n\treturn max\n}\n\nfunc countSort(arr []int, exp int) []int {\n\tn := len(arr)\n\toutput := make([]int, n)\n\tcount := make([]int, 10)\n\n\tfor i := 0; i < n; i++ {\n\t\tindex := (arr[i] / exp) % 10\n\t\tcount[index]++\n\t}\n\n\tfor i := 1; i < 10; i++ {\n\t\tcount[i] += count[i-1]\n\t}\n\n\tfor i := n - 1; i >= 0; i-- {\n\t\tindex := (arr[i] / exp) % 10\n\t\toutput[count[index]-1] = arr[i]\n\t\tcount[index]--\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tarr[i] = output[i]\n\t}\n\n\treturn arr\n}\n\nfunc RadixSort(arr []int) []int {\n\tmax := getMax(arr)\n\n\tfor exp := 1; max/exp > 0; exp *= 10 {\n\t\tarr = countSort(arr, exp)\n\t}\n\n\treturn arr\n}"}
{"sample": "package addressservice\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\tpb \"github.com/user/addressbook/proto\"\n)\n\ntype AddressBookService struct {\n\tpb.UnimplementedAddressBookServer\n}\n\nfunc (s *AddressBookService) AddContact(ctx context.Context, req *pb.AddContactRequest) (*pb.AddContactResponse, error) {\n\tlog.Printf(\"Received: %v\", req)\n\n\t// Add contact to database\n\tcontact := &pb.Contact{\n\t\tName:  req.GetName(),\n\t\tEmail: req.GetEmail(),\n\t\tPhone: req.GetPhone(),\n\t}\n\n\t// Return response\n\treturn &pb.AddContactResponse{\n\t\tContact: contact,\n\t}, nil\n}\n\nfunc (s *AddressBookService) GetContact(ctx context.Context, req *pb.GetContactRequest) (*pb.GetContactResponse, error) {\n\tlog.Printf(\"Received: %v\", req)\n\n\t// Get contact from database\n\tcontact := &pb.Contact{\n\t\tName:  \"John Doe\",\n\t\tEmail: \"johndoe@example.com\",\n\t\tPhone: \"555-555-5555\",\n\t}\n\n\tif req.GetId() == \"invalid-id\" {\n\t\terr := status.Error(codes.NotFound, \"Contact not found\")\n\t\treturn nil, err\n\t}\n\n\t// Return response\n\treturn &pb.GetContactResponse{\n\t\tContact: contact,\n\t}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", 8080))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterAddressBookServer(s, &AddressBookService{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package httpclient\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc Get(url string) ([]byte, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n\nfunc Post(url string, data []byte) ([]byte, error) {\n\tresp, err := http.Post(url, \"application/json\", bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n\nfunc main() {\n\turl := \"https://jsonplaceholder.typicode.com/posts/1\"\n\tresp, err := Get(url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(resp))\n}"}
{"sample": "package neo4jclient\n\nimport (\n\t\"fmt\"\n\t\"github.com/neo4j/neo4j-go-driver/v4/neo4j\"\n)\n\ntype Neo4jClient struct {\n\tdriver neo4j.Driver\n}\n\nfunc NewNeo4jClient(uri, username, password string) (*Neo4jClient, error) {\n\tdriver, err := neo4j.NewDriver(uri, neo4j.BasicAuth(username, password, \"\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Neo4jClient{driver: driver}, nil\n}\n\nfunc (c *Neo4jClient) Close() error {\n\treturn c.driver.Close()\n}\n\nfunc (c *Neo4jClient) Run(query string, params map[string]interface{}) ([][]interface{}, error) {\n\tsession := c.driver.NewSession(neo4j.SessionConfig{})\n\tdefer session.Close()\n\n\tresult, err := session.Run(query, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rows [][]interface{}\n\tfor result.Next() {\n\t\trow := make([]interface{}, len(result.Record().Values))\n\t\tfor i, value := range result.Record().Values {\n\t\t\trow[i] = value\n\t\t}\n\t\trows = append(rows, row)\n\t}\n\n\tif err := result.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn rows, nil\n}\n\nfunc (c *Neo4jClient) GetNode(id int64) (map[string]interface{}, error) {\n\tquery := \"MATCH (n) WHERE id(n) = $id RETURN n\"\n\tparams := map[string]interface{}{\"id\": id}\n\n\trows, err := c.Run(query, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(rows) == 0 {\n\t\treturn nil, fmt.Errorf(\"node not found\")\n\t}\n\n\treturn rows[0][0].(neo4j.Node).Props(), nil\n}"}
{"sample": "package bucketsort\n\nfunc BucketSort(arr []int) []int {\n\tif len(arr) < 2 {\n\t\treturn arr\n\t}\n\n\tbuckets := make([][]int, 10)\n\n\tfor _, num := range arr {\n\t\tbucketIndex := num / 10\n\t\tbuckets[bucketIndex] = append(buckets[bucketIndex], num)\n\t}\n\n\tvar result []int\n\tfor _, bucket := range buckets {\n\t\tif len(bucket) > 0 {\n\t\t\tresult = append(result, BucketSort(bucket)...)\n\t\t}\n\t}\n\n\treturn result\n}"}
{"sample": "package appointmentservice\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\ntype Appointment struct {\n\tID        int\n\tStartTime time.Time\n\tEndTime   time.Time\n\tUserID    int\n}\n\ntype AppointmentService struct {\n\tappointments []Appointment\n}\n\nfunc (s *AppointmentService) ScheduleAppointment(startTime, endTime time.Time, userID int) (int, error) {\n\tif startTime.Before(time.Now()) {\n\t\treturn 0, errors.New(\"start time must be in the future\")\n\t}\n\n\tif startTime.After(endTime) {\n\t\treturn 0, errors.New(\"end time must be after start time\")\n\t}\n\n\tfor _, appointment := range s.appointments {\n\t\tif appointment.StartTime.Before(endTime) && appointment.EndTime.After(startTime) {\n\t\t\treturn 0, errors.New(\"appointment conflicts with existing appointment\")\n\t\t}\n\t}\n\n\tid := len(s.appointments) + 1\n\ts.appointments = append(s.appointments, Appointment{\n\t\tID:        id,\n\t\tStartTime: startTime,\n\t\tEndTime:   endTime,\n\t\tUserID:    userID,\n\t})\n\n\treturn id, nil\n}\n\nfunc (s *AppointmentService) GetAppointmentsForUser(userID int) []Appointment {\n\tvar appointments []Appointment\n\tfor _, appointment := range s.appointments {\n\t\tif appointment.UserID == userID {\n\t\t\tappointments = append(appointments, appointment)\n\t\t}\n\t}\n\treturn appointments\n}"}
{"sample": "package imapclient\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/mail\"\n\t\"net/smtp\"\n\t\"strings\"\n\n\t\"github.com/emersion/go-imap\"\n\t\"github.com/emersion/go-imap/client\"\n\t\"github.com/emersion/go-message\"\n)\n\nfunc fetchMessages() error {\n\tc, err := client.DialTLS(\"imap.example.com:993\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer c.Logout()\n\n\tif err := c.Login(\"username\", \"password\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Select INBOX\n\tmbox, err := c.Select(\"INBOX\", false)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Get the last 10 messages\n\tfrom := uint32(1)\n\tto := mbox.Messages\n\tif mbox.Messages > 10 {\n\t\t// We're using unsigned integers here, only subtract if the result is > 0\n\t\tfrom = mbox.Messages - 9\n\t}\n\n\tseqset := new(imap.SeqSet)\n\tseqset.AddRange(from, to)\n\n\tmessages := make(chan *imap.Message, 10)\n\tdone := make(chan error, 1)\n\tgo func() {\n\t\tdone <- c.Fetch(seqset, []imap.FetchItem{imap.FetchEnvelope}, messages)\n\t}()\n\n\tfor msg := range messages {\n\t\tr := msg.GetEnvelope()\n\n\t\tif r.Subject != \"\" {\n\t\t\tfmt.Println(\"Subject:\", r.Subject)\n\t\t}\n\t\tif r.From != nil {\n\t\t\tfmt.Println(\"From:\", r.From[0].PersonalName)\n\t\t}\n\t\tif r.Date != \"\" {\n\t\t\tfmt.Println(\"Date:\", r.Date)\n\t\t}\n\n\t\t// Get the whole message body\n\t\tsection := &imap.BodySectionName{}\n\t\titems := []imap.FetchItem{section.FetchItem()}\n\t\tmessages := make(chan *imap.Message, 1)\n\t\tdone := make(chan error, 1)\n\t\tgo func() {\n\t\t\tdone <- c.Fetch(seqset, items, messages)\n\t\t}()\n\n\t\tmsg := <-messages\n\t\tif err := <-done; err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tr := msg.GetBody(section)\n\t\tif r == nil {\n\t\t\tlog.Fatal(\"Server didn't returned message body\")\n\t\t}\n\n\t\t// Create a new mail reader\n\t\tmr, err := message.NewReader(r)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Print the message body\n\t\tif body, err := mail.ReadMessage(mr); err == nil {\n\t\t\tfmt.Println(\"Body:\", body.Body)\n\t\t}\n\t}\n\n\tif err := <-done; err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn nil\n}\n\nfunc sendEmail(to, subject, body string) error {\n\tfrom := \"youremail@example.com\"\n\tpass := \"yourpassword\"\n\n\tmsg := \"From: \" + from + \"\\n\" +\n\t\t\"To: \" + to + \"\\n\" +\n\t\t\"Subject: \" + subject + \"\\n\\n\" +\n\t\tbody\n\n\terr := smtp.SendMail(\"smtp.example.com:587\",\n\t\tsmtp.PlainAuth(\"\", from, pass, \"smtp.example.com\"),\n\t\tfrom, []string{to}, []byte(msg))\n\n\tif err != nil {\n\t\tlog.Printf(\"smtp error: %s\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc searchMessages(query string) error {\n\tc, err := client.DialTLS(\"imap.example.com:993\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer c.Logout()\n\n\tif err := c.Login(\"username\", \"password\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Select INBOX\n\tmbox, err := c.Select(\"INBOX\", false)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Search for messages\n\tcriteria := imap.NewSearchCriteria()\n\tcriteria.Text = []string{query}\n\tids, err := c.Search(criteria)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif len(ids) == 0 {\n\t\tfmt.Println(\"No results found\")\n\t\treturn nil\n\t}\n\n\tseqset := new(imap.SeqSet)\n\tseqset.AddNum(ids...)\n\n\tmessages := make(chan *imap.Message, 10)\n\tdone := make(chan error, 1)\n\tgo func() {\n\t\tdone <- c.Fetch(seqset, []imap.FetchItem{imap.FetchEnvelope}, messages)\n\t}()\n\n\tfor msg := range messages {\n\t\tr := msg.GetEnvelope()\n\n\t\tif r.Subject != \"\" {\n\t\t\tfmt.Println(\"Subject:\", r.Subject)\n\t\t}\n\t\tif r.From != nil {\n\t\t\tfmt.Println(\"From:\", r.From[0].PersonalName)\n\t\t}\n\t\tif r.Date != \"\" {\n\t\t\tfmt.Println(\"Date:\", r.Date)\n\t\t}\n\n\t\t// Get the whole message body\n\t\tsection := &imap.BodySectionName{}\n\t\titems := []imap.FetchItem{section.FetchItem()}\n\t\tmessages := make(chan *imap.Message, 1)\n\t\tdone := make(chan error, 1)\n\t\tgo func() {\n\t\t\tdone <- c.Fetch(seqset, items, messages)\n\t\t}()\n\n\t\tmsg := <-messages\n\t\tif err := <-done; err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tr := msg.GetBody(section)\n\t\tif r == nil {\n\t\t\tlog.Fatal(\"Server didn't returned message body\")\n\t\t}\n\n\t\t// Create a new mail reader\n\t\tmr, err := message.NewReader(r)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Print the message body\n\t\tif body, err := mail.ReadMessage(mr); err == nil {\n\t\t\tfmt.Println(\"Body:\", body.Body)\n\t\t}\n\t}\n\n\tif err := <-done; err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn nil\n}"}
{"sample": "package firestoreclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\tfirebase \"firebase.google.com/go\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/api/iterator\"\n\t\"google.golang.org/api/option/firestore\"\n)\n\ntype FirestoreClient struct {\n\tclient *firestore.Client\n}\n\nfunc NewFirestoreClient(ctx context.Context, projectID string, credentialsFile string) (*FirestoreClient, error) {\n\topt := option.WithCredentialsFile(credentialsFile)\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initializing app: %v\", err)\n\t}\n\n\tclient, err := app.Firestore(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting Firestore client: %v\", err)\n\t}\n\n\treturn &FirestoreClient{client}, nil\n}\n\nfunc (fc *FirestoreClient) AddDocument(collection string, data map[string]interface{}) error {\n\t_, err := fc.client.Collection(collection).Doc().Set(context.Background(), data)\n\tif err != nil {\n\t\tlog.Printf(\"Error adding document: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (fc *FirestoreClient) GetDocuments(collection string) ([]map[string]interface{}, error) {\n\tvar documents []map[string]interface{}\n\titer := fc.client.Collection(collection).Documents(context.Background())\n\tfor {\n\t\tdoc, err := iter.Next()\n\t\tif err == iterator.Done {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error getting document: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tdocuments = append(documents, doc.Data())\n\t}\n\treturn documents, nil\n}\n\nfunc (fc *FirestoreClient) DeleteDocument(collection string, documentID string) error {\n\t_, err := fc.client.Collection(collection).Doc(documentID).Delete(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error deleting document: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"sample": "package heapsort\n\nimport (\n\t\"fmt\"\n)\n\nfunc heapSort(arr []int) []int {\n\tn := len(arr)\n\n\tfor i := n/2 - 1; i >= 0; i-- {\n\t\theapify(arr, n, i)\n\t}\n\n\tfor i := n - 1; i >= 0; i-- {\n\t\tarr[0], arr[i] = arr[i], arr[0]\n\t\theapify(arr, i, 0)\n\t}\n\n\treturn arr\n}\n\nfunc heapify(arr []int, n int, i int) {\n\tlargest := i\n\tleft := 2*i + 1\n\tright := 2*i + 2\n\n\tif left < n && arr[left] > arr[largest] {\n\t\tlargest = left\n\t}\n\n\tif right < n && arr[right] > arr[largest] {\n\t\tlargest = right\n\t}\n\n\tif largest != i {\n\t\tarr[i], arr[largest] = arr[largest], arr[i]\n\t\theapify(arr, n, largest)\n\t}\n}\n\nfunc main() {\n\tarr := []int{12, 11, 13, 5, 6, 7}\n\tfmt.Println(\"Unsorted array:\", arr)\n\tfmt.Println(\"Sorted array:\", heapSort(arr))\n}"}
{"sample": "package behaviorservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/jmoiron/sqlx\"\n)\n\ntype Behavior struct {\n\tID        uuid.UUID `db:\"id\"`\n\tUserID    uuid.UUID `db:\"user_id\"`\n\tEvent     string    `db:\"event\"`\n\tCreatedAt time.Time `db:\"created_at\"`\n}\n\ntype BehaviorService struct {\n\tDB *sqlx.DB\n}\n\nfunc (s *BehaviorService) LogBehavior(ctx context.Context, userID uuid.UUID, event string) error {\n\tif userID == uuid.Nil {\n\t\treturn errors.New(\"invalid user ID\")\n\t}\n\n\tif event == \"\" {\n\t\treturn errors.New(\"invalid event\")\n\t}\n\n\tbehavior := Behavior{\n\t\tID:        uuid.New(),\n\t\tUserID:    userID,\n\t\tEvent:     event,\n\t\tCreatedAt: time.Now(),\n\t}\n\n\t_, err := s.DB.NamedExecContext(ctx, \"INSERT INTO behaviors (id, user_id, event, created_at) VALUES (:id, :user_id, :event, :created_at)\", behavior)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn errors.New(\"failed to log behavior\")\n\t}\n\n\treturn nil\n}\n\nfunc (s *BehaviorService) GetBehaviorsByUser(ctx context.Context, userID uuid.UUID) ([]Behavior, error) {\n\tif userID == uuid.Nil {\n\t\treturn nil, errors.New(\"invalid user ID\")\n\t}\n\n\tvar behaviors []Behavior\n\terr := s.DB.SelectContext(ctx, &behaviors, \"SELECT * FROM behaviors WHERE user_id = $1\", userID)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, errors.New(\"failed to get behaviors\")\n\t}\n\n\treturn behaviors, nil\n}"}
{"sample": "package telnetclient\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc TelnetClient() {\n\tconn, err := net.Dial(\"tcp\", \"localhost:23\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"Enter text: \")\n\t\tscanner.Scan()\n\t\ttext := scanner.Text()\n\n\t\tif text == \"quit\" {\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Fprintf(conn, text+\"\\n\")\n\n\t\tmessage, err := bufio.NewReader(conn).ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Print(\"Message from server: \" + message)\n\t}\n}"}
{"sample": "package driveclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"google.golang.org/api/drive/v3\"\n\t\"google.golang.org/api/option\"\n)\n\ntype DriveClient struct {\n\tservice *drive.Service\n}\n\nfunc NewDriveClient(credentialsFile string) (*DriveClient, error) {\n\tctx := context.Background()\n\n\tcreds, err := os.ReadFile(credentialsFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to read client secret file: %v\", err)\n\t}\n\n\tconfig, err := google.ConfigFromJSON(creds, drive.DriveScope)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse client secret file to config: %v\", err)\n\t}\n\n\tclient := getClient(ctx, config)\n\n\tsrv, err := drive.NewService(ctx, option.WithHTTPClient(client))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to retrieve Drive client: %v\", err)\n\t}\n\n\treturn &DriveClient{service: srv}, nil\n}\n\nfunc (c *DriveClient) UploadFile(filename string, r io.Reader) error {\n\tfile := &drive.File{Name: filename}\n\t_, err := c.service.Files.Create(file).Media(r).Do()\n\tif err != nil {\n\t\tlog.Printf(\"Unable to upload file: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc getClient(ctx context.Context, config *oauth2.Config) *http.Client {\n\ttokenFile := \"token.json\"\n\ttok, err := tokenFromFile(tokenFile)\n\tif err != nil {\n\t\ttok = getTokenFromWeb(config)\n\t\tsaveToken(tokenFile, tok)\n\t}\n\treturn config.Client(ctx, tok)\n}\n\nfunc getTokenFromWeb(config *oauth2.Config) *oauth2.Token {\n\tauthURL := config.AuthCodeURL(\"state-token\", oauth2.AccessTypeOffline)\n\tfmt.Printf(\"Go to the following link in your browser then type the \"+\n\t\t\"authorization code: \\n%v\\n\", authURL)\n\n\tvar authCode string\n\tif _, err := fmt.Scan(&authCode); err != nil {\n\t\tlog.Fatalf(\"Unable to read authorization code: %v\", err)\n\t}\n\n\ttok, err := config.Exchange(context.Background(), authCode)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve token from web: %v\", err)\n\t}\n\treturn tok\n}\n\nfunc tokenFromFile(file string) (*oauth2.Token, error) {\n\tf, err := os.Open(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\ttok := &oauth2.Token{}\n\terr = json.NewDecoder(f).Decode(tok)\n\treturn tok, err\n}\n\nfunc saveToken(file string, token *oauth2.Token) {\n\tlog.Printf(\"Saving credential file to: %s\\n\", file)\n\tf, err := os.OpenFile(file, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to cache oauth token: %v\", err)\n\t}\n\tdefer f.Close()\n\tjson.NewEncoder(f).Encode(token)\n}"}
{"sample": "package bubblesort\n\n// BubbleSort sorts a slice of integers in ascending order using the bubble sort algorithm.\nfunc BubbleSort(nums []int) {\n\tn := len(nums)\n\tfor i := 0; i < n-1; i++ {\n\t\tfor j := 0; j < n-i-1; j++ {\n\t\t\tif nums[j] > nums[j+1] {\n\t\t\t\tnums[j], nums[j+1] = nums[j+1], nums[j]\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "package achievementservice\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n)\n\ntype Achievement struct {\n\tID          int\n\tName        string\n\tDescription string\n}\n\ntype AchievementService struct {\n\tdb *sql.DB\n}\n\nfunc NewAchievementService(db *sql.DB) *AchievementService {\n\treturn &AchievementService{db: db}\n}\n\nfunc (s *AchievementService) CreateAchievement(a *Achievement) error {\n\tif a == nil {\n\t\treturn errors.New(\"achievement is nil\")\n\t}\n\n\tstmt, err := s.db.Prepare(\"INSERT INTO achievements(name, description) VALUES(?, ?)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tresult, err := stmt.Exec(a.Name, a.Description)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tid, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ta.ID = int(id)\n\n\treturn nil\n}\n\nfunc (s *AchievementService) GetAchievement(id int) (*Achievement, error) {\n\tstmt, err := s.db.Prepare(\"SELECT id, name, description FROM achievements WHERE id = ?\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\trow := stmt.QueryRow(id)\n\n\tvar a Achievement\n\terr = row.Scan(&a.ID, &a.Name, &a.Description)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &a, nil\n}\n\nfunc (s *AchievementService) UpdateAchievement(a *Achievement) error {\n\tif a == nil {\n\t\treturn errors.New(\"achievement is nil\")\n\t}\n\n\tstmt, err := s.db.Prepare(\"UPDATE achievements SET name = ?, description = ? WHERE id = ?\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(a.Name, a.Description, a.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *AchievementService) DeleteAchievement(id int) error {\n\tstmt, err := s.db.Prepare(\"DELETE FROM achievements WHERE id = ?\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *AchievementService) ListAchievements() ([]*Achievement, error) {\n\trows, err := s.db.Query(\"SELECT id, name, description FROM achievements\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tachievements := make([]*Achievement, 0)\n\tfor rows.Next() {\n\t\tvar a Achievement\n\t\terr := rows.Scan(&a.ID, &a.Name, &a.Description)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tachievements = append(achievements, &a)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn achievements, nil\n}\n\nfunc (a *Achievement) String() string {\n\treturn fmt.Sprintf(\"ID: %d, Name: %s, Description: %s\", a.ID, a.Name, a.Description)\n}"}
{"sample": "package snmpclient\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/gosnmp/gosnmp\"\n)\n\nfunc getSNMP() {\n\tparams := &gosnmp.GoSNMP{\n\t\tTarget:    \"localhost\",\n\t\tPort:      161,\n\t\tCommunity: \"public\",\n\t\tVersion:   gosnmp.Version2c,\n\t\tTimeout:   time.Duration(2) * time.Second,\n\t\tMaxOids:   gosnmp.MaxOids,\n\t}\n\n\terr := params.Connect()\n\tif err != nil {\n\t\tlog.Fatalf(\"Connect err: %v\", err)\n\t}\n\tdefer params.Conn.Close()\n\n\tresult, err := params.Get([]string{\".1.3.6.1.2.1.1.1.0\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"Get err: %v\", err)\n\t}\n\n\tfor _, variable := range result.Variables {\n\t\tswitch variable.Type {\n\t\tcase gosnmp.OctetString:\n\t\t\tfmt.Printf(\"Response: %s : %s \\n\", variable.Name, string(variable.Value.([]byte)))\n\t\tdefault:\n\t\t\tfmt.Printf(\"Response: %s : %d \\n\", variable.Name, gosnmp.ToBigInt(variable.Value))\n\t\t}\n\t}\n}\n\nfunc listenSNMP() {\n\tconn, err := net.ListenPacket(\"udp\", \"127.0.0.1:162\")\n\tif err != nil {\n\t\tlog.Fatalf(\"ListenPacket err: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tbuf := make([]byte, 1024)\n\t\tn, addr, err := conn.ReadFrom(buf)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"ReadFrom err: %v\", err)\n\t\t}\n\n\t\tfmt.Printf(\"Received: %s from %s\\n\", buf[:n], addr)\n\t}\n}"}
{"sample": "package sheetsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/api/sheets/v4\"\n)\n\ntype SheetsClient struct {\n\tservice *sheets.Service\n}\n\nfunc NewSheetsClient(credentialsFile string) (*SheetsClient, error) {\n\tctx := context.Background()\n\tclientOptions := option.WithCredentialsFile(credentialsFile)\n\n\tservice, err := sheets.NewService(ctx, clientOptions)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create sheets service: %v\", err)\n\t}\n\n\treturn &SheetsClient{service: service}, nil\n}\n\nfunc (c *SheetsClient) ReadSheet(spreadsheetID string, sheetName string) ([][]interface{}, error) {\n\treadRange := sheetName + \"!A1:Z\"\n\tresp, err := c.service.Spreadsheets.Values.Get(spreadsheetID, readRange).Do()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read sheet: %v\", err)\n\t}\n\n\tif len(resp.Values) == 0 {\n\t\tlog.Println(\"No data found.\")\n\t\treturn nil, nil\n\t}\n\n\treturn resp.Values, nil\n}\n\nfunc (c *SheetsClient) WriteToSheet(spreadsheetID string, sheetName string, values [][]interface{}) error {\n\twriteRange := sheetName + \"!A1:Z\"\n\tvalueRange := &sheets.ValueRange{\n\t\tValues: values,\n\t}\n\n\t_, err := c.service.Spreadsheets.Values.Update(spreadsheetID, writeRange, valueRange).ValueInputOption(\"USER_ENTERED\").Do()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write to sheet: %v\", err)\n\t}\n\n\treturn nil\n}"}
{"sample": "package selectionsort\n\n// SelectionSort sorts an array of integers using the selection sort algorithm\nfunc SelectionSort(arr []int) {\n\tfor i := 0; i < len(arr)-1; i++ {\n\t\tminIndex := i\n\t\tfor j := i + 1; j < len(arr); j++ {\n\t\t\tif arr[j] < arr[minIndex] {\n\t\t\t\tminIndex = j\n\t\t\t}\n\t\t}\n\t\tif minIndex != i {\n\t\t\tarr[i], arr[minIndex] = arr[minIndex], arr[i]\n\t\t}\n\t}\n}"}
{"sample": "package feedbackservice\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/streadway/amqp\"\n)\n\ntype Feedback struct {\n\tID      string `json:\"id\"`\n\tMessage string `json:\"message\"`\n}\n\nfunc handleFeedback(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tvar feedback Feedback\n\terr := json.NewDecoder(r.Body).Decode(&feedback)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr = publishFeedbackToQueue(feedback)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprint(w, \"Feedback received successfully\")\n}\n\nfunc publishFeedbackToQueue(feedback Feedback) error {\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"feedback_queue\", // name\n\t\tfalse,            // durable\n\t\tfalse,            // delete when unused\n\t\tfalse,            // exclusive\n\t\tfalse,            // no-wait\n\t\tnil,              // arguments\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbody, err := json.Marshal(feedback)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ch.Publish(\n\t\t\"\",     // exchange\n\t\tq.Name, // routing key\n\t\tfalse,  // mandatory\n\t\tfalse,  // immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"application/json\",\n\t\t\tBody:        body,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/feedback\", handleFeedback).Methods(\"POST\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}"}
{"sample": "package sqlserverclient\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t_ \"github.com/denisenkom/go-mssqldb\"\n)\n\ntype SQLServerClient struct {\n\tserver   string\n\tport     int\n\tuser     string\n\tpassword string\n\tdatabase string\n}\n\ntype Employee struct {\n\tID        int\n\tFirstName string\n\tLastName  string\n\tAge       int\n}\n\nfunc NewSQLServerClient(server string, port int, user string, password string, database string) *SQLServerClient {\n\treturn &SQLServerClient{\n\t\tserver:   server,\n\t\tport:     port,\n\t\tuser:     user,\n\t\tpassword: password,\n\t\tdatabase: database,\n\t}\n}\n\nfunc (c *SQLServerClient) Connect() (*sql.DB, error) {\n\tconnString := fmt.Sprintf(\"server=%s;port=%d;user id=%s;password=%s;database=%s\", c.server, c.port, c.user, c.password, c.database)\n\tdb, err := sql.Open(\"sqlserver\", connString)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tif err = db.PingContext(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}\n\nfunc (c *SQLServerClient) GetEmployee(id int) (*Employee, error) {\n\tdb, err := c.Connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tquery := fmt.Sprintf(\"SELECT * FROM Employees WHERE ID=%d\", id)\n\trow := db.QueryRowContext(ctx, query)\n\n\tvar employee Employee\n\tif err := row.Scan(&employee.ID, &employee.FirstName, &employee.LastName, &employee.Age); err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn nil, fmt.Errorf(\"no employee with id %d\", id)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn &employee, nil\n}\n\nfunc (c *SQLServerClient) AddEmployee(employee *Employee) error {\n\tdb, err := c.Connect()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tquery := fmt.Sprintf(\"INSERT INTO Employees (FirstName, LastName, Age) VALUES ('%s', '%s', %d)\", employee.FirstName, employee.LastName, employee.Age)\n\t_, err = db.ExecContext(ctx, query)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *SQLServerClient) UpdateEmployee(employee *Employee) error {\n\tdb, err := c.Connect()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tquery := fmt.Sprintf(\"UPDATE Employees SET FirstName='%s', LastName='%s', Age=%d WHERE ID=%d\", employee.FirstName, employee.LastName, employee.Age, employee.ID)\n\t_, err = db.ExecContext(ctx, query)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *SQLServerClient) DeleteEmployee(id int) error {\n\tdb, err := c.Connect()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tquery := fmt.Sprintf(\"DELETE FROM Employees WHERE ID=%d\", id)\n\t_, err = db.ExecContext(ctx, query)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *SQLServerClient) GetAllEmployees() ([]Employee, error) {\n\tdb, err := c.Connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tquery := \"SELECT * FROM Employees\"\n\trows, err := db.QueryContext(ctx, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar employees []Employee\n\tfor rows.Next() {\n\t\tvar employee Employee\n\t\tif err := rows.Scan(&employee.ID, &employee.FirstName, &employee.LastName, &employee.Age); err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\temployees = append(employees, employee)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn employees, nil\n}"}
{"sample": "package calendarclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/api/calendar/v3\"\n\t\"google.golang.org/api/option\"\n)\n\ntype CalendarClient struct {\n\tservice *calendar.Service\n}\n\nfunc NewCalendarClient(credentialsFile string) (*CalendarClient, error) {\n\tctx := context.Background()\n\n\tcreds, err := google.FindDefaultCredentials(ctx, calendar.CalendarScope)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif credentialsFile != \"\" {\n\t\tcreds, err = google.CredentialsFromFile(ctx, credentialsFile, calendar.CalendarScope)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tclient := oauth2.NewClient(ctx, creds.TokenSource)\n\n\tsrv, err := calendar.NewService(ctx, option.WithHTTPClient(client))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &CalendarClient{service: srv}, nil\n}\n\nfunc (c *CalendarClient) ListEvents(calendarID string, start, end time.Time) ([]*calendar.Event, error) {\n\tevents, err := c.service.Events.List(calendarID).\n\t\tTimeMin(start.Format(time.RFC3339)).\n\t\tTimeMax(end.Format(time.RFC3339)).\n\t\tDo()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn events.Items, nil\n}\n\nfunc (c *CalendarClient) CreateEvent(calendarID string, event *calendar.Event) (*calendar.Event, error) {\n\tnewEvent, err := c.service.Events.Insert(calendarID, event).Do()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newEvent, nil\n}\n\nfunc (c *CalendarClient) DeleteEvent(calendarID, eventID string) error {\n\terr := c.service.Events.Delete(calendarID, eventID).Do()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *CalendarClient) UpdateEvent(calendarID, eventID string, event *calendar.Event) (*calendar.Event, error) {\n\tupdatedEvent, err := c.service.Events.Update(calendarID, eventID, event).Do()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn updatedEvent, nil\n}\n\nfunc (c *CalendarClient) GetEvent(calendarID, eventID string) (*calendar.Event, error) {\n\tevent, err := c.service.Events.Get(calendarID, eventID).Do()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn event, nil\n}\n\nfunc (c *CalendarClient) PrintEvent(event *calendar.Event) {\n\tfmt.Printf(\"Event: %s (%s)\\n\", event.Summary, event.Id)\n\tfmt.Printf(\"\\tStart Time: %s\\n\", event.Start.DateTime)\n\tfmt.Printf(\"\\tEnd Time: %s\\n\", event.End.DateTime)\n\tfmt.Printf(\"\\tDescription: %s\\n\", event.Description)\n\tfmt.Printf(\"\\tLocation: %s\\n\", event.Location)\n}\n\nfunc (c *CalendarClient) PrintEvents(events []*calendar.Event) {\n\tfor _, event := range events {\n\t\tc.PrintEvent(event)\n\t}\n}\n\nfunc (c *CalendarClient) Close() {\n\tlog.Println(\"Closing calendar client\")\n}"}
{"sample": "package shellsort\n\nfunc ShellSort(arr []int) {\n\tn := len(arr)\n\tgap := n / 2\n\n\tfor gap > 0 {\n\t\tfor i := gap; i < n; i++ {\n\t\t\ttemp := arr[i]\n\t\t\tj := i\n\n\t\t\tfor j >= gap && arr[j-gap] > temp {\n\t\t\t\tarr[j] = arr[j-gap]\n\t\t\t\tj -= gap\n\t\t\t}\n\n\t\t\tarr[j] = temp\n\t\t}\n\n\t\tgap /= 2\n\t}\n}"}
{"sample": "package performanceservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"models\"\n\t\"time\"\n)\n\ntype PerformanceService struct {\n\trepo models.PerformanceRepository\n}\n\nfunc NewPerformanceService(repo models.PerformanceRepository) *PerformanceService {\n\treturn &PerformanceService{\n\t\trepo: repo,\n\t}\n}\n\nfunc (s *PerformanceService) CreatePerformance(ctx context.Context, performance *models.Performance) error {\n\tif performance.EmployeeID == \"\" {\n\t\treturn errors.New(\"employee id is required\")\n\t}\n\n\tif performance.ManagerID == \"\" {\n\t\treturn errors.New(\"manager id is required\")\n\t}\n\n\tif performance.Rating < 1 || performance.Rating > 5 {\n\t\treturn errors.New(\"rating should be between 1 and 5\")\n\t}\n\n\tperformance.CreatedAt = time.Now().UTC()\n\n\treturn s.repo.CreatePerformance(ctx, performance)\n}\n\nfunc (s *PerformanceService) GetPerformance(ctx context.Context, id string) (*models.Performance, error) {\n\treturn s.repo.GetPerformance(ctx, id)\n}\n\nfunc (s *PerformanceService) GetPerformances(ctx context.Context, employeeID string, from, to time.Time) ([]*models.Performance, error) {\n\treturn s.repo.GetPerformances(ctx, employeeID, from, to)\n}\n\nfunc (s *PerformanceService) GetManagerPerformances(ctx context.Context, managerID string, from, to time.Time) ([]*models.Performance, error) {\n\treturn s.repo.GetManagerPerformances(ctx, managerID, from, to)\n}"}
{"sample": "package smtpclient\n\nimport (\n\t\"fmt\"\n\t\"net/smtp\"\n)\n\nfunc sendEmail(to []string, subject string, body string) error {\n\tfrom := \"example@gmail.com\"\n\tpassword := \"password\"\n\tsmtpHost := \"smtp.gmail.com\"\n\tsmtpPort := \"587\"\n\n\tauth := smtp.PlainAuth(\"\", from, password, smtpHost)\n\n\tmsg := []byte(fmt.Sprintf(\"To: %s\\r\\nSubject: %s\\r\\n\\r\\n%s\", to, subject, body))\n\n\terr := smtp.SendMail(smtpHost+\":\"+smtpPort, auth, from, to, msg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package analyticsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/api/analyticsreporting/v4\"\n\t\"google.golang.org/api/option\"\n)\n\ntype AnalyticsClient struct {\n\tsvc *analyticsreporting.Service\n}\n\nfunc NewAnalyticsClient(ctx context.Context, keyFile string) (*AnalyticsClient, error) {\n\tsvc, err := analyticsreporting.NewService(ctx, option.WithCredentialsFile(keyFile))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create analytics reporting service: %v\", err)\n\t}\n\n\treturn &AnalyticsClient{svc: svc}, nil\n}\n\nfunc (c *AnalyticsClient) GetReport(ctx context.Context, viewID string, startDate, endDate time.Time) (*analyticsreporting.GetReportsResponse, error) {\n\treq := &analyticsreporting.GetReportsRequest{\n\t\tReportRequests: []*analyticsreporting.ReportRequest{\n\t\t\t{\n\t\t\t\tViewId: viewID,\n\t\t\t\tDateRanges: []*analyticsreporting.DateRange{\n\t\t\t\t\t{\n\t\t\t\t\t\tStartDate: startDate.Format(\"2006-01-02\"),\n\t\t\t\t\t\tEndDate:   endDate.Format(\"2006-01-02\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tMetrics: []*analyticsreporting.Metric{\n\t\t\t\t\t{\n\t\t\t\t\t\tExpression: \"ga:sessions\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tDimensions: []*analyticsreporting.Dimension{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"ga:country\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tresp, err := c.svc.Reports.BatchGet(req).Context(ctx).Do()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to get analytics report: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}"}
{"sample": "package insertionsort\n\nfunc InsertionSort(arr []int) {\n\tfor i := 1; i < len(arr); i++ {\n\t\tkey := arr[i]\n\t\tj := i - 1\n\t\tfor ; j >= 0 && arr[j] > key; j-- {\n\t\t\tarr[j+1] = arr[j]\n\t\t}\n\t\tarr[j+1] = key\n\t}\n}"}
{"sample": "package taskservice\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/pkg/errors\"\n)\n\ntype Task struct {\n\tID        string\n\tTitle     string\n\tDueDate   time.Time\n\tCompleted bool\n}\n\ntype TaskService struct {\n\ttasks []Task\n}\n\nfunc NewTaskService() *TaskService {\n\treturn &TaskService{}\n}\n\nfunc (ts *TaskService) AddTask(ctx context.Context, title string, dueDate time.Time) (string, error) {\n\tif title == \"\" {\n\t\treturn \"\", errors.New(\"title cannot be empty\")\n\t}\n\n\tid := uuid.New().String()\n\n\ttask := Task{\n\t\tID:      id,\n\t\tTitle:   title,\n\t\tDueDate: dueDate,\n\t}\n\n\tts.tasks = append(ts.tasks, task)\n\n\treturn id, nil\n}\n\nfunc (ts *TaskService) CompleteTask(ctx context.Context, id string) error {\n\tfor i, task := range ts.tasks {\n\t\tif task.ID == id {\n\t\t\tts.tasks[i].Completed = true\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn errors.New(\"task not found\")\n}\n\nfunc (ts *TaskService) GetTasks(ctx context.Context) ([]Task, error) {\n\treturn ts.tasks, nil\n}\n\nfunc (ts *TaskService) GetTask(ctx context.Context, id string) (Task, error) {\n\tfor _, task := range ts.tasks {\n\t\tif task.ID == id {\n\t\t\treturn task, nil\n\t\t}\n\t}\n\n\treturn Task{}, errors.New(\"task not found\")\n}\n\nfunc (ts *TaskService) DeleteTask(ctx context.Context, id string) error {\n\tfor i, task := range ts.tasks {\n\t\tif task.ID == id {\n\t\t\tts.tasks = append(ts.tasks[:i], ts.tasks[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn errors.New(\"task not found\")\n}\n\nfunc (ts *TaskService) UpdateTask(ctx context.Context, id string, title string, dueDate time.Time) error {\n\tfor i, task := range ts.tasks {\n\t\tif task.ID == id {\n\t\t\tif title != \"\" {\n\t\t\t\tts.tasks[i].Title = title\n\t\t\t}\n\t\t\tif !dueDate.IsZero() {\n\t\t\t\tts.tasks[i].DueDate = dueDate\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn errors.New(\"task not found\")\n}\n\nfunc (ts *TaskService) Run() error {\n\tlog.Println(\"Task service started\")\n\n\t// Do some background task processing here\n\n\treturn nil\n}"}
{"sample": "package ftpserver\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype FTPServer struct {\n\troot string\n}\n\nfunc NewFTPServer(root string) *FTPServer {\n\treturn &FTPServer{root: root}\n}\n\nfunc (s *FTPServer) ListenAndServe(addr string) error {\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer listener.Close()\n\n\tlog.Printf(\"Listening on %v\", addr)\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to accept connection: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo s.handleConn(conn)\n\t}\n}\n\nfunc (s *FTPServer) handleConn(conn net.Conn) {\n\tdefer conn.Close()\n\n\tlog.Printf(\"Accepted connection from %v\", conn.RemoteAddr())\n\n\tfmt.Fprintf(conn, \"220 FTP Server Ready.\\r\\n\")\n\n\tvar user string\n\tvar authenticated bool\n\n\tfor {\n\t\tcmd, err := readCommand(conn)\n\t\tif err != nil {\n\t\t\tif err != io.EOF {\n\t\t\t\tlog.Printf(\"Failed to read command: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tlog.Printf(\"Received command: %v\", cmd)\n\n\t\tswitch cmd.Code {\n\t\tcase \"USER\":\n\t\t\tuser = cmd.Arg\n\t\t\tfmt.Fprintf(conn, \"331 Password required for %v.\\r\\n\", user)\n\t\tcase \"PASS\":\n\t\t\tif user == \"anonymous\" {\n\t\t\t\tfmt.Fprintf(conn, \"230 Logged on anonymously.\\r\\n\")\n\t\t\t\tauthenticated = true\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(conn, \"530 Login incorrect.\\r\\n\")\n\t\t\t}\n\t\tcase \"QUIT\":\n\t\t\tfmt.Fprintf(conn, \"221 Goodbye.\\r\\n\")\n\t\t\treturn\n\t\tcase \"SYST\":\n\t\t\tfmt.Fprintf(conn, \"215 UNIX Type: L8\\r\\n\")\n\t\tcase \"TYPE\":\n\t\t\tfmt.Fprintf(conn, \"200 Type set to %v.\\r\\n\", cmd.Arg)\n\t\tcase \"PWD\":\n\t\t\tfmt.Fprintf(conn, \"257 \\\"%v\\\" is the current directory.\\r\\n\", s.root)\n\t\tcase \"CWD\":\n\t\t\tpath := filepath.Join(s.root, cmd.Arg)\n\t\t\tif _, err := os.Stat(path); err != nil {\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to change directory.\\r\\n\")\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(conn, \"250 Directory changed to \\\"%v\\\".\\r\\n\", cmd.Arg)\n\t\t\t}\n\t\tcase \"LIST\":\n\t\t\tif !authenticated {\n\t\t\t\tfmt.Fprintf(conn, \"530 Not logged in.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpath := filepath.Join(s.root, cmd.Arg)\n\t\t\tif _, err := os.Stat(path); err != nil {\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to list directory.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Fprintf(conn, \"150 Opening data connection for directory list.\\r\\n\")\n\n\t\t\tfiles, err := os.ReadDir(path)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to read directory: %v\", err)\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to list directory.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, file := range files {\n\t\t\t\tinfo, err := file.Info()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to get file info: %v\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tmode := info.Mode().String()\n\t\t\t\tsize := info.Size()\n\t\t\t\tname := file.Name()\n\n\t\t\t\tif info.IsDir() {\n\t\t\t\t\tmode = \"d\" + mode[1:]\n\t\t\t\t\tsize = 0\n\t\t\t\t}\n\n\t\t\t\tfmt.Fprintf(conn, \"%v %3v %-8v %-8v %12v %v\\r\\n\",\n\t\t\t\t\tmode, 1, \"user\", \"group\", size, name)\n\t\t\t}\n\n\t\t\tfmt.Fprintf(conn, \"226 Directory send OK.\\r\\n\")\n\t\tcase \"RETR\":\n\t\t\tif !authenticated {\n\t\t\t\tfmt.Fprintf(conn, \"530 Not logged in.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpath := filepath.Join(s.root, cmd.Arg)\n\t\t\tif _, err := os.Stat(path); err != nil {\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to retrieve file.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Fprintf(conn, \"150 Opening data connection for file transfer.\\r\\n\")\n\n\t\t\tfile, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to open file: %v\", err)\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to retrieve file.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\tif _, err := io.Copy(conn, file); err != nil {\n\t\t\t\tlog.Printf(\"Failed to transfer file: %v\", err)\n\t\t\t\tfmt.Fprintf(conn, \"550 Failed to retrieve file.\\r\\n\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Fprintf(conn, \"226 File send OK.\\r\\n\")\n\t\tdefault:\n\t\t\tfmt.Fprintf(conn, \"502 Command not implemented.\\r\\n\")\n\t\t}\n\t}\n}\n\nfunc readCommand(conn net.Conn) (*command, error) {\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tline := strings.TrimSpace(string(buf[:n]))\n\tparts := strings.SplitN(line, \" \", 2)\n\n\tcmd := &command{Code: strings.ToUpper(parts[0])}\n\tif len(parts) > 1 {\n\t\tcmd.Arg = parts[1]\n\t}\n\n\treturn cmd, nil\n}\n\ntype command struct {\n\tCode string\n\tArg  string\n}"}
{"sample": "package docsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"google.golang.org/api/docs/v1\"\n\t\"google.golang.org/api/option\"\n)\n\ntype DocsClient struct {\n\tservice *docs.Service\n}\n\nfunc NewDocsClient() (*DocsClient, error) {\n\tctx := context.Background()\n\n\tcreds, err := option.CredentialsFromJSON(ctx, []byte(credentials))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get credentials: %v\", err)\n\t}\n\n\tservice, err := docs.NewService(ctx, option.WithCredentials(creds))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create docs service: %v\", err)\n\t}\n\n\treturn &DocsClient{\n\t\tservice: service,\n\t}, nil\n}\n\nfunc (c *DocsClient) GetDocument(documentID string) (*docs.Document, error) {\n\tdoc, err := c.service.Documents.Get(documentID).Do()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get document: %v\", err)\n\t}\n\n\treturn doc, nil\n}\n\nfunc (c *DocsClient) UpdateDocument(documentID string, requests []*docs.Request) error {\n\t_, err := c.service.Documents.BatchUpdate(documentID, &docs.BatchUpdateDocumentRequest{\n\t\tRequests: requests,\n\t}).Do()\n\n\tif err != nil {\n\t\tlog.Printf(\"failed to update document: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nconst credentials = `{\n\t\"web\": {\n\t\t\"client_id\": \"YOUR_CLIENT_ID\",\n\t\t\"client_secret\": \"YOUR_CLIENT_SECRET\",\n\t\t\"redirect_uris\": [],\n\t\t\"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",\n\t\t\"token_uri\": \"https://accounts.google.com/o/oauth2/token\"\n\t}\n}`"}
{"sample": "package countingsort\n\nfunc CountingSort(arr []int) []int {\n\tif len(arr) == 0 {\n\t\treturn arr\n\t}\n\n\tmax := arr[0]\n\tfor _, val := range arr {\n\t\tif val > max {\n\t\t\tmax = val\n\t\t}\n\t}\n\n\tcounts := make([]int, max+1)\n\n\tfor _, val := range arr {\n\t\tcounts[val]++\n\t}\n\n\tfor i := 1; i < len(counts); i++ {\n\t\tcounts[i] += counts[i-1]\n\t}\n\n\tsorted := make([]int, len(arr))\n\n\tfor _, val := range arr {\n\t\tsorted[counts[val]-1] = val\n\t\tcounts[val]--\n\t}\n\n\treturn sorted\n}"}
{"sample": "package leadservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"leadservice/database\"\n\t\"leadservice/models\"\n)\n\ntype LeadService struct {\n\tdb *database.DB\n}\n\nfunc NewLeadService(db *database.DB) *LeadService {\n\treturn &LeadService{\n\t\tdb: db,\n\t}\n}\n\nfunc (s *LeadService) CreateLead(ctx context.Context, lead *models.Lead) error {\n\tif lead == nil {\n\t\treturn errors.New(\"lead cannot be nil\")\n\t}\n\n\treturn s.db.CreateLead(ctx, lead)\n}\n\nfunc (s *LeadService) GetLead(ctx context.Context, id string) (*models.Lead, error) {\n\tif id == \"\" {\n\t\treturn nil, errors.New(\"id cannot be empty\")\n\t}\n\n\treturn s.db.GetLead(ctx, id)\n}\n\nfunc (s *LeadService) UpdateLead(ctx context.Context, lead *models.Lead) error {\n\tif lead == nil {\n\t\treturn errors.New(\"lead cannot be nil\")\n\t}\n\n\treturn s.db.UpdateLead(ctx, lead)\n}\n\nfunc (s *LeadService) DeleteLead(ctx context.Context, id string) error {\n\tif id == \"\" {\n\t\treturn errors.New(\"id cannot be empty\")\n\t}\n\n\treturn s.db.DeleteLead(ctx, id)\n}\n\nfunc (s *LeadService) ListLeads(ctx context.Context, limit, offset int) ([]*models.Lead, error) {\n\treturn s.db.ListLeads(ctx, limit, offset)\n}"}
{"sample": "package dnsclient\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc lookup(domain string) ([]net.IP, error) {\n\tips, err := net.LookupIP(domain)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ips, nil\n}\n\nfunc main() {\n\tdomain := \"google.com\"\n\tips, err := lookup(domain)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"IP addresses for %s:\\n\", domain)\n\tfor _, ip := range ips {\n\t\tfmt.Println(ip)\n\t}\n}"}
{"sample": "package slidesclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"golang.org/x/oauth2/google\"\n\t\"google.golang.org/api/slides/v1\"\n)\n\nfunc getSlidesClient() (*slides.Service, error) {\n\tctx := context.Background()\n\n\tcreds, err := google.FindDefaultCredentials(ctx, slides.SlidesScope)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve default credentials: %v\", err)\n\t}\n\n\tclient, err := google.DefaultClient(ctx, slides.SlidesScope)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve default client: %v\", err)\n\t}\n\n\tslidesService, err := slides.New(client)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to create slides client: %v\", err)\n\t}\n\n\treturn slidesService, nil\n}\n\nfunc createSlide(title string) error {\n\tslidesService, err := getSlidesClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpresentation := &slides.Presentation{\n\t\tTitle: title,\n\t}\n\n\tpresentation, err = slidesService.Presentations.Create(presentation).Do()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to create presentation: %v\", err)\n\t}\n\n\tfmt.Printf(\"Created presentation with ID: %s\\n\", presentation.PresentationId)\n\treturn nil\n}\n\nfunc addSlide(presentationID string) error {\n\tslidesService, err := getSlidesClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trequests := []*slides.Request{\n\t\t{\n\t\t\tCreateSlide: &slides.CreateSlideRequest{\n\t\t\t\tObjectId: \"\",\n\t\t\t},\n\t\t},\n\t}\n\n\tbatchUpdateRequest := &slides.BatchUpdatePresentationRequest{\n\t\tRequests: requests,\n\t}\n\n\t_, err = slidesService.Presentations.BatchUpdate(presentationID, batchUpdateRequest).Do()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to add slide to presentation: %v\", err)\n\t}\n\n\tfmt.Println(\"Added slide to presentation\")\n\treturn nil\n}\n\nfunc deleteSlide(presentationID string, slideID string) error {\n\tslidesService, err := getSlidesClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trequests := []*slides.Request{\n\t\t{\n\t\t\tDeleteObject: &slides.DeleteObjectRequest{\n\t\t\t\tObjectId: slideID,\n\t\t\t},\n\t\t},\n\t}\n\n\tbatchUpdateRequest := &slides.BatchUpdatePresentationRequest{\n\t\tRequests: requests,\n\t}\n\n\t_, err = slidesService.Presentations.BatchUpdate(presentationID, batchUpdateRequest).Do()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to delete slide from presentation: %v\", err)\n\t}\n\n\tfmt.Println(\"Deleted slide from presentation\")\n\treturn nil\n}\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tlog.Fatalf(\"Usage: %s <presentation title>\", os.Args[0])\n\t}\n\n\ttitle := os.Args[1]\n\tif err := createSlide(title); err != nil {\n\t\tlog.Fatalf(\"Unable to create slide: %v\", err)\n\t}\n\n\tpresentationID := \"presentation-id\" // Replace with actual presentation ID\n\tif err := addSlide(presentationID); err != nil {\n\t\tlog.Fatalf(\"Unable to add slide: %v\", err)\n\t}\n\n\tslideID := \"slide-id\" // Replace with actual slide ID\n\tif err := deleteSlide(presentationID, slideID); err != nil {\n\t\tlog.Fatalf(\"Unable to delete slide: %v\", err)\n\t}\n}"}
{"sample": "package cocktailsort\n\nfunc CocktailSort(arr []int) {\n\tfor i := 0; i < len(arr)/2; i++ {\n\t\tleft := i\n\t\tright := len(arr) - i - 1\n\n\t\tfor j := left; j < right; j++ {\n\t\t\tif arr[j] > arr[j+1] {\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]\n\t\t\t}\n\t\t}\n\n\t\tfor j := right; j > left; j-- {\n\t\t\tif arr[j] < arr[j-1] {\n\t\t\t\tarr[j], arr[j-1] = arr[j-1], arr[j]\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "package ticketservice\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"ticketservice/models\"\n)\n\nfunc createTicket(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttitle := r.FormValue(\"title\")\n\tdescription := r.FormValue(\"description\")\n\tcreatedBy := r.FormValue(\"created_by\")\n\n\tticket := models.Ticket{\n\t\tTitle:       title,\n\t\tDescription: description,\n\t\tCreatedBy:   createdBy,\n\t}\n\n\tif err := ticket.Create(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"Ticket created successfully\")\n}\n\nfunc getTicket(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"GET\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tid := r.URL.Query().Get(\"id\")\n\n\tticket, err := models.GetTicket(id)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"Ticket: %v\", ticket)\n}\n\nfunc updateTicket(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"PUT\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tid := r.FormValue(\"id\")\n\tstatus := r.FormValue(\"status\")\n\n\tif err := models.UpdateTicketStatus(id, status); err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"Ticket status updated successfully\")\n}"}
{"sample": "package pop3client\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"net/textproto\"\n)\n\nfunc receiveMail() ([]string, error) {\n\tconn, err := net.Dial(\"tcp\", \"mail.example.com:110\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\ttp := textproto.NewConn(conn)\n\n\t_, err = tp.ReadLine()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := tp.PrintfLine(\"USER username\"); err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tp.ReadLine()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := tp.PrintfLine(\"PASS password\"); err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tp.ReadLine()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := tp.PrintfLine(\"LIST\"); err != nil {\n\t\treturn nil, err\n\t}\n\n\tlines, err := tp.ReadDotLines()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn lines, nil\n}\n\nfunc main() {\n\tmails, err := receiveMail()\n\tif err != nil {\n\t\tfmt.Println(\"Error receiving mail:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Received mails:\")\n\tfor _, mail := range mails {\n\t\tfmt.Println(mail)\n\t}\n}"}
{"sample": "package tasksclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"golang.org/x/oauth2\"\n\t\"golang.org/x/oauth2/google\"\n\t\"google.golang.org/api/tasks/v1\"\n)\n\nfunc getClient(config *oauth2.Config) *http.Client {\n\ttokenFile := \"token.json\"\n\ttoken, err := tokenFromFile(tokenFile)\n\tif err != nil {\n\t\ttoken = getTokenFromWeb(config)\n\t\tsaveToken(tokenFile, token)\n\t}\n\treturn config.Client(context.Background(), token)\n}\n\nfunc GetTasks() {\n\tconfig, err := google.ConfigFromJSON([]byte(os.Getenv(\"GOOGLE_CLIENT_SECRET\")), tasks.TasksScope)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to parse client secret file to config: %v\", err)\n\t}\n\n\tclient := getClient(config)\n\n\tsrv, err := tasks.New(client)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve tasks Client %v\", err)\n\t}\n\n\ttaskLists, err := srv.Tasklists.List().MaxResults(10).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve task lists. %v\", err)\n\t}\n\n\tif len(taskLists.Items) == 0 {\n\t\tfmt.Println(\"No task lists found.\")\n\t\treturn\n\t}\n\n\tfor _, taskList := range taskLists.Items {\n\t\tfmt.Printf(\"%v (%v)\\n\", taskList.Title, taskList.Id)\n\t}\n}\n\nfunc AddTask(taskName string) {\n\tconfig, err := google.ConfigFromJSON([]byte(os.Getenv(\"GOOGLE_CLIENT_SECRET\")), tasks.TasksScope)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to parse client secret file to config: %v\", err)\n\t}\n\n\tclient := getClient(config)\n\n\tsrv, err := tasks.New(client)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve tasks Client %v\", err)\n\t}\n\n\ttask := &tasks.Task{\n\t\tTitle: taskName,\n\t}\n\n\ttaskList, err := srv.Tasklists.List().MaxResults(1).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to retrieve task lists. %v\", err)\n\t}\n\n\tif len(taskList.Items) == 0 {\n\t\tfmt.Println(\"No task lists found.\")\n\t\treturn\n\t}\n\n\ttaskListId := taskList.Items[0].Id\n\n\t_, err = srv.Tasks.Insert(taskListId, task).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to create task. %v\", err)\n\t}\n\n\tfmt.Printf(\"Task \\\"%v\\\" added to task list \\\"%v\\\".\\n\", taskName, taskList.Items[0].Title)\n}"}
{"sample": "package pancakesort\n\nfunc flip(arr []int, k int) {\n\tfor i := 0; i < k/2; i++ {\n\t\tarr[i], arr[k-i-1] = arr[k-i-1], arr[i]\n\t}\n}\n\nfunc findMaxIndex(arr []int, n int) int {\n\tmaxIndex := 0\n\tfor i := 0; i < n; i++ {\n\t\tif arr[i] > arr[maxIndex] {\n\t\t\tmaxIndex = i\n\t\t}\n\t}\n\treturn maxIndex\n}\n\nfunc pancakeSort(arr []int) []int {\n\tn := len(arr)\n\tfor currSize := n; currSize > 1; currSize-- {\n\t\tmaxIndex := findMaxIndex(arr, currSize)\n\t\tif maxIndex != currSize-1 {\n\t\t\tflip(arr, maxIndex+1)\n\t\t\tflip(arr, currSize)\n\t\t}\n\t}\n\treturn arr\n}"}
{"sample": "package shipmentservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/jinzhu/gorm\"\n)\n\ntype Shipment struct {\n\tID          uuid.UUID `gorm:\"type:uuid;primary_key\"`\n\tOrigin      string\n\tDestination string\n\tStatus      string\n\tCreatedAt   time.Time\n\tUpdatedAt   time.Time\n}\n\ntype ShipmentService struct {\n\tdb *gorm.DB\n}\n\nfunc NewShipmentService(db *gorm.DB) *ShipmentService {\n\treturn &ShipmentService{db: db}\n}\n\nfunc (s *ShipmentService) CreateShipment(ctx context.Context, origin, destination string) (*Shipment, error) {\n\tshipment := &Shipment{\n\t\tID:          uuid.New(),\n\t\tOrigin:      origin,\n\t\tDestination: destination,\n\t\tStatus:      \"created\",\n\t\tCreatedAt:   time.Now(),\n\t\tUpdatedAt:   time.Now(),\n\t}\n\n\tif err := s.db.Create(shipment).Error; err != nil {\n\t\tlog.Printf(\"failed to create shipment: %v\", err)\n\t\treturn nil, errors.New(\"failed to create shipment\")\n\t}\n\n\treturn shipment, nil\n}\n\nfunc (s *ShipmentService) GetShipment(ctx context.Context, id uuid.UUID) (*Shipment, error) {\n\tvar shipment Shipment\n\n\tif err := s.db.Where(\"id = ?\", id).First(&shipment).Error; err != nil {\n\t\tlog.Printf(\"failed to get shipment: %v\", err)\n\t\treturn nil, errors.New(\"failed to get shipment\")\n\t}\n\n\treturn &shipment, nil\n}\n\nfunc (s *ShipmentService) UpdateShipmentStatus(ctx context.Context, id uuid.UUID, status string) error {\n\tshipment, err := s.GetShipment(ctx, id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tshipment.Status = status\n\tshipment.UpdatedAt = time.Now()\n\n\tif err := s.db.Save(shipment).Error; err != nil {\n\t\tlog.Printf(\"failed to update shipment status: %v\", err)\n\t\treturn errors.New(\"failed to update shipment status\")\n\t}\n\n\treturn nil\n}"}
{"sample": "package redisclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\ntype RedisClient struct {\n\tclient *redis.Client\n\tctx    context.Context\n}\n\nfunc NewRedisClient() *RedisClient {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif err := rdb.Ping(ctx).Err(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &RedisClient{\n\t\tclient: rdb,\n\t\tctx:    ctx,\n\t}\n}\n\nfunc (rc *RedisClient) Set(key string, value interface{}) error {\n\treturn rc.client.Set(rc.ctx, key, value, 0).Err()\n}\n\nfunc (rc *RedisClient) Get(key string) (string, error) {\n\treturn rc.client.Get(rc.ctx, key).Result()\n}\n\nfunc (rc *RedisClient) Delete(key string) error {\n\treturn rc.client.Del(rc.ctx, key).Err()\n}\n\nfunc (rc *RedisClient) Increment(key string) error {\n\treturn rc.client.Incr(rc.ctx, key).Err()\n}\n\nfunc (rc *RedisClient) Decrement(key string) error {\n\treturn rc.client.Decr(rc.ctx, key).Err()\n}\n\nfunc (rc *RedisClient) Close() error {\n\treturn rc.client.Close()\n}\n\nfunc Example() {\n\tclient := NewRedisClient()\n\n\tif err := client.Set(\"key\", \"value\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tvalue, err := client.Get(\"key\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(value)\n\n\tif err := client.Delete(\"key\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := client.Increment(\"counter\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := client.Decrement(\"counter\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := client.Close(); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package photosclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"google.golang.org/api/photoslibrary/v1\"\n\t\"google.golang.org/api/option\"\n)\n\ntype PhotosClient struct {\n\tservice *photoslibrary.Service\n}\n\nfunc NewPhotosClient(ctx context.Context, tokenSource option.ClientOption) (*PhotosClient, error) {\n\tservice, err := photoslibrary.NewService(ctx, tokenSource)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create photoslibrary service: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn &PhotosClient{\n\t\tservice: service,\n\t}, nil\n}\n\nfunc (c *PhotosClient) ListAlbums() ([]*photoslibrary.Album, error) {\n\talbums, err := c.service.Albums.List().Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to list albums: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn albums.Albums, nil\n}\n\nfunc (c *PhotosClient) UploadPhoto(photo []byte, filename string) error {\n\t_, err := c.service.UploadBytes(photo, &photoslibrary.MediaItem{Filename: filename})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to upload photo: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *PhotosClient) SearchPhotos(query string) ([]*photoslibrary.MediaItem, error) {\n\tsearchResponse, err := c.service.MediaItems.Search(&photoslibrary.SearchMediaItemsRequest{\n\t\tPageSize: 100,\n\t\tQuery:    query,\n\t}).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to search photos: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn searchResponse.MediaItems, nil\n}\n\nfunc (c *PhotosClient) GetPhoto(photoId string) (*photoslibrary.MediaItem, error) {\n\tmediaItemResponse, err := c.service.MediaItems.Get(photoId).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get photo: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn mediaItemResponse, nil\n}\n\nfunc (c *PhotosClient) CreateAlbum(albumTitle string) (*photoslibrary.Album, error) {\n\talbum, err := c.service.Albums.Create(&photoslibrary.CreateAlbumRequest{\n\t\tAlbum: &photoslibrary.Album{\n\t\t\tTitle: albumTitle,\n\t\t},\n\t}).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create album: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn album, nil\n}\n\nfunc (c *PhotosClient) AddPhotoToAlbum(photoId string, albumId string) error {\n\t_, err := c.service.Albums.BatchAddMediaItems(albumId, &photoslibrary.BatchAddMediaItemsRequest{\n\t\tMediaItemIds: []string{photoId},\n\t}).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to add photo to album: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *PhotosClient) DeletePhoto(photoId string) error {\n\terr := c.service.MediaItems.BatchDelete(&photoslibrary.BatchDeleteMediaItemsRequest{\n\t\tMediaItemIds: []string{photoId},\n\t}).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to delete photo: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *PhotosClient) DeleteAlbum(albumId string) error {\n\terr := c.service.Albums.Delete(albumId).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to delete album: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *PhotosClient) ShareAlbum(albumId string) (string, error) {\n\tshareResponse, err := c.service.SharedAlbums.Join(albumId).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to share album: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\treturn shareResponse.ShareInfo.ShareableUrl, nil\n}\n\nfunc (c *PhotosClient) GetPhotoDownloadUrl(photoId string) (string, error) {\n\tmediaItem, err := c.GetPhoto(photoId)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get photo: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\treturn mediaItem.BaseUrl, nil\n}\n\nfunc (c *PhotosClient) GetAlbumUrl(albumId string) (string, error) {\n\talbum, err := c.service.Albums.Get(albumId).Do()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get album: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(\"https://photos.google.com/album/%s\", album.Id), nil\n}"}
{"sample": "package gnomesort\n\n// GnomeSort sorts an array of integers using the gnome sort algorithm\nfunc GnomeSort(arr []int) {\n\ti := 1\n\tfor i < len(arr) {\n\t\tif i == 0 {\n\t\t\ti = 1\n\t\t}\n\t\tif arr[i] >= arr[i-1] {\n\t\t\ti++\n\t\t} else {\n\t\t\tarr[i], arr[i-1] = arr[i-1], arr[i]\n\t\t\ti--\n\t\t}\n\t}\n}"}
{"sample": "package deliveryservice\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Delivery struct {\n\tID          uuid.UUID\n\tRecipient   string\n\tDestination string\n\tStatus      string\n\tCreatedAt   time.Time\n\tUpdatedAt   time.Time\n}\n\ntype DeliveryService struct {\n\tDB *sql.DB\n}\n\nfunc (ds *DeliveryService) CreateDelivery(recipient, destination string) (*Delivery, error) {\n\tdelivery := &Delivery{\n\t\tID:          uuid.New(),\n\t\tRecipient:   recipient,\n\t\tDestination: destination,\n\t\tStatus:      \"created\",\n\t\tCreatedAt:   time.Now(),\n\t\tUpdatedAt:   time.Now(),\n\t}\n\n\t_, err := ds.DB.Exec(\"INSERT INTO deliveries (id, recipient, destination, status, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6)\",\n\t\tdelivery.ID, delivery.Recipient, delivery.Destination, delivery.Status, delivery.CreatedAt, delivery.UpdatedAt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn delivery, nil\n}\n\nfunc (ds *DeliveryService) UpdateDeliveryStatus(id uuid.UUID, status string) (*Delivery, error) {\n\tdelivery, err := ds.GetDelivery(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif delivery.Status == \"delivered\" {\n\t\treturn nil, errors.New(\"delivery has already been delivered\")\n\t}\n\n\tdelivery.Status = status\n\tdelivery.UpdatedAt = time.Now()\n\n\t_, err = ds.DB.Exec(\"UPDATE deliveries SET status = $1, updated_at = $2 WHERE id = $3\", delivery.Status, delivery.UpdatedAt, delivery.ID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn delivery, nil\n}\n\nfunc (ds *DeliveryService) GetDelivery(id uuid.UUID) (*Delivery, error) {\n\tdelivery := &Delivery{}\n\n\trow := ds.DB.QueryRow(\"SELECT id, recipient, destination, status, created_at, updated_at FROM deliveries WHERE id = $1\", id)\n\terr := row.Scan(&delivery.ID, &delivery.Recipient, &delivery.Destination, &delivery.Status, &delivery.CreatedAt, &delivery.UpdatedAt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn delivery, nil\n}\n\nfunc (ds *DeliveryService) ListDeliveries() ([]*Delivery, error) {\n\tdeliveries := []*Delivery{}\n\n\trows, err := ds.DB.Query(\"SELECT id, recipient, destination, status, created_at, updated_at FROM deliveries\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tdelivery := &Delivery{}\n\t\terr := rows.Scan(&delivery.ID, &delivery.Recipient, &delivery.Destination, &delivery.Status, &delivery.CreatedAt, &delivery.UpdatedAt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdeliveries = append(deliveries, delivery)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn deliveries, nil\n}\n\nfunc (ds *DeliveryService) DeleteDelivery(id uuid.UUID) error {\n\t_, err := ds.DB.Exec(\"DELETE FROM deliveries WHERE id = $1\", id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (d *Delivery) String() string {\n\treturn fmt.Sprintf(\"Delivery{ID: %s, Recipient: %s, Destination: %s, Status: %s, CreatedAt: %s, UpdatedAt: %s}\",\n\t\td.ID, d.Recipient, d.Destination, d.Status, d.CreatedAt, d.UpdatedAt)\n}"}
{"sample": "package httpserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handleRequest(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, World!\")\n}\n\nfunc StartServer() {\n\thttp.HandleFunc(\"/\", handleRequest)\n\n\tfmt.Println(\"Server starting on port 8080\")\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"Error starting server: \", err)\n\t}\n}"}
{"sample": "package mapsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"googlemaps.github.io/maps\"\n)\n\ntype MapsClient struct {\n\tclient *maps.Client\n}\n\nfunc NewMapsClient(apiKey string) (*MapsClient, error) {\n\tc, err := maps.NewClient(maps.WithAPIKey(apiKey))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &MapsClient{\n\t\tclient: c,\n\t}, nil\n}\n\nfunc (mc *MapsClient) GetDirections(origin, destination string) ([]maps.Route, error) {\n\tr := &maps.DirectionsRequest{\n\t\tOrigin:      origin,\n\t\tDestination: destination,\n\t}\n\n\troutes, _, err := mc.client.Directions(context.Background(), r)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\treturn routes, nil\n}\n\nfunc (mc *MapsClient) GetPlaceDetails(placeID string) (*maps.PlaceDetailsResult, error) {\n\tr := &maps.PlaceDetailsRequest{\n\t\tPlaceID: placeID,\n\t}\n\n\tdetails, err := mc.client.PlaceDetails(context.Background(), r)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\treturn details, nil\n}\n\nfunc (mc *MapsClient) Geocode(address string) (*maps.GeocodingResult, error) {\n\tr := &maps.GeocodingRequest{\n\t\tAddress: address,\n\t}\n\n\tresults, err := mc.client.Geocode(context.Background(), r)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no results found for address: %s\", address)\n\t}\n\n\treturn &results[0], nil\n}"}
{"sample": "package combsort\n\nfunc CombSort(arr []int) []int {\n\tn := len(arr)\n\tgap := n\n\tshrink := 1.3\n\tswapped := true\n\n\tfor swapped {\n\t\tgap = int(float64(gap) / shrink)\n\t\tif gap < 1 {\n\t\t\tgap = 1\n\t\t}\n\n\t\tswapped = false\n\n\t\tfor i := 0; i+gap < n; i++ {\n\t\t\tif arr[i] > arr[i+gap] {\n\t\t\t\tarr[i], arr[i+gap] = arr[i+gap], arr[i]\n\t\t\t\tswapped = true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn arr\n}"}
{"sample": "package expenseservice\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"time\"\n)\n\ntype Expense struct {\n\tID          int\n\tDescription string\n\tAmount      float64\n\tDate        time.Time\n}\n\ntype ExpenseService struct {\n\tdb *sql.DB\n}\n\nfunc NewExpenseService(db *sql.DB) *ExpenseService {\n\treturn &ExpenseService{db: db}\n}\n\nfunc (es *ExpenseService) CreateExpense(e *Expense) error {\n\tif e == nil {\n\t\treturn errors.New(\"expense cannot be nil\")\n\t}\n\n\tstmt, err := es.db.Prepare(\"INSERT INTO expenses(description, amount, date) VALUES(?,?,?)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tresult, err := stmt.Exec(e.Description, e.Amount, e.Date)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tid, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\te.ID = int(id)\n\n\treturn nil\n}\n\nfunc (es *ExpenseService) GetExpense(id int) (*Expense, error) {\n\tstmt, err := es.db.Prepare(\"SELECT id, description, amount, date FROM expenses WHERE id = ?\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\trow := stmt.QueryRow(id)\n\n\tvar e Expense\n\terr = row.Scan(&e.ID, &e.Description, &e.Amount, &e.Date)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn &e, nil\n}\n\nfunc (es *ExpenseService) GetExpenses() ([]Expense, error) {\n\trows, err := es.db.Query(\"SELECT id, description, amount, date FROM expenses\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar expenses []Expense\n\tfor rows.Next() {\n\t\tvar e Expense\n\t\terr = rows.Scan(&e.ID, &e.Description, &e.Amount, &e.Date)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\texpenses = append(expenses, e)\n\t}\n\n\treturn expenses, nil\n}"}
{"sample": "package pop3server\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\ntype POP3Server struct {\n\tUsername string\n\tPassword string\n}\n\nfunc (s *POP3Server) Start() error {\n\tln, err := net.Listen(\"tcp\", \":110\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tgo s.handleConnection(conn)\n\t}\n}\n\nfunc (s *POP3Server) handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\tconn.Write([]byte(\"+OK POP3 server ready\\r\\n\"))\n\n\tscanner := bufio.NewScanner(conn)\n\n\tfor scanner.Scan() {\n\t\tcommand := scanner.Text()\n\t\tparts := strings.Fields(command)\n\n\t\tswitch parts[0] {\n\t\tcase \"USER\":\n\t\t\tif len(parts) < 2 || parts[1] != s.Username {\n\t\t\t\tconn.Write([]byte(\"-ERR Invalid username\\r\\n\"))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconn.Write([]byte(\"+OK Password required\\r\\n\"))\n\t\tcase \"PASS\":\n\t\t\tif len(parts) < 2 || parts[1] != s.Password {\n\t\t\t\tconn.Write([]byte(\"-ERR Invalid password\\r\\n\"))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconn.Write([]byte(\"+OK Logged in\\r\\n\"))\n\t\tcase \"QUIT\":\n\t\t\tconn.Write([]byte(\"+OK Goodbye\\r\\n\"))\n\t\t\treturn\n\t\tdefault:\n\t\t\tconn.Write([]byte(\"-ERR Unknown command\\r\\n\"))\n\t\t}\n\t}\n}\n\nfunc main() {\n\tserver := &POP3Server{\n\t\tUsername: \"user\",\n\t\tPassword: \"pass\",\n\t}\n\n\tif err := server.Start(); err != nil {\n\t\tfmt.Println(\"Error starting server:\", err)\n\t}\n}"}
{"sample": "package hangoutsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/gempir/go-twitch-irc\"\n\t\"github.com/layeh/gumble/gumble\"\n\t\"github.com/layeh/gumble/gumbleutil\"\n)\n\ntype HangoutsClient struct {\n\t// ...\n}\n\nfunc NewHangoutsClient() *HangoutsClient {\n\t// ...\n}\n\nfunc (c *HangoutsClient) Connect() error {\n\t// ...\n}\n\nfunc (c *HangoutsClient) Disconnect() error {\n\t// ...\n}\n\nfunc (c *HangoutsClient) SendMessage(message string) error {\n\t// ...\n}\n\nfunc (c *HangoutsClient) ListenForMessages(ctx context.Context) error {\n\t// ...\n}\n\nfunc main() {\n\tc := NewHangoutsClient()\n\n\tif err := c.Connect(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdefer c.Disconnect()\n\n\tif err := c.SendMessage(\"Hello, world!\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tctx := context.Background()\n\n\tif err := c.ListenForMessages(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package cyclesort\n\n// CycleSort implements the cycle sort algorithm\nfunc CycleSort(arr []int) {\n\tn := len(arr)\n\n\tfor cycleStart := 0; cycleStart < n-1; cycleStart++ {\n\t\titem := arr[cycleStart]\n\n\t\tpos := cycleStart\n\t\tfor i := cycleStart + 1; i < n; i++ {\n\t\t\tif arr[i] < item {\n\t\t\t\tpos++\n\t\t\t}\n\t\t}\n\n\t\tif pos == cycleStart {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor item == arr[pos] {\n\t\t\tpos++\n\t\t}\n\n\t\tif pos != cycleStart {\n\t\t\titem, arr[pos] = arr[pos], item\n\t\t}\n\n\t\tfor pos != cycleStart {\n\t\t\tpos = cycleStart\n\t\t\tfor i := cycleStart + 1; i < n; i++ {\n\t\t\t\tif arr[i] < item {\n\t\t\t\t\tpos++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor item == arr[pos] {\n\t\t\t\tpos++\n\t\t\t}\n\n\t\t\tif item != arr[pos] {\n\t\t\t\titem, arr[pos] = arr[pos], item\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "package rewardsservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Reward struct {\n\tID           uuid.UUID\n\tCustomerID   uuid.UUID\n\tPoints       int\n\tRedeemed     bool\n\tDateCreated  time.Time\n\tDateModified time.Time\n}\n\ntype RewardsService struct {\n\trewards map[uuid.UUID]Reward\n}\n\nfunc NewRewardsService() *RewardsService {\n\treturn &RewardsService{\n\t\trewards: make(map[uuid.UUID]Reward),\n\t}\n}\n\nfunc (rs *RewardsService) CreateReward(ctx context.Context, customerID uuid.UUID, points int) (uuid.UUID, error) {\n\tif points <= 0 {\n\t\treturn uuid.Nil, errors.New(\"points must be greater than 0\")\n\t}\n\n\treward := Reward{\n\t\tID:           uuid.New(),\n\t\tCustomerID:   customerID,\n\t\tPoints:       points,\n\t\tRedeemed:     false,\n\t\tDateCreated:  time.Now(),\n\t\tDateModified: time.Now(),\n\t}\n\n\trs.rewards[reward.ID] = reward\n\n\treturn reward.ID, nil\n}\n\nfunc (rs *RewardsService) RedeemReward(ctx context.Context, rewardID uuid.UUID) error {\n\treward, ok := rs.rewards[rewardID]\n\tif !ok {\n\t\treturn fmt.Errorf(\"reward with ID %v not found\", rewardID)\n\t}\n\n\tif reward.Redeemed {\n\t\treturn fmt.Errorf(\"reward with ID %v has already been redeemed\", rewardID)\n\t}\n\n\treward.Redeemed = true\n\treward.DateModified = time.Now()\n\n\trs.rewards[rewardID] = reward\n\n\treturn nil\n}\n\nfunc (rs *RewardsService) GetReward(ctx context.Context, rewardID uuid.UUID) (Reward, error) {\n\treward, ok := rs.rewards[rewardID]\n\tif !ok {\n\t\treturn Reward{}, fmt.Errorf(\"reward with ID %v not found\", rewardID)\n\t}\n\n\treturn reward, nil\n}"}
{"sample": "package mongodbclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\ntype User struct {\n\tName  string `bson:\"name\"`\n\tEmail string `bson:\"email\"`\n}\n\nfunc ConnectToDB() (*mongo.Client, error) {\n\tclientOptions := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n\tclient, err := mongo.Connect(context.Background(), clientOptions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = client.Ping(context.Background(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfmt.Println(\"Connected to MongoDB!\")\n\treturn client, nil\n}\n\nfunc CreateUser(client *mongo.Client, user User) error {\n\tcollection := client.Database(\"test\").Collection(\"users\")\n\t_, err := collection.InsertOne(context.Background(), user)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tfmt.Println(\"User created successfully!\")\n\treturn nil\n}\n\nfunc ReadUser(client *mongo.Client, email string) (User, error) {\n\tvar user User\n\tcollection := client.Database(\"test\").Collection(\"users\")\n\tfilter := bson.M{\"email\": email}\n\terr := collection.FindOne(context.Background(), filter).Decode(&user)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn User{}, err\n\t}\n\n\tfmt.Printf(\"User found: %+v\\n\", user)\n\treturn user, nil\n}\n\nfunc UpdateUser(client *mongo.Client, email string, name string) error {\n\tcollection := client.Database(\"test\").Collection(\"users\")\n\tfilter := bson.M{\"email\": email}\n\tupdate := bson.M{\"$set\": bson.M{\"name\": name}}\n\t_, err := collection.UpdateOne(context.Background(), filter, update)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tfmt.Println(\"User updated successfully!\")\n\treturn nil\n}\n\nfunc DeleteUser(client *mongo.Client, email string) error {\n\tcollection := client.Database(\"test\").Collection(\"users\")\n\tfilter := bson.M{\"email\": email}\n\t_, err := collection.DeleteOne(context.Background(), filter)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\tfmt.Println(\"User deleted successfully!\")\n\treturn nil\n}"}
{"sample": "package gcsclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\n\t\"cloud.google.com/go/storage\"\n)\n\ntype GCSClient struct {\n\tclient *storage.Client\n\tbucket *storage.BucketHandle\n}\n\nfunc NewGCSClient(projectID, bucketName string) (*GCSClient, error) {\n\tctx := context.Background()\n\n\tclient, err := storage.NewClient(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create client: %v\", err)\n\t}\n\n\tbucket := client.Bucket(bucketName)\n\n\treturn &GCSClient{\n\t\tclient: client,\n\t\tbucket: bucket,\n\t}, nil\n}\n\nfunc (c *GCSClient) UploadObject(objectName string, r io.Reader) error {\n\tctx := context.Background()\n\n\twc := c.bucket.Object(objectName).NewWriter(ctx)\n\n\tif _, err := io.Copy(wc, r); err != nil {\n\t\treturn fmt.Errorf(\"failed to upload object: %v\", err)\n\t}\n\n\tif err := wc.Close(); err != nil {\n\t\treturn fmt.Errorf(\"failed to close writer: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *GCSClient) DownloadObject(objectName string, w io.Writer) error {\n\tctx := context.Background()\n\n\trc, err := c.bucket.Object(objectName).NewReader(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open object: %v\", err)\n\t}\n\tdefer rc.Close()\n\n\tif _, err := io.Copy(w, rc); err != nil {\n\t\treturn fmt.Errorf(\"failed to download object: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *GCSClient) ListObjects() ([]string, error) {\n\tctx := context.Background()\n\n\tvar objects []string\n\n\tit := c.bucket.Objects(ctx, nil)\n\tfor {\n\t\tobjAttrs, err := it.Next()\n\t\tif err == iterator.Done {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to iterate objects: %v\", err)\n\t\t}\n\t\tobjects = append(objects, objAttrs.Name)\n\t}\n\n\treturn objects, nil\n}\n\nfunc (c *GCSClient) DeleteObject(objectName string) error {\n\tctx := context.Background()\n\n\tif err := c.bucket.Object(objectName).Delete(ctx); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete object: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *GCSClient) Close() {\n\tif err := c.client.Close(); err != nil {\n\t\tlog.Printf(\"failed to close client: %v\", err)\n\t}\n}"}
{"sample": "package pigeonholesort\n\nfunc PigeonholeSort(arr []int) []int {\n\tmin := arr[0]\n\tmax := arr[0]\n\tn := len(arr)\n\n\tfor i := 1; i < n; i++ {\n\t\tif arr[i] < min {\n\t\t\tmin = arr[i]\n\t\t}\n\t\tif arr[i] > max {\n\t\t\tmax = arr[i]\n\t\t}\n\t}\n\n\trangeSize := max - min + 1\n\n\tholes := make([]int, rangeSize)\n\n\tfor i := 0; i < n; i++ {\n\t\tholes[arr[i]-min]++\n\t}\n\n\tindex := 0\n\tfor i := 0; i < rangeSize; i++ {\n\t\tfor holes[i] > 0 {\n\t\t\tarr[index] = i + min\n\t\t\tindex++\n\t\t\tholes[i]--\n\t\t}\n\t}\n\n\treturn arr\n}"}
{"sample": "package campaignservice\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Campaign struct {\n\tID          string\n\tName        string\n\tDescription string\n\tStartDate   time.Time\n\tEndDate     time.Time\n}\n\ntype CampaignService struct {\n\tcampaigns []*Campaign\n}\n\nfunc NewCampaignService() *CampaignService {\n\treturn &CampaignService{}\n}\n\nfunc (s *CampaignService) CreateCampaign(ctx context.Context, name string, description string, startDate time.Time, endDate time.Time) (*Campaign, error) {\n\tif name == \"\" {\n\t\treturn nil, errors.New(\"name cannot be empty\")\n\t}\n\n\tif startDate.After(endDate) {\n\t\treturn nil, errors.New(\"start date cannot be after end date\")\n\t}\n\n\tcampaign := &Campaign{\n\t\tID:          uuid.New().String(),\n\t\tName:        name,\n\t\tDescription: description,\n\t\tStartDate:   startDate,\n\t\tEndDate:     endDate,\n\t}\n\n\ts.campaigns = append(s.campaigns, campaign)\n\n\treturn campaign, nil\n}\n\nfunc (s *CampaignService) GetCampaigns(ctx context.Context) ([]*Campaign, error) {\n\treturn s.campaigns, nil\n}\n\nfunc (s *CampaignService) GetCampaignByID(ctx context.Context, id string) (*Campaign, error) {\n\tfor _, campaign := range s.campaigns {\n\t\tif campaign.ID == id {\n\t\t\treturn campaign, nil\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"campaign not found\")\n}"}
{"sample": "package imapserver\n\nimport (\n\t\"crypto/tls\"\n\t\"log\"\n\t\"net\"\n\t\"net/mail\"\n\t\"net/textproto\"\n)\n\ntype IMAPServer struct {\n\tAddr     string\n\tCertFile string\n\tKeyFile  string\n}\n\nfunc (s *IMAPServer) ListenAndServe() error {\n\tcert, err := tls.LoadX509KeyPair(s.CertFile, s.KeyFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfig := &tls.Config{Certificates: []tls.Certificate{cert}}\n\n\tlistener, err := tls.Listen(\"tcp\", s.Addr, config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Printf(\"IMAP server listening on %s\", s.Addr)\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo s.handleConnection(conn)\n\t}\n}\n\nfunc (s *IMAPServer) handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\tlog.Printf(\"Connection from %s\", conn.RemoteAddr())\n\n\tr := textproto.NewReader(mail.NewReader(conn))\n\tw := textproto.NewWriter(mail.NewWriter(conn))\n\n\tw.PrintfLine(\"* OK IMAP4rev1 Service Ready\")\n\n\tfor {\n\t\tline, err := r.ReadLine()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Received: %s\", line)\n\n\t\tif line == \"QUIT\" {\n\t\t\tw.PrintfLine(\"* BYE\")\n\t\t\treturn\n\t\t}\n\n\t\tw.PrintfLine(\"%s OK\", line)\n\t}\n}"}
{"sample": "package firestoreclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"cloud.google.com/go/firestore\"\n\t\"google.golang.org/api/option\"\n)\n\ntype FirestoreClient struct {\n\tclient *firestore.Client\n\tctx    context.Context\n}\n\nfunc NewFirestoreClient(ctx context.Context, projectID, credentialsPath string) (*FirestoreClient, error) {\n\tclient, err := firestore.NewClient(ctx, projectID, option.WithCredentialsFile(credentialsPath))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create Firestore client: %v\", err)\n\t}\n\n\treturn &FirestoreClient{client, ctx}, nil\n}\n\nfunc (c *FirestoreClient) Close() error {\n\treturn c.client.Close()\n}\n\nfunc (c *FirestoreClient) GetDocument(collection, document string) (map[string]interface{}, error) {\n\tdocRef := c.client.Collection(collection).Doc(document)\n\tdoc, err := docRef.Get(c.ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get document %s from collection %s: %v\", document, collection, err)\n\t}\n\n\treturn doc.Data(), nil\n}\n\nfunc (c *FirestoreClient) SetDocument(collection, document string, data map[string]interface{}) error {\n\tdocRef := c.client.Collection(collection).Doc(document)\n\t_, err := docRef.Set(c.ctx, data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to set document %s in collection %s: %v\", document, collection, err)\n\t}\n\n\treturn nil\n}"}
{"sample": "package bogosort\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc isSorted(arr []int) bool {\n\tfor i := 1; i < len(arr); i++ {\n\t\tif arr[i] < arr[i-1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc shuffle(arr []int) {\n\trand.Seed(time.Now().UnixNano())\n\tfor i := len(arr) - 1; i > 0; i-- {\n\t\tj := rand.Intn(i + 1)\n\t\tarr[i], arr[j] = arr[j], arr[i]\n\t}\n}\n\nfunc BogoSort(arr []int) []int {\n\tfor !isSorted(arr) {\n\t\tshuffle(arr)\n\t}\n\treturn arr\n}"}
{"sample": "package releaseservice\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"releaseservice/models\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype ReleaseService struct{}\n\nfunc (s *ReleaseService) CreateRelease(ctx context.Context, req *models.CreateReleaseRequest) (*models.CreateReleaseResponse, error) {\n\trelease := models.Release{\n\t\tName:        req.Name,\n\t\tVersion:     req.Version,\n\t\tDescription: req.Description,\n\t\tDate:        time.Now(),\n\t}\n\n\tif err := release.Create(); err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, fmt.Errorf(\"failed to create release\")\n\t}\n\n\treturn &models.CreateReleaseResponse{\n\t\tId: release.Id,\n\t}, nil\n}\n\nfunc (s *ReleaseService) GetRelease(ctx context.Context, req *models.GetReleaseRequest) (*models.GetReleaseResponse, error) {\n\trelease, err := models.GetRelease(req.Id)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, fmt.Errorf(\"failed to get release\")\n\t}\n\n\treturn &models.GetReleaseResponse{\n\t\tName:        release.Name,\n\t\tVersion:     release.Version,\n\t\tDescription: release.Description,\n\t\tDate:        release.Date.Format(\"2006-01-02\"),\n\t}, nil\n}\n\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := models.NewReleaseServiceClient(conn)\n\n\treq := &models.CreateReleaseRequest{\n\t\tName:        \"MyApp\",\n\t\tVersion:     \"1.0.0\",\n\t\tDescription: \"Initial release\",\n\t}\n\n\tres, err := client.CreateRelease(context.Background(), req)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create release: %v\", err)\n\t}\n\n\tfmt.Printf(\"Release created with ID: %s\\n\", res.Id)\n\n\tgetReq := &models.GetReleaseRequest{\n\t\tId: res.Id,\n\t}\n\n\tgetRes, err := client.GetRelease(context.Background(), getReq)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to get release: %v\", err)\n\t}\n\n\tfmt.Printf(\"Release: %v\\n\", getRes)\n}"}
{"sample": "package dnsserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"github.com/miekg/dns\"\n)\n\nfunc handleRequest(w dns.ResponseWriter, r *dns.Msg) {\n\tm := new(dns.Msg)\n\tm.SetReply(r)\n\tq := r.Question[0]\n\tswitch q.Qtype {\n\tcase dns.TypeA:\n\t\trr, err := dns.NewRR(fmt.Sprintf(\"%s A %s\", q.Name, \"127.0.0.1\"))\n\t\tif err == nil {\n\t\t\tm.Answer = append(m.Answer, rr)\n\t\t}\n\tdefault:\n\t\tlog.Printf(\"Unsupported query type: %d\\n\", q.Qtype)\n\t}\n\tw.WriteMsg(m)\n}\n\nfunc StartServer() {\n\tdns.HandleFunc(\".\", handleRequest)\n\taddr := net.JoinHostPort(\"127.0.0.1\", \"53\")\n\tserver := &dns.Server{Addr: addr, Net: \"udp\"}\n\tlog.Printf(\"Starting DNS server on %s\\n\", addr)\n\terr := server.ListenAndServe()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %s\\n\", err.Error())\n\t\tos.Exit(1)\n\t}\n}"}
{"sample": "package bigtableclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"cloud.google.com/go/bigtable\"\n\t\"google.golang.org/api/option\"\n)\n\ntype BigtableClient struct {\n\tclient *bigtable.Client\n}\n\nfunc NewBigtableClient(projectID, instanceID string) (*BigtableClient, error) {\n\tctx := context.Background()\n\tclient, err := bigtable.NewClient(ctx, projectID, instanceID, option.WithCredentialsFile(\"path/to/credentials.json\"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create client: %v\", err)\n\t}\n\treturn &BigtableClient{client: client}, nil\n}\n\nfunc (bt *BigtableClient) CreateTable(tableName string, familyName string) error {\n\tctx := context.Background()\n\tadminClient := bt.client.AdminClient()\n\n\ttables, err := adminClient.Tables(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get tables: %v\", err)\n\t}\n\n\tfor _, table := range tables {\n\t\tif table == tableName {\n\t\t\tlog.Printf(\"table %s already exists\", tableName)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif err := adminClient.CreateTable(ctx, tableName); err != nil {\n\t\treturn fmt.Errorf(\"failed to create table: %v\", err)\n\t}\n\n\tif err := adminClient.CreateColumnFamily(ctx, tableName, familyName); err != nil {\n\t\treturn fmt.Errorf(\"failed to create column family: %v\", err)\n\t}\n\n\tlog.Printf(\"table %s created successfully\", tableName)\n\treturn nil\n}\n\nfunc (bt *BigtableClient) WriteToTable(tableName string, familyName string, rowKey string, data map[string]string) error {\n\tctx := context.Background()\n\n\ttbl := bt.client.Open(tableName)\n\trow := tbl.Row(rowKey)\n\n\tmut := bigtable.NewMutation()\n\tfor k, v := range data {\n\t\tmut.Set(familyName, k, bigtable.Now(), []byte(v))\n\t}\n\n\tif err := row.Apply(ctx, mut); err != nil {\n\t\treturn fmt.Errorf(\"failed to apply row mutation: %v\", err)\n\t}\n\n\tlog.Printf(\"data written to table %s successfully\", tableName)\n\treturn nil\n}\n\nfunc (bt *BigtableClient) ReadFromTable(tableName string, familyName string, rowKey string) (map[string]string, error) {\n\tctx := context.Background()\n\n\ttbl := bt.client.Open(tableName)\n\trow, err := tbl.ReadRow(ctx, rowKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read row: %v\", err)\n\t}\n\n\tdata := make(map[string]string)\n\tfor col, cell := range row[familyName] {\n\t\tdata[col] = string(cell.Value)\n\t}\n\n\treturn data, nil\n}\n\nfunc (bt *BigtableClient) DeleteTable(tableName string) error {\n\tctx := context.Background()\n\tadminClient := bt.client.AdminClient()\n\n\tif err := adminClient.DeleteTable(ctx, tableName); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete table: %v\", err)\n\t}\n\n\tlog.Printf(\"table %s deleted successfully\", tableName)\n\treturn nil\n}\n\nfunc (bt *BigtableClient) Close() {\n\tbt.client.Close()\n\tlog.Println(\"bigtable client closed\")\n}"}
{"sample": "package stoogesort\n\nfunc StoogeSort(arr []int, l int, h int) {\n\tif l >= h {\n\t\treturn\n\t}\n\n\tif arr[l] > arr[h] {\n\t\tarr[l], arr[h] = arr[h], arr[l]\n\t}\n\n\tif h-l+1 > 2 {\n\t\tt := (h - l + 1) / 3\n\n\t\tStoogeSort(arr, l, h-t)\n\t\tStoogeSort(arr, l+t, h)\n\t\tStoogeSort(arr, l, h-t)\n\t}\n\n\treturn\n}"}
{"sample": "package bugservice\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype Bug struct {\n\tID          string    `json:\"id\"`\n\tTitle       string    `json:\"title\"`\n\tDescription string    `json:\"description\"`\n\tCreatedAt   time.Time `json:\"created_at\"`\n}\n\nvar bugs []Bug\n\nfunc createBug(w http.ResponseWriter, r *http.Request) {\n\tvar bug Bug\n\terr := json.NewDecoder(r.Body).Decode(&bug)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tbug.ID = fmt.Sprintf(\"%d\", time.Now().UnixNano())\n\tbug.CreatedAt = time.Now()\n\n\tbugs = append(bugs, bug)\n\n\tw.WriteHeader(http.StatusCreated)\n\tjson.NewEncoder(w).Encode(bug)\n}\n\nfunc getBug(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\n\tfor _, item := range bugs {\n\t\tif item.ID == params[\"id\"] {\n\t\t\tjson.NewEncoder(w).Encode(item)\n\t\t\treturn\n\t\t}\n\t}\n\n\tw.WriteHeader(http.StatusNotFound)\n}\n\nfunc getAllBugs(w http.ResponseWriter, r *http.Request) {\n\tjson.NewEncoder(w).Encode(bugs)\n}\n\nfunc updateBug(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\n\tfor index, item := range bugs {\n\t\tif item.ID == params[\"id\"] {\n\t\t\tbugs = append(bugs[:index], bugs[index+1:]...)\n\t\t\tvar bug Bug\n\t\t\terr := json.NewDecoder(r.Body).Decode(&bug)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tbug.ID = params[\"id\"]\n\t\t\tbug.CreatedAt = item.CreatedAt\n\n\t\t\tbugs = append(bugs, bug)\n\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tjson.NewEncoder(w).Encode(bug)\n\t\t\treturn\n\t\t}\n\t}\n\n\tw.WriteHeader(http.StatusNotFound)\n}\n\nfunc deleteBug(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\n\tfor index, item := range bugs {\n\t\tif item.ID == params[\"id\"] {\n\t\t\tbugs = append(bugs[:index], bugs[index+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc main() {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(\"/bugs\", createBug).Methods(\"POST\")\n\trouter.HandleFunc(\"/bugs\", getAllBugs).Methods(\"GET\")\n\trouter.HandleFunc(\"/bugs/{id}\", getBug).Methods(\"GET\")\n\trouter.HandleFunc(\"/bugs/{id}\", updateBug).Methods(\"PUT\")\n\trouter.HandleFunc(\"/bugs/{id}\", deleteBug).Methods(\"DELETE\")\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", router))\n}"}
{"sample": "package snmpserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/soniah/gosnmp\"\n)\n\nfunc Run() {\n\t// Listen for UDP requests on port 161\n\taddr := net.UDPAddr{\n\t\tPort: 161,\n\t\tIP:   net.ParseIP(\"0.0.0.0\"),\n\t}\n\tconn, err := net.ListenUDP(\"udp\", &addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error opening connection: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Get the system uptime\n\tsysUpTime := uint32(time.Since(startTime).Seconds())\n\n\t// Initialize the SNMP server\n\tparams := &gosnmp.GoSNMP{\n\t\tPort:          161,\n\t\tCommunity:     \"public\",\n\t\tVersion:       gosnmp.Version2c,\n\t\tMaxOids:       gosnmp.MaxOids,\n\t\tTimeout:       time.Duration(2) * time.Second,\n\t\tRetries:       3,\n\t\tExponential:   true,\n\t\tTrapTarget:    \"localhost\",\n\t\tTrapCommunity: \"public\",\n\t}\n\n\t// Register the SNMP handlers\n\tparams.SetPDUHandler(gosnmp.GetRequest, getRequestHandler)\n\tparams.SetPDUHandler(gosnmp.GetNextRequest, getNextRequestHandler)\n\tparams.SetPDUHandler(gosnmp.SetRequest, setRequestHandler)\n\n\t// Start the SNMP server\n\tgo func() {\n\t\tif err := params.ListenAndServe(); err != nil {\n\t\t\tlog.Fatalf(\"Error starting SNMP server: %v\", err)\n\t\t}\n\t}()\n\n\t// Handle incoming requests\n\tbuf := make([]byte, 1024)\n\tfor {\n\t\tn, addr, err := conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading from UDP: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tpacket := gosnmp.SnmpPacket{}\n\t\tif err := packet.UnmarshalMsg(buf[:n]); err != nil {\n\t\t\tlog.Printf(\"Error unmarshalling packet: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Set the system uptime for each request\n\t\tpacket.Variables = append(packet.Variables, gosnmp.SnmpPDU{\n\t\t\tName:  \"1.3.6.1.2.1.1.3.0\",\n\t\t\tType:  gosnmp.TimeTicks,\n\t\t\tValue: sysUpTime,\n\t\t})\n\n\t\t// Handle the request using the appropriate handler\n\t\tresponse, err := params.ProcessPacket(&packet)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error processing packet: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Send the response back to the client\n\t\tbuf, err := response.MarshalMsg()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error marshalling response: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif _, err := conn.WriteToUDP(buf, addr); err != nil {\n\t\t\tlog.Printf(\"Error writing to UDP: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc getRequestHandler(packet *gosnmp.SnmpPacket, target *gosnmp.GoSNMP) (*gosnmp.SnmpPacket, error) {\n\t// Handle the GetRequest\n\t// ...\n\n\treturn &gosnmp.SnmpPacket{}, nil\n}\n\nfunc getNextRequestHandler(packet *gosnmp.SnmpPacket, target *gosnmp.GoSNMP) (*gosnmp.SnmpPacket, error) {\n\t// Handle the GetNextRequest\n\t// ...\n\n\treturn &gosnmp.SnmpPacket{}, nil\n}\n\nfunc setRequestHandler(packet *gosnmp.SnmpPacket, target *gosnmp.GoSNMP) (*gosnmp.SnmpPacket, error) {\n\t// Handle the SetRequest\n\t// ...\n\n\treturn &gosnmp.SnmpPacket{}, nil\n}\n\nvar startTime time.Time\n\nfunc init() {\n\tstartTime = time.Now()\n\tlog.SetOutput(os.Stdout)\n\tlog.SetFlags(log.LstdFlags | log.Lmicroseconds)\n}"}
{"sample": "package pubsub\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"cloud.google.com/go/pubsub\"\n)\n\ntype PubSubManager struct {\n\tclient *pubsub.Client\n\ttopic  *pubsub.Topic\n}\n\nfunc NewPubSubManager(ctx context.Context, projectID, topicName string) (*PubSubManager, error) {\n\tclient, err := pubsub.NewClient(ctx, projectID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create client: %v\", err)\n\t}\n\n\ttopic := client.Topic(topicName)\n\n\treturn &PubSubManager{\n\t\tclient: client,\n\t\ttopic:  topic,\n\t}, nil\n}\n\nfunc (m *PubSubManager) Publish(ctx context.Context, msg []byte) error {\n\tres := m.topic.Publish(ctx, &pubsub.Message{\n\t\tData: msg,\n\t})\n\n\tid, err := res.Get(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to publish message: %v\", err)\n\t}\n\n\tlog.Printf(\"Published message with ID: %s\", id)\n\n\treturn nil\n}\n\nfunc (m *PubSubManager) Close() error {\n\treturn m.client.Close()\n}"}
