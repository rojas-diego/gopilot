{"sample": "package staticserv\n\nimport (\n\t\"net/http\"\n)\n\nfunc serveStaticFiles(w http.ResponseWriter, r *http.Request) {\n\t// Set the directory to serve static files from\n\tfs := http.FileServer(http.Dir(\"static\"))\n\n\t// Serve the static files\n\tfs.ServeHTTP(w, r)\n}\n\nfunc main() {\n\t// Set up the HTTP server\n\thttp.HandleFunc(\"/\", serveStaticFiles)\n\n\t// Start the server\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package restapi\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\t_ \"github.com/lib/pq\"\n)\n\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n\tdb, err := sql.Open(\"postgres\", \"postgres://user:password@localhost/dbname?sslmode=disable\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tusers := []User{}\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Email)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(w).Encode(users)\n}\n\nfunc addUser(w http.ResponseWriter, r *http.Request) {\n\tdb, err := sql.Open(\"postgres\", \"postgres://user:password@localhost/dbname?sslmode=disable\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tvar user User\n\terr = json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO users (username, email) VALUES ($1, $2)\", user.Username, user.Email)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n}"}
{"sample": "package fiborecursion\n\nfunc fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\n\treturn fibonacci(n-1) + fibonacci(n-2)\n}"}
{"sample": "package csvmanip\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype Entry struct {\n\tID    int\n\tName  string\n\tEmail string\n}\n\nfunc readCSV() ([]Entry, error) {\n\tfile, err := os.Open(\"data.csv\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\n\trecords, err := reader.ReadAll()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tentries := []Entry{}\n\tfor _, record := range records {\n\t\tentry := Entry{\n\t\t\tID:    record[0],\n\t\t\tName:  record[1],\n\t\t\tEmail: record[2],\n\t\t}\n\t\tentries = append(entries, entry)\n\t}\n\n\treturn entries, nil\n}\n\nfunc writeCSV(entries []Entry) error {\n\tfile, err := os.Create(\"data.csv\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\n\tfor _, entry := range entries {\n\t\trecord := []string{entry.ID, entry.Name, entry.Email}\n\t\tif err := writer.Write(record); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\twriter.Flush()\n\n\treturn nil\n}\n\nfunc updateEntry(id int, name string, email string) error {\n\tentries, err := readCSV()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i, entry := range entries {\n\t\tif entry.ID == id {\n\t\t\tentry.Name = name\n\t\t\tentry.Email = email\n\t\t\tentries[i] = entry\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err := writeCSV(entries); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tentries, err := readCSV()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(entries)\n\n\tentry := Entry{\n\t\tID:    \"4\",\n\t\tName:  \"John\",\n\t\tEmail: \"john@example.com\",\n\t}\n\n\tentries = append(entries, entry)\n\n\tif err := writeCSV(entries); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := updateEntry(2, \"Jane\", \"jane@example.com\"); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package geocode\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype GeocodeResponse struct {\n\tStatus  string            `json:\"status\"`\n\tResults []GeocodeResult   `json:\"results\"`\n\tError   string            `json:\"error_message,omitempty\"`\n}\n\ntype GeocodeResult struct {\n\tFormattedAddress string              `json:\"formatted_address\"`\n\tGeometry         GeocodeGeometry     `json:\"geometry\"`\n\tAddressComponents []GeocodeComponent `json:\"address_components\"`\n}\n\ntype GeocodeGeometry struct {\n\tLocation GeocodeLocation `json:\"location\"`\n}\n\ntype GeocodeLocation struct {\n\tLat float64 `json:\"lat\"`\n\tLng float64 `json:\"lng\"`\n}\n\ntype GeocodeComponent struct {\n\tLongName  string   `json:\"long_name\"`\n\tShortName string   `json:\"short_name\"`\n\tTypes     []string `json:\"types\"`\n}\n\nfunc Geocode(address string) (*GeocodeResponse, error) {\n\turlStr := fmt.Sprintf(\"https://maps.googleapis.com/maps/api/geocode/json?address=%s\", url.QueryEscape(address))\n\tresp, err := http.Get(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response GeocodeResponse\n\terr = json.Unmarshal(body, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif response.Status != \"OK\" {\n\t\treturn nil, fmt.Errorf(\"Geocoding failed with status: %s\", response.Status)\n\t}\n\n\treturn &response, nil\n}"}
{"sample": "package webscraper\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gocolly/colly\"\n)\n\nfunc Scrape(urls []string) ([]string, error) {\n\tvar results []string\n\tvar mu sync.Mutex\n\n\tc := colly.NewCollector()\n\n\tc.OnHTML(\"title\", func(e *colly.HTMLElement) {\n\t\tmu.Lock()\n\t\tresults = append(results, fmt.Sprintf(\"%s - %s\", e.Text, e.Request.URL.String()))\n\t\tmu.Unlock()\n\t})\n\n\tvar wg sync.WaitGroup\n\tfor _, url := range urls {\n\t\twg.Add(1)\n\t\tgo func(url string) {\n\t\t\tdefer wg.Done()\n\t\t\tif err := c.Visit(url); err != nil {\n\t\t\t\tfmt.Printf(\"Error visiting %s: %v\\n\", url, err)\n\t\t\t}\n\t\t}(url)\n\t}\n\n\twg.Wait()\n\n\tif len(results) == 0 {\n\t\treturn nil, fmt.Errorf(\"no results found\")\n\t}\n\n\treturn results, nil\n}\n\nfunc main() {\n\turls := []string{\"https://www.google.com\", \"https://www.facebook.com\", \"https://www.twitter.com\"}\n\n\tstart := time.Now()\n\tresults, err := Scrape(urls)\n\tif err != nil {\n\t\tfmt.Printf(\"Error scraping: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Results: %v\\n\", results)\n\tfmt.Printf(\"Scraping took %v\\n\", time.Since(start))\n}"}
{"sample": "package chatserver\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nfunc handleConnections(w http.ResponseWriter, r *http.Request) {\n\t// Upgrade initial GET request to a websocket\n\tws, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ws.Close()\n\n\t// Register our new client\n\tclients[ws] = true\n\n\tfor {\n\t\tvar msg Message\n\t\t// Read in a new message as JSON and map it to a Message object\n\t\terr := ws.ReadJSON(&msg)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\tdelete(clients, ws)\n\t\t\tbreak\n\t\t}\n\t\t// Send the newly received message to the broadcast channel\n\t\tbroadcast <- msg\n\t}\n}\n\nfunc handleMessages() {\n\tfor {\n\t\t// Grab the next message from the broadcast channel\n\t\tmsg := <-broadcast\n\t\t// Send it out to every client that is currently connected\n\t\tfor client := range clients {\n\t\t\terr := client.WriteJSON(msg)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\t\tclient.Close()\n\t\t\t\tdelete(clients, client)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc StartServer() {\n\t// Create a simple file server\n\tfs := http.FileServer(http.Dir(\"public\"))\n\thttp.Handle(\"/\", fs)\n\n\t// Configure websocket route\n\thttp.HandleFunc(\"/ws\", handleConnections)\n\n\t// Start listening for incoming chat messages\n\tgo handleMessages()\n\n\t// Start the server on localhost port 8080 and log any errors\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err)\n\t}\n}"}
