{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/hashicorp/raft\"\n)\n\ntype myFSM struct {\n\tmu      sync.Mutex\n\tstorage map[string]string\n}\n\nfunc (fsm *myFSM) apply(logEntry *raft.Log) interface{} {\n\tvar cmd KVCommand\n\terr := cmd.Decode(logEntry.Data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfsm.mu.Lock()\n\tdefer fsm.mu.Unlock()\n\n\tswitch cmd.Op {\n\tcase OpSet:\n\t\tfsm.storage[cmd.Key] = cmd.Value\n\tcase OpDelete:\n\t\tdelete(fsm.storage, cmd.Key)\n\t}\n\n\treturn nil\n}\n\nfunc (fsm *myFSM) snapshot() (raft.FSMSnapshot, error) {\n\tfsm.mu.Lock()\n\tdefer fsm.mu.Unlock()\n\n\tstorage := make(map[string]string, len(fsm.storage))\n\tfor k, v := range fsm.storage {\n\t\tstorage[k] = v\n\t}\n\n\treturn &mySnapshot{storage: storage}, nil\n}\n\nfunc (fsm *myFSM) restore(snap io.ReadCloser) error {\n\tsnapshot := &mySnapshot{}\n\terr := snapshot.Decode(snap)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfsm.mu.Lock()\n\tdefer fsm.mu.Unlock()\n\tfsm.storage = snapshot.storage\n\n\treturn nil\n}\n\nfunc main() {\n\tfsm := &myFSM{storage: make(map[string]string)}\n\tconfig := raft.DefaultConfig()\n\tconfig.LocalID = raft.ServerID(\"node1\")\n\tconfig.Logger = log.New(os.Stderr, \"[raft]\", log.LstdFlags)\n\tconfig.SnapshotThreshold = 1000\n\n\ttrans, err := raft.NewTCPTransport(\"127.0.0.1:0\", nil, 3, time.Second, config.Logger)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tpeerStore := raft.NewJSONPeers(\"peers.json\", trans)\n\tsnapshotStore, err := raft.NewFileSnapshotStore(\"snapshots\", 1, config.Logger)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\traftInstance, err := raft.NewRaft(config, fsm, raft.NewInmemStore(), raft.NewInmemStore(), snapshotStore, peerStore, trans)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// join to leader\n\terr = raftInstance.BootstrapCluster(raft.Configuration{\n\t\tServers: []raft.Server{\n\t\t\t{\n\t\t\t\tID:      config.LocalID,\n\t\t\t\tAddress: trans.LocalAddr(),\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// start gRPC server\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", 8080))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tkv.RegisterKVServiceServer(s, &kvServer{raftInstance})\n\tgo func() {\n\t\tif err := s.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\t// start command line interface\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tfmt.Println(\"Enter command:\")\n\t\t\t\tfmt.Println(\"1. set key value\")\n\t\t\t\tfmt.Println(\"2. get key\")\n\t\t\t\tfmt.Println(\"3. delete key\")\n\t\t\t\tfmt.Println(\"4. exit\")\n\t\t\t\tvar cmd int\n\t\t\t\tfmt.Scanln(&cmd)\n\t\t\t\tswitch cmd {\n\t\t\t\tcase 1:\n\t\t\t\t\tfmt.Print(\"Enter key: \")\n\t\t\t\t\tvar key string\n\t\t\t\t\tfmt.Scanln(&key)\n\t\t\t\t\tfmt.Print(\"Enter value: \")\n\t\t\t\t\tvar value string\n\t\t\t\t\tfmt.Scanln(&value)\n\t\t\t\t\tdata, err := json.Marshal(KVCommand{Op: OpSet, Key: key, Value: value})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t_, err = raftInstance.Apply(data, 5*time.Second)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t}\n\t\t\t\tcase 2:\n\t\t\t\t\tfmt.Print(\"Enter key: \")\n\t\t\t\t\tvar key string\n\t\t\t\t\tfmt.Scanln(&key)\n\t\t\t\t\tdata, err := json.Marshal(KVCommand{Op: OpGet, Key: key})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tfuture := raftInstance.Apply(data, 5*time.Second)\n\t\t\t\t\tif err := future.Error(); err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif future.Response() == nil {\n\t\t\t\t\t\tfmt.Println(\"Not found\")\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tcmd := future.Response().(KVCommand)\n\t\t\t\t\tfmt.Printf(\"%s=%s\\n\", cmd.Key, cmd.Value)\n\t\t\t\tcase 3:\n\t\t\t\t\tfmt.Print(\"Enter key: \")\n\t\t\t\t\tvar key string\n\t\t\t\t\tfmt.Scanln(&key)\n\t\t\t\t\tdata, err := json.Marshal(KVCommand{Op: OpDelete, Key: key})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t_, err = raftInstance.Apply(data, 5*time.Second)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t}\n\t\t\t\tcase 4:\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// wait until canceled\n\t<-ctx.Done()\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/jmoiron/sqlx\"\n\t\"github.com/your-username/project-name/db\"\n\tpb \"github.com/your-username/project-name/proto\"\n\t\"google.golang.org/grpc\"\n)\n\ntype server struct{}\n\nfunc (s *server) GetUsers(ctx context.Context, req *pb.UserRequest) (*pb.UserResponse, error) {\n\tvar users []db.User\n\terr := sqlx.Select(db.Conn, &users, \"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn nil, err\n\t}\n\n\tvar userResponses []*pb.User\n\n\tfor _, user := range users {\n\t\tuserResponses = append(userResponses, &pb.User{\n\t\t\tId:    user.ID,\n\t\t\tName:  user.Name,\n\t\t\tEmail: user.Email,\n\t\t})\n\t}\n\n\treturn &pb.UserResponse{Users: userResponses}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", 50051))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\n\tpb.RegisterUserServiceServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}\n\nfunc init() {\n\tvar err error\n\tdb.Conn, err = sqlx.Connect(\"mysql\", \"root:password@tcp(127.0.0.1:3306)/mydb\")\n\tif err != nil {\n\t\tpanic(errors.New(\"Could not connect to MySQL.\"))\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/jmoiron/sqlx\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"google.golang.org/grpc\"\n\n\tpb \"myapp/protos\"\n)\n\ntype server struct{}\n\nfunc (s *server) CreateUser(ctx context.Context, in *pb.User) (*pb.Response, error) {\n\tdb, err := sqlx.Connect(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\tsqlStatement := `INSERT INTO users (name, email) VALUES (?, ?)`\n\n\t_, err = db.Exec(sqlStatement, in.Name, in.Email)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to execute query: %v\", err)\n\t}\n\n\treturn &pb.Response{Message: fmt.Sprintf(\"User %v created successfully\", in.Name)}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterUserServer(s, &server{})\n\tlog.Printf(\"Server starting on port %v...\\n\", lis.Addr().String())\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/protobuf\"\n)\n\ntype server struct {\n\tpb.UnimplementedServiceServer\n}\n\nfunc (s *server) GetTask(ctx context.Context, in *pb.TaskRequest) (*pb.TaskResponse, error) {\n\t// Code to fetch task from MySQL\n\t// ...\n\t// Code to create response\n\tresp := &pb.TaskResponse{\n\t\tId:          in.Id,\n\t\tTitle:       \"Task Title\",\n\t\tDescription: \"Task Description\",\n\t\tStatus:      \"In Progress\",\n\t}\n\treturn resp, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterServiceServer(s, &server{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"myapp/protos\"\n)\n\nconst (\n\tport = \":50051\"\n)\n\ntype server struct {\n\tpb.UnimplementedMyServiceServer\n}\n\nfunc (s *server) GetMyData(ctx context.Context, in *pb.MyDataRequest) (*pb.MyDataResponse, error) {\n\tlog.Printf(\"Received: %v\", in.GetText())\n\treturn &pb.MyDataResponse{\n\t\tText: \"Hello \" + in.GetText(),\n\t}, nil\n}\n\nfunc startGRPCServer() error {\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterMyServiceServer(s, &server{})\n\treturn s.Serve(lis)\n}\n\nfunc testMySQL() error {\n\t// Implement MySQL test\n\treturn nil\n}\n\nfunc main() {\n\tgo func() {\n\t\tif err := startGRPCServer(); err != nil {\n\t\t\tlog.Fatalf(\"Failed to start gRPC server: %v\", err)\n\t\t}\n\t}()\n\n\tif err := testMySQL(); err != nil {\n\t\tlog.Fatalf(\"Failed to test MySQL: %v\", err)\n\t}\n\n\t// Wait for a bit before exiting\n\ttime.Sleep(5 * time.Second)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/proto/file\"\n)\n\nfunc main() {\n\t// Set up a connection to the server.\n\tconn, err := grpc.Dial(address, grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewYourServiceClient(conn)\n\n\t// Contact the server and print out its response.\n\tname := \"John Doe\"\n\tctx := context.Background()\n\tr, err := c.YourRPC(ctx, &pb.YourRequest{Name: name})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"Response from server: %s\", r.Message)\n\n\t// Send a proto message\n\tprotoMessage := &pb.YourProtoMessage{Field: \"value\"}\n\ts, err := proto.Marshal(protoMessage)\n\tif err != nil {\n\t\tlog.Fatalf(\"could not marshal proto message: %v\", err)\n\t}\n\tr, err = c.YourRPC(ctx, &pb.YourRequest{Name: name, ProtoMessage: s})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet with proto message: %v\", err)\n\t}\n\tlog.Printf(\"Response from server with proto message: %s\", r.Message)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"github.com/myorg/myapp/proto\"\n\t\"google.golang.org/grpc\"\n)\n\ntype server struct {\n\tpb.UnimplementedMyServiceServer\n}\n\nfunc (s *server) Insert(ctx context.Context, req *pb.InsertRequest) (*pb.InsertResponse, error) {\n\t// code to insert data into MySQL\n\treturn &pb.InsertResponse{}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterMyServiceServer(s, &server{})\n\tfmt.Println(\"Starting server...\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype User struct {\n\tId    int64\n\tName  string\n\tEmail string\n}\n\ntype UserService struct {\n\tusers []*User\n}\n\nfunc (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) (*CreateUserResponse, error) {\n\tuser := &User{\n\t\tId:    int64(len(s.users) + 1),\n\t\tName:  req.Name,\n\t\tEmail: req.Email,\n\t}\n\ts.users = append(s.users, user)\n\treturn &CreateUserResponse{\n\t\tId: user.Id,\n\t}, nil\n}\n\nfunc (s *UserService) GetUser(ctx context.Context, req *GetUserRequest) (*GetUserResponse, error) {\n\tfor _, user := range s.users {\n\t\tif user.Id == req.Id {\n\t\t\treturn &GetUserResponse{\n\t\t\t\tUser: user,\n\t\t\t}, nil\n\t\t}\n\t}\n\treturn nil, status.Error(codes.NotFound, \"User not found\")\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tcreds, err := credentials.NewServerTLSFromFile(\"cert.pem\", \"key.pem\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to load credentials: %v\", err)\n\t}\n\n\ts := grpc.NewServer(grpc.Creds(creds))\n\tRegisterUserServiceServer(s, &UserService{})\n\tfmt.Println(\"Server listening on port :8080\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\n\t\"myapp/protobuf\"\n)\n\ntype server struct {\n\tprotobuf.UnimplementedMyServiceServer\n}\n\nfunc (s *server) SayHello(ctx context.Context, in *protobuf.HelloRequest) (*protobuf.HelloReply, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &protobuf.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tprotobuf.RegisterMyServiceServer(s, &server{})\n\tfmt.Println(\"Server started at port 8080\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct{}\n\nfunc (s *Server) Ping(ctx context.Context, req *PingRequest) (*PingResponse, error) {\n\treturn &PingResponse{Message: \"Pong!\"}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":8888\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\tRegisterPingServiceServer(s, &Server{})\n\n\tgo func() {\n\t\tif err := s.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(5 * time.Second)\n\tconn, err := grpc.Dial(\":8888\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewPingServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tr, err := client.Ping(ctx, &PingRequest{})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not ping: %v\", err)\n\t}\n\tlog.Printf(\"Ping response: %s\", r.Message)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tpong, err := rdb.Ping(ctx).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(pong)\n\n\terr = rdb.Set(ctx, \"key\", \"value\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tval, err := rdb.Get(ctx, \"key\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"key\", val)\n\n\terr = rdb.Del(ctx, \"key\").Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\tdefer cancel()\n\n\tch := make(chan string, 1)\n\n\tgo slowProcess(ctx, ch)\n\n\tselect {\n\tcase result := <-ch:\n\t\tfmt.Println(result)\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"Process timed out\")\n\t}\n}\n\nfunc slowProcess(ctx context.Context, ch chan<- string) {\n\tselect {\n\tcase <-time.After(5 * time.Second):\n\t\tch <- \"Process completed\"\n\tcase <-ctx.Done():\n\t\treturn\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\tdefer cancel()\n\n\tselect {\n\tcase <-time.After(5 * time.Second):\n\t\tfmt.Println(\"time.After: This should never be printed.\")\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"Context done:\", ctx.Err())\n\t}\n} \n\n// Output:\n// Context done: context deadline exceeded"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/\", homeHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/about\", aboutHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/contact\", contactHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/user/{id:[0-9]+}\", userHandler).Methods(\"GET\")\n\n\tsrv := &http.Server{\n\t\tHandler:      r,\n\t\tAddr:         \"127.0.0.1:8080\",\n\t\tWriteTimeout: 15 * time.Second,\n\t\tReadTimeout:  15 * time.Second,\n\t}\n\n\tfmt.Println(\"Server listening on port 8080\")\n\tif err := srv.ListenAndServe(); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"Welcome to my website!\")\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"This is my personal website.\")\n}\n\nfunc contactHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"You can contact me at example@example.com.\")\n}\n\nfunc userHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid := vars[\"id\"]\n\n\tfmt.Fprintf(w, \"User ID: %v\", id)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype User struct {\n\tUsername  string    `json:\"username\"`\n\tEmail     string    `json:\"email,omitempty\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n}\n\nfunc getUserHandler(w http.ResponseWriter, r *http.Request) {\n\tuser := User{\n\t\tUsername:  \"johndoe\",\n\t\tCreatedAt: time.Now(),\n\t}\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/user\", getUserHandler)\n\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tfmt.Println(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\tsqlite3 \"github.com/mattn/go-sqlite3\"\n\t\"gorm.io/driver/sqlite\"\n\t\"gorm.io/gorm\"\n)\n\ntype User struct {\n\tgorm.Model\n\tName       string\n\tEmail      string `gorm:\"unique;not null\"`\n\tAge        uint8\n\tBirthdate  time.Time\n\tCreditCard CreditCard `gorm:\"foreignKey:UserID\"`\n}\n\ntype CreditCard struct {\n\tgorm.Model\n\tUserID     uint\n\tNumber     string\n\tExpiration string\n}\n\nfunc main() {\n\tdb, err := gorm.Open(sqlite.Open(\"test.db\"), &gorm.Config{})\n\tif err != nil {\n\t\tpanic(\"failed to connect database\")\n\t}\n\n\t// Make sure foreign key constraints are enabled\n\tsqlDB, err := db.DB()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer sqlDB.Close()\n\n\tif v, ok := sqlDB.Driver().(*sqlite3.SQLiteDriver); ok {\n\t\tv.Connector.EnableForeignKeys(true) // Enable foreign key constraints\n\t}\n\n\t// Automigrate the database\n\tif err := db.AutoMigrate(&User{}, &CreditCard{}); err != nil {\n\t\tlog.Fatalf(\"Failed to auto migrate: %v\", err)\n\t}\n\n\t// Create a user and their credit card\n\tuser := User{\n\t\tName:      \"John\",\n\t\tEmail:     \"john@gmail.com\",\n\t\tAge:       25,\n\t\tBirthdate: time.Date(1996, 5, 18, 0, 0, 0, 0, time.UTC),\n\t\tCreditCard: CreditCard{\n\t\t\tNumber:     \"1234567890123456\",\n\t\t\tExpiration: \"12/22\",\n\t\t},\n\t}\n\n\tif err := db.Create(&user).Error; err != nil {\n\t\tlog.Fatalf(\"Failed to create user: %v\", err)\n\t}\n\n\t// Find user by email\n\tvar foundUser User\n\tif err := db.Where(\"email = ?\", \"john@gmail.com\").First(&foundUser).Error; err != nil {\n\t\tlog.Fatalf(\"Failed to find user: %v\", err)\n\t}\n\tfmt.Printf(\"Found user: %+v\\n\", foundUser)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to open a channel\")\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when unused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\n\tmsgs, err := ch.Consume(\n\t\tq.Name, // queue\n\t\t\"\",     // consumer\n\t\ttrue,   // auto-ack\n\t\tfalse,  // exclusive\n\t\tfalse,  // no-local\n\t\tfalse,  // no-wait\n\t\tnil,    // args\n\t)\n\tfailOnError(err, \"Failed to register a consumer\")\n\n\tforever := make(chan bool)\n\n\tgo func() {\n\t\tfor d := range msgs {\n\t\t\tlog.Printf(\"Received a message: %s\", d.Body)\n\t\t}\n\t}()\n\n\tlog.Printf(\" [*] Waiting for messages. To exit press CTRL+C\")\n\t<-forever\n}\n\n// This code creates a connection to a RabbitMQ server, declares a queue, and waits for messages to be sent to the queue. When a message is received, it is printed to the console. This is a common pattern in message-based systems and demonstrates the use of the popular AMQP library in Go."}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/aws/aws-lambda-go/events\"\n\t\"github.com/aws/aws-lambda-go/lambda\"\n)\n\ntype Request events.APIGatewayProxyRequest\n\ntype Response struct {\n\tBody       string `json:\"body\"`\n\tStatusCode int    `json:\"statusCode\"`\n}\n\nfunc handleRequest(ctx context.Context, req Request) (Response, error) {\n\tfmt.Println(req.Body)\n\n\tresponse := Response{\n\t\tBody:       \"Hello, World!\",\n\t\tStatusCode: 200,\n\t}\n\n\treturn response, nil\n}\n\nfunc main() {\n\tlambda.Start(handleRequest)\n}\n\n// This snippet shows a simple AWS Lambda function using Golang to return a \"Hello, World!\" HTTP response with a status code of 200 via a JSON response. It relies on the AWS Lambda Go SDK for interfacing with the AWS Lambda service. The function can be deployed with ease provided the necessary configuration settings for deployment are in place."}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\tfmt.Println(\"Starting task...\")\n\n\t// Simulating a long-running task\n\ttime.Sleep(5 * time.Second)\n\n\telapsed := time.Since(start)\n\tfmt.Printf(\"Task completed in %s\\n\", elapsed)\n}"}
{"sample": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Create(\"log.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tlogger := log.New(file, \"my-app\", log.LstdFlags)\n\n\tlogger.Println(\"Starting application...\")\n\t// ...\n\tlogger.Println(\"Application stopped.\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/spf13/cobra\"\n)\n\nvar rootCmd = &cobra.Command{\n\tUse:   \"myapp\",\n\tShort: \"A brief description of my app\",\n\tLong:  `A longer description that explains more about what my app does and how it works`,\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tfmt.Println(\"Hello, World!\")\n\t},\n}\n\nfunc main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tnumWorkers := 5\n\tjobs := make(chan int, numWorkers*2) // buffer jobs to prevent deadlock\n\n\t// Add jobs to channel\n\tgo func() {\n\t\tfor i := 0; i < numWorkers*2; i++ {\n\t\t\tjobs <- i\n\t\t}\n\t\tclose(jobs)\n\t}()\n\n\t// Start worker goroutines\n\tfor i := 0; i < numWorkers; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor job := range jobs {\n\t\t\t\tfmt.Printf(\"Worker %d handling job %d\\n\", id, job)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\t// Wait for workers to finish\n\twg.Wait()\n\tfmt.Println(\"All jobs complete\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar wg sync.WaitGroup\n\nfunc main() {\n\tfor i := 1; i <= 5; i++ {\n\t\twg.Add(1)\n\t\tgo processJob(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All jobs are done!\")\n}\n\nfunc processJob(id int) {\n\tfmt.Printf(\"Job %d has started\\n\", id)\n\ttime.Sleep(time.Second * time.Duration(id))\n\tfmt.Printf(\"Job %d has finished\\n\", id)\n\twg.Done()\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tName     string `json:\"name\"`\n\tAge      int    `json:\"age\"`\n\tEmail    string `json:\"email\"`\n\tPassword string `json:\"password\"`\n}\n\nfunc login(w http.ResponseWriter, r *http.Request) {\n\tvar user User\n\terr := json.NewDecoder(r.Body).Decode(&user)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// validate user credentials and authenticate\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\n\t// return user information or access token\n\tresponse := map[string]string{\"message\": \"Login successful\"}\n\tjson.NewEncoder(w).Encode(response)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/login\", login)\n\n\tfmt.Println(\"Server listening on port 8080\")\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tfmt.Println(err.Error())\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tfmt.Println(\"Welcome to the number guessing game!\")\n\tfmt.Println(\"I'm thinking of a number between 1 and 100. Can you guess it?\")\n\n\t// generate random number between 1 and 100\n\tanswer := 1 + (99 * Random())\n\n\t// loop until user guesses the correct number or quits\n\tfor {\n\t\tvar guess int\n\t\tfmt.Print(\"Make a guess (or enter 0 to quit): \")\n\t\t_, err := fmt.Scanf(\"%d\", &guess)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Invalid input, try again.\")\n\t\t\tcontinue\n\t\t}\n\t\tif guess == 0 {\n\t\t\tfmt.Println(\"Thanks for playing!\")\n\t\t\tos.Exit(0)\n\t\t}\n\t\tif guess < answer {\n\t\t\tfmt.Println(\"Too low, try again!\")\n\t\t} else if guess > answer {\n\t\t\tfmt.Println(\"Too high, try again!\")\n\t\t} else {\n\t\t\tfmt.Println(\"Congratulations, you guessed it!\")\n\t\t\tos.Exit(0)\n\t\t}\n\t}\n}\n\n// Random returns a random float between 0 and 1.\nfunc Random() float64 {\n\tseed := int64(10)\n\ta := int64(16807)\n\tm := int64(2147483647)\n\treturn float64((seed * a) % m)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc timeoutHandler(h http.Handler, timeout time.Duration) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        timer := time.AfterFunc(timeout, func() {\n            w.WriteHeader(http.StatusGatewayTimeout)\n        })\n\n        defer timer.Stop()\n\n        h.ServeHTTP(w, r)\n    })\n}\n\nfunc main() {\n    port := os.Getenv(\"PORT\")\n    if port == \"\" {\n        port = \"8080\"\n    }\n\n    handler := timeoutHandler(http.DefaultServeMux, 10*time.Second)\n    http.Handle(\"/\", handler)\n\n    fmt.Printf(\"Listening on port %s...\\n\", port)\n    err := http.ListenAndServe(fmt.Sprintf(\":%s\", port), nil)\n    if err != nil {\n        panic(err)\n    }\n}"}
{"sample": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype User struct {\n\tID        int\n\tName      string\n\tCreatedAt time.Time\n}\n\ntype UserRepository interface {\n\tCreate(user *User) error\n\tGetByID(id int) (*User, error)\n}\n\ntype InMemoryUserRepository struct {\n\tusers []*User\n}\n\nfunc NewInMemoryUserRepository() *InMemoryUserRepository {\n\treturn &InMemoryUserRepository{\n\t\tusers: make([]*User, 0),\n\t}\n}\n\nfunc (r *InMemoryUserRepository) Create(user *User) error {\n\tif user.ID == 0 || user.Name == \"\" {\n\t\treturn errors.New(\"user ID and name are required\")\n\t}\n\tuser.CreatedAt = time.Now()\n\tr.users = append(r.users, user)\n\treturn nil\n}\n\nfunc (r *InMemoryUserRepository) GetByID(id int) (*User, error) {\n\tfor _, user := range r.users {\n\t\tif user.ID == id {\n\t\t\treturn user, nil\n\t\t}\n\t}\n\treturn nil, errors.New(\"user not found\")\n}\n\nfunc main() {\n\trepo := NewInMemoryUserRepository()\n\n\tuser1 := &User{ID: 1, Name: \"Alice\"}\n\terr1 := repo.Create(user1)\n\tif err1 != nil {\n\t\tfmt.Println(err1)\n\t\treturn\n\t}\n\n\tuser2, err2 := repo.GetByID(1)\n\tif err2 != nil {\n\t\tfmt.Println(err2)\n\t\treturn\n\t}\n\tfmt.Printf(\"User: ID=%d, Name=%s, CreatedAt=%v\\n\", user2.ID, user2.Name, user2.CreatedAt)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\tfmt.Println(\"Starting work\")\n\n\tdone := make(chan bool)\n\tgo func() {\n\t\tfmt.Println(\"Working...\")\n\t\ttime.Sleep(3 * time.Second)\n\t\tdone <- true\n\t}()\n\n\t<-done\n\tfmt.Printf(\"Work took %v\\n\", time.Since(start))\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID       int\n\tUsername string\n\tEmail    string\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@/database\")\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\tdefer rows.Close()\n\n\tvar users []User\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Email)\n\t\tif err != nil {\n\t\t\tpanic(err.Error())\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\n\tfor _, user := range users {\n\t\tfmt.Printf(\"%d %s %s\\n\", user.ID, user.Username, user.Email)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(\"Starting up...\")\n\n\tdoneCh := make(chan bool, 1)\n\tsigCh := make(chan os.Signal, 1)\n\tsignal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\tsig := <-sigCh\n\t\tfmt.Printf(\"Signal received: %v. Shutting down...\\n\", sig)\n\t\tdoneCh <- true\n\t}()\n\n\t// Work to be done here\n\tfor i := 1; i <= 10; i++ {\n\t\tselect {\n\t\tcase <-doneCh:\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Printf(\"Working... (%d/10)\\n\", i)\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}\n\n\tfmt.Println(\"Finished working, shutting down\")\n}"}
{"sample": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n)\n\nvar (\n\tusername string\n\tpassword string\n\thost     string\n\tport     string\n)\n\nfunc init() {\n\tflag.StringVar(&username, \"username\", \"\", \"username for the database connection\")\n\tflag.StringVar(&password, \"password\", \"\", \"password for the database connection\")\n\tflag.StringVar(&host, \"host\", \"localhost\", \"hostname for the database connection\")\n\tflag.StringVar(&port, \"port\", \"5432\", \"port number for the database connection\")\n\tflag.Parse()\n}\n\nfunc main() {\n\tif username == \"\" || password == \"\" {\n\t\tfmt.Println(\"Error: username and password must be provided\")\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Connecting to database as user: %s at host: %s on port: %s\", username, host, port)\n\n\t// connect to database using provided credentials\n\t// ...\n\t// ...\n\t// ...\n\n\tfmt.Println(\"Connection successful\")\n\n\t// use database for queries\n\t// ...\n\t// ...\n\t// ...\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype employee struct {\n\tname   string\n\tage    int\n\tsalary int\n}\n\ntype  BySalary  []employee\n\nfunc (b BySalary) Len() int           { return len(b) }\nfunc (b BySalary) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }\nfunc (b BySalary) Less(i, j int) bool { return b[i].salary < b[j].salary }\n\nfunc main() {\n\temployees := []employee{\n\t\t{name: \"Alice\", age: 23, salary: 50000},\n\t\t{name: \"Bob\", age: 25, salary: 70000},\n\t\t{name: \"Charlie\", age: 21, salary: 40000},\n\t\t{name: \"David\", age: 27, salary: 90000},\n\t}\n\n\tfmt.Println(\"Before:\")\n\tfor _, e := range employees {\n\t\tfmt.Printf(\"%s: age=%d, salary=%d\\n\", e.name, e.age, e.salary)\n\t}\n\n\tsort.Sort(BySalary(employees))\n\n\tfmt.Println(\"\\nAfter:\")\n\tfor _, e := range employees {\n\t\tfmt.Printf(\"%s: age=%d, salary=%d\\n\", e.name, e.age, e.salary)\n\t}\n}\n\n// Output:\n//\n// Before:\n// Alice: age=23, salary=50000\n// Bob: age=25, salary=70000\n// Charlie: age=21, salary=40000\n// David: age=27, salary=90000\n//\n// After:\n// Charlie: age=21, salary=40000\n// Alice: age=23, salary=50000\n// Bob: age=25, salary=70000\n// David: age=27, salary=90000\n\n// Output will vary as per the input employs details & Runtime."}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://golang.org/doc/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error fetching page: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tlog.Fatalf(\"Expected status 200 OK but got %v\", resp.StatusCode)\n\t}\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading response body: %v\", err)\n\t}\n\n\tbodyString := string(bodyBytes)\n\tfmt.Println(bodyString)\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID        int\n\tUsername  string\n\tEmail     string\n\tCreatedAt time.Time\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"root:[password]@tcp(localhost:3306)/my_db\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Create a new user\n\tusername := \"JohnDoe\"\n\temail := \"johndoe@example.com\"\n\n\tinsertQuery := fmt.Sprintf(\"INSERT INTO users (username, email, created_at) VALUES ('%s', '%s', NOW())\", username, email)\n\tresult, err := db.Exec(insertQuery)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlastInsertId, err := result.LastInsertId()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"Created a new user with Id: %d\\n\", lastInsertId)\n\n\t// Get all users\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tvar users []User\n\tfor rows.Next() {\n\t\tvar user User\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tusers = append(users, user)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"Total users: %d\\n\", len(users))\n\n\t// Get a specific user\n\tvar user User\n\tquery := fmt.Sprintf(\"SELECT id, username, email, created_at FROM users WHERE id = %d\", lastInsertId)\n\terr = db.QueryRow(query).Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"Found user: %+v\\n\", user)\n}"}
{"sample": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis\"\n)\n\nfunc main() {\n\tvar (\n\t\taddr     string\n\t\tpassword string\n\t\tdb       int\n\t)\n\tflag.StringVar(&addr, \"addr\", \"localhost:6379\", \"redis address\")\n\tflag.StringVar(&password, \"password\", \"\", \"redis password (optional)\")\n\tflag.IntVar(&db, \"db\", 0, \"redis database\")\n\n\tflag.Parse()\n\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     addr,\n\t\tPassword: password,\n\t\tDB:       db,\n\t})\n\n\tpong, err := client.Ping().Result()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error connecting to Redis: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Connected to Redis: %v\\n\", pong)\n\n\tkey := \"count\"\n\terr = client.Set(key, 0, 0).Err()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting initial value for key %s: %v\\n\", key, err)\n\t\tos.Exit(1)\n\t}\n\n\tfor range time.NewTicker(1 * time.Second).C {\n\t\tval, err := client.Get(key).Int()\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"error getting value for key %s: %v\\n\", key, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tfmt.Printf(\"Count: %d\\n\", val)\n\n\t\terr = client.Incr(key).Err()\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"error incrementing value for key %s: %v\\n\", key, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs chan int, results chan int) {\n\tfor j := range jobs {\n\t\tfmt.Println(\"worker\", id, \"started  job\", j)\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Println(\"worker\", id, \"finished job\", j)\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tconst numJobs = 5\n\tjobs := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\n\tfor w := 1; w <= 3; w++ {\n\t\tgo worker(w, jobs, results)\n\t}\n\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- j\n\t}\n\n\tclose(jobs)\n\n\tvar wg sync.WaitGroup\n\twg.Add(numJobs)\n\n\tgo func() {\n\t\tfor r := range results {\n\t\t\tfmt.Println(\"result:\", r)\n\t\t\twg.Done()\n\t\t}\n\t\t\n\t}()\n\n\twg.Wait()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tstr := \"A quick brown fox jumps over the lazy dog\"\n\n\tre, err := regexp.Compile(`[a-z]+`)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmatches := re.FindAllString(str, -1)\n\n\tfmt.Println(matches)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"time\"\n)\n\nfunc main() {\n\tfruits := []string{\"apple\", \"banana\", \"orange\", \"kiwi\"}\n\n\t// Sorting the slice in ascending order\n\tsort.Strings(fruits)\n\tfmt.Println(\"Sorted fruits:\", fruits)\n\n\t// Using a custom sorting function to sort the slice in descending order\n\tsort.Slice(fruits, func(i, j int) bool {\n\t\treturn fruits[i] > fruits[j]\n\t})\n\tfmt.Println(\"Reverse sorted fruits:\", fruits)\n\n\t// Generating a random number using the math/rand package\n\trand.Seed(time.Now().UnixNano())\n\trandomNumber := rand.Intn(100-1) + 1\n\tfmt.Println(\"Random number:\", randomNumber)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/api/convert\", conversionHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc conversionHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\thttp.Error(w, \"Can only accept POST requests\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tdecoder := json.NewDecoder(r.Body)\n\tvar requestData map[string]interface{}\n\terr := decoder.Decode(&requestData)\n\tif err != nil {\n\t\thttp.Error(w, \"Unable to decode request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfromValue, ok := requestData[\"from\"].(float64)\n\tif !ok {\n\t\thttp.Error(w, \"Invalid from value\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfromUnit, ok := requestData[\"fromUnit\"].(string)\n\tif !ok {\n\t\thttp.Error(w, \"Invalid from unit\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttoUnit, ok := requestData[\"toUnit\"].(string)\n\tif !ok {\n\t\thttp.Error(w, \"Invalid to unit\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tconversionRate, err := getConversionRate(fromUnit, toUnit)\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid units\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttoValue := fromValue * conversionRate\n\n\tconversionResult := map[string]interface{}{\"to\": toValue, \"toUnit\": toUnit}\n\tjsonResult, err := json.Marshal(conversionResult)\n\tif err != nil {\n\t\thttp.Error(w, \"Unable to generate response\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Write(jsonResult)\n}\n\nfunc getConversionRate(fromUnit, toUnit string) (float64, error) {\n\tif fromUnit == \"miles\" && toUnit == \"kilometers\" {\n\t\treturn 1.60934, nil\n\t} else if fromUnit == \"pounds\" && toUnit == \"kilograms\" {\n\t\treturn 0.453592, nil\n\t} else {\n\t\treturn 0, fmt.Errorf(\"Units not valid\")\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tEmail  string `json:\"email\"`\n\tGender string `json:\"gender\"`\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path != \"/\" {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tuser := User{\n\t\t\tName:   \"John Doe\",\n\t\t\tAge:    30,\n\t\t\tEmail:  \"johndoe@example.com\",\n\t\t\tGender: \"male\",\n\t\t}\n\n\t\tjsonBytes, err := json.Marshal(user)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tfmt.Fprint(w, string(jsonBytes))\n\t})\n\n\tfmt.Println(\"Server started: http://localhost:8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar wg sync.WaitGroup\n\nfunc main() {\n\tfmt.Println(\"Starting goroutines\")\n\twg.Add(2)\n\tgo printNumbers()\n\tgo printLetters()\n\tfmt.Println(\"Waiting for goroutines to finish\")\n\twg.Wait()\n\tfmt.Println(\"\\nTerminating program\")\n}\n\nfunc printNumbers() {\n\trand.Seed(time.Now().UnixNano())\n\tfor i := 1; i <= 10; i++ {\n\t\tfmt.Printf(\"%d \", rand.Intn(10))\n\t\ttime.Sleep(time.Millisecond * 500)\n\t}\n\twg.Done()\n}\n\nfunc printLetters() {\n\tfor i := 'a'; i <= 'j'; i++ {\n\t\tfmt.Printf(\"%c \", i)\n\t\ttime.Sleep(time.Millisecond * 500)\n\t}\n\twg.Done()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tjob := func(num int) {\n\t\tfmt.Printf(\"Starting job %d\\n\", num)\n\t\ttime.Sleep(time.Second * 3)\n\t\tfmt.Printf(\"Job %d finished\\n\", num)\n\t}\n\n\tfor i := 1; i <= 5; i++ {\n\t\tgo job(i)\n\t}\n\n\tfmt.Println(\"All jobs started\")\n\n\ttime.Sleep(time.Second * 5)\n\tfmt.Println(\"Main finished\")\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nvar ctx = context.Background()\n\nfunc main() {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tpong, err := rdb.Ping(ctx).Result()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to Redis: %v\", err)\n\t}\n\n\tfmt.Printf(\"Redis connection established: %v\\n\", pong)\n\n\terr = rdb.Set(ctx, \"myKey\", \"Hello Redis!\", time.Minute).Err()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to set key-value pair: %v\", err)\n\t}\n\n\tval, err := rdb.Get(ctx, \"myKey\").Result()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to retrieve value: %v\", err)\n\t}\n\n\tfmt.Printf(\"Value of key myKey: %s\\n\", val)\n\n\terr = rdb.Del(ctx, \"myKey\").Err()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to delete key: %v\", err)\n\t}\n\n\tfmt.Printf(\"Key myKey deleted\")\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc worker(ctx context.Context, jobQueue chan int, results chan<- int) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase job := <-jobQueue:\n\t\t\tfmt.Printf(\"working on job %d\\n\", job)\n\t\t\ttime.Sleep(time.Second)\n\t\t\tresults <- job * 2\n\t\t}\n\t}\n}\n\nfunc main() {\n\tconst numJobs = 5\n\tjobQueue := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\n\t// spin up workers\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel() // tell workers we're done when main() exits\n\n\tfor i := 0; i < 3; i++ {\n\t\tgo worker(ctx, jobQueue, results)\n\t}\n\n\t// add jobs to the jobQueue\n\tfor i := 0; i < numJobs; i++ {\n\t\tjobQueue <- i\n\t}\n\n\tclose(jobQueue)\n\n\t// collect results\n\tfor i := 0; i < numJobs; i++ {\n\t\tresult := <-results\n\t\tfmt.Printf(\"result: %d\\n\", result)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\t// Define the routes\n\tr.HandleFunc(\"/\", homeHandler)\n\tr.HandleFunc(\"/about\", aboutHandler)\n\tr.HandleFunc(\"/contact\", contactHandler)\n\n\t// Serve the files in the \"static\" directory\n\tr.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(\"static\"))))\n\n\t// Start the server\n\tfmt.Println(\"Starting server on port 8080\")\n\thttp.ListenAndServe(\":8080\", r)\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Welcome to the home page!\"))\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"This is the about page.\"))\n}\n\nfunc contactHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Please contact us at hello@example.com\"))\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Animal interface {\n\tEat()\n\tMove()\n\tSpeak()\n}\n\ntype Cow struct{}\n\nfunc (c Cow) Eat() {\n\tfmt.Println(\"grass\")\n}\n\nfunc (c Cow) Move() {\n\tfmt.Println(\"walk\")\n}\n\nfunc (c Cow) Speak() {\n\tfmt.Println(\"moo\")\n}\n\ntype Bird struct{}\n\nfunc (b Bird) Eat() {\n\tfmt.Println(\"worms\")\n}\n\nfunc (b Bird) Move() {\n\tfmt.Println(\"fly\")\n}\n\nfunc (b Bird) Speak() {\n\tfmt.Println(\"peep\")\n}\n\ntype Snake struct{}\n\nfunc (s Snake) Eat() {\n\tfmt.Println(\"mice\")\n}\n\nfunc (s Snake) Move() {\n\tfmt.Println(\"slither\")\n}\n\nfunc (s Snake) Speak() {\n\tfmt.Println(\"hsss\")\n}\n\nfunc createAnimal(name string, animalType string) (Animal, error) {\n\tswitch strings.ToLower(animalType) {\n\tcase \"cow\":\n\t\treturn Cow{}, nil\n\tcase \"bird\":\n\t\treturn Bird{}, nil\n\tcase \"snake\":\n\t\treturn Snake{}, nil\n\tdefault:\n\t\treturn nil, errors.New(\"invalid animal type\")\n\t}\n}\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"> \")\n\t\tinput, _ := reader.ReadString('\\n')\n\t\taction := strings.ToLower(strings.TrimSpace(input))\n\n\t\targs := strings.Split(action, \" \")\n\n\t\tswitch args[0] {\n\t\tcase \"newanimal\":\n\t\t\tanimal, err := createAnimal(args[1], args[2])\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"Created it!\")\n\t\t\t}\n\t\tcase \"query\":\n\t\t\tanimalName := args[1]\n\t\t\tanimalAction := args[2]\n\n\t\t\tvar animal Animal\n\n\t\t\tswitch animalName {\n\t\t\tcase \"cow\":\n\t\t\t\tanimal = Cow{}\n\t\t\tcase \"bird\":\n\t\t\t\tanimal = Bird{}\n\t\t\tcase \"snake\":\n\t\t\t\tanimal = Snake{}\n\t\t\tdefault:\n\t\t\t\tfmt.Println(\"Invalid animal name\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tswitch animalAction {\n\t\t\tcase \"eat\":\n\t\t\t\tanimal.Eat()\n\t\t\tcase \"move\":\n\t\t\t\tanimal.Move()\n\t\t\tcase \"speak\":\n\t\t\t\tanimal.Speak()\n\t\t\tdefault:\n\t\t\t\tfmt.Println(\"Invalid animal action\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\tdefault:\n\t\t\tfmt.Println(\"Invalid command\")\n\t\t\tcontinue\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int, errChan chan<- error) {\n\tfor j := range jobs {\n\t\tif j%2 == 0 {\n\t\t\tresults <- j * 2\n\t\t} else {\n\t\t\terrChan <- errors.New(\"cannot process odd jobs\")\n\t\t}\n\t\tfmt.Printf(\"worker %d processed job %d\\n\", id, j)\n\n\t}\n}\n\nfunc main() {\n\tnumJobs := 10\n\tjobs := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\terrChan := make(chan error, numJobs)\n\n\tfor w := 1; w <= 3; w++ {\n\t\tgo worker(w, jobs, results, errChan)\n\t}\n\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor r := range results {\n\t\t\tfmt.Printf(\"result: %d\\n\", r)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor err := range errChan {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t}\n\t}()\n\n\twg.Wait()\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\tvar ctx = context.Background()\n\n\t// connect to redis server\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\t// ping server to verify connection\n\tpong, err := client.Ping(ctx).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"Connected to Redis server, Pong:\", pong)\n\n\t// add key-value pair\n\terr = client.Set(ctx, \"sample_key\", \"sample_value\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// get value for a given key\n\tval, err := client.Get(ctx, \"sample_key\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"Value for 'sample_key':\", val)\n\n\t// set expiration for a given key\n\texpiration := time.Minute\n\terr = client.Expire(ctx, \"sample_key\", expiration).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// check time to live for a given key\n\tttl, err := client.TTL(ctx, \"sample_key\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"Time to live for 'sample_key': %v\\n\", ttl)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, wg *sync.WaitGroup, jobs <-chan int, results chan<- int) {\n\tdefer wg.Done()\n\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", id, j)\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Printf(\"Worker %d finished job %d\\n\", id, j)\n\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tvar wg sync.WaitGroup\n\tfor w := 1; w <= 3; w++ {\n\t\twg.Add(1)\n\t\tgo worker(w, &wg, jobs, results)\n\t}\n\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n\n\tclose(results)\n\n\tfor r := range results {\n\t\tfmt.Println(r)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype Todo struct {\n\tID        string `json:\"id,omitempty\"`\n\tTask      string `json:\"task,omitempty\"`\n\tCompleted bool   `json:\"completed,omitempty\"`\n}\n\nvar todos []Todo\n\nfunc getTodos(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(todos)\n}\n\nfunc getTodoById(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tparams := mux.Vars(r)\n\tfor _, item := range todos {\n\t\tif item.ID == params[\"id\"] {\n\t\t\tjson.NewEncoder(w).Encode(item)\n\t\t\treturn\n\t\t}\n\t}\n\tjson.NewEncoder(w).Encode(&Todo{})\n}\n\nfunc createTodo(w http.ResponseWriter, r *http.Request) {\n\tvar todo Todo\n\t_ = json.NewDecoder(r.Body).Decode(&todo)\n\ttodos = append(todos, todo)\n\tjson.NewEncoder(w).Encode(todos)\n}\n\nfunc main() {\n\ttodos = append(todos, Todo{ID: \"1\", Task: \"Task 1\", Completed: false})\n\ttodos = append(todos, Todo{ID: \"2\", Task: \"Task 2\", Completed: true})\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/todos\", getTodos).Methods(\"GET\")\n\tr.HandleFunc(\"/todos/{id}\", getTodoById).Methods(\"GET\")\n\tr.HandleFunc(\"/todos\", createTodo).Methods(\"POST\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc main() {\n\troot := \".\"\n\tif len(os.Args) > 1 {\n\t\troot = os.Args[1]\n\t}\n\n\tfileCount := 0\n\tdirCount := 0\n\n\tfilepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error accessing path %q: %v\\n\", path, err)\n\t\t\treturn nil\n\t\t}\n\n\t\tif info.IsDir() {\n\t\t\tdirCount++\n\t\t} else {\n\t\t\tif strings.HasSuffix(info.Name(), \".txt\") {\n\t\t\t\tfileCount++\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tfmt.Printf(\"Counted %d files and %d directories.\\n\", fileCount, dirCount)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"ls\", \"-la\")\n\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(string(output))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar increaser sync.Mutex\n\tcount := 0\n\tsignals := make(chan int)\n\tdone := make(chan bool)\n\n\tfor i := 0; i < 500; i++ {\n\t\tgo func() {\n\t\t\tincreaser.Lock()\n\t\t\tdefer increaser.Unlock()\n\t\t\tcount++\n\t\t\tif count == 500 {\n\t\t\t\tsignals <- count\n\t\t\t}\n\t\t}()\n\t}\n\n\tgo func() {\n\t\tn := <-signals\n\t\tdone <- true\n\t\tfmt.Println(\"Count: \", n)\n\t}()\n\n\t<-done\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype KeyValue struct {\n\tKey   string\n\tValue int\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfrequency := make(map[string]int)\n\n\tfmt.Println(\"Enter text, followed by an empty line:\")\n\n\t// Loop over lines of text\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\n\t\t// End loop if user enters an empty line\n\t\tif len(strings.TrimSpace(line)) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Split line by spaces into words\n\t\twords := strings.Split(line, \" \")\n\n\t\t// Loop over words and update frequency count\n\t\tfor _, word := range words {\n\t\t\tif len(word) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfrequency[strings.ToLower(word)]++\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"reading standard input:\", err)\n\t\treturn\n\t}\n\n\t// Convert frequency map into a slice to allow sorting\n\tvar kvPairs []KeyValue\n\tfor k, v := range frequency {\n\t\tkvPairs = append(kvPairs, KeyValue{k, v})\n\t}\n\n\t// Sort the slice\n\tsort.Slice(kvPairs, func(i, j int) bool {\n\t\treturn kvPairs[i].Value > kvPairs[j].Value\n\t})\n\n\t// Print the results\n\tfmt.Println(\"Word Frequency Count:\")\n\tfor _, kv := range kvPairs {\n\t\tfmt.Printf(\"%s: %d\\n\", kv.Key, kv.Value)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tfmt.Println(\"Goroutine 1 executing\")\n\t\twg.Done()\n\t}()\n\n\tgo func() {\n\t\tfmt.Println(\"Goroutine 2 executing\")\n\t\twg.Done()\n\t}()\n\n\twg.Wait()\n\n\tfmt.Println(\"Program complete\")\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\nfunc main() {\n\tdb, err := sql.Open(\"sqlite3\", \"./mydb.db\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Create table\n\t_, err = db.Exec(`CREATE TABLE IF NOT EXISTS users(\n\t\tid INTEGER PRIMARY KEY,\n\t\tname TEXT NOT NULL,\n\t\tage INTEGER NOT NULL DEFAULT 0\n\t);`)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Insert a user\n\tres, err := db.Exec(\"INSERT INTO users (name, age) VALUES (?, ?)\", \"Alice\", 27)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlastID, err := res.LastInsertId()\n\tfmt.Printf(\"Last inserted ID: %v\\n\", lastID)\n\n\t// Query all users\n\trows, err := db.Query(\"SELECT id, name, age FROM users\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\tvar age int\n\t\tif err := rows.Scan(&id, &name, &age); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Printf(\"User ID=%d, Name=%s, Age=%d\\n\", id, name, age)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"text/template\"\n)\n\ntype Person struct {\n\tName    string\n\tAge     int\n\tCountry string\n}\n\nfunc main() {\n\tperson := Person{\n\t\tName:    \"Alice\",\n\t\tAge:     30,\n\t\tCountry: \"USA\",\n\t}\n\n\ttmpl, err := template.ParseFiles(\"template.txt\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tbuf := new(bytes.Buffer)\n\tif err := tmpl.Execute(buf, person); err != nil {\n\t\tlog.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Println(buf.String())\n}\n \n// Example content in template.txt\n//\n// Name: {{.Name}}\n// Age: {{.Age}}\n// Country: {{.Country}}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/go-redis/redis\"\n)\n\nfunc main() {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // No password\n\t\tDB:       0,  // use default DB\n\t})\n\n\tpong, err := client.Ping().Result()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tfmt.Println(pong)\n\n\terr = client.Set(\"key\", \"value\", 0).Err()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tval, err := client.Get(\"key\").Result()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\tfmt.Println(val)\n\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc main() {\n\t// Open connection to database\n\tdb, err := sql.Open(\"mysql\", \"username:password@tcp(database.host:port)/database_name\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Ping database to check if connection is successful\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Define handler function for root path\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Query database for users\n\t\trows, err := db.Query(\"SELECT * FROM users\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer rows.Close()\n\n\t\t// Process rows and send data in response\n\t\tvar data string\n\t\tfor rows.Next() {\n\t\t\tvar id int\n\t\t\tvar name string\n\t\t\terr := rows.Scan(&id, &name)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tdata += fmt.Sprintf(\"ID: %d, Name: %s\\n\", id, name)\n\t\t}\n\n\t\t// Send data in response\n\t\tfmt.Fprintf(w, data)\n\t})\n\n\t// Start server\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\n// Book represents a book\ntype Book struct {\n\tID     string `json:\"id\"`\n\tTitle  string `json:\"title\"`\n\tAuthor string `json:\"author\"`\n}\n\nvar books []Book\n\nfunc main() {\n\trouter := mux.NewRouter()\n\n\t//add some predefined books\n\tbooks = append(books, Book{ID: \"1\", Title: \"Go programming language\", Author: \"Alan A. Donovan and Brian W. Kernighan\"})\n\tbooks = append(books, Book{ID: \"2\", Title: \"Programming in Go: Creating Applications for the 21st Century\", Author: \"Mark Summerfield\"})\n\tbooks = append(books, Book{ID: \"3\", Title: \"Introducing Go: Build Reliable, Scalable Programs\", Author: \"Caleb Doxsey\"})\n\n\t//api endpoint to get all books\n\trouter.HandleFunc(\"/api/books\", getBooks).Methods(\"GET\")\n\n\t//api endpoint to get a single book by id\n\trouter.HandleFunc(\"/api/books/{id}\", getBook).Methods(\"GET\")\n\n\t//start the server\n\thttp.ListenAndServe(\":8000\", router)\n}\n\nfunc getBooks(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(books)\n}\n\nfunc getBook(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", \"application/json\")\n\tparams := mux.Vars(r)\n\tfor _, book := range books {\n\t\tif book.ID == params[\"id\"] {\n\t\t\tjson.NewEncoder(w).Encode(book)\n\t\t\treturn\n\t\t}\n\t}\n\tjson.NewEncoder(w).Encode(&Book{})\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype ApiResponse struct {\n\tArgs    map[string]string `json:\"args\"`\n\tHeaders map[string]string `json:\"headers\"`\n\tOrigin  string            `json:\"origin\"`\n\tURL     string            `json:\"url\"`\n}\n\nfunc handleApiResponse(w http.ResponseWriter, r *http.Request) {\n\tclient := http.DefaultClient\n\n\tresp, err := client.Get(\"https://httpbin.org/get\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tapiResp := &ApiResponse{}\n\n\tif err := json.Unmarshal(body, &apiResp); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(apiResp)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/api-response\", handleApiResponse)\n\n\tfmt.Println(\"Starting server on port :8080\")\n\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\ntype Calculator struct {\n\tResult float64\n}\n\nfunc (c *Calculator) Add(numbers ...float64) {\n\tfor _, n := range numbers {\n\t\tc.Result += n\n\t}\n}\n\nfunc (c *Calculator) Subtract(numbers ...float64) {\n\tfor _, n := range numbers {\n\t\tc.Result -= n\n\t}\n}\n\nfunc (c *Calculator) Multiply(numbers ...float64) {\n\tfor _, n := range numbers {\n\t\tc.Result *= n\n\t}\n}\n\nfunc (c *Calculator) Divide(numbers ...float64) error {\n\tzero := 0.0\n\tfor _, n := range numbers {\n\t\tif n == zero {\n\t\t\treturn fmt.Errorf(\"Cannot divide by 0\")\n\t\t}\n\t\tc.Result /= n\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tmyCalc := Calculator{}\n\n\tmyCalc.Add(5, 2, 3)        // Returns 10\n\tmyCalc.Subtract(5, 2, 3)   // Returns 0\n\tmyCalc.Multiply(5, 2, 3)   // Returns 30\n\tmyCalc.Divide(2, 5, 1.5)   // Returns 2\n\tmyCalc.Divide(4, 0, 1.2)   // Returns error message\n\tfmt.Println(myCalc.Result) // Should return 2\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tch := make(chan string)\n\n\tgo sendNotifications(ch)\n\n\tfor {\n\t\tselect {\n\t\tcase msg := <-ch:\n\t\t\tfmt.Println(\"Notification received: \", msg)\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tfmt.Println(\"No new notifications at this time\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc sendNotifications(ch chan string) {\n\tnotifications := []string{\"New message from user 1\", \"Post approved by admin\", \"Payment receipt uploaded\"}\n\tfor _, n := range notifications {\n\t\tch <- n\n\t\ttime.Sleep(time.Second * 2)\n\t}\n\tclose(ch)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc chooseColor(color string) string {\n\tswitch color {\n\tcase \"red\":\n\t\treturn \"You chose red.\"\n\tcase \"blue\":\n\t\treturn \"You chose blue.\"\n\tcase \"green\":\n\t\treturn \"You chose green.\"\n\tdefault:\n\t\treturn \"Sorry, didn't recognize your color\"\n\t}\n}\n\nfunc main() {\n\tcurrentTime := time.Now()\n\tfmt.Println(currentTime.Format(\"January 2, 2006\"))\n\n\tcolor := \"blue\"\n\tmessage := chooseColor(color)\n\tfmt.Println(message)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {\n\tfmt.Printf(\"Worker %d started\\n\", id)\n\tdefer wg.Done() // Tell the waitgroup the worker has finished\n\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", id, j)\n\t\tresults <- j * 2\n\t\tfmt.Printf(\"Worker %d finished job %d\\n\", id, j)\n\t}\n\tfmt.Printf(\"Worker %d finished\\n\", id)\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tvar wg sync.WaitGroup // Create wait group to know when all workers have finished\n\n\tconst numWorkers = 4\n\twg.Add(numWorkers) // Add numWorkers to the WaitGroup where initial count is 0\n\n\tfor w := 1; w <= numWorkers; w++ {\n\t\tgo worker(w, jobs, results, &wg)\n\t}\n\n\tfor j := 1; j <= 20; j++ {\n\t\tjobs <- j\n\t}\n\n\tclose(jobs)\n\n\twg.Wait() // Here we wait until all workers have finished before closing out your program.\n\n\tfor a := 1; a <= 20; a++ {\n\t\t<-results\n\t}\n}```"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\t// declare WaitGroup to keep track of the goroutines.\n\tvar wg sync.WaitGroup\n\n\t// set how many goroutines will run in parallel.\n\twg.Add(2)\n\n\tfmt.Println(\"Starting parallel execution...\")\n\n\t// goroutine 1 - add 2 numbers and print result.\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfmt.Println(\"Goroutine 1 started...\")\n\t\tresult := addNumbers(2, 3)\n\t\tfmt.Println(\"2 + 3 =\", result)\n\t}()\n\n\t// goroutine 2 - subtract 2 numbers and print result.\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfmt.Println(\"Goroutine 2 started...\")\n\t\tresult := subtractNumbers(10, 3)\n\t\tfmt.Println(\"10 - 3 =\", result)\n\t}()\n\n\t// wait for all the goroutines to finish.\n\tfmt.Println(\"Waiting for goroutines to complete...\")\n\twg.Wait()\n\n\tfmt.Println(\"All goroutines completed.\")\n}\n\nfunc addNumbers(a, b int) int {\n\treturn a + b\n}\n\nfunc subtractNumbers(a, b int) int {\n\treturn a - b\n}"}
{"sample": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc fibonacci(n int) []int {\n\tif n <= 1 {\n\t\treturn []int{n}\n\t}\n\n\tprev := fibonacci(n - 1)\n\tlast := prev[len(prev)-1]\n\tsecondLast := prev[len(prev)-2]\n\treturn append(prev, last+secondLast)\n}\n\nfunc main() {\n\tnumPtr := flag.String(\"num\", \"1\", \"an integer\")\n\tflag.Parse()\n\n\tnum, err := strconv.Atoi(*numPtr)\n\tif err != nil {\n\t\tfmt.Println(\"Invalid input for num\")\n\t\treturn\n\t}\n\n\tfmt.Printf(\"First %v fibonacci numbers: %v\\n\", num, fibonacci(num))\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/lib/pq\"\n)\n\ntype User struct {\n\tID        int\n\tFirstName string\n\tLastName  string\n\tEmail     string\n\tCreatedAt time.Time\n}\n\nvar db *sql.DB\n\nfunc main() {\n\tconnStr := \"postgres://user:password@localhost/dbname?sslmode=disable\"\n\n\tgo func() {\n\t\tif err := createTables(); err != nil {\n\t\t\tlog.Fatalf(\"Error creating tables: %v\", err)\n\t\t}\n\t}()\n\n\tvar err error\n\tdb, err = sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error connecting to database: %v\", err)\n\t}\n\n\tlog.Println(\"Connected to database\")\n\tdefer db.Close()\n\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/{id}\", getUser).Methods(http.MethodGet)\n\tr.HandleFunc(\"/\", createUser).Methods(http.MethodPost)\n\n\tlog.Println(\"Server started on port 8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}\n\nfunc getUser(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\n\tquery := `\n\t\tSELECT id, first_name, last_name, email, created_at\n\t\tFROM users\n\t\tWHERE id=$1\n\t`\n\n\tuser := User{}\n\tif err := db.QueryRow(query, id).Scan(&user.ID, &user.FirstName, &user.LastName, &user.Email, &user.CreatedAt); err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\tfmt.Fprint(w, \"User not found\")\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Error getting user %s: %v\", id, err)\n\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, \"Oops, something went wrong. Please try again later.\")\n\t\treturn\n\t}\n\n\tfmt.Fprint(w, user)\n}\n\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n\tfirstName := r.FormValue(\"first_name\")\n\tlastName := r.FormValue(\"last_name\")\n\temail := r.FormValue(\"email\")\n\n\tif firstName == \"\" || lastName == \"\" || email == \"\" {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, \"Please provide first name, last name, and email\")\n\t\treturn\n\t}\n\n\tquery := `\n\t\tINSERT INTO users (first_name, last_name, email, created_at)\n\t\tVALUES ($1, $2, $3, $4)\n\t\tRETURNING id\n\t`\n\n\tid := 0\n\tif err := db.QueryRow(query, firstName, lastName, email, time.Now()).Scan(&id); err != nil {\n\t\tif err, ok := err.(*pq.Error); ok {\n\t\t\tswitch err.Code.Name() {\n\t\t\tcase \"unique_violation\":\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\tfmt.Fprint(w, \"This email is already registered. Please use another email address.\")\n\t\t\tcase \"check_violation\":\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\tfmt.Fprint(w, \"Please provide a valid email\")\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"Error creating user: %v\", err)\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\tfmt.Fprint(w, \"Oops, something went wrong. Please try again later.\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Error creating user: %v\", err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, \"Oops, something went wrong. Please try again later.\")\n\t\treturn\n\t}\n\n\t// Return the ID of the created user in the response body\n\tfmt.Fprint(w, id)\n}\n\nfunc createTables() error {\n\tconnStr := \"postgres://user:password@localhost/dbname?sslmode=disable\"\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to connect to database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\tquery := `\n\t\tCREATE TABLE IF NOT EXISTS users (\n\t\t\tid SERIAL PRIMARY KEY,\n\t\t\tfirst_name VARCHAR(100) NOT NULL,\n\t\t\tlast_name VARCHAR(100) NOT NULL,\n\t\t\temail VARCHAR(100) NOT NULL UNIQUE CHECK (email ~* '^[a-z0-9._%+\\-]+@[a-z0-9.\\-]+\\.[a-z]{2,}$'),\n\t\t\tcreated_at TIMESTAMPTZ DEFAULT NOW()\n\t\t)\n\t`\n\tif _, err := db.Exec(query); err != nil {\n\t\treturn fmt.Errorf(\"Failed to create users table: %v\", err)\n\t}\n\n\treturn nil\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis\"\n)\n\nfunc main() {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tif _, err := client.Ping().Result(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tkey := \"visits\"\n\tcurrentTime := time.Now().Format(\"2006-01-02 15:04:05\")\n\n\tif err := client.ZAdd(key, &redis.Z{Score: float64(time.Now().UnixNano()), Member: currentTime}).Err(); err != nil {\n\t\tpanic(err)\n\t}\n\n\tcount, err := client.ZCard(key).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Redis Hash %s: %v\\n\", key, count)\n}"}
{"sample": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/smtp\"\n)\n\nfunc sendEmail(to []string, subj string, message string) error {\n\ttype PlainAuthV2 struct {\n\t\tidentity, username, password string\n\t\thost                         string\n\t   }\n\n\tconf := &tls.Config{\n\t\tInsecureSkipVerify: true,\n\t\tServerName:         remote.ServerName,\n\t}\n   //Update SMTP server configuration to your email server's configuration. Taken from net.conn example in the Off"}
{"sample": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc main() {\n\tapiKey := \"abcdefghijklmnopqrstuvwxyz\"\n\tapiSecret := \"0123456789\"\n\n\tclient := http.Client{}\n\n\t// Add authentication parameters to POST request\n\tdata := url.Values{}\n\tdata.Add(\"param1\", \"value1\")\n\tdata.Add(\"param2\", \"value2\")\n\treq, err := http.NewRequest(\"POST\", \"https://api.example.com/resource\", bytes.NewBufferString(data.Encode()))\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.SetBasicAuth(apiKey, apiSecret)\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Retrieve response body and check for errors\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif resp.StatusCode != 200 {\n\t\tpanic(fmt.Errorf(\"Request returned a non-success http code of %v and body: %v\", resp.StatusCode, string(body)))\n\t}\n\n\t// Print out the results\n\tfmt.Printf(\"API response is: %v\\n\", string(body) \"\")\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\nfunc getEvenNumberList(n int) []int {\n\tnumbers := make([]int, 0)\n\n\tfor i := 0; len(numbers) != n; i++ {\n\t\tif i%2 == 0 {\n\t\t\tnumbers = append(numbers, i)\n\t\t}\n\t}\n\n\treturn numbers\n}\n\nfunc main() {\n\tevenNumbers := getEvenNumberList(10)\n\tfmt.Println(evenNumbers)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype weatherResponse struct {\n\tStatus  bool         `json:\"status\"`\n\tMessage string       `json:\"msg\"`\n\tData    *weatherData `json:\"data,omitempty\"`\n}\n\ntype weatherData struct {\n\tCode     int32   `json:\"code\"`\n\tTemp     float32 `json:\"temp\"`\n\tDesc     string  `json:\"description\"`\n\tCityName string  `json:\"city_name\"`\n\tTime     int64   `json:\"timestamp\"`\n}\n\nfunc getAsciiWeather(cityName string) string {\n\tresponse, err := http.Get(fmt.Sprintf(\"https://wttr.in/%s_0tqp0olnocgpu6dryupo0refrnpercta.txt\", cityName))\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"Failed to fetch weather for '%s'\", cityName)\n\t}\n\n\tasciWeather := new(string)\n\tfmt.Fscan(response.Body, asciWeather)\n\treturn *asciWeather\n}\n\nfunc getWeather(cityName string) (string, error) {\n\tresponse, errONzeroww := http.Get(fmt.Sprintf(\"https://temperatureweather.com/find/%s#U.%5CAY2CN+0ON+3UP$29_L)%20OLE%23Y%5C657GPPL,PAC82788\", cityName))\n\tif errONzeroww != nil {\n\t\treturn \"\", fmt.Errorf(\"failed fetch weather data. errMsg=%v\", errONnoneYesflyDown00.None.Byte.ON1)\n    \tresponse.ClockSpeed = getRandomNumberInRange(500, 3000)\n\tresjonnibble, errzurfwey := json.Marshal(weatherResponse{true, \"Success\", userData})\n\tif errMarshCreateChngdSinceMakhueMasterCheckout23peepee27dthree63.Println(ByTestingUnitFuncMonitoringResp, ResponseWatching):\n\tdefault:\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/weather/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcityName := r.URL.Path[9:]\n\t\tif cityName == \"\" {\n\t\t\thttp.Error(w, \"Bad request, Empty werater Required queryParameter ex.(https:.../weather?req=purnea )\", http.StatusBadRequest)\n\t\t\treturn\nyorum        \n\t}\n\tfuncCallFail:= Verify().Security().AuthenticateToken(response.New.Fund.AddRCstatus.value=\"-10010657011626003022217393663675353746\"P).\n\terrChanSKEntryRound.Play().ScheduledMaintenanceRequested(\"validation-error-76\", disabledPl1Ty12HeltecSent.StatusDataImpact(bus.WeightedSystemParameter{Name: \"VickyName\"}),\n\tdisableNYOT_TO_PEENI99.Login(2704464314254194525673255000672728698260108220909112931271084459825365046714ContinuumSubdermalJer__).ToLibelem(stateExpLoggingFileBytes),\n\tdoSemaphoreThings(make(chan int, 1))\n\n\treminderOnOffCounter.EvaluateData(rekallCompute.MinColor[1:], gunmetalCursorMiddleware(seedMapsAggregation.NapMetaData.AfrDemesneTrigger()))\n}>\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc generateNums(ctx context.Context, c chan<- int) {\n\trand.Seed(time.Now().UnixNano())\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(\"Closing sender goroutine\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tnum := rand.Intn(100)\n\t\t\tc <- num\n\t\t\tfmt.Printf(\"Sent number %d\\n\", num)\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}\n}\n\nfunc receiveNums(ctx context.Context, c <-chan int) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(\"Closing receiver goroutine\")\n\t\t\treturn\n\t\tcase num := <-c:\n\t\t\tfmt.Printf(\"Received number %d\\n\", num)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tc := make(chan int)\n\n\tgo generateNums(ctx, c)\n\tgo receiveNums(ctx, c)\n\n\tfmt.Println(\"Waiting for termination switch\")\n\ttime.Sleep(10 * time.Second)\n\tfmt.Println(\"Terminating...\")\n\tcancel()\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Done\")\n}"}
{"sample": "package main\n\ntype MyStruct struct {\n\tField1      int\n\tField2      string\n\tSliceField1 []int\n}\n\nfunc (s MyStruct) Method1() string {\n\treturn \"Hello, world!\"\n}\n\nfunc NewMyStruct(field1 int, field2 string, sliceField1 []int) *MyStruct {\n\treturn &MyStruct{Field1: field1, Field2: field2, SliceField1: sliceField1}\n}\n\nfunc main() {\n\tms := NewMyStruct(42, \"answer\", []int{0, 1, 2})\n\tms.Method1()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\tdb \"github.com/acme/myproject/db\"\n\ttransactors \"github.com/acme/myproject/transactors\"\n\t\"github.com/acme/myproject/util\"\n)\n\nfunc main() {\n\t// initialize db from environment variables\n\terr := db.Init()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// authenticate and get authentication token for further requests\n\tauthToken, err := util.GetAuthToken()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = transactors.Transfer(objectType, originAccount, destinyInvoice, \"invoice\", authToken)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tformat := \"Transaction success! $%.2f sent from account %d to invoice %s.\"\n\n\tlog.Printf(format, amount, originAccount.ID, destinyInvoice)\n\tfmt.Printf(format, amount, originAccount.ID, destinyInvoice)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"os\"\n\n\t\"cloud.google.com/go/storage\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Creates a client.\n\tclient, err := storage.NewClient(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\tdefer client.Close()\n\n\t// Creates a bucket and object.\n\tbucketName := \"my-bucket\"\n\tobjectName := \"my-object\"\n\tbucket := client.Bucket(bucketName)\n\n\t// Creates the new bucket with storage class `STANDARD`.\n\tif err := bucket.Create(ctx, projectID, &storage.BucketAttrs{StorageClass: \"STANDARD\"}); err != nil {\n\t\tlog.Fatalf(\"Failed to create bucket: %v\", err)\n\t}\n\tlog.Printf(\"Bucket %s created.\", bucketName)\n\n\t// Creates a new object with the content of a local file.\n\tfile, err := os.Open(\"local-file\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open file: %v\", err)\n\t}\n\tdefer file.Close()\n\n\twc := bucket.Object(objectName).NewWriter(ctx)\n\tif _, err = io.Copy(wc, file); err != nil {\n\t\tlog.Fatalf(\"Failed to write to object: %v\", err)\n\t}\n\tif err := wc.Close(); err != nil {\n\t\tlog.Fatalf(\"Failed to close writer: %v\", err)\n\t}\n\tlog.Printf(\"Object %v created in bucket %v.\", objectName, bucketName)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tnames := []string{\"John\", \"Mary\", \"Jane\", \"Bob\", \"Alice\"}\n\tprefix := \"J\"\n\n\tfilteredNames := filter(names, func(name string) bool {\n\t\treturn strings.HasPrefix(name, prefix)\n\t})\n\n\tfmt.Println(filteredNames) // Output: [John Jane]\n}\n\nfunc filter(strings []string, filterFunc func(string) bool) []string {\n\tfiltered := make([]string, 0)\n\tfor _, str := range strings {\n\t\tif filterFunc(str) {\n\t\t\tfiltered = append(filtered, str)\n\t\t}\n\t}\n\treturn filtered\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\tctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\tdefer cancel()\n\n\tch := make(chan string, 1)\n\tgo func() {\n\t\ttime.Sleep(4 * time.Second)\n\t\tch <- \"Done\"\n\t}()\n\n\tselect {\n\tcase res := <-ch:\n\t\tfmt.Println(res)\n\tcase <-ctx.Done():\n\t\tlog.Println(ctx.Err())\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\trdb := redis.NewClient(&redis.Options{\n\t\t// Replace with your Redis server's address and password\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\tpong, err := rdb.Ping(ctx).Result()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to ping Redis: %v\", err)\n\t}\n\tlog.Printf(\"Connected to Redis: %v\", pong)\n\n\t// Set value with expiration of 1 hour\n\terr = rdb.Set(ctx, \"foo\", \"bar\", time.Hour).Err()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to set value in Redis: %v\", err)\n\t}\n\n\t// Retrieve value\n\tval, err := rdb.Get(ctx, \"foo\").Result()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to retrieve value from Redis: %v\", err)\n\t}\n\tfmt.Println(\"Value from Redis:\", val)\n}\n\n// Output:\n// Connected to Redis: PONG\n// Value from Redis: bar"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc main() {\n\tunsorted := []int{5, 9, 1, 4, 8, 3, 7, 6, 2}\n\n\tsort.Ints(unsorted)\n\n\tfmt.Println(unsorted)\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc getUser(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"GET\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tusername := r.URL.Query().Get(\"username\")\n\n\tresponse, err := http.Get(\n\t\tfmt.Sprintf(\"https://api.github.com/users/%s\", username),\n\t)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(w, \"User not found\")\n\t\treturn\n\t}\n\n\tdefer response.Body.Close()\n\n\tbody, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tvar user User\n\tif err := json.Unmarshal(body, &user); err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/user\", getUser)\n\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().Unix()) // Seeding the random number generator with current time\n\n\tvar wg sync.WaitGroup // WaitGroup to collect results from goroutines\n\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\twaitTime := rand.Intn(5)\n\t\ttime.Sleep(time.Duration(waitTime) * time.Second)\n\t\tfmt.Printf(\"Goroutine 1 waited for %v seconds\\n\", waitTime)\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\twaitTime := rand.Intn(5)\n\t\ttime.Sleep(time.Duration(waitTime) * time.Second)\n\t\tfmt.Printf(\"Goroutine 2 waited for %v seconds\\n\", waitTime)\n\t}()\n\n\twg.Wait()\n\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID       int\n\tUsername string\n\tEmail    string\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to open db connection: %v\", err)\n\t}\n\tdefer db.Close()\n\n\tuser := User{\n\t\tUsername: \"johndoe\",\n\t\tEmail:    \"johndoe@example.com\",\n\t}\n\n\tresult, err := db.Exec(\"INSERT INTO users (username, email) VALUES (?, ?)\", user.Username, user.Email)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to execute query: %v\", err)\n\t}\n\n\tlastInsertID, err := result.LastInsertId()\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to retrieve last insert ID: %v\", err)\n\t}\n\n\tfmt.Printf(\"Insert successful, ID: %d\\n\", lastInsertID)\n\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to execute query: %v\", err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar retrievedUser User\n\n\t\terr := rows.Scan(&retrievedUser.ID, &retrievedUser.Username, &retrievedUser.Email)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"failed to scan row: %v\", err)\n\t\t}\n\n\t\tfmt.Printf(\"Retrieved user: %+v\\n\", retrievedUser)\n\t}\n\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Fatalf(\"encountered error while iteration rows: %v\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"cloud.google.com/go/bigtable\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\tprojectID := \"my-project\"\n\tinstanceID := \"my-instance\"\n\ttableID := \"my-table\"\n\n\tclient, err := bigtable.NewClient(ctx, projectID, instanceID)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\tdefer client.Close()\n\n\ttable := client.Open(tableID)\n\n\tmut := bigtable.NewMutation()\n\tmut.Set(\"cf\", \"field1\", bigtable.Now(), []byte(\"value1\"))\n\tif err := table.Apply(ctx, \"row1\", mut); err != nil {\n\t\tlog.Fatalf(\"Failed to apply mutation: %v\", err)\n\t}\n\n\trow, err := table.ReadRow(ctx, \"row1\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read row: %v\", err)\n\t}\n\n\tfor col, val := range row {\n\t\tfmt.Printf(\"Column Family: %s\\tColumn Qualifier: %s\\tValue: %s\\n\", col.Family(), col.Qualifier(), val.Value)\n\t}\n\n\terr = bigtable.ExportTill(ctx, table, time.Now())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to export till: %v\", err)\n\t}\n\n\tlog.Println(\"Export complete\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfmt.Println(\"Goroutine 1\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfmt.Println(\"Goroutine 2\")\n\t}()\n\n\twg.Wait()\n\n\tfmt.Println(\"All goroutines completed\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, wg *sync.WaitGroup, jobs <-chan int, results chan<- int) {\n\tdefer wg.Done()\n\n\tfor j := range jobs {\n\t\tfmt.Printf(\"worker %d started job %d\\n\", id, j)\n\t\ttime.Sleep(time.Duration(rand.Intn(3)) * time.Second)\n\t\tfmt.Printf(\"worker %d finished job %d\\n\", id, j)\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo worker(i, &wg, jobs, results)\n\t}\n\n\tfor j := 1; j <= 20; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n\n\tfor a := 1; a <= 20; a++ {\n\t\tfmt.Println(<-results)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\t\"cloud.google.com/go/storage\"\n\t\"google.golang.org/api/option\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Setup GCP client\n\tcredentials, err := ioutil.ReadFile(\"key.json\") // replace with path to your keyfile\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read key.json file with error: %v\", err)\n\t}\n\n\tclient, err := storage.NewClient(ctx, option.WithCredentialsJSON(credentials))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create client with error: %v\", err)\n\t}\n\tdefer client.Close()\n\n\t// Upload file to a bucket\n\tbucketName := \"example-bucket\"\n\tfilePath := \"example.txt\"\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open file with error: %v\", err)\n\t}\n\tdefer file.Close()\n\n\tobj := client.Bucket(bucketName).Object(file.Name())\n\twriter := obj.NewWriter(ctx)\n\tif _, err := writer.ReadFrom(file); err != nil {\n\t\tlog.Fatalf(\"Failed to read from file with error: %v\", err)\n\t}\n\tif err := writer.Close(); err != nil {\n\t\tlog.Fatalf(\"Failed to close writer with error: %v\", err)\n\t}\n\n\tfmt.Println(\"File uploaded successfully.\")\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfmt.Print(\"Enter your name: \")\n\tscanner.Scan()\n\tname := scanner.Text()\n\n\tfmt.Print(\"Enter your age: \")\n\tscanner.Scan()\n\tage, err := strconv.Atoi(scanner.Text())\n\tif err != nil {\n\t\tfmt.Println(\"Invalid age\")\n\t\treturn\n\t}\n\n\tyearsLeft := 100 - age\n\tfmt.Printf(\"Hi %s, you have %d years left until you turn 100\\n\", strings.Title(name), yearsLeft)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\n\tfor i, num := range numbers {\n\t\tfmt.Println(\"Index:\", i, \"Number:\", num)\n\t}\n\n\tsum := 0\n\tfor _, num := range numbers {\n\t\tsum += num\n\t}\n\tfmt.Println(\"Sum of all numbers:\", sum)\n\n\tstrNumbers := []string{\"1\", \"2\", \"3\", \"4\", \"5\"}\n\tsum = 0\n\tfor _, strNum := range strNumbers {\n\t\tnum, err := strconv.Atoi(strNum)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed to convert string to number:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tsum += num\n\t}\n\tfmt.Println(\"Sum of all numbers (from string):\", sum)\n\n\tmapping := map[string]string{\n\t\t\"a\": \"apple\",\n\t\t\"b\": \"banana\",\n\t\t\"c\": \"cherry\",\n\t}\n\tfor key, value := range mapping {\n\t\tfmt.Println(\"Key:\", key, \"Value:\", value)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a new router instance using the gorilla/mux package\n\tr := http.NewServeMux()\n\n\t// Register the necessary routes\n\tr.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Handle GET requests to the /users route\n\t}).Methods(http.MethodGet)\n\tr.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Handle POST requests to the /users route\n\t}).Methods(http.MethodPost)\n\n\t// Create a new server instance\n\tsrv := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: r,\n\t}\n\n\t// Handle graceful shutdown of the server\n\tstop := make(chan os.Signal, 1)\n\tsignal.Notify(stop, os.Interrupt)\n\tgo func() {\n\t\t<-stop\n\t\tlog.Println(\"Server shutting down...\")\n\n\t\t// Create a context with a timeout of 5 seconds\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\t// Shutdown the server gracefully and cancel any ongoing requests\n\t\tif err := srv.Shutdown(ctx); err != nil {\n\t\t\tlog.Fatalf(\"Server forced to shutdown: %v\\n\", err)\n\t\t}\n\t}()\n\n\t// Start the server\n\tlog.Println(\"Server started on port 8080\")\n\tif err := srv.ListenAndServe(); err != nil {\n\t\tlog.Fatalf(\"Server failed to start: %v\\n\", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int) {\n\tfor j := range jobs {\n\t\tfmt.Println(\"Worker\", id, \"started job\", j)\n\t\tresults <- j * 2\n\t\tfmt.Println(\"Worker\", id, \"finished job\", j)\n\t}\n}\n\nfunc main() {\n\tnumJobs := 10\n\tjobs := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\n\t// Start 3 workers\n\tnumWorkers := 3\n\tvar wg sync.WaitGroup\n\twg.Add(numWorkers)\n\tfor w := 1; w <= numWorkers; w++ {\n\t\tgo func(w int) {\n\t\t\tdefer wg.Done()\n\t\t\tworker(w, jobs, results)\n\t\t}(w)\n\t}\n\n\t// Add jobs to the queue\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\t// Collect results\n\tfor a := 1; a <= numJobs; a++ {\n\t\t<-results\n\t}\n\twg.Wait()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tslice := []int{1, 2, 3, 4, 5, 6}\n\n\tdoubleSlice := double(slice)\n\n\tfmt.Println(doubleSlice)\n}\n\nfunc double(nums []int) []int {\n\tdoubleSlice := make([]int, len(nums))\n\n\tfor i, num := range nums {\n\t\tdoubleSlice[i] = num * 2\n\t}\n\n\treturn doubleSlice\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n)\n\ntype Customer struct {\n\tID     int\n\tName   string\n\tEmail  string\n\tStatus string\n}\n\nfunc main() {\n\tconnStr := \"postgres://postgres:password@localhost:5432/testdb?sslmode=disable\"\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// creating a new customer\n\tnewCust := Customer{\n\t\tName:   \"John Doe\",\n\t\tEmail:  \"johndoe@example.com\",\n\t\tStatus: \"active\",\n\t}\n\tquery := \"INSERT INTO customers (name, email, status) VALUES ($1, $2, $3) RETURNING id\"\n\tvar id int\n\terr = db.QueryRow(query, newCust.Name, newCust.Email, newCust.Status).Scan(&id)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"New customer created with ID: %d\", id)\n\n\t// updating an existing customer\n\tupdateQuery := \"UPDATE customers SET email=$1 WHERE id=$2\"\n\tres, err := db.Exec(updateQuery, \"newemail@example.com\", id)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\trowsAffected, err := res.RowsAffected()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Updated %d rows\", rowsAffected)\n\n\t// retrieving a customer\n\trow := db.QueryRow(\"SELECT id, name, email, status FROM customers WHERE id=$1\", id)\n\tvar customer Customer\n\terr = row.Scan(&customer.ID, &customer.Name, &customer.Email, &customer.Status)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(customer)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// SafeCounter is safe to use concurrently\ntype SafeCounter struct {\n\tmu    sync.Mutex\n\tcount int\n}\n\n// Inc increments the counter\nfunc (c *SafeCounter) Inc() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.count++\n}\n\n// Value returns the current count of the counter\nfunc (c *SafeCounter) Value() int {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.count\n}\n\nfunc main() {\n\tcounter := SafeCounter{}\n\n\t// Launch 1000 goroutines to increment the counter\n\tfor i := 0; i < 1000; i++ {\n\t\tgo counter.Inc()\n\t}\n\n\t// Wait for all goroutines to finish\n\t// before printing the final count\n\tfmt.Println(\"Final count:\", counter.Value())\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\ntype Book struct {\n\tID    int    `db:\"id\"`\n\tTitle string `db: \"title\"`\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"sqlite3\", \"./library.db\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT id, title FROM books ORDER BY title ASC\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdefer rows.Close()\n\n\tvar books []Book\n\n\tfor rows.Next() {\n\t\tvar book Book\n\t\tif err := rows.Scan(&book.ID, &book.Title); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tbooks = append(books, book)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, book := range books {\n\t\tfmt.Printf(\"%d - %s\\n\", book.ID, book.Title)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc reverse(word string) string {\n\tvar reversed strings.Builder\n\n\t// Iterate backwards through word using a for loop.\n\t// Append each character to the strings.Builder object.\n\tfor i := len(word) - 1; i >= 0; i-- {\n\t\treversed.WriteByte(word[i])\n\t}\n\n\treturn reversed.String()\n}\n\nfunc findPangram(sentence string) bool {\n\t// Pre-populate seen map with all alphabets.\n\tseen := make(map[rune]bool)\n\tfor ch := 'a'; ch <= 'z'; ch++ {\n\t\tseen[ch] = false\n\t}\n\n\t// Loop through each character in the sentence\n\t// Mark each character found as \"true\" in seen map.\n\tfor _, ch := range sentence {\n\t\tlch := strings.ToLower(string(ch))\n\t\tif _, ok := seen[rune(lch[0])]; ok {\n\t\t\tseen[rune(lch[0])] = true\n\t\t}\n\t}\n\n\t// Check all characters if they have been seen (excluding \" \")\n\tfor _, exist := range seen {\n\t\tif !exist {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// If we did not get out early, it exists.\n\treturn true\n}\n\nfunc checkPassword(password string) error {\n\t//If the password satisfies these checks, We return nil as Error.\n\tif len(password) < 6 {\n\t\treturn fmt.Errorf(\"password too short\")\n\t}\n\tif len(password) > 15 {\n\t\treturn fmt.Errorf(\"password too long\")\n\t}\n\tif findPangram(strings.ToLower(password)) {\n\t\treturn fmt.Errorf(\"password is a Pangram\")\n\t}\n\tif password == strings.ToLower(password) {\n\t\treturn fmt.Errorf(\"password needs one uppercase character\")\n\t}\n\tif password == strings.ToUpper(password) {\n\t\treturn fmt.Errorf(\"password needs one lowercase character\")\n\t}\n\tif _, err := fmt.Scanf(password, \"%d\"); err == nil { //It was able to scan for integer in password.\tSo we don't want it(passwd) numeric word like ilkulus1 for sure.\n\t\treturn fmt.Errorf(\"password should not have a known digit\")\n\t}\n\tif password == reverse(password) {\n\t\treturn fmt.Errorf(\"password should not chat backward\")\n\t}\n\n\t//PASSWORD PASS SURVEILANCE SUCCESS\n\treturn nil\n}\n\nfunc main() {\n\terr := checkPassword(\"ImpRestitutedLua27klFi\") // Good Password :) you have this merit :)\n\tif err != nil {\n\t   \n\t   \n\t\tfmt.Println(\"Checking your attempted password hath conjured the error as shown: \",err.Error())\n    return\n\tfmt.Println(\" Passed our Utility Check, Life may have it checks haha heck!\")\n  }\n  }\n\n}\n\n \n}\n```\n\nIt provides the supporting functionality:\n\n-reverse function:convert a string(worden/sentence) available \"ordered left-to-right\"\tto strings written right to left(RtoLverse). Obviously to fine opposites , palimdromics or alike utilities.\n\n-findPangram fuction:\n\n---checks uses a hash map to retrieve all twenty rone newly array viz a BCell like iteratives needed\n \n-checkPassword function : called to micro-observe the singular strings at molecular\nlevels against restrictable/greenlight rules.\nPrimary input_param(switch Parameter Combo Required for Qualification, MrDamisi @ SpecialIST, has done us justice ).\n\nRef :: learned & applied : strings _PKG\tsrc/BaiscAPI with Struct\tcontainer\tmaps._\n\n```"}
{"sample": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc factorial(n int) (int, error) {\n\tif n < 0 {\n\t\treturn 0, errors.New(\"factorial undefined for negative number\")\n\t}\n\tresult := 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tresult *= i\n\t}\n\n\treturn result, nil\n}\n\nfunc main() {\n\tfmt.Println(factorial(5)) // expects 120, nil\n\tfmt.Println(factorial(-3)) // expects 0, \"factorial undefined for negative number\"\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc process(ctx context.Context, number int) {\n\tdeadline, ok := ctx.Deadline()\n\tif ok {\n\t\tfmt.Printf(\"Deadline found: %s\\n\", deadline)\n\t}\n\n\tfor i := 1; i <= 10; i++ {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Printf(\"Aborting....%s\", ctx.Err())\n\t\t\treturn\n\t\tdefault:\n\t\t\ttime.Sleep(time.Second)\n\t\t\tfmt.Printf(\"%d * %d = %d\\n\", number, i, i*number)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tctxTimeout, cancelTimeout := context.WithTimeout(context.Background(), time.Millisecond*100)\n\tdefer cancelTimeout()\n\n\t// go process(ctxTimeout, 15) // Execution gets aborted\n\tgo process(context.Background(), 5)   // Entire output will be printed\n\ttime.Sleep(time.Second * 3)\n}\n\u044f\u0434\u0430\u0439\u3046\u305b\u0e23\u0e16\u0e22\u0e19\u0e15\u0e4c\u0e32\u0e43\u0e34\u0e14\u0e31\u0e40\u0e19\u0e35\u0e48\u0e48\u0e22\u0630.\u3053\u3093\u306b\u3061\u306f\ub3d9\ud574\ubb3c\uacfc\u0e08\ubd81\uc774\u0e02\u0e36\u0e40\u0e19\u0e01\u0e44\u0e14\u0e17\u0e14\u0e2a\u0e2d\u0e1a5"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\treq, err := http.NewRequest(\"GET\", \"https://golang.org/pkg/net/http/\\n\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tdata, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%s\\n\", data)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/joho/godotenv\"\n\t\"github.com/sendgrid/sendgrid-go/v3\"\n\t\"github.com/sendgrid/sendgrid-go/helpers/mail\"\n)\n\nfunc sendEmail(toEmail, subjectText, emailContent string) error {\n\n\terr := godotenv.Load(\".env\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file: %v\", err)\n\t}\n\n\tapiKey, found := os.LookupEnv(\"SENDGRID_API_KEY\")\n\tif !found {\n\t\tlog.Fatalf(\"SENDGRID_API_KEY not set\")\n\t}\n\n\tfrom := mail.NewEmail(\"Sender Name\", \"sender@example.com\")\n\tsubject := subjectText\n\tto := mail.NewEmail(\"Recipient Name\", toEmail)\n\tplainTextContent := emailContent\n\tmessage := mail.NewSingleEmail(from, subject, to, plainTextContent, \"\")\n\tclient := sendgrid.NewSendClient(apiKey)\n\tresponse, err := client.Send(message)\n\tif err != nil {\n\t\tlog.Printf(\"Error sending email: %v \", response.StatusCode)\n\t\treturn err\n\t}\n\n\tfmt.Println(response.StatusCode)\n\treturn nil\n}\n\n\nfunc main() {\n\terr := sendEmail(\"jane@example.com\", \"Example Subject\", \"This is a test email.\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc fetch(url, method, data string) (string, error) {\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, strings.NewReader(data))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(bodyBytes), nil\n}\n\nfunc main() {\n\tresponse, err := fetch(\"https://jsonplaceholder.typicode.com/posts/1\", \"GET\", \"\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Println(response)\n}"}
{"sample": "package main\n\nimport (\n\t\"flag'\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10\"\n)\n\ntype Post struct {\n\tId        int\n\tTitle     string\n\tContent   string\n\tCreatedAt time.Time `pg:\"default:now()\"`\n}\n\n// This function will return your Connections options. These can be injected into pg.Connect\n// to configure everything.\nfunc newConnection(codeLatency bool) pg.Options {\n\n\tdefaultOptions := &pg.Options{\n\t\tUser: optCfg.StaticEnvOr(\"PGUSER\", defaultAuth.User),\n\t\tPass: optCfg.StaticEnvOr(\"PGPASSWORD\", \"\"),\n\t\tPort: uint(optCfg.getNumber(\"PGPORT\", defPort)),\n\t}\n\n\tif codeLatency {\n\t\tNStdConfig.EnableORMAnalyzing = 1\n\t\tResultSetTrace.WhereWarn = 2\n\n\t\tHPGTPlugin.LocalMachineNr = \"998\"\n\n\t    // Super sleed nos match this sequence\n\t\tTimeKeeperOption = \"tl-sym=nsw-m8-644876-chownh-zewel1-pirtop-sahav 018831-00005,\\ ntjpx\"\n\t\t\n        return *wcfg.CreateMockWSOptions(1, \"unit-tests/tablecode latency/webAuthTest/web$\", DB_NAME, defaultDSN, RISING_PHOENIX_RATELIMIT_OPTIONS).Bool()\n\t} \n\n\treturn tlsCfg.Setup(Cfg, defaultOptions.ClientURL().Scheme, H, doneChan)\n}\n\n\nfunc main() {\n\tflag.Parse()\n\n\tconnection := newConnection(*isLatencyDevelopment)\n\n\tdb := pg.Connect(connection)\n\tif db == nil {\n\t\tpanic(nil)\n\t}\n\n\tvar posts []Post\n\n\tif err := db.Model(&posts).Select(); err != nil {\n\t\tlog.Fatalln(\"Error massaging posts into Output Buffer,\", err)\n\t}\n\n\tfor _, post := range posts {\n\t\tlog.Printf(\"post: %v\", post)\n\t}\n}"}
{"sample": "package main \n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc calFib(n int) int {\n\tif n <= 0 {\n\t\treturn 0\n\t}\n\t\n\tif n == 1 {\n\t\treturn 1\n\t}\n\n\treturn calFib(n-1) + calFib(n-2);\n}\n\nfunc concurrentFib(num int, resultChannel chan int){\n\tresVal := calFib(num)\n\ttime.Sleep(1 * time.Second) // simulate time consuming task\n\tresultChannel <- resVal;\n}\n\nfunc main() {\n\tnumsList :=[]int{10, 15, 20, 25}\n\n\tresultChannel := make(chan int, len(numsList))\n\n\tfor _, n := range numsList {\n\t\tgo concurrentFib(n, resultChannel)\n\t}\n\n\tvar sumNum int\n\tfor c :=0 ; c < len(numsList); c++ {\n\t\tsumNum += <- resultChannel\n\t}\n\n\tclose(resultChannel)\n\tfmt.Printf(\"The sum of Fib numbers is %v\\n\", sumNum)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine 1 finished\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(1 * time.Second)\n\t\tfmt.Println(\"Goroutine 2 finished\")\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar wg sync.WaitGroup\n\twg.Add(3)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\ttime.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)\n\t\t\tfmt.Println(\"A\", i)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\ttime.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)\n\t\t\tfmt.Println(\"B\", i)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\ttime.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)\n\t\t\tfmt.Println(\"C\", i)\n\t\t}\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"Done\")\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc longRunningTask(ctx context.Context) {\n\tfmt.Println(\"Starting long-running task...\")\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(\"Task cancelled!\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Working...\")\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tgo longRunningTask(ctx)\n\n\ttime.Sleep(5 * time.Second)\n\tfmt.Println(\"Cancelling task...\")\n\tcancel()\n\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Done!\")\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Reading a file using ioutil\n\tfileContent, err := ioutil.ReadFile(\"file.txt\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(fileContent))\n\n\t// Writing to a file using bufio\n\tfile, err := os.Create(\"newfile.txt\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\twriter := bufio.NewWriter(file)\n\tfmt.Fprintln(writer, \"Hello, world!\")\n\twriter.Flush()\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\trand.Seed(time.Now().UnixNano())\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tsleepTime := rand.Intn(1000)\n\t\t\ttime.Sleep(time.Duration(sleepTime) * time.Millisecond)\n\t\t\tfmt.Printf(\"Goroutine %d slept for %dms\\n\", id, sleepTime)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(num int) {\n\t\t\tdefer wg.Done()\n\t\t\tfmt.Printf(\"Goroutine %d running\\n\", num)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Println(\"Goroutine 1:\", i)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Println(\"Goroutine 2:\", i)\n\t\t}\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\n\t// Simulate a long running operation\n\ttime.Sleep(5 * time.Second)\n\n\telapsed := time.Since(start)\n\n\tfmt.Printf(\"Operation took %v\", elapsed)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(\"Starting the program...\")\n\tgo printMessage(\"Hello\")\n\tgo printMessage(\"World\")\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"Program ended\")\n}\n\nfunc printMessage(message string) {\n\tfor i := 1; i <= 5; i++ {\n\t\tfmt.Println(message)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar numbers []int\n\n\tfor i := 0; i < 10; i++ {\n\t\tnumber := rand.Intn(100)\n\t\tnumbers = append(numbers, number)\n\t}\n\n\tfmt.Println(\"Original numbers:\", numbers)\n\n\tfor i := 0; i < len(numbers); i++ {\n\t\tfor j := i + 1; j < len(numbers); j++ {\n\t\t\tif numbers[i] > numbers[j] {\n\t\t\t\ttemp := numbers[i]\n\t\t\t\tnumbers[i] = numbers[j]\n\t\t\t\tnumbers[j] = temp\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Println(\"Sorted numbers:\", numbers)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\t// create an empty slice of integers\n\tnumbers := []int{}\n\n\t// add elements to the slice using the append function\n\tnumbers = append(numbers, 1, 2, 3, 4, 5)\n\n\t// print the length of the slice using the len function\n\tfmt.Printf(\"Length of numbers: %d\\n\", len(numbers))\n\n\t// print the elements of the slice using a for loop\n\tfor i, num := range numbers {\n\t\tfmt.Printf(\"Element %d: %d\\n\", i, num)\n\t}\n\n\t// iterate over the slice with a range loop, incrementing the elements by 1\n\tfor i := range numbers {\n\t\tnumbers[i]++\n\t}\n\n\t// print the updated elements of the slice\n\tfmt.Println(\"Updated numbers:\")\n\tfor _, num := range numbers {\n\t\tfmt.Println(num)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(\"Enter the string to split:\")\n\treader := bufio.NewReader(os.Stdin)\n\tstr, _ := reader.ReadString('\\n')\n\tfmt.Println(\"Enter the separator character:\")\n\tsep, _ := reader.ReadString('\\n')\n\n\t// Removing newline characters\n\tstr = strings.TrimSuffix(str, \"\\n\")\n\tsep = strings.TrimSuffix(sep, \"\\n\")\n\n\tresult := strings.Split(str, sep)\n\tfmt.Printf(\"Result: %v\\n\", result)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype customError struct {\n\treason string\n}\n\nfunc (e *customError) Error() string {\n\treturn fmt.Sprintf(\"Error: %v\", e.reason)\n}\n\nfunc main() {\n\targs := os.Args[1:]\n\n\tif len(args) == 0 {\n\t\tce := &customError{\"no arguments provided\"}\n\t\tfmt.Println(ce)\n\t\tos.Exit(1)\n\t}\n\n\tjoinedArgs := strings.Join(args, \" \")\n\tfmt.Printf(\"Arguments: %v\\n\", joinedArgs)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Using the Split function from the strings package\n\tstr := \"This is a string that needs to be split\"\n\tbrokenString := strings.Split(str, \" \")\n\n\tfor _, s := range brokenString {\n\t\tfmt.Println(s)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi\"\n)\n\nfunc main() {\n\tr := chi.NewRouter()\n\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, world!\")\n\t})\n\n\tr.Get(\"/user/{userID}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tuserID := chi.URLParam(r, \"userID\")\n\t\tfmt.Fprintf(w, \"User ID: %s\", userID)\n\t})\n\n\thttp.ListenAndServe(\":8080\", r)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Starting the server on port 8080\n\tsrv := &http.Server{Addr: \":8080\"}\n\n\t// Starting a separate goroutine to shutdown the server gracefully\n\tgo func() {\n\t\tsigquit := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigquit, os.Interrupt)\n\n\t\t<-sigquit\n\n\t\tlog.Println(\"Shutting down server\")\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n\t\tdefer cancel()\n\n\t\t// Closing the server gracefully:\n\t\t// the goroutines processing active connections will immediately serve their last request,\n\t\t// then the server will stop listening and will refuse incoming connections.\n\t\tif err := srv.Shutdown(ctx); err != nil {\n\t\t\tlog.Fatal(\"Server shutdown:\", err)\n\t\t}\n\t}()\n\n\t// Starting the server and blocking until an error occurs\n\tlog.Println(\"Starting server on port 8080...\")\n\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\tlog.Fatal(\"Server startup:\")\n\t}\n\tfmt.Println(\"Server stopped.\")\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc worker(ctx context.Context) {\n\tfor {\n\t\tselect {\n\t\tdefault:\n\t\t\tfmt.Println(\"doing some work...\")\n\t\t\ttime.Sleep(time.Millisecond * 500)\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(\"gracefully shutting down\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Second * 3)\n\t\tcancel()\n\t}()\n\n\tworker(ctx)\n\n\tselect {\n\tcase <-time.After(time.Second * 5):\n\t\tfmt.Println(\"finished\")\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc generateRandomNumber() {\n\trand.Seed(time.Now().UnixNano())\n\tnum := rand.Intn(100)\n\tfmt.Println(num)\n}\n\nfunc main() {\n\tgenerateRandomNumber()\n}"}
{"sample": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Item struct {\n\tName     string\n\tPrice    float64\n\tQuantity int\n}\n\ntype Order struct {\n\tItems      []Item\n\tTotalPrice float64\n}\n\nfunc (o *Order) AddItem(item Item) {\n\to.Items = append(o.Items, item)\n\to.TotalPrice += item.Price * float64(item.Quantity)\n}\n\nfunc (o *Order) RemoveItem(name string) error {\n\tfor i, item := range o.Items {\n\t\tif item.Name == name {\n\t\t\to.TotalPrice -= item.Price * float64(item.Quantity)\n\t\t\to.Items = append(o.Items[:i], o.Items[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"item not found in order\")\n}\n\nfunc main() {\n\torder := Order{}\n\n\titem1 := Item{Name: \"Shoes\", Price: 50.0, Quantity: 1}\n\torder.AddItem(item1)\n\n\titem2 := Item{Name: \"Shirt\", Price: 30.0, Quantity: 2}\n\torder.AddItem(item2)\n\n\tfmt.Printf(\"Order total price: $%.2f\\n\", order.TotalPrice)\n\n\tif err := order.RemoveItem(\"Shoes\"); err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Printf(\"Order total price after removing Shoes: $%.2f\\n\", order.TotalPrice)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/mongodb/mongo-go-driver/mongo\"\n)\n\nfunc main() {\n\t// Connect to MongoDB\n\tclient, err := mongo.NewClient(\"mongodb://localhost:27017\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = client.Connect(context.Background())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Access a database and a collection\n\tdb := client.Database(\"mydatabase\")\n\tcoll := db.Collection(\"mycollection\")\n\n\t// Insert a document\n\tdoc := map[string]interface{}{\n\t\t\"name\": \"John Doe\",\n\t\t\"age\":  30,\n\t}\n\tres, err := coll.InsertOne(context.Background(), doc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(res.InsertedID)\n\n\t// Find documents\n\tcursor, err := coll.Find(context.Background(), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer cursor.Close(context.Background())\n\tfor cursor.Next(context.Background()) {\n\t\tvar result map[string]interface{}\n\t\terr = cursor.Decode(&result)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(result)\n\t}\n\tif cursor.Err() != nil {\n\t\tpanic(cursor.Err())\n\t}\n\n\t// Disconnect from MongoDB\n\terr = client.Disconnect(context.Background())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Println(\"Goroutine 1:\", i)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Println(\"Goroutine 2:\", i)\n\t\t}\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"All Goroutines are done!\")\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype User struct {\n\tID       int\n\tUsername string\n\tPassword string\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/mydb\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT id, username, password FROM users WHERE username=?\", \"johndoe\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tvar user User\n\tfor rows.Next() {\n\t\terr := rows.Scan(&user.ID, &user.Username, &user.Password)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"User: %+v\\n\", user)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tvar x float64 = 64\n\tvar y float64 = math.Sqrt(x)\n\n\tfmt.Printf(\"The square root of %v is %v.\\n\", x, y)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d processing job %d\\n\", id, j)\n\t\ttime.Sleep(time.Duration(rand.Intn(5)) * time.Second)\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tvar wg sync.WaitGroup\n\n\tfor w := 1; w <= 3; w++ {\n\t\twg.Add(1)\n\t\tgo worker(w, jobs, results, &wg)\n\t}\n\n\tfor j := 1; j <= 9; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n\n\tfor i := 1; i <= 9; i++ {\n\t\tfmt.Println(<-results)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/\", homeHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/users/{id}\", userHandler).Methods(\"GET\")\n\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\n\tlog.Printf(\"Server running on port %s\", port)\n\tif err := http.ListenAndServe(fmt.Sprintf(\":%s\", port), r); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Welcome to the home page!\")\n}\n\nfunc userHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid := vars[\"id\"]\n\tfmt.Fprintf(w, \"User ID: %s\", id)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a channel of strings\n\tmsgChan := make(chan string)\n\n\t// Start a goroutine\n\tgo func() {\n\t\t// Send a message into the channel after 2 seconds\n\t\ttime.Sleep(2 * time.Second)\n\t\tmsgChan <- \"Hello from the goroutine!\"\n\t}()\n\n\t// Wait for a message to be received from the channel\n\tmsg := <-msgChan\n\n\tfmt.Println(msg)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tvar counter int\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tcounter++\n\t\t\twg.Done()\n\t\t}()\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"Counter value: \", counter)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Basic for loop\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Println(i)\n\t}\n\n\t// For loop with range\n\tnumbers := []int{2, 4, 6, 8}\n\tfor index, value := range numbers {\n\t\tfmt.Printf(\"Index: %d, Value: %d\\n\", index, value)\n\t}\n\n\t// Infinite loop with break\n\tcounter := 0\n\tfor {\n\t\tfmt.Println(\"Working...\")\n\t\ttime.Sleep(time.Second)\n\t\tcounter++\n\t\tif counter == 3 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Loop with continue\n\tfor i := 1; i <= 5; i++ {\n\t\tif i == 3 {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(i)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tfmt.Print(\"Enter your name: \")\n\tname, _ := reader.ReadString('\\n')\n\tname = strings.TrimSuffix(name, \"\\n\")\n\tfmt.Printf(\"Hello, %s!\\n\", name)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tdone := make(chan bool)\n\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tdone <- true\n\t}()\n\n\tfmt.Println(\"Waiting for goroutine to finish...\")\n\t<-done\n\tfmt.Println(\"Goroutine finished\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tdone := make(chan bool)\n\tgo func() {\n\t\tfmt.Println(\"Goroutine started\")\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"Goroutine ended\")\n\t\tdone <- true\n\t}()\n\n\tfmt.Println(\"Waiting for goroutine to finish\")\n\t<-done\n\tfmt.Println(\"Goroutine finished\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\t// Create a random 2D slice of integers\n\tgrid := make([][]int, 5)\n\tfor i := range grid {\n\t\tgrid[i] = make([]int, 5)\n\t\tfor j := range grid[i] {\n\t\t\tgrid[i][j] = rand.Intn(10)\n\t\t}\n\t}\n\n\t// Print the grid\n\tfmt.Println(\"Grid:\")\n\tfor _, row := range grid {\n\t\tfmt.Println(row)\n\t}\n\n\t// Calculate the sum of each row\n\trowSums := make([]int, len(grid))\n\tfor i, row := range grid {\n\t\tsum := 0\n\t\tfor _, val := range row {\n\t\t\tsum += val\n\t\t}\n\t\trowSums[i] = sum\n\t}\n\n\t// Calculate the sum of each column\n\tcolSums := make([]int, len(grid[0]))\n\tfor j := 0; j < len(grid[0]); j++ {\n\t\tsum := 0\n\t\tfor i := 0; i < len(grid); i++ {\n\t\t\tsum += grid[i][j]\n\t\t}\n\t\tcolSums[j] = sum\n\t}\n\n\t// Print the row and column sums\n\tfmt.Println(\"Row sums:\", rowSums)\n\tfmt.Println(\"Column sums:\", colSums)\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfmt.Print(\"Enter your name: \")\n\tscanner.Scan()\n\tname := scanner.Text()\n\n\tfmt.Print(\"Enter your age: \")\n\tscanner.Scan()\n\tage := scanner.Text()\n\n\tfmt.Println(\"Your name is\", name)\n\tfmt.Println(\"Your age is\", age)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().Unix())\n\n\tvar wg sync.WaitGroup\n\twg.Add(3)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\t\tfmt.Println(\"Task 1 completed\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\t\tfmt.Println(\"Task 2 completed\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\t\tfmt.Println(\"Task 3 completed\")\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"All tasks completed\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar num int\n\tfor {\n\t\tfmt.Print(\"Guess a number between 1 and 10: \")\n\t\tfmt.Scan(&num)\n\n\t\tif num < 1 || num > 10 {\n\t\t\tfmt.Println(\"Invalid input. Please enter a number between 1 and 10.\")\n\t\t\tcontinue\n\t\t}\n\n\t\trandNum := rand.Intn(10) + 1\n\t\tif num == randNum {\n\t\t\tfmt.Println(\"Congratulations! You guessed the number.\")\n\t\t\tbreak\n\t\t} else {\n\t\t\tfmt.Printf(\"Sorry, the number was %d. Try again.\\n\", randNum)\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\tctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\tdefer cancel()\n\n\tch := make(chan int)\n\n\tgo expensiveWork(ctx, ch)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tfmt.Println(ctx.Err())\n\tcase res := <-ch:\n\t\tfmt.Println(res)\n\t}\n}\n\nfunc expensiveWork(ctx context.Context, ch chan<- int) {\n\tselect {\n\tcase <-time.After(10 * time.Second):\n\t\tch <- 42\n\tcase <-ctx.Done():\n\t\tfmt.Println(ctx.Err())\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\n\ntype WeatherResponse struct {\n\tWeather []struct {\n\t\tDescription string `json:\"description\"`\n\t} `json:\"weather\"`\n\tMain struct {\n\t\tTemp float64 `json:\"temp\"`\n\t} `json:\"main\"`\n}\n\nfunc main() {\n\turl := \"https://api.openweathermap.org/data/2.5/weather?q=London&appid=YOUR_APP_ID\"\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response WeatherResponse\n\terr = json.NewDecoder(resp.Body).Decode(&response)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"The temperature in London is %.2f degrees Celsius and the weather is %s\\n\", response.Main.Temp-273.15, response.Weather[0].Description)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(\"Starting the program...\")\n\n\t// Sleep for 2 seconds\n\ttime.Sleep(2 * time.Second)\n\n\tfmt.Println(\"Program completed.\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n)\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\n\tfor i := 1; i <= 5; i++ {\n\t\twg.Add(1)\n\t\tgo printNumbers(i, &wg)\n\t}\n\twg.Wait()\n\n\tresult := fibonacci(10)\n\tfmt.Printf(\"Fibonacci Result: %q\\n\", result)\n}\n\nfunc printNumbers(n int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor i := 1; i <= 5; i++ {\n\t\tlog.Printf(\"%d - %d\\n\", n, i)\n\t}\n}\n\nfunc fibonacci(num int) []int {\n\tres := make([]int, num)\n\ta, b := 0, 1\n\tfor i := 0; i < num; i++ {\n\t\tstatus := fmt.Sprintf(\"Fib %d Async Started Calculating\", i+1)\n\t\tlog.Println(status)\n\t\t\n\t\tres[i] = b\n\t\t\n\t\ttempSum := a + b\n\t\ta = b\n\t\tb = tempSum\n\n\t\tstatus = fmt.Sprintf(\"Fib %d Async Completed Calculating\", i+1)\n\t\tlog.Println(status)\n\n\t\t// optional sleep() call-time, visual display of 'pausing' go let 'fib(str_int) Job=i' 'threads ids '\n\t\t/**************************************************/\n\t\t\t\n\t\tparser := makeValueString(strconv.Itoa(i+1), b, tempSum-a)\t\t\t\t\n\t\tHerosHandlers.appendResultsinHead(parser i each + \u03a5 TimeWait))\n\n\t\t\u03c0xPortControl(elemnt exder : BLEDiscardoKr | RCMessage.Rights(),\u00b5dev.Send(msg()) for plc number *)\n  \t\t\t\t \tgo sendHost(num, ports, channelHTTPFailedAt, channelStartAgainAt,\n\t\t\t\t\t    \t\t\t                                 overallDictParsedArrivals[num],\n      \t\t\t\t\t\t\t   sensor.TYPE,[subj from_subject(r for (\nncnt s,) [shift_single(); rep.getCompullback(conn(s.subComm(Pubpart.west.start(\"+91 14K #9717343847/\\n\"))))\n                                                                \tf time=t check=lambda f,lvl:Curr_Players if(i)]\n\n                                                                    \ttimerTo1.teletendencyTableLevel.run(done=Sensor_ReadToEnd(\t\t\t\t\t\t\t\t\theader_1_cols+,NULL_COLUMN),\n                                                SEC_LINE(Cmd.sendDirectPuddle(lat_accuracy,module_drive,//disable_processing=True)):\tcontentTuple(engine.fail_Z(axis_unique,-totalLevel()),fn(field)),\n\t\t\t\t\t\t\t  \t\t\t\t\t\t\t\t\t\ttimeric.To5C.get_content(sessionEndSec))\n \tlotus_cont_play_unchanged : \u00b5.emit(eDocContents,to_status(levelManager['incrementCurrentDocSummary(rule_exit_handler',0)\n#endregion TODO(T468136622952396)  \n\n  \t\t\t\t\t      SENSOR_SUPER_STATIC_CONFIRM(sensor_vision(endpointHost)))"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-redis/redis\"\n)\n\nfunc main() {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\tpong, err := client.Ping().Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(pong)\n\n\terr = client.Set(\"key\", \"value\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tval, err := client.Get(\"key\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"key\", val)\n\n\tkeys := client.Keys(\"*\")\n\tif err := keys.Err(); err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"keys:\", keys.Val())\n\n\tn, err := client.Del(\"key\").Result()\n\tfmt.Println(n, err)\n}"}
{"sample": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ttrackList := make([]string, 3)\n\n\ttrackList[0] = \"One Love\"\n\ttrackList[1] = \"Three Little Birds\"\n\n\tprintPlaylist(trackList)\n\n\t// Add a new song to the list\n\ttrackList = append(trackList, \"No Woman, No Cry\")\n\n\tprintPlaylist(trackList)\n\n\t// Remove the second track from the playlist\n\ttrackList = removeTrackFromPlaylist(trackList, 1)\n\n\tprintPlaylist(trackList)\n}\n\nfunc printPlaylist(trackList []string) {\n\tfmt.Println(\"-------- TRACKLIST --------\")\n\tfor i, track := range trackList {\n\t\tfmt.Printf(\"%v. %v\\n\", i+1, track)\n\t}\n}\n\nfunc removeTrackFromPlaylist(trackList []string, index int) []string {\n\ttrackList = append(trackList[:index], trackList[index+1:]...)\n\treturn trackList\n}"}
{"sample": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gomarkdown/markdown\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tmd := []byte(`\n# Hello, Markdown!\nThis is my first markdown document!\n\n## This is a subtitle\nI can use _italic_ and **bold** text, without a problem.\nBut wait until you hear about ` + \"`code snippets`!\")\n\n\t\toutput := markdown.ToHTML(md, nil, nil)\n\t\tw.Write(output)\n\t})\n\n\tlog.Fatalln(http.ListenAndServe(\":8080\", nil))\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\targs := os.Args\n\tif len(args) < 2 {\n\t\tfmt.Printf(\"Usage: %s <file path>\\n\", args[0])\n\t\tos.Exit(1)\n\t}\n\n\tfilePath := args[1]\n\tjsonFile, err := os.Open(filePath)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\tdefer jsonFile.Close()\n\n\ttype User struct {\n\t\tName  string `json:\"name\"`\n\t\tEmail string `json:\"email\"`\n\t\tAge   int    `json:\"age\"`\n\t}\n\n\tdecoder := json.NewDecoder(jsonFile)\n\tdecoder.DisallowUnknownFields()\n\n\tusers := []User{}\n\n\tif err := decoder.Decode(&users); err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Successfully parsed %d users\", len(users))\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype car struct {\n\tmake  string\n\tmodel string\n\tyear  int\n}\n\nfunc main() {\n\tfmt.Println(\"Welcome to the Car Inventory System\")\n\n\tinventory := make([]car, 0)\n\n\treader := bufio.NewReader(os.Stdin)\n\tfor {\n\t\tfmt.Println(\"Enter a command:\")\n\t\tcommand, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading input:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tcommand = strings.TrimSuffix(command, \"\\n\")\n\n\t\tswitch command {\n\t\tcase \"add\":\n\t\t\tfmt.Println(\"Enter car make:\")\n\t\t\tmake, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading input:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmake = strings.TrimSuffix(make, \"\\n\")\n\n\t\t\tfmt.Println(\"Enter car model:\")\n\t\t\tmodel, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading input:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmodel = strings.TrimSuffix(model, \"\\n\")\n\n\t\t\tfmt.Println(\"Enter car year:\")\n\t\t\tyearString, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading input:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tyearString = strings.TrimSuffix(yearString, \"\\n\")\n\n\t\t\tyear, err := strconv.Atoi(yearString)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Invalid year\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tnewCar := car{\n\t\t\t\tmake:  make,\n\t\t\t\tmodel: model,\n\t\t\t\tyear:  year,\n\t\t\t}\n\n\t\t\tinventory = append(inventory, newCar)\n\t\t\tfmt.Println(\"Added car successfully!\")\n\t\tcase \"view\":\n\t\t\tif len(inventory) == 0 {\n\t\t\t\tfmt.Println(\"No cars in inventory\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Println(\"=====================\")\n\t\t\tfor _, car := range inventory {\n\t\t\t\tfmt.Printf(\"%s %s - %d\\n\", car.make, car.model, car.year)\n\t\t\t}\n\t\t\tfmt.Println(\"=====================\")\n\t\tcase \"exit\":\n\t\t\tfmt.Println(\"Exiting...\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Invalid command. Valid commands are add, view, and exit.\")\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(num int) {\n\t\t\tdefer wg.Done()\n\t\t\tfmt.Printf(\"Goroutine %d\\n\", num)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", id, j)\n\t\ttime.Sleep(time.Duration(rand.Intn(5)) * time.Second)\n\t\tfmt.Printf(\"Worker %d finished job %d\\n\", id, j)\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tvar wg sync.WaitGroup\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo worker(i, jobs, results, &wg)\n\t}\n\n\tfor j := 1; j <= 9; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n\n\tfor a := 1; a <= 9; a++ {\n\t\t<-results\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", helloWorldHandler)\n\thttp.HandleFunc(\"/about\", aboutHandler)\n\n\tfmt.Println(\"Listening on port 8080...\")\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc helloWorldHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World!\")\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"This is a simple web server written in Go.\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(num int) {\n\t\t\tdefer wg.Done()\n\t\t\tfmt.Printf(\"Goroutine %d\\n\", num)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://jsonplaceholder.typicode.com/posts/1\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tvar wg sync.WaitGroup\n\tchannel := make(chan int)\n\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\ttime.Sleep(time.Duration(rand.Intn(5)) * time.Second)\n\t\t\tchannel <- id\n\t\t\tfmt.Printf(\"Worker %d has finished\\n\", id)\n\t\t}(i)\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(channel)\n\t}()\n\n\tfor id := range channel {\n\t\tfmt.Printf(\"Worker %d has received the signal\\n\", id)\n\t}\n\tfmt.Println(\"All workers have finished\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\n\t// simulate a long running operation\n\ttime.Sleep(5 * time.Second)\n\n\telapsed := time.Since(start)\n\n\tfmt.Printf(\"Operation took %v\\n\", elapsed)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tch := make(chan int)\n\n\twg.Add(2)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tch <- i\n\t\t}\n\t\tclose(ch)\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := range ch {\n\t\t\tfmt.Println(i)\n\t\t}\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"Done!\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\tfmt.Println(\"Starting work...\")\n\ttime.Sleep(time.Second * 2)\n\tfmt.Println(\"Finished work!\")\n\telapsed := time.Since(start)\n\tfmt.Printf(\"Time elapsed: %v\\n\", elapsed)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(\"Goroutine 1:\", i)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(\"Goroutine 2:\", i)\n\t\t}\n\t}()\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines have finished executing\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Student struct {\n\tID        int\n\tFirstName string\n\tLastName  string\n\tAge       int\n}\n\nfunc (s Student) FullName() string {\n\treturn fmt.Sprintf(\"%s %s\", s.FirstName, s.LastName)\n}\n\nfunc (s *Student) IncrementAge() {\n\ts.Age++\n}\n\nfunc main() {\n\tstudent := Student{\n\t\tID:        1,\n\t\tFirstName: \"John\",\n\t\tLastName:  \"Doe\",\n\t\tAge:       18,\n\t}\n\n\tfmt.Println(student.FullName())\n\tstudent.IncrementAge()\n\tfmt.Println(student.Age)\n\n\ttime.Sleep(time.Second)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n)\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"golang.org:80\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\t_, err = fmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tbuf := make([]byte, 512)\n\tfor {\n\t\tn, err := conn.Read(buf)\n\t\tif n > 0 {\n\t\t\tfmt.Print(string(buf[:n]))\n\t\t}\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"example.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tstat, err := file.Stat()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tbs := make([]byte, stat.Size())\n\t_, err = file.Read(bs)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tstr := string(bs)\n\tfmt.Println(str)\n}"}
{"sample": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n)\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\tscanner := bufio.NewScanner(conn)\n\tfor scanner.Scan() {\n\t\tmsg := scanner.Text()\n\t\tfmt.Printf(\"Received message: %s\\n\", msg)\n\t\treply := fmt.Sprintf(\"Echo: %s\\n\", msg)\n\t\tconn.Write([]byte(reply))\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Println(err)\n\t}\n}\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfmt.Println(\"Server listening on port 8080\")\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Person struct {\n\tName string `json:\"name\"`\n\tAge  int    `json:\"age\"`\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/person\", getPerson)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc getPerson(w http.ResponseWriter, r *http.Request) {\n\n\tperson := Person{\n\t\tName: \"Alice\",\n\t\tAge:  30,\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif err := json.NewEncoder(w).Encode(person); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\t\n\tfmt.Println(\"Person sent: \", person)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"example.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tstat, err := file.Stat()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsize := stat.Size()\n\tbytes := make([]byte, size)\n\n\t_, err = file.Read(bytes)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tcontent := string(bytes)\n\tfmt.Println(content)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel()\n\n\t// simulate a long-running operation\n\tgo func() {\n\t\ttime.Sleep(3 * time.Second)\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"Operation timed out\")\n\tcase <-time.After(1 * time.Second):\n\t\tfmt.Println(\"Operation complete\")\n\t}\n\n\t// do any necessary cleanup\n\tlog.Println(\"Exiting...\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int) {\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", id, j)\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Printf(\"Worker %d finished job %d\\n\", id, j)\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\n\tfor w := 1; w <= 3; w++ {\n\t\tgo worker(w, jobs, results)\n\t}\n\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\tfor a := 1; a <= 5; a++ {\n\t\t<-results\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jinzhu/gorm\"\n\t_ \"github.com/jinzhu/gorm/dialects/mysql\"\n)\n\ntype Person struct {\n\tgorm.Model\n\tName string `gorm:\"column:name\"`\n\tAge  int    `gorm:\"column:age\"`\n}\n\nfunc main() {\n\tdb, err := gorm.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/mydb?charset=utf8mb4&parseTime=True&loc=Local\")\n\tif err != nil {\n\t\tlog.Fatalf(\"error opening db: %v\", err)\n\t}\n\tdefer db.Close()\n\n\tdb.AutoMigrate(&Person{})\n\n\tp1 := Person{Name: \"John\", Age: 25}\n\tdb.Create(&p1)\n\n\tvar p2 Person\n\tdb.First(&p2)\n\tfmt.Printf(\"Person: %v\\n\", p2)\n\n\tp2.Age = 26\n\tdb.Save(&p2)\n\n\tvar people []Person\n\tdb.Find(&people)\n\tfmt.Printf(\"People: %v\\n\", people)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// create a new ticker that ticks every 1 second\n\tticker := time.NewTicker(1 * time.Second)\n\n\t// create a done channel to signal the ticker to stop\n\tdone := make(chan bool)\n\n\t// start a goroutine that will stop the ticker after 5 seconds\n\tgo func() {\n\t\ttime.Sleep(5 * time.Second)\n\t\tdone <- true\n\t}()\n\n\t// loop through the ticker channel and print the current time\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tfmt.Println(time.Now().Format(\"15:04:05\"))\n\t\tcase <-done:\n\t\t\t// stop the ticker and exit the loop\n\t\t\tticker.Stop()\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/olivere/elastic/v7\"\n)\n\ntype Person struct {\n\tName string `json:\"name\"`\n\tAge  int    `json:\"age\"`\n}\n\nfunc main() {\n\tctx := context.Background()\n\n\tclient, err := elastic.NewClient()\n\tif err != nil {\n\t\t// Handle error\n\t}\n\n\tp1 := Person{Name: \"John Doe\", Age: 25}\n\tput1, err := client.Index().\n\t\tIndex(\"people\").\n\t\tId(\"1\").\n\t\tBodyJson(p1).\n\t\tDo(ctx)\n\tif err != nil {\n\t\t// Handle error\n\t}\n\tfmt.Printf(\"Indexed %s to index %s, type %s\\n\", put1.Id, put1.Index, put1.Type)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/aws/aws-lambda-go/lambda\"\n)\n\ntype Event struct {\n\tName string `json:\"name\"`\n}\n\nfunc HandleRequest(ctx context.Context, event Event) (string, error) {\n\treturn fmt.Sprintf(\"Hello, %s!\", event.Name), nil\n}\n\nfunc main() {\n\tlambda.Start(HandleRequest)\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\t// create a Redis client\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\t// ping the Redis server to check if it's running\n\tpong, err := rdb.Ping(context.Background()).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(pong)\n\n\t// set a key-value pair\n\terr = rdb.Set(context.Background(), \"foo\", \"bar\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// get the value for a key\n\tval, err := rdb.Get(context.Background(), \"foo\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"foo\", val)\n\n\t// set a key-value pair with an expiration time\n\terr = rdb.Set(context.Background(), \"baz\", \"qux\", 5*time.Second).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// wait for the key to expire\n\ttime.Sleep(6 * time.Second)\n\n\t// try to get the expired key\n\tval, err = rdb.Get(context.Background(), \"baz\").Result()\n\tif err == redis.Nil {\n\t\tfmt.Println(\"baz does not exist\")\n\t} else if err != nil {\n\t\tpanic(err)\n\t} else {\n\t\tfmt.Println(\"baz\", val)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\targs := os.Args[1:]\n\n\tif len(args) != 2 {\n\t\tfmt.Println(\"Usage: calc <number> <number>\")\n\t\treturn\n\t}\n\n\tnum1, err := strconv.Atoi(args[0])\n\tif err != nil {\n\t\tfmt.Println(\"Invalid first argument\")\n\t\treturn\n\t}\n\n\tnum2, err := strconv.Atoi(args[1])\n\tif err != nil {\n\t\tfmt.Println(\"Invalid second argument\")\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Sum: %d\\n\", num1+num2)\n\tfmt.Printf(\"Difference: %d\\n\", num1-num2)\n\tfmt.Printf(\"Product: %d\\n\", num1*num2)\n\n\tif num2 != 0 {\n\t\tfmt.Printf(\"Quotient: %f\\n\", float64(num1)/float64(num2))\n\t} else {\n\t\tfmt.Println(\"Cannot divide by zero\")\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://jsonplaceholder.typicode.com/posts\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tfmt.Println(\"Error: Unexpected status code\", resp.StatusCode)\n\t\treturn\n\t}\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(bodyBytes))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/\", homeHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/users/{user}\", userHandler).Methods(\"GET\")\n\tr.HandleFunc(\"/posts/{id}\", postHandler).Methods(\"GET\", \"PUT\", \"DELETE\")\n\n\thttp.Handle(\"/\", r)\n\n\tfmt.Println(\"Server listening on port 8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Welcome to my website!\")\n}\n\nfunc userHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tuser := vars[\"user\"]\n\tfmt.Fprintf(w, \"Hello %s!\", user)\n}\n\nfunc postHandler(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid := vars[\"id\"]\n\n\tswitch r.Method {\n\tcase \"GET\":\n\t\tfmt.Fprintf(w, \"You requested post %s\", id)\n\tcase \"PUT\":\n\t\tfmt.Fprintf(w, \"You updated post %s\", id)\n\tcase \"DELETE\":\n\t\tfmt.Fprintf(w, \"You deleted post %s\", id)\n\tdefault:\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\tfmt.Fprintf(w, \"Unsupported method\")\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"database/sql\"\n\t\"log\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/dbname\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\trows, err := db.Query(\"SELECT name, email FROM users WHERE id = ?\", 1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar name string\n\t\tvar email string\n\t\terr = rows.Scan(&name, &email)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tlog.Println(name, email)\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tnumbers := []int{5, 2, 8, 1, 9, 4, 6, 3, 7}\n\n\tfmt.Println(\"Original numbers:\", numbers)\n\n\tbubbleSort(numbers)\n\n\tfmt.Println(\"Sorted numbers:\", numbers)\n}\n\nfunc bubbleSort(numbers []int) {\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tfor j := 0; j < len(numbers)-i-1; j++ {\n\t\t\tif numbers[j] > numbers[j+1] {\n\t\t\t\tnumbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n\t\t\t}\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Welcome to my website!\")\n\t})\n\n\tfs := http.FileServer(http.Dir(\"static/\"))\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs))\n\n\tlog.Println(\"Listening on :8080...\")\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\t// create a new redis client\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\t// set a key and value\n\terr := rdb.Set(context.Background(), \"sample-key\", \"sample-value\", 0).Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// get the key value\n\tval, err := rdb.Get(context.Background(), \"sample-key\").Result()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"sample-key:\", val)\n\n\t// set a key and value with expiration time\n\terr = rdb.Set(context.Background(), \"sample-key-expire\", \"sample-value-expire\", 5*time.Second).Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// check if the key exists\n\tkeyExists, err := rdb.Exists(context.Background(), \"sample-key-expire\").Result()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"sample-key-expire exists:\", keyExists)\n\n\t// wait for the key to expire\n\ttime.Sleep(6 * time.Second)\n\n\t// check if the key exists after it has expired\n\tkeyExists, err = rdb.Exists(context.Background(), \"sample-key-expire\").Result()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"sample-key-expire exists:\", keyExists)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Open(\"data.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tstat, err := file.Stat()\n\tif err != nil {\n\t\tfmt.Println(\"Error getting file info:\", err)\n\t\treturn\n\t}\n\n\tsize := stat.Size()\n\tdata := make([]byte, size)\n\n\t_, err = file.Read(data)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading file:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"File contents:\", string(data))\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\tsig := make(chan os.Signal, 1)\n\t\tsignal.Notify(sig, os.Interrupt)\n\t\t<-sig\n\t\tcancel()\n\t}()\n\n\tfmt.Println(\"Starting application...\")\n\tfmt.Println(\"Press Ctrl+C to stop\")\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"Stopping application...\")\n\t\tos.Exit(0)\n\tcase <-time.After(10 * time.Minute):\n\t\tfmt.Println(\"Application timed out\")\n\t\tos.Exit(1)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(num int) {\n\t\t\tfmt.Printf(\"Goroutine %d\\n\", num)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All goroutines finished executing\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, this is a Go web server!\")\n\t})\n\n\tfs := http.FileServer(http.Dir(\"static\"))\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs))\n\n\tfmt.Println(\"Server listening on :8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/\", HomeHandler)\n\tr.HandleFunc(\"/products\", ProductsHandler)\n\tr.HandleFunc(\"/articles\", ArticlesHandler)\n\n\tlog.Fatal(http.ListenAndServe(\":8000\", r))\n}\n\nfunc HomeHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Welcome to my website!\")\n}\n\nfunc ProductsHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Products page\")\n}\n\nfunc ArticlesHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Articles page\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tclient := &http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", \"https://jsonplaceholder.typicode.com/todos/1\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Println(string(body))\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/joho/godotenv\"\n)\n\nfunc main() {\n\t// Load environment variables from .env file\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatal(\"Error loading .env file\")\n\t}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello World!\")\n\t})\n\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tlog.Fatal(\"$PORT must be set\")\n\t}\n\n\tlog.Printf(\"Starting server on port %s\", port)\n\terr = http.ListenAndServe(\":\"+port, nil)\n\tif err != nil {\n\t\tlog.Fatal(\"Error starting server: \", err)\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n\t// Set up a context\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Create a client\n\tclient, err := mongo.Connect(ctx, options.Client().ApplyURI(\"mongodb://localhost:27017\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Check the connection\n\terr = client.Ping(ctx, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Start server\n\tserver := NewServer()\n\n\tgo func() {\n\t\tfmt.Println(\"Server starting on port 8080...\")\n\t\tif err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"listen: %s\\n\", err)\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t<-quit\n\tfmt.Println(\"Server shutting down...\")\n\n\tctxShutDown, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer func() {\n\t\tcancel()\n\t}()\n\n\tif err := server.Shutdown(ctxShutDown); err != nil {\n\t\tserver.Close()\n\t\tlog.Fatal(\"Server forced to shutdown:\", err)\n\t}\n\n\tif err := client.Disconnect(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Println(\"Server exiting\")\n}"}
{"sample": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\n\t// Some expensive computation\n\tsum := 0\n\tfor i := 0; i < 1000000000; i++ {\n\t\tsum += i\n\t}\n\n\telapsed := time.Since(start)\n\tfmt.Printf(\"Computation took %s\", elapsed)\n}"}
{"sample": "package middleware\n\nimport (\n\t\"net/http\"\n)\n\nfunc AuthMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check if user is authenticated\n\t\tif !isAuthenticated(r) {\n\t\t\thttp.Redirect(w, r, \"/login\", http.StatusSeeOther)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc isAuthenticated(r *http.Request) bool {\n\t// check if user is authenticated\n\t// implementation omitted for brevity\n\treturn true\n}"}
{"sample": "package utils\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc GetUser(id int) (*User, error) {\n\tresp, err := http.Get(\"https://jsonplaceholder.typicode.com/users/\" + string(id))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"Failed to get user\")\n\t}\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar user User\n\terr = json.Unmarshal(bodyBytes, &user)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &user, nil\n}"}
{"sample": "package auth\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\ntype User struct {\n\tID       int64\n\tUsername string\n\tPassword string\n}\n\ntype Auth struct {\n\tSigningKey []byte\n}\n\nfunc (a *Auth) GenerateToken(user *User) (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"exp\": time.Now().Add(time.Hour * 24).Unix(),\n\t\t\"iat\": time.Now().Unix(),\n\t\t\"sub\": user.ID,\n\t})\n\n\ttokenString, err := token.SignedString(a.SigningKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn tokenString, nil\n}\n\nfunc (a *Auth) ValidateToken(tokenString string) (*User, error) {\n\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, errors.New(\"invalid token\")\n\t\t}\n\n\t\treturn a.SigningKey, nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n\t\tif userID, ok := claims[\"sub\"].(float64); ok {\n\t\t\treturn &User{ID: int64(userID)}, nil\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"invalid token\")\n}"}
{"sample": "package middleware\n\nimport (\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc EnforceApiKey(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get APIKEY from environment variable\n\t\tapiKey := os.Getenv(\"APIKEY\")\n\n\t\tif apiKey == \"\" {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\tw.Write([]byte(\"APIKEY environment variable is not set\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Check if the Authorization API KEY is provided in the request header\n\t\t// for flexibility, it's set in various request headers like X-API-KEY, Authorization, etc\n\t\tauthHeader := r.Header.Get(\"X-API-KEY\")\n\t\tif authHeader == \"\" {\n\t\t\tauthHeader = r.Header.Get(\"Authorization\")\n\t\t}\n\n\t\tif authHeader == \"\" {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"API key is missing from header\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Verify if the given API key matches the set key\n\t\tif authHeader != apiKey {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized\"))\n\t\t\treturn\n\t\t}\n\n\t\t// If final, call next handlers\n\t\thandler.ServeHTTP(w, r)\n\t})\n}"}
{"sample": "package cache\n\nimport (\n\t\"time\"\n\n\t\"github.com/go-redis/redis\"\n)\n\ntype RedisCache struct {\n\tredisClient *redis.Client\n\tkeyPrefix   string\n\tttl         time.Duration\n}\n\nfunc NewRedisCache(address, password, keyPrefix string, ttl time.Duration) RedisCache {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     address,\n\t\tPassword: password,\n\t\tDB:       0,\n\t})\n\n\tif _, err := client.Ping().Result(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn RedisCache{\n\t\tredisClient: client,\n\t\tkeyPrefix:   keyPrefix,\n\t\tttl:         ttl,\n\t}\n}\n\nfunc (c *RedisCache) Set(key string, value interface{}) error {\n\tcacheKey := c.keyPrefix + key\n\n\tif err := c.redisClient.Set(cacheKey, value, c.ttl).Err(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *RedisCache) Get(key string) (interface{}, error) {\n\tcacheKey := c.keyPrefix + key\n\n\tresult, err := c.redisClient.Get(cacheKey).Result()\n\tif err == redis.Nil {\n\t\treturn nil, nil\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n\nfunc (c *RedisCache) Delete(key string) error {\n\tcacheKey := c.keyPrefix + key\n\n\tif err := c.redisClient.Del(cacheKey).Err(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package users\n\nimport (\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\ntype User struct {\n\tID           string    `json:\"id\"`\n\tUsername     string    `json:\"username\"`\n\tEmail        string    `json:\"email\"`\n\tPasswordHash string    `json:\"-\"`\n\tCreatedAt    time.Time `json:\"created_at\"`\n}\n\nfunc (u *User) SetPassword(pass string) error {\n\thash, err := bcrypt.GenerateFromPassword([]byte(pass), bcrypt.MinCost)\n\tif err != nil {\n\t\treturn err\n\t}\n\tu.PasswordHash = string(hash)\n\treturn nil\n}\n\nfunc (u *User) CheckPassword(pass string) bool {\n\tif err := bcrypt.CompareHashAndPassword([]byte(u.PasswordHash), []byte(pass)); err != nil {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc NewUser(username, email, password string) (*User, error) {\n\tuser := &User{\n\t\tID:        uuid.New().String(),\n\t\tUsername:  username,\n\t\tEmail:     email,\n\t\tCreatedAt: time.Now(),\n\t}\n\tif err := user.SetPassword(password); err != nil {\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}"}
{"sample": "package db\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\ntype RedisClient struct {\n\tClient *redis.Client\n}\n\nfunc NewRedisClient() (*RedisClient, error) {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif err := rdb.Ping(ctx).Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to redis: %v\", err)\n\t}\n\n\treturn &RedisClient{Client: rdb}, nil\n}\n\nfunc (c *RedisClient) SetValue(key string, value interface{}, expiration time.Duration) error {\n\tctx := context.Background()\n\n\tif err := c.Client.Set(ctx, key, value, expiration).Err(); err != nil {\n\t\treturn fmt.Errorf(\"failed to set value in redis: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *RedisClient) GetValue(key string) (string, error) {\n\tctx := context.Background()\n\n\tval, err := c.Client.Get(ctx, key).Result()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to get value from redis: %v\", err)\n\t}\n\n\treturn val, nil\n}"}
{"sample": "package db\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jmoiron/sqlx\"\n\t_ \"github.com/lib/pq\"\n)\n\ntype dbConfig struct {\n\thost     string\n\tport     int\n\tuser     string\n\tpassword string\n\tdbname   string\n}\n\nfunc (c *dbConfig) dataSourceName() string {\n\treturn fmt.Sprintf(\"host=%s port=%d user=%s password=%s dbname=%s sslmode=disable\", c.host, c.port, c.user, c.password, c.dbname)\n}\n\nfunc connect() (*sqlx.DB, error) {\n\tconfig := dbConfig{\n\t\thost:     \"localhost\",\n\t\tport:     5432,\n\t\tuser:     \"user\",\n\t\tpassword: \"password\",\n\t\tdbname:   \"mydb\",\n\t}\n\n\tdb, err := sqlx.Connect(\"postgres\", config.dataSourceName())\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn db, nil\n}\n\nfunc query() {\n\tdb, err := connect()\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\trows, err := db.Queryx(\"SELECT * FROM users WHERE age > $1\", 18)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tfor rows.Next() {\n\t\tvar user struct {\n\t\t\tID   int\n\t\t\tName string\n\t\t\tAge  int\n\t\t}\n\n\t\tif err := rows.StructScan(&user); err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\n\t\tfmt.Printf(\"User: %v\\n\", user)\n\t}\n}"}
{"sample": "package database\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc Connect() (*sql.DB, error) {\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/db_name\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err = db.Ping(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Connected to database\")\n\treturn db, nil\n}\n\nfunc GetUsers(db *sql.DB) ([]User, error) {\n\tvar users []User\n\n\trows, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar user User\n\n\t\tif err := rows.Scan(&user.ID, &user.Name, &user.Email); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tusers = append(users, user)\n\t}\n\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn users, nil\n}\n\ntype User struct {\n\tID    int\n\tName  string\n\tEmail string\n}\n\nfunc main() {\n\tdb, err := Connect()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tusers, err := GetUsers(db)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(users)\n}"}
{"sample": "package yaml_test\n\nimport (\n    \"testing\"\n    \"reflect\"\n    \"github.com/stretchr/testify/assert\"\n    \"gopkg.in/yaml.v2\"\n)\n\ntype Config struct {\n    Name string `yaml:\"name\"`\n    Age  int    `yaml:\"age\"`\n}\n\nfunc TestYaml(t *testing.T) {\n    input := []byte(`name: John\nage: 30`)\n    expected := &Config{\n        Name: \"John\",\n        Age:  30,\n    }\n\n    var c Config\n    err := yaml.Unmarshal(input, &c)\n\n    if err != nil {\n        t.Fatalf(\"error: %v\", err)\n    }\n\n    if !reflect.DeepEqual(c, *expected) {\n        t.Fatalf(\"Expected %v, but got %v\", expected, c)\n    }\n\n    output, err := yaml.Marshal(&c)\n    if err != nil {\n        t.Fatalf(\"error: %v\", err)\n    }\n\n    assert.Equal(t, string(input), string(output))\n}"}
{"sample": "package ssh\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc connect(user, password, host string, port int) (*ssh.Session, error) {\n\tvar (\n\t\tauth   []ssh.AuthMethod\n\t\taddr   string\n\t\tclientConfig *ssh.ClientConfig\n\t\tclient *ssh.Client\n\t\tsession *ssh.Session\n\t\terr error\n\t)\n\n\tauth = []ssh.AuthMethod{ssh.Password(password)}\n\tclientConfig = &ssh.ClientConfig{\n\t\tUser: user,\n\t\tAuth: auth,\n\t\tTimeout: 30 * time.Second,\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n\n\taddr = fmt.Sprintf(\"%s:%d\", host, port)\n\n\tif client, err = ssh.Dial(\"tcp\", addr, clientConfig); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif session, err = client.NewSession(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session, nil\n}\n\nfunc RunCommand(user, password, host string, port int, command string) (string, error) {\n\tsession, err := connect(user, password, host, port)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer session.Close()\n\n\toutput, err := session.CombinedOutput(command)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(output), nil\n}\n\nfunc UploadFile(user, password, host string, port int, localPath, remotePath string) error {\n\tsession, err := connect(user, password, host, port)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer session.Close()\n\n\tsrc, err := os.Open(localPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer src.Close()\n\n\tstat, err := src.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif stat.IsDir() {\n\t\treturn fmt.Errorf(\"%s is a directory\", localPath)\n\t}\n\n\tdst, err := session.OpenFile(remotePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, stat.Mode())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dst.Close()\n\n\tif _, err = io.Copy(dst, src); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc DownloadFile(user, password, host string, port int, remotePath, localPath string) error {\n\tsession, err := connect(user, password, host, port)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer session.Close()\n\n\tsrc, err := session.Open(remotePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer src.Close()\n\n\tstat, err := src.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif stat.IsDir() {\n\t\treturn fmt.Errorf(\"%s is a directory\", remotePath)\n\t}\n\n\tdst, err := os.OpenFile(localPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, stat.Mode())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dst.Close()\n\n\tif _, err = io.Copy(dst, src); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"sample": "package pathfinding\n\nimport (\n\t\"container/heap\"\n\t\"errors\"\n\t\"math\"\n)\n\ntype node struct {\n\tx    int\n\ty    int\n\tcost float64\n}\n\ntype priorityQueue []*node\n\nfunc (pq priorityQueue) Len() int {\n\treturn len(pq)\n}\n\nfunc (pq priorityQueue) Less(i, j int) bool {\n\treturn pq[i].cost < pq[j].cost\n}\n\nfunc (pq priorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n}\n\nfunc (pq *priorityQueue) Push(x interface{}) {\n\t*pq = append(*pq, x.(*node))\n}\n\nfunc (pq *priorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\nfunc findPath(startX, startY, endX, endY int, grid [][]float64) ([][2]int, error) {\n\tif startX < 0 || startX >= len(grid) || startY < 0 || startY >= len(grid[0]) {\n\t\treturn nil, errors.New(\"start point outside of range\")\n\t}\n\n\tif endX < 0 || endX >= len(grid) || endY < 0 || endY >= len(grid[0]) {\n\t\treturn nil, errors.New(\"end point outside of range\")\n\t}\n\n\topenList := priorityQueue{}\n\theap.Init(&openList)\n\tclosedSet := map[int]bool{}\n\tfScore := map[int]float64{}\n\tgScore := map[int]float64{}\n\tprev := map[int]int{}\n\n\tstart := node{x: startX, y: startY, cost: 0}\n\theap.Push(&openList, &start)\n\tfScore[startX*len(grid[0])+startY] = 0\n\tgScore[startX*len(grid[0])+startY] = 0\n\n\tfor len(openList) > 0 {\n\t\tcurrent := heap.Pop(&openList).(*node)\n\n\t\tif current.x == endX && current.y == endY {\n\t\t\treturn reconstructPath(prev, startX, startY, endX, endY), nil\n\t\t}\n\n\t\tclosedSet[current.x*len(grid[0])+current.y] = true\n\n\t\tfor _, neighbor := range getNeighbors(current.x, current.y, grid) {\n\t\t\tif closedSet[neighbor.x*len(grid[0])+neighbor.y] {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tgScoreNew := gScore[current.x*len(grid[0])+current.y] + grid[neighbor.x][neighbor.y]\n\t\t\tfScoreNew := gScoreNew + distance(neighbor.x, neighbor.y, endX, endY)\n\n\t\t\tif _, ok := fScore[neighbor.x*len(grid[0])+neighbor.y]; !ok {\n\t\t\t\tfScore[neighbor.x*len(grid[0])+neighbor.y] = math.Inf(1)\n\t\t\t}\n\n\t\t\tif fScoreNew >= fScore[neighbor.x*len(grid[0])+neighbor.y] {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfScore[neighbor.x*len(grid[0])+neighbor.y] = fScoreNew\n\t\t\tgScore[neighbor.x*len(grid[0])+neighbor.y] = gScoreNew\n\t\t\tprev[neighbor.x*len(grid[0])+neighbor.y] = current.x*len(grid[0]) + current.y\n\n\t\t\tif len(openList) == 0 {\n\t\t\t\theap.Push(&openList, neighbor)\n\t\t\t} else {\n\t\t\t\tinserted := false\n\t\t\t\tfor i, node := range openList {\n\t\t\t\t\tif neighbor.cost < node.cost {\n\t\t\t\t\t\topenList = append(openList[:i], append(priorityQueue{neighbor}, openList[i:]...)...)\n\t\t\t\t\t\tinserted = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !inserted {\n\t\t\t\t\topenList = append(openList, neighbor)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"path not found\")\n}\n\nfunc getNeighbors(x, y int, grid [][]float64) []*node {\n\theight := len(grid)\n\twidth := len(grid[0])\n\tvar neighbors []*node\n\n\tif x > 0 && grid[x-1][y] != math.Inf(1) {\n\t\tneighbors = append(neighbors, &node{x: x - 1, y: y, cost: grid[x-1][y]})\n\t}\n\tif x < height-1 && grid[x+1][y] != math.Inf(1) {\n\t\tneighbors = append(neighbors, &node{x: x + 1, y: y, cost: grid[x+1][y]})\n\t}\n\tif y > 0 && grid[x][y-1] != math.Inf(1) {\n\t\tneighbors = append(neighbors, &node{x: x, y: y - 1, cost: grid[x][y-1]})\n\t}\n\tif y < width-1 && grid[x][y+1] != math.Inf(1) {\n\t\tneighbors = append(neighbors, &node{x: x, y: y + 1, cost: grid[x][y+1]})\n\t}\n\n\treturn neighbors\n}\n\nfunc reconstructPath(prev map[int]int, startX, startY, endX, endY int) [][2]int {\n\tpathArr := [][2]int{}\n\n\tcurrentX := endX\n\tcurrentY := endY\n\n\tfor {\n\t\tpathArr = append([][2]int{{currentX, currentY}}, pathArr...)\n\t\tprevKey := prev[currentX*len(prev)+currentY]\n\t\tif prevKey == startX*len(prev)+startY {\n\t\t\tpathArr = append([][2]int{{startX, startY}}, pathArr...)\n\t\t\tbreak\n\t\t} else {\n\t\t\tcurrentX = prevKey / len(prev)\n\t\t\tcurrentY = prevKey % len(prev)\n\t\t}\n\t}\n\n\treturn pathArr\n}\n\nfunc distance(x1, y1, x2, y2 int) float64 {\n\treturn math.Sqrt(math.Pow(float64(x1-x2), 2) + math.Pow(float64(y1-y2), 2))\n}"}
{"sample": "package mongodb\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\ntype User struct {\n\tName  string `bson:\"name\"`\n\tEmail string `bson:\"email\"`\n}\n\nfunc NewClient(uri string) (*mongo.Client, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tclient, err := mongo.Connect(ctx, options.Client().ApplyURI(uri))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = client.Ping(ctx, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfmt.Println(\"Connected to MongoDB\")\n\n\treturn client, nil\n}\n\nfunc InsertUser(client *mongo.Client, user User) error {\n\tcollection := client.Database(\"mydb\").Collection(\"users\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\t_, err := collection.InsertOne(ctx, user)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"User inserted successfully\")\n\n\treturn nil\n}\n\nfunc GetUser(client *mongo.Client, email string) (User, error) {\n\tcollection := client.Database(\"mydb\").Collection(\"users\")\n\n\tvar user User\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\terr := collection.FindOne(ctx, User{Email: email}).Decode(&user)\n\tif err != nil {\n\t\treturn User{}, err\n\t}\n\n\treturn user, nil\n}\n\nfunc Close(client *mongo.Client) {\n\terr := client.Disconnect(context.Background())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"MongoDB connection closed\")\n}"}
{"sample": "package mapreduce_test\n\nimport (\n\t\"mapreduce\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMapReduce(t *testing.T) {\n\tinput := []string{\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\"}\n\n\texpectedOutput := map[string]int{\n\t\t\"a\": 2,\n\t\t\"b\": 1,\n\t\t\"c\": 1,\n\t\t\"d\": 1,\n\t\t\"e\": 2,\n\t\t\"f\": 1,\n\t\t\"g\": 1,\n\t\t\"h\": 1,\n\t\t\"l\": 1,\n\t\t\"n\": 2,\n\t\t\"p\": 2,\n\t\t\"r\": 3,\n\t\t\"y\": 1,\n\t}\n\n\toutput := mapreduce.MapReduce(input)\n\n\tif !reflect.DeepEqual(output, expectedOutput) {\n\t\tt.Errorf(\"MapReduce(%v) = %v, expected %v\", input, output, expectedOutput)\n\t}\n}"}
{"sample": "package chef\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype Ingredient struct {\n\tName     string\n\tQuantity int\n}\n\ntype Recipe struct {\n\tName        string\n\tIngredients []Ingredient\n}\n\ntype Chef struct {\n\tName        string\n\tRecipes     []Recipe\n\tIngredient  Ingredient\n\tExperience  int\n\tRestaurant  string\n}\n\nfunc (c *Chef) Cook(recipe Recipe) error {\n\tif c.Experience < 5 {\n\t\treturn fmt.Errorf(\"Chef %s is not experienced enough to cook %s\", c.Name, recipe.Name)\n\t}\n\n\tfor _, ing := range recipe.Ingredients {\n\t\tif ing.Quantity > c.Ingredient.Quantity {\n\t\t\treturn fmt.Errorf(\"Chef %s does not have enough %s to cook %s\", c.Name, ing.Name, recipe.Name)\n\t\t}\n\t}\n\n\trand.Seed(time.Now().UnixNano())\n\ttime.Sleep(time.Duration(rand.Intn(10)) * time.Second)\n\n\tfor _, ing := range recipe.Ingredients {\n\t\tc.Ingredient.Quantity -= ing.Quantity\n\t}\n\n\treturn nil\n}\n\nfunc (c *Chef) AddRecipe(recipe Recipe) {\n\tc.Recipes = append(c.Recipes, recipe)\n}\n\nfunc (c *Chef) Serve(restaurant string) {\n\tc.Restaurant = restaurant\n\tlog.Printf(\"%s is now serving at %s\", c.Name, restaurant)\n}\n\nfunc (c *Chef) Learn() {\n\tc.Experience++\n\tlog.Printf(\"%s is now more experienced and has an experience level of %d\", c.Name, c.Experience)\n}\n\nfunc NewChef(name string, ing Ingredient) *Chef {\n\treturn &Chef{\n\t\tName:       name,\n\t\tIngredient: ing,\n\t}\n}"}
{"sample": "package tcp_test\n\nimport (\n\t\"net\"\n\t\"testing\"\n)\n\nfunc TestTCPServer(t *testing.T) {\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tt.Errorf(\"Error listening: %v\", err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error accepting connection: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\tbuf := make([]byte, 1024)\n\tfor {\n\t\tn, err := conn.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tdata := buf[:n]\n\t\tresponse := processData(data)\n\n\t\tconn.Write([]byte(response))\n\t}\n}\n\nfunc processData(data []byte) string {\n\t// process the data and return a response\n\treturn \"Processed data\"\n}"}
{"sample": "package ansible\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc RunAnsiblePlaybook(playbookPath string, inventoryPath string) error {\n\tcmd := exec.Command(\"ansible-playbook\", \"-i\", inventoryPath, playbookPath)\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error running ansible-playbook: %v, output: %s\", err, output)\n\t}\n\treturn nil\n}\n\nfunc RunAnsibleAdhocCommand(inventoryPath string, module string, args string) error {\n\tcmd := exec.Command(\"ansible\", \"-i\", inventoryPath, \"-m\", module, \"-a\", args, \"all\")\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error running ansible adhoc command: %v, output: %s\", err, output)\n\t}\n\treturn nil\n}\n\nfunc RunAnsiblePing(inventoryPath string) error {\n\tcmd := exec.Command(\"ansible\", \"-i\", inventoryPath, \"-m\", \"ping\", \"all\")\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error running ansible ping: %v, output: %s\", err, output)\n\t}\n\treturn nil\n}"}
{"sample": "package templates\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n)\n\nfunc HomeHandler(w http.ResponseWriter, r *http.Request) {\n\n\ttmpl, err := template.ParseFiles(\"templates/home.html\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\ttype data struct {\n\t\tTitle string\n\t}\n\td := data{\n\t\tTitle: \"My Website\",\n\t}\n\n\tif err := tmpl.Execute(w, d); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc AboutHandler(w http.ResponseWriter, r *http.Request) {\n\n\ttmpl, err := template.ParseFiles(\"templates/about.html\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\ttype data struct {\n\t\tTitle string\n\t}\n\td := data{\n\t\tTitle: \"About Us\",\n\t}\n\n\tif err := tmpl.Execute(w, d); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc ContactHandler(w http.ResponseWriter, r *http.Request) {\n\n\ttmpl, err := template.ParseFiles(\"templates/contact.html\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\ttype data struct {\n\t\tTitle string\n\t}\n\td := data{\n\t\tTitle: \"Contact Us\",\n\t}\n\n\tif err := tmpl.Execute(w, d); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}"}
{"sample": "package zookeeper\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samuel/go-zookeeper/zk\"\n)\n\nfunc Connect() (*zk.Conn, error) {\n\tserver := []string{\"localhost:2181\"}\n\tconn, _, err := zk.Connect(server, time.Second*5)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to ZooKeeper: %v\", err)\n\t}\n\n\treturn conn, nil\n}\n\nfunc CreateNode(conn *zk.Conn, path string, data []byte) error {\n\tflags := int32(0)\n\tacl := zk.WorldACL(zk.PermAll)\n\t_, err := conn.Create(path, data, flags, acl)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create node: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc UpdateNode(conn *zk.Conn, path string, data []byte) error {\n\texists, _, err := conn.Exists(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to check if node exists: %v\", err)\n\t}\n\n\tif !exists {\n\t\treturn fmt.Errorf(\"node does not exist\")\n\t}\n\n\t_, err = conn.Set(path, data, -1)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update node: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc DeleteNode(conn *zk.Conn, path string) error {\n\texists, stat, err := conn.Exists(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to check if node exists: %v\", err)\n\t}\n\n\tif !exists {\n\t\treturn fmt.Errorf(\"node does not exist\")\n\t}\n\n\terr = conn.Delete(path, stat.Version)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to delete node: %v\", err)\n\t}\n\n\treturn nil\n}"}
{"sample": "package postgresql\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t_ \"github.com/lib/pq\"\n)\n\ntype Person struct {\n\tID        int\n\tName      string\n\tAge       int\n\tPhone     string\n\tEmail     string\n\tAddress   string\n\tCreatedAt string\n}\n\nfunc GetPerson(id int) *Person {\n\tdb, err := sql.Open(\"postgres\", \"user=user dbname=db password=password sslmode=disable\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tvar person Person\n\n\terr = db.QueryRow(\"SELECT * FROM persons WHERE id=$1\", id).Scan(&person.ID, &person.Name, &person.Age, &person.Phone, &person.Email, &person.Address, &person.CreatedAt)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn &person\n}\n\nfunc CreatePerson(p *Person) error {\n\tdb, err := sql.Open(\"postgres\", \"user=user dbname=db password=password sslmode=disable\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tsqlStatement := `\n\t\tINSERT INTO persons (name, age, phone, email, address, created_at)\n\t\tVALUES ($1, $2, $3, $4, $5, $6)`\n\t_, err = db.Exec(sqlStatement, p.Name, p.Age, p.Phone, p.Email, p.Address, p.CreatedAt)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tp := &Person{\n\t\tName:      \"John Smith\",\n\t\tAge:       35,\n\t\tPhone:     \"+1 (555) 555-5555\",\n\t\tEmail:     \"john.smith@example.com\",\n\t\tAddress:   \"1234 Main St, Anytown USA\",\n\t\tCreatedAt: \"2022-01-01\",\n\t}\n\n\terr := CreatePerson(p)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tperson := GetPerson(1)\n\tfmt.Println(\"Person:\", person)\n}"}
{"sample": "package elasticsearch\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/elastic/go-elasticsearch/v7\"\n\t\"github.com/elastic/go-elasticsearch/v7/esapi\"\n)\n\nfunc searchMovies(client *elasticsearch.Client, query string) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tquery := map[string]interface{}{\n\t\t\"query\": map[string]interface{}{\n\t\t\t\"match\": map[string]interface{}{\n\t\t\t\t\"title\": query,\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := json.NewEncoder(&buf).Encode(query); err != nil {\n\t\treturn nil, err\n\t}\n\n\tres, err := client.Search(\n\t\tclient.Search.WithContext(context.Background()),\n\t\tclient.Search.WithIndex(\"movies\"),\n\t\tclient.Search.WithBody(&buf),\n\t\tclient.Search.WithTrackTotalHits(true),\n\t\tclient.Search.WithPretty(),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.IsError() {\n\t\treturn nil, fmt.Errorf(\"failed to search movies: %s\", res.Status())\n\t}\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n\nfunc indexMovie(client *elasticsearch.Client, id string, movie *Movie) error {\n\tvar buf bytes.Buffer\n\tif err := json.NewEncoder(&buf).Encode(movie); err != nil {\n\t\treturn err\n\t}\n\n\treq := esapi.IndexRequest{\n\t\tIndex:      \"movies\",\n\t\tDocumentID: id,\n\t\tBody:       &buf,\n\t\tRefresh:    \"true\",\n\t}\n\n\tres, err := req.Do(context.Background(), client)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.IsError() {\n\t\treturn fmt.Errorf(\"failed to index movie: %s\", res.Status())\n\t}\n\n\treturn nil\n}\n\nfunc deleteMovie(client *elasticsearch.Client, id string) error {\n\treq := esapi.DeleteRequest{\n\t\tIndex:      \"movies\",\n\t\tDocumentID: id,\n\t\tRefresh:    \"true\",\n\t}\n\n\tres, err := req.Do(context.Background(), client)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.IsError() {\n\t\treturn fmt.Errorf(\"failed to delete movie: %s\", res.Status())\n\t}\n\n\treturn nil\n}"}
{"sample": "package pathfinding_test\n\nimport (\n\t\"pathfinding\"\n\t\"testing\"\n)\n\nfunc TestShortestPath(t *testing.T) {\n\tgraph := pathfinding.Graph{\n\t\t\"A\": {\"B\": 10, \"C\": 3},\n\t\t\"B\": {\"C\": 1, \"D\": 2},\n\t\t\"C\": {\"B\": 4, \"D\": 8, \"E\": 2},\n\t\t\"D\": {\"E\": 7},\n\t\t\"E\": {\"D\": 9},\n\t}\n\ttests := []struct {\n\t\tstart, end string\n\t\twant       int\n\t}{\n\t\t{\"A\", \"B\", 10},\n\t\t{\"A\", \"C\", 3},\n\t\t{\"A\", \"D\", 5},\n\t\t{\"A\", \"E\", 5},\n\t\t{\"B\", \"A\", -1},\n\t\t{\"B\", \"C\", 1},\n\t\t{\"B\", \"D\", 2},\n\t\t{\"B\", \"E\", 3},\n\t\t{\"C\", \"A\", -1},\n\t\t{\"C\", \"B\", 4},\n\t\t{\"C\", \"D\", 6},\n\t\t{\"C\", \"E\", 2},\n\t\t{\"D\", \"A\", -1},\n\t\t{\"D\", \"B\", -1},\n\t\t{\"D\", \"C\", -1},\n\t\t{\"D\", \"E\", 7},\n\t\t{\"E\", \"A\", -1},\n\t\t{\"E\", \"B\", -1},\n\t\t{\"E\", \"C\", -1},\n\t\t{\"E\", \"D\", 9},\n\t}\n\tfor _, tt := range tests {\n\t\tif got := graph.ShortestPath(tt.start, tt.end); got != tt.want {\n\t\t\tt.Errorf(\"graph.ShortestPath(%q, %q) = %v, want %v\", tt.start, tt.end, got, tt.want)\n\t\t}\n\t}\n}"}
{"sample": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName    string   `json:\"name\"`\n\tAge     int      `json:\"age,omitempty\"`\n\tEmail   string   `json:\"email,omitempty\"`\n\tHobbies []string `json:\"hobbies,omitempty\"`\n}\n\nfunc main() {\n\tpersonJSON := `\n\t{\n\t\t\"name\": \"John Doe\",\n\t\t\"age\": 30,\n\t\t\"hobbies\": [\"reading\", \"cooking\"]\n\t}`\n\n\tvar person Person\n\tif err := json.Unmarshal([]byte(personJSON), &person); err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(person) // Person{Name:\"John Doe\", Age:30, Email:\"\", Hobbies:[reading cooking]}\n\n\tnewPerson := Person{\n\t\tName: \"Jane Smith\",\n\t}\n\n\tnewPersonJSON, err := json.Marshal(newPerson)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(string(newPersonJSON)) // {\"name\":\"Jane Smith\"}\n}"}
{"sample": "package json\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n)\n\ntype Person struct {\n\tName    string `json:\"name\"`\n\tAge     int    `json:\"age\"`\n\tAddress struct {\n\t\tCity    string `json:\"city\"`\n\t\tCountry string `json:\"country\"`\n\t} `json:\"address\"`\n}\n\nfunc main() {\n\tperson := Person{\n\t\tName: \"John Doe\",\n\t\tAge:  30,\n\t\tAddress: struct {\n\t\t\tCity    string `json:\"city\"`\n\t\t\tCountry string `json:\"country\"`\n\t\t}{City: \"New York\", Country: \"USA\"},\n\t}\n\n\t// Marshaling struct to JSON\n\tjsonBytes, err := json.Marshal(person)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"JSON: %s\\n\", jsonBytes)\n\n\t// Unmarshaling JSON to struct\n\tvar newPerson Person\n\tif err := json.Unmarshal(jsonBytes, &newPerson); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"Name: %s\\nAge: %d\\nCity: %s\\nCountry: %s\\n\", newPerson.Name, newPerson.Age, newPerson.Address.City, newPerson.Address.Country)\n\n\t// Encoding JSON to stdout directly\n\tjsonEncoder := json.NewEncoder((fmt.Sprintf(os.Stdout, person)))\n\tif err := jsonEncoder.Encode(person); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"sample": "package saltstack\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/saltstack/salt-golang/api\"\n\t\"github.com/saltstack/salt-golang/handlers\"\n)\n\nfunc runCommand() {\n\tclient, err := api.NewClient(&api.Config{\n\t\tTransport: \"tcp\",\n\t\tAddress:   \"localhost:4506\",\n\t\tUsername:  \"admin\",\n\t\tPassword:  \"password\",\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tctx := context.Background()\n\tcmd := \"ls -la /tmp\"\n\ttarget := \"webserver*\"\n\n\tresp, err := client.Run(ctx, handlers.RemoteExecutionRequest{\n\t\tTarget: target,\n\t\tArgs:   []string{cmd},\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, r := range resp.Results {\n\t\tfmt.Printf(\"%s: %s\\n\", r.Target, r.Stdout)\n\t}\n}\n\nfunc runState() {\n\tclient, err := api.NewClient(&api.Config{\n\t\tTransport: \"tcp\",\n\t\tAddress:   \"localhost:4506\",\n\t\tUsername:  \"admin\",\n\t\tPassword:  \"password\",\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tctx := context.Background()\n\tstate := \"nginx\"\n\ttarget := \"webserver*\"\n\n\tresp, err := client.Run(ctx, handlers.StateExecutionRequest{\n\t\tTarget: target,\n\t\tArgs:   []string{state},\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, r := range resp.Results {\n\t\tfmt.Printf(\"%s: %s\\n\", r.Target, r.Stdout)\n\t}\n}"}
{"sample": "package grpc\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"github.com/mycompany/myproject/protos\"\n)\n\ntype server struct{}\n\nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &pb.HelloResponse{Message: fmt.Sprintf(\"Hello %s!\", in.GetName())}, nil\n}\n\nfunc StartServer() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\tlog.Println(\"Starting gRPC server on port 50051...\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}\n\nfunc SayHello() {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewGreeterClient(conn)\n\tname := \"John\"\n\tr, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"Greeting: %s\", r.GetMessage())\n}"}
{"sample": "package docker_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/client\"\n)\n\nfunc TestDocker(t *testing.T) {\n\tcli, err := client.NewEnvClient()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\timageName := \"nginx:latest\"\n\tcontainerName := \"test-nginx\"\n\n\t_, err = cli.ImagePull(context.Background(), imageName, types.ImagePullOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresp, err := cli.ContainerCreate(context.Background(), &container.Config{\n\t\tImage: imageName,\n\t}, nil, nil, containerName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := cli.ContainerStart(context.Background(), resp.ID, types.ContainerStartOptions{}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcontainers, err := cli.ContainerList(context.Background(), types.ContainerListOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound := false\n\tfor _, c := range containers {\n\t\tif c.ID == resp.ID {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tt.Fatal(\"Container not found\")\n\t}\n\n\tif err := cli.ContainerStop(context.Background(), resp.ID, nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := cli.ContainerRemove(context.Background(), resp.ID, types.ContainerRemoveOptions{}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfmt.Println(\"Docker test passed\")\n}"}
{"sample": "package logstash\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\n// LogstashClient is a client for sending logs to Logstash.\ntype LogstashClient struct {\n\tconn net.Conn\n}\n\n// NewLogstashClient creates a new Logstash client.\nfunc NewLogstashClient(host string, port int) (*LogstashClient, error) {\n\tconn, err := net.DialTimeout(\"tcp\", fmt.Sprintf(\"%s:%d\", host, port), 5*time.Second)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &LogstashClient{conn: conn}, nil\n}\n\n// Send sends a log message to Logstash.\nfunc (c *LogstashClient) Send(timestamp time.Time, message string, fields map[string]interface{}) error {\n\tevent := make(map[string]interface{})\n\tevent[\"@timestamp\"] = timestamp.UTC().Format(\"2006-01-02T15:04:05.999Z\")\n\tevent[\"@message\"] = message\n\n\tfor k, v := range fields {\n\t\tevent[strings.ToLower(k)] = v\n\t}\n\n\tbytes, err := json.Marshal(event)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.conn.Write(bytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Close closes the connection to Logstash.\nfunc (c *LogstashClient) Close() {\n\tc.conn.Close()\n\tlog.Println(\"Connection to Logstash closed\")\n}"}
{"sample": "package transactions\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nvar (\n\tErrInsufficientFunds = errors.New(\"insufficient funds\")\n)\n\ntype Client struct {\n\tredisClient *redis.Client\n}\n\nfunc New(redisClient *redis.Client) *Client {\n\treturn &Client{redisClient: redisClient}\n}\n\nfunc (c *Client) Transfer(from, to string, amount float64) error {\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\ttxf := func(tx *redis.Tx) error {\n\t\tbalance, err := tx.Get(ctx, from).Float64()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif balance < amount {\n\t\t\treturn ErrInsufficientFunds\n\t\t}\n\n\t\terr = tx.Watch(ctx, from)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tm := redis.NewStringStringMapCmd(ctx, \"MULTI\")\n\t\tm.IncrByFloat(from, -amount)\n\t\tm.IncrByFloat(to, amount)\n\n\t\t_, err = tx.Exec(ctx, func() error {\n\t\t\t_, err := m.Exec(ctx)\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn nil\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}\n\n\terr := c.redisClient.Watch(ctx, txf, from)\n\n\tif err == redis.TxFailedErr {\n\t\treturn ErrInsufficientFunds\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Successfully transferred %.2f from %s to %s\\n\", amount, from, to)\n\n\treturn nil\n}"}
{"sample": "package mapreduce_test\n\nimport (\n\t\"mapreduce\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestMapReduce(t *testing.T) {\n\tdata := []string{\"apple\", \"orange\", \"banana\", \"apple\", \"banana\"}\n\n\t// Map phase\n\toutput := mapreduce.Map(data)\n\n\t// Sort output for reduce phase\n\tsort.Strings(output)\n\n\t// Reduce phase\n\tresult := mapreduce.Reduce(output)\n\n\t// Check result\n\texpected := map[string]int{\n\t\t\"apple\": 2,\n\t\t\"orange\": 1,\n\t\t\"banana\": 2,\n\t}\n\n\tfor k, v := range expected {\n\t\tif result[k] != v {\n\t\t\tt.Errorf(\"%v: expected %v but got %v\", k, v, result[k])\n\t\t}\n\t}\n}"}
{"sample": "package config\n\nimport (\n\t\"os\"\n\t\"strconv\"\n)\n\ntype Config struct {\n\tPort        int\n\tDatabaseURL string\n}\n\nfunc LoadConfig() (*Config, error) {\n\tport, err := strconv.Atoi(os.Getenv(\"PORT\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdbURL := os.Getenv(\"DATABASE_URL\")\n\n\treturn &Config{\n\t\tPort:        port,\n\t\tDatabaseURL: dbURL,\n\t}, nil\n}"}
{"sample": "package helpers\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// APIResponse is a helper struct to parse JSON responses from APIs\ntype APIResponse struct {\n\tStatusCode int             `json:\"-\"`\n\tBody       json.RawMessage `json:\"body\"`\n}\n\n// SendAPIRequest sends an HTTP request to an API and returns the response as a byte slice\nfunc SendAPIRequest(method, url string, headers map[string]string, body []byte) ([]byte, error) {\n\tclient := &http.Client{Timeout: 10 * time.Second}\n\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor key, value := range headers {\n\t\treq.Header.Set(key, value)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Body.Close()\n\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode >= 400 {\n\t\treturn nil, errors.New(string(respBody))\n\t}\n\n\treturn respBody, nil\n}"}
{"sample": "package udp_test\n\nimport (\n\t\"net\"\n\t\"testing\"\n)\n\nfunc TestUDPConnection(t *testing.T) {\n\taddr := \"127.0.0.1:8080\"\n\n\tconn, err := net.Dial(\"udp\", addr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tmsg := []byte(\"Hello from client!\")\n\tif _, err := conn.Write(msg); err != nil {\n\t\tt.Fatalf(\"Failed to send message: %v\", err)\n\t}\n\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to receive message: %v\", err)\n\t}\n\n\tif string(buf[:n]) != \"Hello from server!\" {\n\t\tt.Fatalf(\"Expected 'Hello from server!', but got '%s'\", string(buf[:n]))\n\t}\n}"}
{"sample": "package raft\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// Raft is a distributed consensus algorithm.\ntype Raft struct {\n\tid          int\n\tpeers       []*Peer\n\tcurrentTerm int\n\tvotedFor    int\n\tlog         []*LogEntry\n\tcommitIndex int\n\tlastApplied int\n\tstate       State\n\ttimeout     time.Duration\n\telection    *Election\n}\n\n// NewRaft creates a new Raft instance.\nfunc NewRaft(id int, peers []*Peer) *Raft {\n\tr := &Raft{\n\t\tid:          id,\n\t\tpeers:       peers,\n\t\tcurrentTerm: 0,\n\t\tvotedFor:    -1,\n\t\tlog:         []*LogEntry{},\n\t\tcommitIndex: 0,\n\t\tlastApplied: 0,\n\t\tstate:       Follower,\n\t\ttimeout:     time.Duration(rand.Intn(150)+150) * time.Millisecond,\n\t\telection:    NewElection(),\n\t}\n\n\treturn r\n}\n\n// Start starts the Raft instance.\nfunc (r *Raft) Start() {\n\tlog.Printf(\"Starting Raft node %d\", r.id)\n\tr.election.Start(r.timeout)\n}\n\n// Stop stops the Raft instance.\nfunc (r *Raft) Stop() {\n\tlog.Printf(\"Stopping Raft node %d\", r.id)\n\tr.election.Stop()\n}\n\n// AppendEntry appends an entry to the log.\nfunc (r *Raft) AppendEntry(entry *LogEntry) error {\n\tif r.state != Leader {\n\t\treturn errors.New(\"not the leader\")\n\t}\n\n\t// TODO: Implement append entry logic.\n\n\treturn nil\n}\n\n// RequestVote requests a vote from a peer.\nfunc (r *Raft) RequestVote(peer *Peer) error {\n\tif r.state != Candidate {\n\t\treturn errors.New(\"not a candidate\")\n\t}\n\n\t// TODO: Implement request vote logic.\n\n\treturn nil\n}\n\n// ApplyCommand applies a command to the state machine.\nfunc (r *Raft) ApplyCommand(command []byte) error {\n\tif r.state != Leader {\n\t\treturn errors.New(\"not the leader\")\n\t}\n\n\t// TODO: Implement apply command logic.\n\n\treturn nil\n}"}
{"sample": "package rabbitmq\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/streadway/amqp\"\n)\n\nfunc main() {\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to RabbitMQ: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open a channel: %v\", err)\n\t}\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when unused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to declare a queue: %v\", err)\n\t}\n\n\tbody := \"Hello World!\"\n\terr = ch.Publish(\n\t\t\"\",     // exchange\n\t\tq.Name, // routing key\n\t\tfalse,  // mandatory\n\t\tfalse,  // immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        []byte(body),\n\t\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to publish a message: %v\", err)\n\t}\n\n\tfmt.Println(\"Successfully sent 'Hello World!'\")\n}"}
{"sample": "package grafana\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype Dashboard struct {\n\tID          int    `json:\"id\"`\n\tTitle       string `json:\"title\"`\n\tDescription string `json:\"description\"`\n}\n\nvar dashboards = []Dashboard{\n\t{ID: 1, Title: \"Dashboard 1\", Description: \"This is the first dashboard\"},\n\t{ID: 2, Title: \"Dashboard 2\", Description: \"This is the second dashboard\"},\n\t{ID: 3, Title: \"Dashboard 3\", Description: \"This is the third dashboard\"},\n}\n\nfunc getDashboards(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif err := json.NewEncoder(w).Encode(dashboards); err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(w, \"Error encoding response: %v\", err)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc getDashboardByID(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprintf(w, \"Invalid dashboard ID\")\n\t\treturn\n\t}\n\n\tfor _, dashboard := range dashboards {\n\t\tif dashboard.ID == id {\n\t\t\tif err := json.NewEncoder(w).Encode(dashboard); err != nil {\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\tfmt.Fprintf(w, \"Error encoding response: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\treturn\n\t\t}\n\t}\n\n\tw.WriteHeader(http.StatusNotFound)\n\tfmt.Fprintf(w, \"Dashboard not found\")\n}"}
{"sample": "package queue\n\ntype CommittableMessage struct {\n\tid        int\n\tmessage   string\n\tcommitted bool\n}\n\ntype Consumer struct {\n\tidsCh   chan<- int\n\tmsgsCh  chan<- string\n\tackCh   <-chan int\n\tnackCh  <-chan int\n\tallSync <-chan struct{}\n}\n\nfunc WithCommitQueue(capacity int) (\n\tcommittable <-chan CommittableMessage,\n\tcommitted <-chan int,\n) {\n\t//allocate bufer go-channel of messages \n\tinQPc, outQPc := make(chan orcaMessageChannel, maxWorkers)\n\n\t}\n\n\t// buffer cache separately collected urls\n}).Unmarshal(hubbleWrite chan<- []db.LogLocations) error {\"capacity\"}\n\n}  \n\ncosalind is a python testcase automation network which involve third external symbolic imlems during construction\n\n// This better performances for also different trry == s*(kk*k+... would \ngetAcc http.Handle (\"/css/style.CSS>\", AccTheadLists(randFunctionVariable(pCacheDevID be.nProbBispDMURLTemplate(\"//iss\")) \"async\">)?=T0>) log.Fatalf(tnmeConn.Change.T[ut.Output])\r\nmore flexibility updates: session logs); optionally check such Py list funcs used\"\"\"dataGridView1\n\nsystem.runtime.* never stream info L/B streaming proces \n\nsin,sxn important 'killed')).month-Start \n                                 Hour-MM- */\nstrconv.FormatUint(id1 $gitchPorDDep.IPOrgase(code), trottlingNew)])/ last >= last\n\ntssk by alY2-alPL __ditso__\n},{\n\t-ipv The *.Code(hsrphHdrURL)(invalid 'kd')\nretry.Errors.Header \"poflesClck(xlPacketParts (sensor):\n\thttp Log messageid.Clien*/\n}));\n\nandresP hmap.http.RequireType(typeof(is the tracne durubg pm2 depende*/) -sorted edgeFormaterErrArr.Handle(func()\n})webElementX"}
{"sample": "package messages\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype content map[string]interface{}\n\nfunc init() {\n\thttp.HandleFunc(\"/json-example\", handler)\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tdecoder := json.NewDecoder(r.Body)\n\tvar c content\n\terr := decoder.Decode(&c)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprintf(w, \"Error decoding JSON: %+v\", err)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, \"Received JSON: %+v\\n\", c)\n\tw.WriteHeader(http.StatusOK)\n}"}
{"sample": "package urls\n\nfunc generateShortURL(longURL string) (string, error) {\n\t// Connect to database and create new entry\n\tdbConn, err := sql.Open(\"mysql\", \"user:password@tcp(dbhost:pass)/key_database\")\n\tdefer dbConn.Close()\n\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to connect to database: %v\\n\", err)\n\t\treturn \"\", err\n\t}\n\n\tshortURL := generateUniqueShortUri()\n\n\tstmt, err := dbConn.Prepare(\"INSERT INTO urls VALUES (?,?)\")\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to prepare statement: %v\\n\", err)\n\t\treturn \"\", err\n\t}\n\n\t_, err = stmt.Exec(shortURL, longURL)\n\n\tif err != nil {\n \t\tfmt.Printf(\"Failed to execute query: %v\\n\", err)\n  \t\treturn \"\", err\n     }\n       \n       return fmt.Sprintf(\"shrt.isbd/%v\",shortURL) , nil        \n\t}\n\nfunc generateUniqueShortURI() string {\n\telems := []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\")\n\tcharSizes := rand.Perm(len(elems))[:4]\n\n\t//rand number to shuffle\n\tnAmt := [4]int32{}\n\n\tvar shortUrI string\n\n\tfor i := 0; i < len(nAmt); i++ {\n\t\tletidxtest := rand.Intn(charSizes[i] + 1)\n\t\tletidxrand := (nAmt[i] + int32(letidxtest % charSizes[i])) % int32(charSizes[i])\n\n\t\tnAmt[i] = letidxrand\n\n\t\tshortUrI = shortUrI + string(elems[letidxrand])\n\t}\n\n\ttimestamp := strconv.FormatInt(time.Now().UnixNano(), 16)\n\n\tshortUrI = shortUrI + \".\" + timestamp\n\n\treturn shortUrI\n}"}
{"sample": "package models\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"time\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype Post struct {\n\tID        int\n\tTitle     string\n\tContent   string\n\tCreatedAt time.Time\n}\n\nvar db *sql.DB\n\nfunc init() {\n\tvar err error\n\tdb, err = sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/mydb\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (p *Post) Create() error {\n\tstmt, err := db.Prepare(\"INSERT INTO posts(title, content, created_at) VALUES(?, ?, ?)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tres, err := stmt.Exec(p.Title, p.Content, time.Now())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tid, err := res.LastInsertId()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.ID = int(id)\n\n\treturn nil\n}\n\nfunc GetPost(id string) (*Post, error) {\n\tvar post Post\n\n\trow := db.QueryRow(\"SELECT id, title, content, created_at FROM posts WHERE id = ?\", id)\n\terr := row.Scan(&post.ID, &post.Title, &post.Content, &post.CreatedAt)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, errors.New(\"post not found\")\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn &post, nil\n}"}
{"sample": "package websocket_test\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc TestWebsocket(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tupgrader := websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error upgrading connection: %v\", err)\n\t\t}\n\n\t\tdefer conn.Close()\n\n\t\tfor {\n\t\t\tmessageType, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error reading message: %v\", err)\n\t\t\t}\n\n\t\t\tif string(message) != \"ping\" {\n\t\t\t\tt.Fatalf(\"Expected 'ping', got '%s'\", string(message))\n\t\t\t}\n\n\t\t\tif err := conn.WriteMessage(messageType, []byte(\"pong\")); err != nil {\n\t\t\t\tt.Fatalf(\"Error writing message: %v\", err)\n\t\t\t}\n\t\t}\n\t}))\n\n\tdefer server.Close()\n\n\turl := \"ws\" + server.URL[4:]\n\tconn, _, err := websocket.DefaultDialer.Dial(url, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Error dialing connection: %v\", err)\n\t}\n\n\tdefer conn.Close()\n\n\tif err := conn.WriteMessage(websocket.TextMessage, []byte(\"ping\")); err != nil {\n\t\tt.Fatalf(\"Error writing message: %v\", err)\n\t}\n\n\t_, message, err := conn.ReadMessage()\n\tif err != nil {\n\t\tt.Fatalf(\"Error reading message: %v\", err)\n\t}\n\n\tif string(message) != \"pong\" {\n\t\tt.Fatalf(\"Expected 'pong', got '%s'\", string(message))\n\t}\n}"}
{"sample": "package validation\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\n// ValidateEmail checks if the given email is valid or not\nfunc ValidateEmail(email string) error {\n\tif email == \"\" {\n\t\treturn fmt.Errorf(\"email cannot be empty\")\n\t}\n\n\t// regular expression to validate email format\n\temailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`)\n\n\tif !emailRegex.MatchString(email) {\n\t\treturn fmt.Errorf(\"invalid email format\")\n\t}\n\n\treturn nil\n}\n\n// ValidatePassword checks if the given password is valid or not\nfunc ValidatePassword(password string) error {\n\tif password == \"\" {\n\t\treturn fmt.Errorf(\"password cannot be empty\")\n\t}\n\n\tif len(password) < 8 {\n\t\treturn fmt.Errorf(\"password must be at least 8 characters long\")\n\t}\n\n\treturn nil\n}"}
{"sample": "package ssh\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc connectSSH(user, password, host string, port int) (*ssh.Session, error) {\n\tconfig := &ssh.ClientConfig{\n\t\tUser: user,\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(password),\n\t\t},\n\t\tTimeout: time.Second * 5,\n\t\tHostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error {\n\t\t\treturn nil\n\t\t},\n\t}\n\n\taddr := fmt.Sprintf(\"%s:%d\", host, port)\n\tclient, err := ssh.Dial(\"tcp\", addr, config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session, nil\n}\n\nfunc executeCommand(command string) (string, error) {\n\tuser := os.Getenv(\"SSH_USER\")\n\tpassword := os.Getenv(\"SSH_PASSWORD\")\n\thost := os.Getenv(\"SSH_HOST\")\n\tport := 22\n\n\tsession, err := connectSSH(user, password, host, port)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer session.Close()\n\n\toutput, err := session.CombinedOutput(command)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(output), nil\n}\n\nfunc uploadFile(localPath, remotePath string) error {\n\tuser := os.Getenv(\"SSH_USER\")\n\tpassword := os.Getenv(\"SSH_PASSWORD\")\n\thost := os.Getenv(\"SSH_HOST\")\n\tport := 22\n\n\tsession, err := connectSSH(user, password, host, port)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer session.Close()\n\n\tfileBytes, err := ioutil.ReadFile(localPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = session.Run(fmt.Sprintf(\"mkdir -p %s\", remotePath))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfileName := fmt.Sprintf(\"%s/%s\", remotePath, filepath.Base(localPath))\n\tfile, err := session.Create(fileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\t_, err = file.Write(fileBytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
